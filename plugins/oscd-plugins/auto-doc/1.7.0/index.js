var Tk = Object.defineProperty;
var xk = (r, e, t) => e in r ? Tk(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var Bs = (r, e, t) => xk(r, typeof e != "symbol" ? e + "" : e, t);
function sr() {
}
function ze(r, e) {
  for (const t in e) r[t] = e[t];
  return (
    /** @type {T & S} */
    r
  );
}
function pE(r) {
  return r();
}
function $y() {
  return /* @__PURE__ */ Object.create(null);
}
function fr(r) {
  r.forEach(pE);
}
function ar(r) {
  return typeof r == "function";
}
function Mt(r, e) {
  return r != r ? e == e : r !== e || r && typeof r == "object" || typeof r == "function";
}
let jh;
function Vy(r, e) {
  return r === e ? !0 : (jh || (jh = document.createElement("a")), jh.href = e, r === jh.href);
}
function kk(r) {
  return Object.keys(r).length === 0;
}
function Zp(r, ...e) {
  if (r == null) {
    for (const n of e)
      n(void 0);
    return sr;
  }
  const t = r.subscribe(...e);
  return t.unsubscribe ? () => t.unsubscribe() : t;
}
function bn(r) {
  let e;
  return Zp(r, (t) => e = t)(), e;
}
function GA(r, e, t) {
  r.$$.on_destroy.push(Zp(e, t));
}
function Nt(r, e, t, n) {
  if (r) {
    const i = gE(r, e, t, n);
    return r[0](i);
  }
}
function gE(r, e, t, n) {
  return r[1] && n ? ze(t.ctx.slice(), r[1](n(e))) : t.ctx;
}
function Ot(r, e, t, n) {
  if (r[2] && n) {
    const i = r[2](n(t));
    if (e.dirty === void 0)
      return i;
    if (typeof i == "object") {
      const s = [], a = Math.max(e.dirty.length, i.length);
      for (let o = 0; o < a; o += 1)
        s[o] = e.dirty[o] | i[o];
      return s;
    }
    return e.dirty | i;
  }
  return e.dirty;
}
function Qt(r, e, t, n, i, s) {
  if (i) {
    const a = gE(e, t, n, s);
    r.p(a, i);
  }
}
function Dt(r) {
  if (r.ctx.length > 32) {
    const e = [], t = r.ctx.length / 32;
    for (let n = 0; n < t; n++)
      e[n] = -1;
    return e;
  }
  return -1;
}
function Nr(r) {
  const e = {};
  for (const t in r) t[0] !== "$" && (e[t] = r[t]);
  return e;
}
function xt(r, e) {
  const t = {};
  e = new Set(e);
  for (const n in r) !e.has(n) && n[0] !== "$" && (t[n] = r[n]);
  return t;
}
function D2(r) {
  const e = {};
  for (const t in r)
    e[t] = !0;
  return e;
}
function gi(r) {
  return r ?? "";
}
function D1(r, e, t) {
  return r.set(t), e;
}
function Bt(r) {
  return r && ar(r.destroy) ? r.destroy : sr;
}
const Lk = typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);
function je(r, e) {
  r.appendChild(e);
}
function Pi(r, e, t) {
  const n = Uk(r);
  if (!n.getElementById(e)) {
    const i = We("style");
    i.id = e, i.textContent = t, Nk(n, i);
  }
}
function Uk(r) {
  if (!r) return document;
  const e = r.getRootNode ? r.getRootNode() : r.ownerDocument;
  return e && /** @type {ShadowRoot} */
  e.host ? (
    /** @type {ShadowRoot} */
    e
  ) : r.ownerDocument;
}
function Nk(r, e) {
  return je(
    /** @type {Document} */
    r.head || r,
    e
  ), e.sheet;
}
function ke(r, e, t) {
  r.insertBefore(e, t || null);
}
function xe(r) {
  r.parentNode && r.parentNode.removeChild(r);
}
function Ok(r, e) {
  for (let t = 0; t < r.length; t += 1)
    r[t] && r[t].d(e);
}
function We(r) {
  return document.createElement(r);
}
function Gc(r) {
  return document.createElementNS("http://www.w3.org/2000/svg", r);
}
function ir(r) {
  return document.createTextNode(r);
}
function tt() {
  return ir(" ");
}
function Or() {
  return ir("");
}
function pt(r, e, t, n) {
  return r.addEventListener(e, t, n), () => r.removeEventListener(e, t, n);
}
function mE(r) {
  return function(e) {
    return e.stopPropagation(), r.call(this, e);
  };
}
function Me(r, e, t) {
  t == null ? r.removeAttribute(e) : r.getAttribute(e) !== t && r.setAttribute(e, t);
}
const Qk = ["width", "height"];
function Ut(r, e) {
  const t = Object.getOwnPropertyDescriptors(r.__proto__);
  for (const n in e)
    e[n] == null ? r.removeAttribute(n) : n === "style" ? r.style.cssText = e[n] : n === "__value" ? r.value = r[n] = e[n] : t[n] && t[n].set && Qk.indexOf(n) === -1 ? r[n] = e[n] : Me(r, n, e[n]);
}
function vp(r, e) {
  for (const t in e)
    Me(r, t, e[t]);
}
function Dk(r, e) {
  Object.keys(e).forEach((t) => {
    qc(r, t, e[t]);
  });
}
function qc(r, e, t) {
  const n = e.toLowerCase();
  n in r ? r[n] = typeof r[n] == "boolean" && t === "" ? !0 : t : e in r ? r[e] = typeof r[e] == "boolean" && t === "" ? !0 : t : Me(r, e, t);
}
function bp(r) {
  return /-/.test(r) ? Dk : Ut;
}
function Mk(r) {
  return Array.from(r.childNodes);
}
function Ds(r, e) {
  e = "" + e, r.data !== e && (r.data = /** @type {string} */
  e);
}
function zy(r, e) {
  r.value = e ?? "";
}
function Rk(r, e, t, n) {
  r.style.setProperty(e, t, "");
}
function Pk(r, e, { bubbles: t = !1, cancelable: n = !1 } = {}) {
  return new CustomEvent(r, { detail: e, bubbles: t, cancelable: n });
}
function Hk(r) {
  const e = {};
  return r.childNodes.forEach(
    /** @param {Element} node */
    (t) => {
      e[t.slot || "default"] = !0;
    }
  ), e;
}
function An(r, e) {
  return new r(e);
}
let df;
function Wc(r) {
  df = r;
}
function yr() {
  if (!df) throw new Error("Function called outside component initialization");
  return df;
}
function ui(r) {
  yr().$$.on_mount.push(r);
}
function jk(r) {
  yr().$$.after_update.push(r);
}
function fo(r) {
  yr().$$.on_destroy.push(r);
}
function eg() {
  const r = yr();
  return (e, t, { cancelable: n = !1 } = {}) => {
    const i = r.$$.callbacks[e];
    if (i) {
      const s = Pk(
        /** @type {string} */
        e,
        t,
        { cancelable: n }
      );
      return i.slice().forEach((a) => {
        a.call(r, s);
      }), !s.defaultPrevented;
    }
    return !0;
  };
}
function Pr(r, e) {
  return yr().$$.context.set(r, e), e;
}
function pn(r) {
  return yr().$$.context.get(r);
}
function Sa(r, e) {
  const t = r.$$.callbacks[e.type];
  t && t.slice().forEach((n) => n.call(this, e));
}
const nu = [], yt = [];
let bu = [];
const M1 = [], vE = /* @__PURE__ */ Promise.resolve();
let R1 = !1;
function bE() {
  R1 || (R1 = !0, vE.then(pe));
}
function M2() {
  return bE(), vE;
}
function P1(r) {
  bu.push(r);
}
function zn(r) {
  M1.push(r);
}
const Nm = /* @__PURE__ */ new Set();
let Hl = 0;
function pe() {
  if (Hl !== 0)
    return;
  const r = df;
  do {
    try {
      for (; Hl < nu.length; ) {
        const e = nu[Hl];
        Hl++, Wc(e), Kk(e.$$);
      }
    } catch (e) {
      throw nu.length = 0, Hl = 0, e;
    }
    for (Wc(null), nu.length = 0, Hl = 0; yt.length; ) yt.pop()();
    for (let e = 0; e < bu.length; e += 1) {
      const t = bu[e];
      Nm.has(t) || (Nm.add(t), t());
    }
    bu.length = 0;
  } while (nu.length);
  for (; M1.length; )
    M1.pop()();
  R1 = !1, Nm.clear(), Wc(r);
}
function Kk(r) {
  if (r.fragment !== null) {
    r.update(), fr(r.before_update);
    const e = r.dirty;
    r.dirty = [-1], r.fragment && r.fragment.p(r.ctx, e), r.after_update.forEach(P1);
  }
}
function $k(r) {
  const e = [], t = [];
  bu.forEach((n) => r.indexOf(n) === -1 ? e.push(n) : t.push(n)), t.forEach((n) => n()), bu = e;
}
const Yd = /* @__PURE__ */ new Set();
let RA;
function er() {
  RA = {
    r: 0,
    c: [],
    p: RA
    // parent group
  };
}
function tr() {
  RA.r || fr(RA.c), RA = RA.p;
}
function fe(r, e) {
  r && r.i && (Yd.delete(r), r.i(e));
}
function ge(r, e, t, n) {
  if (r && r.o) {
    if (Yd.has(r)) return;
    Yd.add(r), RA.c.push(() => {
      Yd.delete(r), n && (t && r.d(1), n());
    }), r.o(e);
  } else n && n();
}
function Iu(r) {
  return (r == null ? void 0 : r.length) !== void 0 ? r : Array.from(r);
}
function yE(r, e) {
  ge(r, 1, 1, () => {
    e.delete(r.key);
  });
}
function wE(r, e, t, n, i, s, a, o, A, l, u, c) {
  let h = r.length, f = s.length, d = h;
  const p = {};
  for (; d--; ) p[r[d].key] = d;
  const v = [], m = /* @__PURE__ */ new Map(), b = /* @__PURE__ */ new Map(), w = [];
  for (d = f; d--; ) {
    const C = c(i, s, d), F = t(C);
    let N = a.get(F);
    N ? w.push(() => N.p(C, e)) : (N = l(F, C), N.c()), m.set(F, v[d] = N), F in p && b.set(F, Math.abs(d - p[F]));
  }
  const B = /* @__PURE__ */ new Set(), _ = /* @__PURE__ */ new Set();
  function x(C) {
    fe(C, 1), C.m(o, u), a.set(C.key, C), u = C.first, f--;
  }
  for (; h && f; ) {
    const C = v[f - 1], F = r[h - 1], N = C.key, D = F.key;
    C === F ? (u = C.first, h--, f--) : m.has(D) ? !a.has(N) || B.has(N) ? x(C) : _.has(D) ? h-- : b.get(N) > b.get(D) ? (_.add(N), x(C)) : (B.add(D), h--) : (A(F, a), h--);
  }
  for (; h--; ) {
    const C = r[h];
    m.has(C.key) || A(C, a);
  }
  for (; f; ) x(v[f - 1]);
  return fr(w), v;
}
function Et(r, e) {
  const t = {}, n = {}, i = { $$scope: 1 };
  let s = r.length;
  for (; s--; ) {
    const a = r[s], o = e[s];
    if (o) {
      for (const A in a)
        A in o || (n[A] = 1);
      for (const A in o)
        i[A] || (t[A] = o[A], i[A] = 1);
      r[s] = o;
    } else
      for (const A in a)
        i[A] = 1;
  }
  for (const a in n)
    a in t || (t[a] = void 0);
  return t;
}
function Vt(r) {
  return typeof r == "object" && r !== null ? r : {};
}
function Gn(r, e, t) {
  const n = r.$$.props[e];
  n !== void 0 && (r.$$.bound[n] = t, t(r.$$.ctx[n]));
}
function Ve(r) {
  r && r.c();
}
function Ke(r, e, t) {
  const { fragment: n, after_update: i } = r.$$;
  n && n.m(e, t), P1(() => {
    const s = r.$$.on_mount.map(pE).filter(ar);
    r.$$.on_destroy ? r.$$.on_destroy.push(...s) : fr(s), r.$$.on_mount = [];
  }), i.forEach(P1);
}
function $e(r, e) {
  const t = r.$$;
  t.fragment !== null && ($k(t.after_update), fr(t.on_destroy), t.fragment && t.fragment.d(e), t.on_destroy = t.fragment = null, t.ctx = []);
}
function Vk(r, e) {
  r.$$.dirty[0] === -1 && (nu.push(r), bE(), r.$$.dirty.fill(0)), r.$$.dirty[e / 31 | 0] |= 1 << e % 31;
}
function Pt(r, e, t, n, i, s, a = null, o = [-1]) {
  const A = df;
  Wc(r);
  const l = r.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: s,
    update: sr,
    not_equal: i,
    bound: $y(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(e.context || (A ? A.$$.context : [])),
    // everything else
    callbacks: $y(),
    dirty: o,
    skip_bound: !1,
    root: e.target || A.$$.root
  };
  a && a(l.root);
  let u = !1;
  if (l.ctx = t ? t(r, e.props || {}, (c, h, ...f) => {
    const d = f.length ? f[0] : h;
    return l.ctx && i(l.ctx[c], l.ctx[c] = d) && (!l.skip_bound && l.bound[c] && l.bound[c](d), u && Vk(r, c)), h;
  }) : [], l.update(), u = !0, fr(l.before_update), l.fragment = n ? n(l.ctx) : !1, e.target) {
    if (e.hydrate) {
      const c = Mk(e.target);
      l.fragment && l.fragment.l(c), c.forEach(xe);
    } else
      l.fragment && l.fragment.c();
    e.intro && fe(r.$$.fragment), Ke(r, e.target, e.anchor), pe();
  }
  Wc(A);
}
let BE;
typeof HTMLElement == "function" && (BE = class extends HTMLElement {
  constructor(e, t, n) {
    super();
    /** The Svelte component constructor */
    Bs(this, "$$ctor");
    /** Slots */
    Bs(this, "$$s");
    /** The Svelte component instance */
    Bs(this, "$$c");
    /** Whether or not the custom element is connected */
    Bs(this, "$$cn", !1);
    /** Component props data */
    Bs(this, "$$d", {});
    /** `true` if currently in the process of reflecting component props back to attributes */
    Bs(this, "$$r", !1);
    /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
    Bs(this, "$$p_d", {});
    /** @type {Record<string, Function[]>} Event listeners */
    Bs(this, "$$l", {});
    /** @type {Map<Function, Function>} Event listener unsubscribe functions */
    Bs(this, "$$l_u", /* @__PURE__ */ new Map());
    this.$$ctor = e, this.$$s = t, n && this.attachShadow({ mode: "open" });
  }
  addEventListener(e, t, n) {
    if (this.$$l[e] = this.$$l[e] || [], this.$$l[e].push(t), this.$$c) {
      const i = this.$$c.$on(e, t);
      this.$$l_u.set(t, i);
    }
    super.addEventListener(e, t, n);
  }
  removeEventListener(e, t, n) {
    if (super.removeEventListener(e, t, n), this.$$c) {
      const i = this.$$l_u.get(t);
      i && (i(), this.$$l_u.delete(t));
    }
  }
  async connectedCallback() {
    if (this.$$cn = !0, !this.$$c) {
      let e = function(s) {
        return () => {
          let a;
          return {
            c: function() {
              a = We("slot"), s !== "default" && Me(a, "name", s);
            },
            /**
             * @param {HTMLElement} target
             * @param {HTMLElement} [anchor]
             */
            m: function(l, u) {
              ke(l, a, u);
            },
            d: function(l) {
              l && xe(a);
            }
          };
        };
      };
      if (await Promise.resolve(), !this.$$cn || this.$$c)
        return;
      const t = {}, n = Hk(this);
      for (const s of this.$$s)
        s in n && (t[s] = [e(s)]);
      for (const s of this.attributes) {
        const a = this.$$g_p(s.name);
        a in this.$$d || (this.$$d[a] = Zd(a, s.value, this.$$p_d, "toProp"));
      }
      for (const s in this.$$p_d)
        !(s in this.$$d) && this[s] !== void 0 && (this.$$d[s] = this[s], delete this[s]);
      this.$$c = new this.$$ctor({
        target: this.shadowRoot || this,
        props: {
          ...this.$$d,
          $$slots: t,
          $$scope: {
            ctx: []
          }
        }
      });
      const i = () => {
        this.$$r = !0;
        for (const s in this.$$p_d)
          if (this.$$d[s] = this.$$c.$$.ctx[this.$$c.$$.props[s]], this.$$p_d[s].reflect) {
            const a = Zd(
              s,
              this.$$d[s],
              this.$$p_d,
              "toAttribute"
            );
            a == null ? this.removeAttribute(this.$$p_d[s].attribute || s) : this.setAttribute(this.$$p_d[s].attribute || s, a);
          }
        this.$$r = !1;
      };
      this.$$c.$$.after_update.push(i), i();
      for (const s in this.$$l)
        for (const a of this.$$l[s]) {
          const o = this.$$c.$on(s, a);
          this.$$l_u.set(a, o);
        }
      this.$$l = {};
    }
  }
  // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
  // and setting attributes through setAttribute etc, this is helpful
  attributeChangedCallback(e, t, n) {
    var i;
    this.$$r || (e = this.$$g_p(e), this.$$d[e] = Zd(e, n, this.$$p_d, "toProp"), (i = this.$$c) == null || i.$set({ [e]: this.$$d[e] }));
  }
  disconnectedCallback() {
    this.$$cn = !1, Promise.resolve().then(() => {
      !this.$$cn && this.$$c && (this.$$c.$destroy(), this.$$c = void 0);
    });
  }
  $$g_p(e) {
    return Object.keys(this.$$p_d).find(
      (t) => this.$$p_d[t].attribute === e || !this.$$p_d[t].attribute && t.toLowerCase() === e
    ) || e;
  }
});
function Zd(r, e, t, n) {
  var s;
  const i = (s = t[r]) == null ? void 0 : s.type;
  if (e = i === "Boolean" && typeof e != "boolean" ? e != null : e, !n || !t[r])
    return e;
  if (n === "toAttribute")
    switch (i) {
      case "Object":
      case "Array":
        return e == null ? null : JSON.stringify(e);
      case "Boolean":
        return e ? "" : null;
      case "Number":
        return e ?? null;
      default:
        return e;
    }
  else
    switch (i) {
      case "Object":
      case "Array":
        return e && JSON.parse(e);
      case "Boolean":
        return e;
      case "Number":
        return e != null ? +e : e;
      default:
        return e;
    }
}
function Ht(r, e, t, n, i, s) {
  let a = class extends BE {
    constructor() {
      super(r, t, i), this.$$p_d = e;
    }
    static get observedAttributes() {
      return Object.keys(e).map(
        (o) => (e[o].attribute || o).toLowerCase()
      );
    }
  };
  return Object.keys(e).forEach((o) => {
    Object.defineProperty(a.prototype, o, {
      get() {
        return this.$$c && o in this.$$c ? this.$$c[o] : this.$$d[o];
      },
      set(A) {
        var l;
        A = Zd(o, A, e), this.$$d[o] = A, (l = this.$$c) == null || l.$set({ [o]: A });
      }
    });
  }), n.forEach((o) => {
    Object.defineProperty(a.prototype, o, {
      get() {
        var A;
        return (A = this.$$c) == null ? void 0 : A[o];
      }
    });
  }), r.element = /** @type {any} */
  a, a;
}
class jt {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    Bs(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    Bs(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    $e(this, 1), this.$destroy = sr;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(e, t) {
    if (!ar(t))
      return sr;
    const n = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
    return n.push(t), () => {
      const i = n.indexOf(t);
      i !== -1 && n.splice(i, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(e) {
    this.$$set && !kk(e) && (this.$$.skip_bound = !0, this.$$set(e), this.$$.skip_bound = !1);
  }
}
const zk = "4";
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(zk);
const Gk = {
  upload_file: "M440-200h80v-167l64 64 56-57-160-160-160 160 57 56 63-63v167ZM240-80q-33 0-56.5-23.5T160-160v-640q0-33 23.5-56.5T240-880h320l240 240v480q0 33-23.5 56.5T720-80H240Zm280-520v-200H240v640h480v-440H520ZM240-800v200-200 640-640Z",
  download: "M480-320 280-520l56-58 104 104v-326h80v326l104-104 56 58-200 200ZM240-160q-33 0-56.5-23.5T160-240v-120h80v120h480v-120h80v120q0 33-23.5 56.5T720-160H240Z",
  visibility: "M480-320q75 0 127.5-52.5T660-500q0-75-52.5-127.5T480-680q-75 0-127.5 52.5T300-500q0 75 52.5 127.5T480-320Zm0-72q-45 0-76.5-31.5T372-500q0-45 31.5-76.5T480-608q45 0 76.5 31.5T588-500q0 45-31.5 76.5T480-392Zm0 192q-146 0-266-81.5T40-500q54-137 174-218.5T480-800q146 0 266 81.5T920-500q-54 137-174 218.5T480-200Zm0-300Zm0 220q113 0 207.5-59.5T832-500q-50-101-144.5-160.5T480-720q-113 0-207.5 59.5T128-500q50 101 144.5 160.5T480-280Z",
  visibility_off: "m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z",
  close: "m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z",
  nearby: "M480-304 304-480l176-176 176 176-176 176Zm56 199q-11 11-26 17t-30 6q-15 0-30-6t-26-17L105-424q-11-11-17-26t-6-30q0-15 6-30t17-26l318-318q12-12 26.5-18t30.5-6q16 0 30.5 6t26.5 18l318 318q11 11 17 26t6 30q0 15-6 30t-17 26L536-105Zm-56-87 288-288-288-288-288 288 288 288Z",
  nearby_empty: "M536-105c-7.333 7.333-16 13-26 17s-20 6-30 6-20-2-30-6-18.667-9.667-26-17L105-424c-7.333-7.333-13-16-17-26s-6-20-6-30 2-20 6-30 9.667-18.667 17-26l318-318c8-8 16.833-14 26.5-18 9.667-4 19.833-6 30.5-6 10.667 0 20.833 2 30.5 6 9.667 4 18.5 10 26.5 18l318 318c7.333 7.333 13 16 17 26s6 20 6 30-2 20-6 30-9.667 18.667-17 26zm-56-87 288-288-288-288-288 288z",
  more_vert: "M480.34-95Q438-95 409-124.42t-29-70.74q0-42.14 29.07-71.99Q438.13-297 479.66-297 522-297 551-267.26t29 71.5q0 41.76-29.02 71.26Q521.97-95 480.34-95Zm0-285Q438-380 409-409.07q-29-29.06-29-70.59Q380-522 409.07-551q29.06-29 70.59-29Q522-580 551-550.98q29 29.01 29 70.64Q580-438 550.98-409q-29.01 29-70.64 29Zm0-283Q438-663 409-692.95q-29-29.94-29-72Q380-807 409.07-836q29.06-29 70.59-29Q522-865 551-835.98q29 29.01 29 70.86 0 42.25-29.02 72.19Q521.97-663 480.34-663Z",
  keyboard_arrow_down: "M480-305 200-586l95-94 185 185 186-185 95 94-281 281Z",
  keyboard_arrow_right: "M466-480 281-665l95-95 280 280-280 279-95-95 185-184Z",
  edit: "M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z",
  delete: "M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm400-600H280v520h400v-520ZM360-280h80v-360h-80v360Zm160 0h80v-360h-80v360ZM280-720v520-520Z",
  content_copy: "M360-240q-33 0-56.5-23.5T280-320v-480q0-33 23.5-56.5T360-880h360q33 0 56.5 23.5T800-800v480q0 33-23.5 56.5T720-240H360Zm0-80h360v-480H360v480ZM200-80q-33 0-56.5-23.5T120-160v-560h80v560h440v80H200Zm160-240v-480 480Z",
  add: "M440-440H200v-80h240v-240h80v240h240v80H520v240h-80v-240Z",
  arrow_back: "m313-440 224 224-57 56-320-320 320-320 57 56-224 224h487v80H313Z",
  arrow_upward: "M440-160v-487L216-423l-56-57 320-320 320 320-56 57-224-224v487h-80Z",
  arrow_downward: "M440-800v487L216-537l-56 57 320 320 320-320-56-57-224 224v-487h-80Z"
};
function qk(r) {
  let e, t, n, i, s;
  return {
    c() {
      e = Gc("svg"), t = Gc("title"), n = ir("icon "), i = ir(
        /*icon*/
        r[1]
      ), s = Gc("path"), Me(
        s,
        "d",
        /*draw*/
        r[3]
      ), Me(
        e,
        "class",
        /*className*/
        r[2]
      ), Me(e, "xmlns", "http://www.w3.org/2000/svg"), Me(e, "height", "24px"), Me(e, "viewBox", "0 -960 960 960"), Me(e, "width", "24px"), Me(
        e,
        "fill",
        /*fillColor*/
        r[0]
      );
    },
    m(a, o) {
      ke(a, e, o), je(e, t), je(t, n), je(t, i), je(e, s);
    },
    p(a, [o]) {
      o & /*icon*/
      2 && Ds(
        i,
        /*icon*/
        a[1]
      ), o & /*draw*/
      8 && Me(
        s,
        "d",
        /*draw*/
        a[3]
      ), o & /*className*/
      4 && Me(
        e,
        "class",
        /*className*/
        a[2]
      ), o & /*fillColor*/
      1 && Me(
        e,
        "fill",
        /*fillColor*/
        a[0]
      );
    },
    i: sr,
    o: sr,
    d(a) {
      a && xe(e);
    }
  };
}
function Wk(r) {
  return r === "primary" ? "var(--mdc-theme-primary)" : r === "secondary" ? "var(--mdc-theme-secondary)" : r;
}
function Xk(r, e, t) {
  let n, { fillColor: i = "primary" } = e, { icon: s } = e, { class: a = "" } = e;
  function o(A) {
    return Gk[A];
  }
  return r.$$set = (A) => {
    "fillColor" in A && t(0, i = A.fillColor), "icon" in A && t(1, s = A.icon), "class" in A && t(2, a = A.class);
  }, r.$$.update = () => {
    r.$$.dirty & /*icon*/
    2 && t(3, n = o(s)), r.$$.dirty & /*fillColor*/
    1 && t(0, i = Wk(i));
  }, [i, s, a, n];
}
class tg extends jt {
  constructor(e) {
    super(), Pt(this, e, Xk, qk, Mt, { fillColor: 0, icon: 1, class: 2 });
  }
  get fillColor() {
    return this.$$.ctx[0];
  }
  set fillColor(e) {
    this.$$set({ fillColor: e }), pe();
  }
  get icon() {
    return this.$$.ctx[1];
  }
  set icon(e) {
    this.$$set({ icon: e }), pe();
  }
  get class() {
    return this.$$.ctx[2];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
}
Ht(tg, { fillColor: {}, icon: {}, class: {} }, [], [], !0);
var H1 = function(r, e) {
  return H1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
  }, H1(r, e);
};
function Zi(r, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  H1(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var Jr = function() {
  return Jr = Object.assign || function(e) {
    for (var t, n = 1, i = arguments.length; n < i; n++) {
      t = arguments[n];
      for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
    }
    return e;
  }, Jr.apply(this, arguments);
};
function Jk(r, e, t, n) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(u) {
      try {
        l(n.next(u));
      } catch (c) {
        a(c);
      }
    }
    function A(u) {
      try {
        l(n.throw(u));
      } catch (c) {
        a(c);
      }
    }
    function l(u) {
      u.done ? s(u.value) : i(u.value).then(o, A);
    }
    l((n = n.apply(r, e || [])).next());
  });
}
function Yk(r, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, a = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return a.next = o(0), a.throw = o(1), a.return = o(2), typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function o(l) {
    return function(u) {
      return A([l, u]);
    };
  }
  function A(l) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; a && (a = 0, l[0] && (t = 0)), t; ) try {
      if (n = 1, i && (s = l[0] & 2 ? i.return : l[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, l[1])).done) return s;
      switch (i = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
        case 0:
        case 1:
          s = l;
          break;
        case 4:
          return t.label++, { value: l[1], done: !1 };
        case 5:
          t.label++, i = l[1], l = [0];
          continue;
        case 7:
          l = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            t = 0;
            continue;
          }
          if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
            t.label = l[1];
            break;
          }
          if (l[0] === 6 && t.label < s[1]) {
            t.label = s[1], s = l;
            break;
          }
          if (s && t.label < s[2]) {
            t.label = s[2], t.ops.push(l);
            break;
          }
          s[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      l = e.call(r, t);
    } catch (u) {
      l = [6, u], i = 0;
    } finally {
      n = s = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function jo(r) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && r[e], n = 0;
  if (t) return t.call(r);
  if (r && typeof r.length == "number") return {
    next: function() {
      return r && n >= r.length && (r = void 0), { value: r && r[n++], done: !r };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var La = (
  /** @class */
  function() {
    function r(e) {
      e === void 0 && (e = {}), this.adapter = e;
    }
    return Object.defineProperty(r, "cssClasses", {
      get: function() {
        return {};
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "strings", {
      get: function() {
        return {};
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "numbers", {
      get: function() {
        return {};
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "defaultAdapter", {
      get: function() {
        return {};
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.init = function() {
    }, r.prototype.destroy = function() {
    }, r;
  }()
);
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function Zk(r) {
  return r === void 0 && (r = window), eL(r) ? { passive: !0 } : !1;
}
function eL(r) {
  r === void 0 && (r = window);
  var e = !1;
  try {
    var t = {
      // This function will be called when the browser
      // attempts to access the passive property.
      get passive() {
        return e = !0, !1;
      }
    }, n = function() {
    };
    r.document.addEventListener("test", n, t), r.document.removeEventListener("test", n, t);
  } catch {
    e = !1;
  }
  return e;
}
const CE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  applyPassive: Zk
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function tL(r, e) {
  if (r.closest)
    return r.closest(e);
  for (var t = r; t; ) {
    if (_E(t, e))
      return t;
    t = t.parentElement;
  }
  return null;
}
function _E(r, e) {
  var t = r.matches || r.webkitMatchesSelector || r.msMatchesSelector;
  return t.call(r, e);
}
function rL(r) {
  var e = r;
  if (e.offsetParent !== null)
    return e.scrollWidth;
  var t = e.cloneNode(!0);
  t.style.setProperty("position", "absolute"), t.style.setProperty("transform", "translate(-9999px, -9999px)"), document.documentElement.appendChild(t);
  var n = t.scrollWidth;
  return document.documentElement.removeChild(t), n;
}
const EE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  closest: tL,
  estimateScrollWidth: rL,
  matches: _E
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var nL = {
  // Ripple is a special case where the "root" component is really a "mixin" of sorts,
  // given that it's an 'upgrade' to an existing component. That being said it is the root
  // CSS class that all other CSS classes derive from.
  BG_FOCUSED: "mdc-ripple-upgraded--background-focused",
  FG_ACTIVATION: "mdc-ripple-upgraded--foreground-activation",
  FG_DEACTIVATION: "mdc-ripple-upgraded--foreground-deactivation",
  ROOT: "mdc-ripple-upgraded",
  UNBOUNDED: "mdc-ripple-upgraded--unbounded"
}, iL = {
  VAR_FG_SCALE: "--mdc-ripple-fg-scale",
  VAR_FG_SIZE: "--mdc-ripple-fg-size",
  VAR_FG_TRANSLATE_END: "--mdc-ripple-fg-translate-end",
  VAR_FG_TRANSLATE_START: "--mdc-ripple-fg-translate-start",
  VAR_LEFT: "--mdc-ripple-left",
  VAR_TOP: "--mdc-ripple-top"
}, Gy = {
  DEACTIVATION_TIMEOUT_MS: 225,
  FG_DEACTIVATION_MS: 150,
  INITIAL_ORIGIN_SCALE: 0.6,
  PADDING: 10,
  TAP_DELAY_MS: 300
  // Delay between touch and simulated mouse events on touch devices
}, Kh;
function sL(r, e) {
  e === void 0 && (e = !1);
  var t = r.CSS, n = Kh;
  if (typeof Kh == "boolean" && !e)
    return Kh;
  var i = t && typeof t.supports == "function";
  if (!i)
    return !1;
  var s = t.supports("--css-vars", "yes"), a = t.supports("(--css-vars: yes)") && t.supports("color", "#00000000");
  return n = s || a, e || (Kh = n), n;
}
function aL(r, e, t) {
  if (!r)
    return { x: 0, y: 0 };
  var n = e.x, i = e.y, s = n + t.left, a = i + t.top, o, A;
  if (r.type === "touchstart") {
    var l = r;
    o = l.changedTouches[0].pageX - s, A = l.changedTouches[0].pageY - a;
  } else {
    var u = r;
    o = u.pageX - s, A = u.pageY - a;
  }
  return { x: o, y: A };
}
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var qy = [
  "touchstart",
  "pointerdown",
  "mousedown",
  "keydown"
], Wy = [
  "touchend",
  "pointerup",
  "mouseup",
  "contextmenu"
], $h = [], oL = (
  /** @class */
  function(r) {
    Zi(e, r);
    function e(t) {
      var n = r.call(this, Jr(Jr({}, e.defaultAdapter), t)) || this;
      return n.activationAnimationHasEnded = !1, n.activationTimer = 0, n.fgDeactivationRemovalTimer = 0, n.fgScale = "0", n.frame = { width: 0, height: 0 }, n.initialSize = 0, n.layoutFrame = 0, n.maxRadius = 0, n.unboundedCoords = { left: 0, top: 0 }, n.activationState = n.defaultActivationState(), n.activationTimerCallback = function() {
        n.activationAnimationHasEnded = !0, n.runDeactivationUXLogicIfReady();
      }, n.activateHandler = function(i) {
        n.activateImpl(i);
      }, n.deactivateHandler = function() {
        n.deactivateImpl();
      }, n.focusHandler = function() {
        n.handleFocus();
      }, n.blurHandler = function() {
        n.handleBlur();
      }, n.resizeHandler = function() {
        n.layout();
      }, n;
    }
    return Object.defineProperty(e, "cssClasses", {
      get: function() {
        return nL;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "strings", {
      get: function() {
        return iL;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "numbers", {
      get: function() {
        return Gy;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
          },
          browserSupportsCssVars: function() {
            return !0;
          },
          computeBoundingRect: function() {
            return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
          },
          containsEventTarget: function() {
            return !0;
          },
          deregisterDocumentInteractionHandler: function() {
          },
          deregisterInteractionHandler: function() {
          },
          deregisterResizeHandler: function() {
          },
          getWindowPageOffset: function() {
            return { x: 0, y: 0 };
          },
          isSurfaceActive: function() {
            return !0;
          },
          isSurfaceDisabled: function() {
            return !0;
          },
          isUnbounded: function() {
            return !0;
          },
          registerDocumentInteractionHandler: function() {
          },
          registerInteractionHandler: function() {
          },
          registerResizeHandler: function() {
          },
          removeClass: function() {
          },
          updateCssVariable: function() {
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.init = function() {
      var t = this, n = this.supportsPressRipple();
      if (this.registerRootHandlers(n), n) {
        var i = e.cssClasses, s = i.ROOT, a = i.UNBOUNDED;
        requestAnimationFrame(function() {
          t.adapter.addClass(s), t.adapter.isUnbounded() && (t.adapter.addClass(a), t.layoutInternal());
        });
      }
    }, e.prototype.destroy = function() {
      var t = this;
      if (this.supportsPressRipple()) {
        this.activationTimer && (clearTimeout(this.activationTimer), this.activationTimer = 0, this.adapter.removeClass(e.cssClasses.FG_ACTIVATION)), this.fgDeactivationRemovalTimer && (clearTimeout(this.fgDeactivationRemovalTimer), this.fgDeactivationRemovalTimer = 0, this.adapter.removeClass(e.cssClasses.FG_DEACTIVATION));
        var n = e.cssClasses, i = n.ROOT, s = n.UNBOUNDED;
        requestAnimationFrame(function() {
          t.adapter.removeClass(i), t.adapter.removeClass(s), t.removeCssVars();
        });
      }
      this.deregisterRootHandlers(), this.deregisterDeactivationHandlers();
    }, e.prototype.activate = function(t) {
      this.activateImpl(t);
    }, e.prototype.deactivate = function() {
      this.deactivateImpl();
    }, e.prototype.layout = function() {
      var t = this;
      this.layoutFrame && cancelAnimationFrame(this.layoutFrame), this.layoutFrame = requestAnimationFrame(function() {
        t.layoutInternal(), t.layoutFrame = 0;
      });
    }, e.prototype.setUnbounded = function(t) {
      var n = e.cssClasses.UNBOUNDED;
      t ? this.adapter.addClass(n) : this.adapter.removeClass(n);
    }, e.prototype.handleFocus = function() {
      var t = this;
      requestAnimationFrame(function() {
        return t.adapter.addClass(e.cssClasses.BG_FOCUSED);
      });
    }, e.prototype.handleBlur = function() {
      var t = this;
      requestAnimationFrame(function() {
        return t.adapter.removeClass(e.cssClasses.BG_FOCUSED);
      });
    }, e.prototype.supportsPressRipple = function() {
      return this.adapter.browserSupportsCssVars();
    }, e.prototype.defaultActivationState = function() {
      return {
        activationEvent: void 0,
        hasDeactivationUXRun: !1,
        isActivated: !1,
        isProgrammatic: !1,
        wasActivatedByPointer: !1,
        wasElementMadeActive: !1
      };
    }, e.prototype.registerRootHandlers = function(t) {
      var n, i;
      if (t) {
        try {
          for (var s = jo(qy), a = s.next(); !a.done; a = s.next()) {
            var o = a.value;
            this.adapter.registerInteractionHandler(o, this.activateHandler);
          }
        } catch (A) {
          n = { error: A };
        } finally {
          try {
            a && !a.done && (i = s.return) && i.call(s);
          } finally {
            if (n) throw n.error;
          }
        }
        this.adapter.isUnbounded() && this.adapter.registerResizeHandler(this.resizeHandler);
      }
      this.adapter.registerInteractionHandler("focus", this.focusHandler), this.adapter.registerInteractionHandler("blur", this.blurHandler);
    }, e.prototype.registerDeactivationHandlers = function(t) {
      var n, i;
      if (t.type === "keydown")
        this.adapter.registerInteractionHandler("keyup", this.deactivateHandler);
      else
        try {
          for (var s = jo(Wy), a = s.next(); !a.done; a = s.next()) {
            var o = a.value;
            this.adapter.registerDocumentInteractionHandler(o, this.deactivateHandler);
          }
        } catch (A) {
          n = { error: A };
        } finally {
          try {
            a && !a.done && (i = s.return) && i.call(s);
          } finally {
            if (n) throw n.error;
          }
        }
    }, e.prototype.deregisterRootHandlers = function() {
      var t, n;
      try {
        for (var i = jo(qy), s = i.next(); !s.done; s = i.next()) {
          var a = s.value;
          this.adapter.deregisterInteractionHandler(a, this.activateHandler);
        }
      } catch (o) {
        t = { error: o };
      } finally {
        try {
          s && !s.done && (n = i.return) && n.call(i);
        } finally {
          if (t) throw t.error;
        }
      }
      this.adapter.deregisterInteractionHandler("focus", this.focusHandler), this.adapter.deregisterInteractionHandler("blur", this.blurHandler), this.adapter.isUnbounded() && this.adapter.deregisterResizeHandler(this.resizeHandler);
    }, e.prototype.deregisterDeactivationHandlers = function() {
      var t, n;
      this.adapter.deregisterInteractionHandler("keyup", this.deactivateHandler);
      try {
        for (var i = jo(Wy), s = i.next(); !s.done; s = i.next()) {
          var a = s.value;
          this.adapter.deregisterDocumentInteractionHandler(a, this.deactivateHandler);
        }
      } catch (o) {
        t = { error: o };
      } finally {
        try {
          s && !s.done && (n = i.return) && n.call(i);
        } finally {
          if (t) throw t.error;
        }
      }
    }, e.prototype.removeCssVars = function() {
      var t = this, n = e.strings, i = Object.keys(n);
      i.forEach(function(s) {
        s.indexOf("VAR_") === 0 && t.adapter.updateCssVariable(n[s], null);
      });
    }, e.prototype.activateImpl = function(t) {
      var n = this;
      if (!this.adapter.isSurfaceDisabled()) {
        var i = this.activationState;
        if (!i.isActivated) {
          var s = this.previousActivationEvent, a = s && t !== void 0 && s.type !== t.type;
          if (!a) {
            i.isActivated = !0, i.isProgrammatic = t === void 0, i.activationEvent = t, i.wasActivatedByPointer = i.isProgrammatic ? !1 : t !== void 0 && (t.type === "mousedown" || t.type === "touchstart" || t.type === "pointerdown");
            var o = t !== void 0 && $h.length > 0 && $h.some(function(A) {
              return n.adapter.containsEventTarget(A);
            });
            if (o) {
              this.resetActivationState();
              return;
            }
            t !== void 0 && ($h.push(t.target), this.registerDeactivationHandlers(t)), i.wasElementMadeActive = this.checkElementMadeActive(t), i.wasElementMadeActive && this.animateActivation(), requestAnimationFrame(function() {
              $h = [], !i.wasElementMadeActive && t !== void 0 && (t.key === " " || t.keyCode === 32) && (i.wasElementMadeActive = n.checkElementMadeActive(t), i.wasElementMadeActive && n.animateActivation()), i.wasElementMadeActive || (n.activationState = n.defaultActivationState());
            });
          }
        }
      }
    }, e.prototype.checkElementMadeActive = function(t) {
      return t !== void 0 && t.type === "keydown" ? this.adapter.isSurfaceActive() : !0;
    }, e.prototype.animateActivation = function() {
      var t = this, n = e.strings, i = n.VAR_FG_TRANSLATE_START, s = n.VAR_FG_TRANSLATE_END, a = e.cssClasses, o = a.FG_DEACTIVATION, A = a.FG_ACTIVATION, l = e.numbers.DEACTIVATION_TIMEOUT_MS;
      this.layoutInternal();
      var u = "", c = "";
      if (!this.adapter.isUnbounded()) {
        var h = this.getFgTranslationCoordinates(), f = h.startPoint, d = h.endPoint;
        u = f.x + "px, " + f.y + "px", c = d.x + "px, " + d.y + "px";
      }
      this.adapter.updateCssVariable(i, u), this.adapter.updateCssVariable(s, c), clearTimeout(this.activationTimer), clearTimeout(this.fgDeactivationRemovalTimer), this.rmBoundedActivationClasses(), this.adapter.removeClass(o), this.adapter.computeBoundingRect(), this.adapter.addClass(A), this.activationTimer = setTimeout(function() {
        t.activationTimerCallback();
      }, l);
    }, e.prototype.getFgTranslationCoordinates = function() {
      var t = this.activationState, n = t.activationEvent, i = t.wasActivatedByPointer, s;
      i ? s = aL(n, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect()) : s = {
        x: this.frame.width / 2,
        y: this.frame.height / 2
      }, s = {
        x: s.x - this.initialSize / 2,
        y: s.y - this.initialSize / 2
      };
      var a = {
        x: this.frame.width / 2 - this.initialSize / 2,
        y: this.frame.height / 2 - this.initialSize / 2
      };
      return { startPoint: s, endPoint: a };
    }, e.prototype.runDeactivationUXLogicIfReady = function() {
      var t = this, n = e.cssClasses.FG_DEACTIVATION, i = this.activationState, s = i.hasDeactivationUXRun, a = i.isActivated, o = s || !a;
      o && this.activationAnimationHasEnded && (this.rmBoundedActivationClasses(), this.adapter.addClass(n), this.fgDeactivationRemovalTimer = setTimeout(function() {
        t.adapter.removeClass(n);
      }, Gy.FG_DEACTIVATION_MS));
    }, e.prototype.rmBoundedActivationClasses = function() {
      var t = e.cssClasses.FG_ACTIVATION;
      this.adapter.removeClass(t), this.activationAnimationHasEnded = !1, this.adapter.computeBoundingRect();
    }, e.prototype.resetActivationState = function() {
      var t = this;
      this.previousActivationEvent = this.activationState.activationEvent, this.activationState = this.defaultActivationState(), setTimeout(function() {
        return t.previousActivationEvent = void 0;
      }, e.numbers.TAP_DELAY_MS);
    }, e.prototype.deactivateImpl = function() {
      var t = this, n = this.activationState;
      if (n.isActivated) {
        var i = Jr({}, n);
        n.isProgrammatic ? (requestAnimationFrame(function() {
          t.animateDeactivation(i);
        }), this.resetActivationState()) : (this.deregisterDeactivationHandlers(), requestAnimationFrame(function() {
          t.activationState.hasDeactivationUXRun = !0, t.animateDeactivation(i), t.resetActivationState();
        }));
      }
    }, e.prototype.animateDeactivation = function(t) {
      var n = t.wasActivatedByPointer, i = t.wasElementMadeActive;
      (n || i) && this.runDeactivationUXLogicIfReady();
    }, e.prototype.layoutInternal = function() {
      var t = this;
      this.frame = this.adapter.computeBoundingRect();
      var n = Math.max(this.frame.height, this.frame.width), i = function() {
        var a = Math.sqrt(Math.pow(t.frame.width, 2) + Math.pow(t.frame.height, 2));
        return a + e.numbers.PADDING;
      };
      this.maxRadius = this.adapter.isUnbounded() ? n : i();
      var s = Math.floor(n * e.numbers.INITIAL_ORIGIN_SCALE);
      this.adapter.isUnbounded() && s % 2 !== 0 ? this.initialSize = s - 1 : this.initialSize = s, this.fgScale = "" + this.maxRadius / this.initialSize, this.updateLayoutCssVars();
    }, e.prototype.updateLayoutCssVars = function() {
      var t = e.strings, n = t.VAR_FG_SIZE, i = t.VAR_LEFT, s = t.VAR_TOP, a = t.VAR_FG_SCALE;
      this.adapter.updateCssVariable(n, this.initialSize + "px"), this.adapter.updateCssVariable(a, this.fgScale), this.adapter.isUnbounded() && (this.unboundedCoords = {
        left: Math.round(this.frame.width / 2 - this.initialSize / 2),
        top: Math.round(this.frame.height / 2 - this.initialSize / 2)
      }, this.adapter.updateCssVariable(i, this.unboundedCoords.left + "px"), this.adapter.updateCssVariable(s, this.unboundedCoords.top + "px"));
    }, e;
  }(La)
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var Vh = {
  ICON_BUTTON_ON: "mdc-icon-button--on",
  ROOT: "mdc-icon-button"
}, qa = {
  ARIA_LABEL: "aria-label",
  ARIA_PRESSED: "aria-pressed",
  DATA_ARIA_LABEL_OFF: "data-aria-label-off",
  DATA_ARIA_LABEL_ON: "data-aria-label-on",
  CHANGE_EVENT: "MDCIconButtonToggle:change"
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var AL = (
  /** @class */
  function(r) {
    Zi(e, r);
    function e(t) {
      var n = r.call(this, Jr(Jr({}, e.defaultAdapter), t)) || this;
      return n.hasToggledAriaLabel = !1, n;
    }
    return Object.defineProperty(e, "cssClasses", {
      get: function() {
        return Vh;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "strings", {
      get: function() {
        return qa;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
          },
          hasClass: function() {
            return !1;
          },
          notifyChange: function() {
          },
          removeClass: function() {
          },
          getAttr: function() {
            return null;
          },
          setAttr: function() {
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.init = function() {
      var t = this.adapter.getAttr(qa.DATA_ARIA_LABEL_ON), n = this.adapter.getAttr(qa.DATA_ARIA_LABEL_OFF);
      if (t && n) {
        if (this.adapter.getAttr(qa.ARIA_PRESSED) !== null)
          throw new Error("MDCIconButtonToggleFoundation: Button should not set `aria-pressed` if it has a toggled aria label.");
        this.hasToggledAriaLabel = !0;
      } else
        this.adapter.setAttr(qa.ARIA_PRESSED, String(this.isOn()));
    }, e.prototype.handleClick = function() {
      this.toggle(), this.adapter.notifyChange({ isOn: this.isOn() });
    }, e.prototype.isOn = function() {
      return this.adapter.hasClass(Vh.ICON_BUTTON_ON);
    }, e.prototype.toggle = function(t) {
      if (t === void 0 && (t = !this.isOn()), t ? this.adapter.addClass(Vh.ICON_BUTTON_ON) : this.adapter.removeClass(Vh.ICON_BUTTON_ON), this.hasToggledAriaLabel) {
        var n = t ? this.adapter.getAttr(qa.DATA_ARIA_LABEL_ON) : this.adapter.getAttr(qa.DATA_ARIA_LABEL_OFF);
        this.adapter.setAttr(qa.ARIA_LABEL, n || "");
      } else
        this.adapter.setAttr(qa.ARIA_PRESSED, "" + t);
    }, e;
  }(La)
);
function ht(r) {
  return Object.entries(r).filter(([e, t]) => e !== "" && t).map(([e]) => e).join(" ");
}
function pr(r, e, t, n = { bubbles: !0 }, i = !1) {
  if (typeof Event > "u")
    throw new Error("Event not defined.");
  if (!r)
    throw new Error("Tried to dipatch event without element.");
  const s = new CustomEvent(e, Object.assign(Object.assign({}, n), { detail: t }));
  if (r == null || r.dispatchEvent(s), i && e.startsWith("SMUI")) {
    const a = new CustomEvent(e.replace(/^SMUI/g, () => "MDC"), Object.assign(Object.assign({}, n), { detail: t }));
    r == null || r.dispatchEvent(a), a.defaultPrevented && s.preventDefault();
  }
  return s;
}
function Ia(r, e) {
  let t = Object.getOwnPropertyNames(r);
  const n = {};
  for (let i = 0; i < t.length; i++) {
    const s = t[i], a = s.indexOf("$");
    a !== -1 && e.indexOf(s.substring(0, a + 1)) !== -1 || e.indexOf(s) === -1 && (n[s] = r[s]);
  }
  return n;
}
const Xy = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/, lL = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
function Kr(r) {
  let e, t = [];
  r.$on = (i, s) => {
    let a = i, o = () => {
    };
    return e ? o = e(a, s) : t.push([a, s]), a.match(Xy) && console && console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', a), () => {
      o();
    };
  };
  function n(i) {
    const s = r.$$.callbacks[i.type];
    s && s.slice().forEach((a) => a.call(this, i));
  }
  return (i) => {
    const s = [], a = {};
    e = (o, A) => {
      let l = o, u = A, c = !1;
      const h = l.match(Xy), f = l.match(lL), d = h || f;
      if (l.match(/^SMUI:\w+:/)) {
        const m = l.split(":");
        let b = "";
        for (let w = 0; w < m.length; w++)
          b += w === m.length - 1 ? ":" + m[w] : m[w].split("-").map((B) => B.slice(0, 1).toUpperCase() + B.slice(1)).join("");
        console.warn(`The event ${l.split("$")[0]} has been renamed to ${b.split("$")[0]}.`), l = b;
      }
      if (d) {
        const m = l.split(h ? ":" : "$");
        l = m[0];
        const b = m.slice(1).reduce((w, B) => (w[B] = !0, w), {});
        b.passive && (c = c || {}, c.passive = !0), b.nonpassive && (c = c || {}, c.passive = !1), b.capture && (c = c || {}, c.capture = !0), b.once && (c = c || {}, c.once = !0), b.preventDefault && (u = uL(u)), b.stopPropagation && (u = cL(u)), b.stopImmediatePropagation && (u = fL(u)), b.self && (u = hL(i, u)), b.trusted && (u = dL(u));
      }
      const p = Jy(i, l, u, c), v = () => {
        p();
        const m = s.indexOf(v);
        m > -1 && s.splice(m, 1);
      };
      return s.push(v), l in a || (a[l] = Jy(i, l, n)), v;
    };
    for (let o = 0; o < t.length; o++)
      e(t[o][0], t[o][1]);
    return {
      destroy: () => {
        for (let o = 0; o < s.length; o++)
          s[o]();
        for (let o of Object.entries(a))
          o[1]();
      }
    };
  };
}
function Jy(r, e, t, n) {
  return r.addEventListener(e, t, n), () => r.removeEventListener(e, t, n);
}
function uL(r) {
  return function(e) {
    return e.preventDefault(), r.call(this, e);
  };
}
function cL(r) {
  return function(e) {
    return e.stopPropagation(), r.call(this, e);
  };
}
function fL(r) {
  return function(e) {
    return e.stopImmediatePropagation(), r.call(this, e);
  };
}
function hL(r, e) {
  return function(t) {
    if (t.target === r)
      return e.call(this, t);
  };
}
function dL(r) {
  return function(e) {
    if (e.isTrusted)
      return r.call(this, e);
  };
}
function on(r, e) {
  let t = Object.getOwnPropertyNames(r);
  const n = {};
  for (let i = 0; i < t.length; i++) {
    const s = t[i];
    s.substring(0, e.length) === e && (n[s.substring(e.length)] = r[s]);
  }
  return n;
}
function xr(r, e) {
  let t = [];
  if (e)
    for (let n = 0; n < e.length; n++) {
      const i = e[n], s = Array.isArray(i) ? i[0] : i;
      Array.isArray(i) && i.length > 1 ? t.push(s(r, i[1])) : t.push(s(r));
    }
  return {
    update(n) {
      if ((n && n.length || 0) != t.length)
        throw new Error("You must not change the length of an actions array.");
      if (n)
        for (let i = 0; i < n.length; i++) {
          const s = t[i];
          if (s && s.update) {
            const a = n[i];
            Array.isArray(a) && a.length > 1 ? s.update(a[1]) : s.update();
          }
        }
    },
    destroy() {
      for (let n = 0; n < t.length; n++) {
        const i = t[n];
        i && i.destroy && i.destroy();
      }
    }
  };
}
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var Om = "mdc-dom-focus-sentinel", pL = (
  /** @class */
  function() {
    function r(e, t) {
      t === void 0 && (t = {}), this.root = e, this.options = t, this.elFocusedBeforeTrapFocus = null;
    }
    return r.prototype.trapFocus = function() {
      var e = this.getFocusableElements(this.root);
      if (e.length === 0)
        throw new Error("FocusTrap: Element must have at least one focusable child.");
      this.elFocusedBeforeTrapFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null, this.wrapTabFocus(this.root), this.options.skipInitialFocus || this.focusInitialElement(e, this.options.initialFocusEl);
    }, r.prototype.releaseFocus = function() {
      [].slice.call(this.root.querySelectorAll("." + Om)).forEach(function(e) {
        e.parentElement.removeChild(e);
      }), !this.options.skipRestoreFocus && this.elFocusedBeforeTrapFocus && this.elFocusedBeforeTrapFocus.focus();
    }, r.prototype.wrapTabFocus = function(e) {
      var t = this, n = this.createSentinel(), i = this.createSentinel();
      n.addEventListener("focus", function() {
        var s = t.getFocusableElements(e);
        s.length > 0 && s[s.length - 1].focus();
      }), i.addEventListener("focus", function() {
        var s = t.getFocusableElements(e);
        s.length > 0 && s[0].focus();
      }), e.insertBefore(n, e.children[0]), e.appendChild(i);
    }, r.prototype.focusInitialElement = function(e, t) {
      var n = 0;
      t && (n = Math.max(e.indexOf(t), 0)), e[n].focus();
    }, r.prototype.getFocusableElements = function(e) {
      var t = [].slice.call(e.querySelectorAll("[autofocus], [tabindex], a, input, textarea, select, button"));
      return t.filter(function(n) {
        var i = n.getAttribute("aria-disabled") === "true" || n.getAttribute("disabled") != null || n.getAttribute("hidden") != null || n.getAttribute("aria-hidden") === "true", s = n.tabIndex >= 0 && n.getBoundingClientRect().width > 0 && !n.classList.contains(Om) && !i, a = !1;
        if (s) {
          var o = getComputedStyle(n);
          a = o.display === "none" || o.visibility === "hidden";
        }
        return s && !a;
      });
    }, r.prototype.createSentinel = function() {
      var e = document.createElement("div");
      return e.setAttribute("tabindex", "0"), e.setAttribute("aria-hidden", "true"), e.classList.add(Om), e;
    }, r;
  }()
);
const gL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FocusTrap: pL
}, Symbol.toStringTag, { value: "Module" })), { applyPassive: zh } = CE, { matches: mL } = EE;
function io(r, { ripple: e = !0, surface: t = !1, unbounded: n = !1, disabled: i = !1, color: s, active: a, rippleElement: o, eventTarget: A, activeTarget: l, addClass: u = (d) => r.classList.add(d), removeClass: c = (d) => r.classList.remove(d), addStyle: h = (d, p) => r.style.setProperty(d, p), initPromise: f = Promise.resolve() } = {}) {
  let d, p = pn("SMUI:addLayoutListener"), v, m = a, b = A, w = l;
  function B() {
    t ? (u("mdc-ripple-surface"), s === "primary" ? (u("smui-ripple-surface--primary"), c("smui-ripple-surface--secondary")) : s === "secondary" ? (c("smui-ripple-surface--primary"), u("smui-ripple-surface--secondary")) : (c("smui-ripple-surface--primary"), c("smui-ripple-surface--secondary"))) : (c("mdc-ripple-surface"), c("smui-ripple-surface--primary"), c("smui-ripple-surface--secondary")), d && m !== a && (m = a, a ? d.activate() : a === !1 && d.deactivate()), e && !d ? (d = new oL({
      addClass: u,
      browserSupportsCssVars: () => sL(window),
      computeBoundingRect: () => (o || r).getBoundingClientRect(),
      containsEventTarget: (x) => r.contains(x),
      deregisterDocumentInteractionHandler: (x, C) => document.documentElement.removeEventListener(x, C, zh()),
      deregisterInteractionHandler: (x, C) => (A || r).removeEventListener(x, C, zh()),
      deregisterResizeHandler: (x) => window.removeEventListener("resize", x),
      getWindowPageOffset: () => ({
        x: window.pageXOffset,
        y: window.pageYOffset
      }),
      isSurfaceActive: () => a ?? mL(l || r, ":active"),
      isSurfaceDisabled: () => !!i,
      isUnbounded: () => !!n,
      registerDocumentInteractionHandler: (x, C) => document.documentElement.addEventListener(x, C, zh()),
      registerInteractionHandler: (x, C) => (A || r).addEventListener(x, C, zh()),
      registerResizeHandler: (x) => window.addEventListener("resize", x),
      removeClass: c,
      updateCssVariable: h
    }), f.then(() => {
      d && (d.init(), d.setUnbounded(n));
    })) : d && !e && f.then(() => {
      d && (d.destroy(), d = void 0);
    }), d && (b !== A || w !== l) && (b = A, w = l, d.destroy(), requestAnimationFrame(() => {
      d && (d.init(), d.setUnbounded(n));
    })), !e && n && u("mdc-ripple-upgraded--unbounded");
  }
  B(), p && (v = p(_));
  function _() {
    d && d.layout();
  }
  return {
    update(x) {
      ({
        ripple: e,
        surface: t,
        unbounded: n,
        disabled: i,
        color: s,
        active: a,
        rippleElement: o,
        eventTarget: A,
        activeTarget: l,
        addClass: u,
        removeClass: c,
        addStyle: h,
        initPromise: f
      } = Object.assign({ ripple: !0, surface: !1, unbounded: !1, disabled: !1, color: void 0, active: void 0, rippleElement: void 0, eventTarget: void 0, activeTarget: void 0, addClass: (C) => r.classList.add(C), removeClass: (C) => r.classList.remove(C), addStyle: (C, F) => r.style.setProperty(C, F), initPromise: Promise.resolve() }, x)), B();
    },
    destroy() {
      d && (d.destroy(), d = void 0, c("mdc-ripple-surface"), c("smui-ripple-surface--primary"), c("smui-ripple-surface--secondary")), v && v();
    }
  };
}
function vL(r) {
  let e;
  const t = (
    /*#slots*/
    r[10].default
  ), n = Nt(
    t,
    r,
    /*$$scope*/
    r[12],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, s) {
      n && n.m(i, s), e = !0;
    },
    p(i, s) {
      n && n.p && (!e || s & /*$$scope*/
      4096) && Qt(
        n,
        t,
        i,
        /*$$scope*/
        i[12],
        e ? Ot(
          t,
          /*$$scope*/
          i[12],
          s,
          null
        ) : Dt(
          /*$$scope*/
          i[12]
        ),
        null
      );
    },
    i(i) {
      e || (fe(n, i), e = !0);
    },
    o(i) {
      ge(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function bL(r) {
  let e, t, n;
  const i = [
    { tag: (
      /*tag*/
      r[3]
    ) },
    {
      use: [
        /*forwardEvents*/
        r[5],
        .../*use*/
        r[0]
      ]
    },
    {
      class: ht({
        [
          /*className*/
          r[1]
        ]: !0,
        "mdc-button__label": (
          /*context*/
          r[6] === "button"
        ),
        "mdc-fab__label": (
          /*context*/
          r[6] === "fab"
        ),
        "mdc-tab__text-label": (
          /*context*/
          r[6] === "tab"
        ),
        "mdc-image-list__label": (
          /*context*/
          r[6] === "image-list"
        ),
        "mdc-snackbar__label": (
          /*context*/
          r[6] === "snackbar"
        ),
        "mdc-banner__text": (
          /*context*/
          r[6] === "banner"
        ),
        "mdc-segmented-button__label": (
          /*context*/
          r[6] === "segmented-button"
        ),
        "mdc-data-table__pagination-rows-per-page-label": (
          /*context*/
          r[6] === "data-table:pagination"
        ),
        "mdc-data-table__header-cell-label": (
          /*context*/
          r[6] === "data-table:sortable-header-cell"
        )
      })
    },
    /*context*/
    r[6] === "snackbar" ? { "aria-atomic": "false" } : {},
    { tabindex: (
      /*tabindex*/
      r[7]
    ) },
    /*$$restProps*/
    r[8]
  ];
  var s = (
    /*component*/
    r[2]
  );
  function a(o, A) {
    let l = {
      $$slots: { default: [vL] },
      $$scope: { ctx: o }
    };
    for (let u = 0; u < i.length; u += 1)
      l = ze(l, i[u]);
    return A !== void 0 && A & /*tag, forwardEvents, use, className, context, tabindex, $$restProps*/
    491 && (l = ze(l, Et(i, [
      A & /*tag*/
      8 && { tag: (
        /*tag*/
        o[3]
      ) },
      A & /*forwardEvents, use*/
      33 && {
        use: [
          /*forwardEvents*/
          o[5],
          .../*use*/
          o[0]
        ]
      },
      A & /*className, context*/
      66 && {
        class: ht({
          [
            /*className*/
            o[1]
          ]: !0,
          "mdc-button__label": (
            /*context*/
            o[6] === "button"
          ),
          "mdc-fab__label": (
            /*context*/
            o[6] === "fab"
          ),
          "mdc-tab__text-label": (
            /*context*/
            o[6] === "tab"
          ),
          "mdc-image-list__label": (
            /*context*/
            o[6] === "image-list"
          ),
          "mdc-snackbar__label": (
            /*context*/
            o[6] === "snackbar"
          ),
          "mdc-banner__text": (
            /*context*/
            o[6] === "banner"
          ),
          "mdc-segmented-button__label": (
            /*context*/
            o[6] === "segmented-button"
          ),
          "mdc-data-table__pagination-rows-per-page-label": (
            /*context*/
            o[6] === "data-table:pagination"
          ),
          "mdc-data-table__header-cell-label": (
            /*context*/
            o[6] === "data-table:sortable-header-cell"
          )
        })
      },
      A & /*context*/
      64 && Vt(
        /*context*/
        o[6] === "snackbar" ? { "aria-atomic": "false" } : {}
      ),
      A & /*tabindex*/
      128 && { tabindex: (
        /*tabindex*/
        o[7]
      ) },
      A & /*$$restProps*/
      256 && Vt(
        /*$$restProps*/
        o[8]
      )
    ]))), { props: l };
  }
  return s && (e = An(s, a(r)), r[11](e)), {
    c() {
      e && Ve(e.$$.fragment), t = Or();
    },
    m(o, A) {
      e && Ke(e, o, A), ke(o, t, A), n = !0;
    },
    p(o, [A]) {
      if (A & /*component*/
      4 && s !== (s = /*component*/
      o[2])) {
        if (e) {
          er();
          const l = e;
          ge(l.$$.fragment, 1, 0, () => {
            $e(l, 1);
          }), tr();
        }
        s ? (e = An(s, a(o, A)), o[11](e), Ve(e.$$.fragment), fe(e.$$.fragment, 1), Ke(e, t.parentNode, t)) : e = null;
      } else if (s) {
        const l = A & /*tag, forwardEvents, use, className, context, tabindex, $$restProps*/
        491 ? Et(i, [
          A & /*tag*/
          8 && { tag: (
            /*tag*/
            o[3]
          ) },
          A & /*forwardEvents, use*/
          33 && {
            use: [
              /*forwardEvents*/
              o[5],
              .../*use*/
              o[0]
            ]
          },
          A & /*className, context*/
          66 && {
            class: ht({
              [
                /*className*/
                o[1]
              ]: !0,
              "mdc-button__label": (
                /*context*/
                o[6] === "button"
              ),
              "mdc-fab__label": (
                /*context*/
                o[6] === "fab"
              ),
              "mdc-tab__text-label": (
                /*context*/
                o[6] === "tab"
              ),
              "mdc-image-list__label": (
                /*context*/
                o[6] === "image-list"
              ),
              "mdc-snackbar__label": (
                /*context*/
                o[6] === "snackbar"
              ),
              "mdc-banner__text": (
                /*context*/
                o[6] === "banner"
              ),
              "mdc-segmented-button__label": (
                /*context*/
                o[6] === "segmented-button"
              ),
              "mdc-data-table__pagination-rows-per-page-label": (
                /*context*/
                o[6] === "data-table:pagination"
              ),
              "mdc-data-table__header-cell-label": (
                /*context*/
                o[6] === "data-table:sortable-header-cell"
              )
            })
          },
          A & /*context*/
          64 && Vt(
            /*context*/
            o[6] === "snackbar" ? { "aria-atomic": "false" } : {}
          ),
          A & /*tabindex*/
          128 && { tabindex: (
            /*tabindex*/
            o[7]
          ) },
          A & /*$$restProps*/
          256 && Vt(
            /*$$restProps*/
            o[8]
          )
        ]) : {};
        A & /*$$scope*/
        4096 && (l.$$scope = { dirty: A, ctx: o }), e.$set(l);
      }
    },
    i(o) {
      n || (e && fe(e.$$.fragment, o), n = !0);
    },
    o(o) {
      e && ge(e.$$.fragment, o), n = !1;
    },
    d(o) {
      o && xe(t), r[11](null), e && $e(e, o);
    }
  };
}
function yL(r, e, t) {
  const n = ["use", "class", "component", "tag", "getElement"];
  let i = xt(e, n), { $$slots: s = {}, $$scope: a } = e;
  const o = Kr(yr());
  let { use: A = [] } = e, { class: l = "" } = e, u, { component: c = Ni } = e, { tag: h = c === Ni ? "span" : void 0 } = e;
  const f = pn("SMUI:label:context"), d = pn("SMUI:label:tabindex");
  function p() {
    return u.getElement();
  }
  function v(m) {
    yt[m ? "unshift" : "push"](() => {
      u = m, t(4, u);
    });
  }
  return r.$$set = (m) => {
    e = ze(ze({}, e), Nr(m)), t(8, i = xt(e, n)), "use" in m && t(0, A = m.use), "class" in m && t(1, l = m.class), "component" in m && t(2, c = m.component), "tag" in m && t(3, h = m.tag), "$$scope" in m && t(12, a = m.$$scope);
  }, [
    A,
    l,
    c,
    h,
    u,
    o,
    f,
    d,
    i,
    p,
    s,
    v,
    a
  ];
}
class R2 extends jt {
  constructor(e) {
    super(), Pt(this, e, yL, bL, Mt, {
      use: 0,
      class: 1,
      component: 2,
      tag: 3,
      getElement: 9
    });
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[1];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get component() {
    return this.$$.ctx[2];
  }
  set component(e) {
    this.$$set({ component: e }), pe();
  }
  get tag() {
    return this.$$.ctx[3];
  }
  set tag(e) {
    this.$$set({ tag: e }), pe();
  }
  get getElement() {
    return this.$$.ctx[9];
  }
}
Ht(R2, { use: {}, class: {}, component: {}, tag: {} }, ["default"], ["getElement"], !0);
function wL(r) {
  let e;
  const t = (
    /*#slots*/
    r[11].default
  ), n = Nt(
    t,
    r,
    /*$$scope*/
    r[13],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, s) {
      n && n.m(i, s), e = !0;
    },
    p(i, s) {
      n && n.p && (!e || s & /*$$scope*/
      8192) && Qt(
        n,
        t,
        i,
        /*$$scope*/
        i[13],
        e ? Ot(
          t,
          /*$$scope*/
          i[13],
          s,
          null
        ) : Dt(
          /*$$scope*/
          i[13]
        ),
        null
      );
    },
    i(i) {
      e || (fe(n, i), e = !0);
    },
    o(i) {
      ge(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function BL(r) {
  let e, t, n;
  const i = [
    { tag: (
      /*tag*/
      r[4]
    ) },
    {
      use: [
        /*forwardEvents*/
        r[6],
        .../*use*/
        r[0]
      ]
    },
    {
      class: ht({
        [
          /*className*/
          r[1]
        ]: !0,
        "mdc-button__icon": (
          /*context*/
          r[8] === "button"
        ),
        "mdc-fab__icon": (
          /*context*/
          r[8] === "fab"
        ),
        "mdc-icon-button__icon": (
          /*context*/
          r[8] === "icon-button"
        ),
        "mdc-icon-button__icon--on": (
          /*context*/
          r[8] === "icon-button" && /*on*/
          r[2]
        ),
        "mdc-tab__icon": (
          /*context*/
          r[8] === "tab"
        ),
        "mdc-banner__icon": (
          /*context*/
          r[8] === "banner"
        ),
        "mdc-segmented-button__icon": (
          /*context*/
          r[8] === "segmented-button"
        )
      })
    },
    { "aria-hidden": "true" },
    /*svg*/
    r[7] ? { focusable: "false", tabindex: "-1" } : {},
    /*$$restProps*/
    r[9]
  ];
  var s = (
    /*component*/
    r[3]
  );
  function a(o, A) {
    let l = {
      $$slots: { default: [wL] },
      $$scope: { ctx: o }
    };
    for (let u = 0; u < i.length; u += 1)
      l = ze(l, i[u]);
    return A !== void 0 && A & /*tag, forwardEvents, use, className, context, on, svg, $$restProps*/
    983 && (l = ze(l, Et(i, [
      A & /*tag*/
      16 && { tag: (
        /*tag*/
        o[4]
      ) },
      A & /*forwardEvents, use*/
      65 && {
        use: [
          /*forwardEvents*/
          o[6],
          .../*use*/
          o[0]
        ]
      },
      A & /*className, context, on*/
      262 && {
        class: ht({
          [
            /*className*/
            o[1]
          ]: !0,
          "mdc-button__icon": (
            /*context*/
            o[8] === "button"
          ),
          "mdc-fab__icon": (
            /*context*/
            o[8] === "fab"
          ),
          "mdc-icon-button__icon": (
            /*context*/
            o[8] === "icon-button"
          ),
          "mdc-icon-button__icon--on": (
            /*context*/
            o[8] === "icon-button" && /*on*/
            o[2]
          ),
          "mdc-tab__icon": (
            /*context*/
            o[8] === "tab"
          ),
          "mdc-banner__icon": (
            /*context*/
            o[8] === "banner"
          ),
          "mdc-segmented-button__icon": (
            /*context*/
            o[8] === "segmented-button"
          )
        })
      },
      i[3],
      A & /*svg*/
      128 && Vt(
        /*svg*/
        o[7] ? { focusable: "false", tabindex: "-1" } : {}
      ),
      A & /*$$restProps*/
      512 && Vt(
        /*$$restProps*/
        o[9]
      )
    ]))), { props: l };
  }
  return s && (e = An(s, a(r)), r[12](e)), {
    c() {
      e && Ve(e.$$.fragment), t = Or();
    },
    m(o, A) {
      e && Ke(e, o, A), ke(o, t, A), n = !0;
    },
    p(o, [A]) {
      if (A & /*component*/
      8 && s !== (s = /*component*/
      o[3])) {
        if (e) {
          er();
          const l = e;
          ge(l.$$.fragment, 1, 0, () => {
            $e(l, 1);
          }), tr();
        }
        s ? (e = An(s, a(o, A)), o[12](e), Ve(e.$$.fragment), fe(e.$$.fragment, 1), Ke(e, t.parentNode, t)) : e = null;
      } else if (s) {
        const l = A & /*tag, forwardEvents, use, className, context, on, svg, $$restProps*/
        983 ? Et(i, [
          A & /*tag*/
          16 && { tag: (
            /*tag*/
            o[4]
          ) },
          A & /*forwardEvents, use*/
          65 && {
            use: [
              /*forwardEvents*/
              o[6],
              .../*use*/
              o[0]
            ]
          },
          A & /*className, context, on*/
          262 && {
            class: ht({
              [
                /*className*/
                o[1]
              ]: !0,
              "mdc-button__icon": (
                /*context*/
                o[8] === "button"
              ),
              "mdc-fab__icon": (
                /*context*/
                o[8] === "fab"
              ),
              "mdc-icon-button__icon": (
                /*context*/
                o[8] === "icon-button"
              ),
              "mdc-icon-button__icon--on": (
                /*context*/
                o[8] === "icon-button" && /*on*/
                o[2]
              ),
              "mdc-tab__icon": (
                /*context*/
                o[8] === "tab"
              ),
              "mdc-banner__icon": (
                /*context*/
                o[8] === "banner"
              ),
              "mdc-segmented-button__icon": (
                /*context*/
                o[8] === "segmented-button"
              )
            })
          },
          i[3],
          A & /*svg*/
          128 && Vt(
            /*svg*/
            o[7] ? { focusable: "false", tabindex: "-1" } : {}
          ),
          A & /*$$restProps*/
          512 && Vt(
            /*$$restProps*/
            o[9]
          )
        ]) : {};
        A & /*$$scope*/
        8192 && (l.$$scope = { dirty: A, ctx: o }), e.$set(l);
      }
    },
    i(o) {
      n || (e && fe(e.$$.fragment, o), n = !0);
    },
    o(o) {
      e && ge(e.$$.fragment, o), n = !1;
    },
    d(o) {
      o && xe(t), r[12](null), e && $e(e, o);
    }
  };
}
function CL(r, e, t) {
  const n = ["use", "class", "on", "component", "tag", "getElement"];
  let i = xt(e, n), { $$slots: s = {}, $$scope: a } = e;
  const o = Kr(yr());
  let { use: A = [] } = e, { class: l = "" } = e, { on: u = !1 } = e, c, { component: h = Ni } = e, { tag: f = h === Ni ? "i" : void 0 } = e;
  const d = h === SE, p = pn("SMUI:icon:context");
  function v() {
    return c.getElement();
  }
  function m(b) {
    yt[b ? "unshift" : "push"](() => {
      c = b, t(5, c);
    });
  }
  return r.$$set = (b) => {
    e = ze(ze({}, e), Nr(b)), t(9, i = xt(e, n)), "use" in b && t(0, A = b.use), "class" in b && t(1, l = b.class), "on" in b && t(2, u = b.on), "component" in b && t(3, h = b.component), "tag" in b && t(4, f = b.tag), "$$scope" in b && t(13, a = b.$$scope);
  }, [
    A,
    l,
    u,
    h,
    f,
    c,
    o,
    d,
    p,
    i,
    v,
    s,
    m,
    a
  ];
}
class _L extends jt {
  constructor(e) {
    super(), Pt(this, e, CL, BL, Mt, {
      use: 0,
      class: 1,
      on: 2,
      component: 3,
      tag: 4,
      getElement: 10
    });
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[1];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get on() {
    return this.$$.ctx[2];
  }
  set on(e) {
    this.$$set({ on: e }), pe();
  }
  get component() {
    return this.$$.ctx[3];
  }
  set component(e) {
    this.$$set({ component: e }), pe();
  }
  get tag() {
    return this.$$.ctx[4];
  }
  set tag(e) {
    this.$$set({ tag: e }), pe();
  }
  get getElement() {
    return this.$$.ctx[10];
  }
}
Ht(_L, { use: {}, class: {}, on: { type: "Boolean" }, component: {}, tag: {} }, ["default"], ["getElement"], !0);
function EL(r) {
  let e = (
    /*tag*/
    r[1]
  ), t, n, i = (
    /*tag*/
    r[1] && Qm(r)
  );
  return {
    c() {
      i && i.c(), t = Or();
    },
    m(s, a) {
      i && i.m(s, a), ke(s, t, a), n = !0;
    },
    p(s, a) {
      /*tag*/
      s[1] ? e ? Mt(
        e,
        /*tag*/
        s[1]
      ) ? (i.d(1), i = Qm(s), e = /*tag*/
      s[1], i.c(), i.m(t.parentNode, t)) : i.p(s, a) : (i = Qm(s), e = /*tag*/
      s[1], i.c(), i.m(t.parentNode, t)) : e && (i.d(1), i = null, e = /*tag*/
      s[1]);
    },
    i(s) {
      n || (fe(i, s), n = !0);
    },
    o(s) {
      ge(i, s), n = !1;
    },
    d(s) {
      s && xe(t), i && i.d(s);
    }
  };
}
function SL(r) {
  let e = (
    /*tag*/
    r[1]
  ), t, n = (
    /*tag*/
    r[1] && Dm(r)
  );
  return {
    c() {
      n && n.c(), t = Or();
    },
    m(i, s) {
      n && n.m(i, s), ke(i, t, s);
    },
    p(i, s) {
      /*tag*/
      i[1] ? e ? Mt(
        e,
        /*tag*/
        i[1]
      ) ? (n.d(1), n = Dm(i), e = /*tag*/
      i[1], n.c(), n.m(t.parentNode, t)) : n.p(i, s) : (n = Dm(i), e = /*tag*/
      i[1], n.c(), n.m(t.parentNode, t)) : e && (n.d(1), n = null, e = /*tag*/
      i[1]);
    },
    i: sr,
    o: sr,
    d(i) {
      i && xe(t), n && n.d(i);
    }
  };
}
function IL(r) {
  let e, t, n, i, s;
  const a = (
    /*#slots*/
    r[8].default
  ), o = Nt(
    a,
    r,
    /*$$scope*/
    r[7],
    null
  );
  let A = [
    /*$$restProps*/
    r[5]
  ], l = {};
  for (let u = 0; u < A.length; u += 1)
    l = ze(l, A[u]);
  return {
    c() {
      e = Gc("svg"), o && o.c(), vp(e, l);
    },
    m(u, c) {
      ke(u, e, c), o && o.m(e, null), r[9](e), n = !0, i || (s = [
        Bt(t = xr.call(
          null,
          e,
          /*use*/
          r[0]
        )),
        Bt(
          /*forwardEvents*/
          r[4].call(null, e)
        )
      ], i = !0);
    },
    p(u, c) {
      o && o.p && (!n || c & /*$$scope*/
      128) && Qt(
        o,
        a,
        u,
        /*$$scope*/
        u[7],
        n ? Ot(
          a,
          /*$$scope*/
          u[7],
          c,
          null
        ) : Dt(
          /*$$scope*/
          u[7]
        ),
        null
      ), vp(e, l = Et(A, [c & /*$$restProps*/
      32 && /*$$restProps*/
      u[5]])), t && ar(t.update) && c & /*use*/
      1 && t.update.call(
        null,
        /*use*/
        u[0]
      );
    },
    i(u) {
      n || (fe(o, u), n = !0);
    },
    o(u) {
      ge(o, u), n = !1;
    },
    d(u) {
      u && xe(e), o && o.d(u), r[9](null), i = !1, fr(s);
    }
  };
}
function Qm(r) {
  let e, t, n, i, s;
  const a = (
    /*#slots*/
    r[8].default
  ), o = Nt(
    a,
    r,
    /*$$scope*/
    r[7],
    null
  );
  let A = [
    /*$$restProps*/
    r[5]
  ], l = {};
  for (let u = 0; u < A.length; u += 1)
    l = ze(l, A[u]);
  return {
    c() {
      e = We(
        /*tag*/
        r[1]
      ), o && o.c(), bp(
        /*tag*/
        r[1]
      )(e, l);
    },
    m(u, c) {
      ke(u, e, c), o && o.m(e, null), r[11](e), n = !0, i || (s = [
        Bt(t = xr.call(
          null,
          e,
          /*use*/
          r[0]
        )),
        Bt(
          /*forwardEvents*/
          r[4].call(null, e)
        )
      ], i = !0);
    },
    p(u, c) {
      o && o.p && (!n || c & /*$$scope*/
      128) && Qt(
        o,
        a,
        u,
        /*$$scope*/
        u[7],
        n ? Ot(
          a,
          /*$$scope*/
          u[7],
          c,
          null
        ) : Dt(
          /*$$scope*/
          u[7]
        ),
        null
      ), bp(
        /*tag*/
        u[1]
      )(e, l = Et(A, [c & /*$$restProps*/
      32 && /*$$restProps*/
      u[5]])), t && ar(t.update) && c & /*use*/
      1 && t.update.call(
        null,
        /*use*/
        u[0]
      );
    },
    i(u) {
      n || (fe(o, u), n = !0);
    },
    o(u) {
      ge(o, u), n = !1;
    },
    d(u) {
      u && xe(e), o && o.d(u), r[11](null), i = !1, fr(s);
    }
  };
}
function Dm(r) {
  let e, t, n, i, s = [
    /*$$restProps*/
    r[5]
  ], a = {};
  for (let o = 0; o < s.length; o += 1)
    a = ze(a, s[o]);
  return {
    c() {
      e = We(
        /*tag*/
        r[1]
      ), bp(
        /*tag*/
        r[1]
      )(e, a);
    },
    m(o, A) {
      ke(o, e, A), r[10](e), n || (i = [
        Bt(t = xr.call(
          null,
          e,
          /*use*/
          r[0]
        )),
        Bt(
          /*forwardEvents*/
          r[4].call(null, e)
        )
      ], n = !0);
    },
    p(o, A) {
      bp(
        /*tag*/
        o[1]
      )(e, a = Et(s, [A & /*$$restProps*/
      32 && /*$$restProps*/
      o[5]])), t && ar(t.update) && A & /*use*/
      1 && t.update.call(
        null,
        /*use*/
        o[0]
      );
    },
    d(o) {
      o && xe(e), r[10](null), n = !1, fr(i);
    }
  };
}
function FL(r) {
  let e, t, n, i;
  const s = [IL, SL, EL], a = [];
  function o(A, l) {
    return (
      /*tag*/
      A[1] === "svg" ? 0 : (
        /*selfClosing*/
        A[3] ? 1 : 2
      )
    );
  }
  return e = o(r), t = a[e] = s[e](r), {
    c() {
      t.c(), n = Or();
    },
    m(A, l) {
      a[e].m(A, l), ke(A, n, l), i = !0;
    },
    p(A, [l]) {
      let u = e;
      e = o(A), e === u ? a[e].p(A, l) : (er(), ge(a[u], 1, 1, () => {
        a[u] = null;
      }), tr(), t = a[e], t ? t.p(A, l) : (t = a[e] = s[e](A), t.c()), fe(t, 1), t.m(n.parentNode, n));
    },
    i(A) {
      i || (fe(t), i = !0);
    },
    o(A) {
      ge(t), i = !1;
    },
    d(A) {
      A && xe(n), a[e].d(A);
    }
  };
}
function TL(r, e, t) {
  let n;
  const i = ["use", "tag", "getElement"];
  let s = xt(e, i), { $$slots: a = {}, $$scope: o } = e, { use: A = [] } = e, { tag: l } = e;
  const u = Kr(yr());
  let c;
  function h() {
    return c;
  }
  function f(v) {
    yt[v ? "unshift" : "push"](() => {
      c = v, t(2, c);
    });
  }
  function d(v) {
    yt[v ? "unshift" : "push"](() => {
      c = v, t(2, c);
    });
  }
  function p(v) {
    yt[v ? "unshift" : "push"](() => {
      c = v, t(2, c);
    });
  }
  return r.$$set = (v) => {
    e = ze(ze({}, e), Nr(v)), t(5, s = xt(e, i)), "use" in v && t(0, A = v.use), "tag" in v && t(1, l = v.tag), "$$scope" in v && t(7, o = v.$$scope);
  }, r.$$.update = () => {
    r.$$.dirty & /*tag*/
    2 && t(3, n = [
      "area",
      "base",
      "br",
      "col",
      "embed",
      "hr",
      "img",
      "input",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ].indexOf(l) > -1);
  }, [
    A,
    l,
    c,
    n,
    u,
    s,
    h,
    o,
    a,
    f,
    d,
    p
  ];
}
class Ni extends jt {
  constructor(e) {
    super(), Pt(this, e, TL, FL, Mt, { use: 0, tag: 1, getElement: 6 });
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get tag() {
    return this.$$.ctx[1];
  }
  set tag(e) {
    this.$$set({ tag: e }), pe();
  }
  get getElement() {
    return this.$$.ctx[6];
  }
}
Ht(Ni, { use: {}, tag: {} }, ["default"], ["getElement"], !0);
function xL(r) {
  let e, t, n, i, s;
  const a = (
    /*#slots*/
    r[6].default
  ), o = Nt(
    a,
    r,
    /*$$scope*/
    r[5],
    null
  );
  let A = [
    /*$$restProps*/
    r[3]
  ], l = {};
  for (let u = 0; u < A.length; u += 1)
    l = ze(l, A[u]);
  return {
    c() {
      e = Gc("svg"), o && o.c(), vp(e, l);
    },
    m(u, c) {
      ke(u, e, c), o && o.m(e, null), r[7](e), n = !0, i || (s = [
        Bt(t = xr.call(
          null,
          e,
          /*use*/
          r[0]
        )),
        Bt(
          /*forwardEvents*/
          r[2].call(null, e)
        )
      ], i = !0);
    },
    p(u, [c]) {
      o && o.p && (!n || c & /*$$scope*/
      32) && Qt(
        o,
        a,
        u,
        /*$$scope*/
        u[5],
        n ? Ot(
          a,
          /*$$scope*/
          u[5],
          c,
          null
        ) : Dt(
          /*$$scope*/
          u[5]
        ),
        null
      ), vp(e, l = Et(A, [c & /*$$restProps*/
      8 && /*$$restProps*/
      u[3]])), t && ar(t.update) && c & /*use*/
      1 && t.update.call(
        null,
        /*use*/
        u[0]
      );
    },
    i(u) {
      n || (fe(o, u), n = !0);
    },
    o(u) {
      ge(o, u), n = !1;
    },
    d(u) {
      u && xe(e), o && o.d(u), r[7](null), i = !1, fr(s);
    }
  };
}
function kL(r, e, t) {
  const n = ["use", "getElement"];
  let i = xt(e, n), { $$slots: s = {}, $$scope: a } = e;
  console && console.warn && console.warn('The @smui/common Svg component is deprecated. You can use `tag="svg"` now.');
  let { use: o = [] } = e;
  const A = Kr(yr());
  let l;
  function u() {
    return l;
  }
  function c(h) {
    yt[h ? "unshift" : "push"](() => {
      l = h, t(1, l);
    });
  }
  return r.$$set = (h) => {
    e = ze(ze({}, e), Nr(h)), t(3, i = xt(e, n)), "use" in h && t(0, o = h.use), "$$scope" in h && t(5, a = h.$$scope);
  }, [
    o,
    l,
    A,
    i,
    u,
    a,
    s,
    c
  ];
}
class SE extends jt {
  constructor(e) {
    super(), Pt(this, e, kL, xL, Mt, { use: 0, getElement: 4 });
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get getElement() {
    return this.$$.ctx[4];
  }
}
Ht(SE, { use: {} }, ["default"], ["getElement"], !0);
const jl = [];
function P2(r, e) {
  return {
    subscribe: ia(r, e).subscribe
  };
}
function ia(r, e = sr) {
  let t;
  const n = /* @__PURE__ */ new Set();
  function i(o) {
    if (Mt(r, o) && (r = o, t)) {
      const A = !jl.length;
      for (const l of n)
        l[1](), jl.push(l, r);
      if (A) {
        for (let l = 0; l < jl.length; l += 2)
          jl[l][0](jl[l + 1]);
        jl.length = 0;
      }
    }
  }
  function s(o) {
    i(o(r));
  }
  function a(o, A = sr) {
    const l = [o, A];
    return n.add(l), n.size === 1 && (t = e(i, s) || sr), o(r), () => {
      n.delete(l), n.size === 0 && t && (t(), t = null);
    };
  }
  return { set: i, update: s, subscribe: a };
}
function IE(r, e, t) {
  const n = !Array.isArray(r), i = n ? [r] : r;
  if (!i.every(Boolean))
    throw new Error("derived() expects stores as input, got a falsy value");
  const s = e.length < 2;
  return P2(t, (a, o) => {
    let A = !1;
    const l = [];
    let u = 0, c = sr;
    const h = () => {
      if (u)
        return;
      c();
      const d = e(n ? l[0] : l, a, o);
      s ? a(d) : c = ar(d) ? d : sr;
    }, f = i.map(
      (d, p) => Zp(
        d,
        (v) => {
          l[p] = v, u &= ~(1 << p), A && h();
        },
        () => {
          u |= 1 << p;
        }
      )
    );
    return A = !0, h(), function() {
      fr(f), c(), A = !1;
    };
  });
}
function LL(r) {
  let e;
  const t = (
    /*#slots*/
    r[4].default
  ), n = Nt(
    t,
    r,
    /*$$scope*/
    r[3],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, s) {
      n && n.m(i, s), e = !0;
    },
    p(i, [s]) {
      n && n.p && (!e || s & /*$$scope*/
      8) && Qt(
        n,
        t,
        i,
        /*$$scope*/
        i[3],
        e ? Ot(
          t,
          /*$$scope*/
          i[3],
          s,
          null
        ) : Dt(
          /*$$scope*/
          i[3]
        ),
        null
      );
    },
    i(i) {
      e || (fe(n, i), e = !0);
    },
    o(i) {
      ge(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function UL(r, e, t) {
  let n, { $$slots: i = {}, $$scope: s } = e, { key: a } = e, { value: o } = e;
  const A = ia(o);
  return GA(r, A, (l) => t(5, n = l)), Pr(a, A), fo(() => {
    A.set(void 0);
  }), r.$$set = (l) => {
    "key" in l && t(1, a = l.key), "value" in l && t(2, o = l.value), "$$scope" in l && t(3, s = l.$$scope);
  }, r.$$.update = () => {
    r.$$.dirty & /*value*/
    4 && D1(A, n = o, n);
  }, [A, a, o, s, i];
}
class pf extends jt {
  constructor(e) {
    super(), Pt(this, e, UL, LL, Mt, { key: 1, value: 2 });
  }
  get key() {
    return this.$$.ctx[1];
  }
  set key(e) {
    this.$$set({ key: e }), pe();
  }
  get value() {
    return this.$$.ctx[2];
  }
  set value(e) {
    this.$$set({ value: e }), pe();
  }
}
Ht(pf, { key: {}, value: {} }, ["default"], [], !0);
function Yy(r) {
  let e;
  return {
    c() {
      e = We("div"), Me(e, "class", "mdc-icon-button__touch");
    },
    m(t, n) {
      ke(t, e, n);
    },
    d(t) {
      t && xe(e);
    }
  };
}
function NL(r) {
  let e, t, n, i;
  const s = (
    /*#slots*/
    r[33].default
  ), a = Nt(
    s,
    r,
    /*$$scope*/
    r[37],
    null
  );
  let o = (
    /*touch*/
    r[8] && Yy()
  );
  return {
    c() {
      e = We("div"), t = tt(), a && a.c(), o && o.c(), n = Or(), Me(e, "class", "mdc-icon-button__ripple");
    },
    m(A, l) {
      ke(A, e, l), ke(A, t, l), a && a.m(A, l), o && o.m(A, l), ke(A, n, l), i = !0;
    },
    p(A, l) {
      a && a.p && (!i || l[1] & /*$$scope*/
      64) && Qt(
        a,
        s,
        A,
        /*$$scope*/
        A[37],
        i ? Ot(
          s,
          /*$$scope*/
          A[37],
          l,
          null
        ) : Dt(
          /*$$scope*/
          A[37]
        ),
        null
      ), /*touch*/
      A[8] ? o || (o = Yy(), o.c(), o.m(n.parentNode, n)) : o && (o.d(1), o = null);
    },
    i(A) {
      i || (fe(a, A), i = !0);
    },
    o(A) {
      ge(a, A), i = !1;
    },
    d(A) {
      A && (xe(e), xe(t), xe(n)), a && a.d(A), o && o.d(A);
    }
  };
}
function OL(r) {
  let e, t, n;
  const i = [
    { tag: (
      /*tag*/
      r[14]
    ) },
    {
      use: [
        [
          io,
          {
            ripple: (
              /*ripple*/
              r[4]
            ),
            unbounded: !0,
            color: (
              /*color*/
              r[5]
            ),
            disabled: !!/*$$restProps*/
            r[29].disabled,
            addClass: (
              /*addClass*/
              r[26]
            ),
            removeClass: (
              /*removeClass*/
              r[27]
            ),
            addStyle: (
              /*addStyle*/
              r[28]
            )
          }
        ],
        /*forwardEvents*/
        r[22],
        .../*use*/
        r[1]
      ]
    },
    {
      class: ht({
        [
          /*className*/
          r[2]
        ]: !0,
        "mdc-icon-button": !0,
        "mdc-icon-button--on": !/*isUninitializedValue*/
        r[23](
          /*pressed*/
          r[0]
        ) && /*pressed*/
        r[0],
        "mdc-icon-button--touch": (
          /*touch*/
          r[8]
        ),
        "mdc-icon-button--display-flex": (
          /*displayFlex*/
          r[9]
        ),
        "smui-icon-button--size-button": (
          /*size*/
          r[10] === "button"
        ),
        "smui-icon-button--size-mini": (
          /*size*/
          r[10] === "mini"
        ),
        "mdc-icon-button--reduced-size": (
          /*size*/
          r[10] === "mini" || /*size*/
          r[10] === "button"
        ),
        "mdc-card__action": (
          /*context*/
          r[24] === "card:action"
        ),
        "mdc-card__action--icon": (
          /*context*/
          r[24] === "card:action"
        ),
        "mdc-top-app-bar__navigation-icon": (
          /*context*/
          r[24] === "top-app-bar:navigation"
        ),
        "mdc-top-app-bar__action-item": (
          /*context*/
          r[24] === "top-app-bar:action"
        ),
        "mdc-snackbar__dismiss": (
          /*context*/
          r[24] === "snackbar:actions"
        ),
        "mdc-data-table__pagination-button": (
          /*context*/
          r[24] === "data-table:pagination"
        ),
        "mdc-data-table__sort-icon-button": (
          /*context*/
          r[24] === "data-table:sortable-header-cell"
        ),
        "mdc-dialog__close": (
          /*context*/
          (r[24] === "dialog:header" || /*context*/
          r[24] === "dialog:sheet") && /*action*/
          r[12] === "close"
        ),
        .../*internalClasses*/
        r[18]
      })
    },
    {
      style: Object.entries(
        /*internalStyles*/
        r[19]
      ).map(Mm).concat([
        /*style*/
        r[3]
      ]).join(" ")
    },
    {
      "aria-pressed": /*isUninitializedValue*/ r[23](
        /*pressed*/
        r[0]
      ) ? null : (
        /*pressed*/
        r[0] ? "true" : "false"
      )
    },
    {
      "aria-label": (
        /*pressed*/
        r[0] ? (
          /*ariaLabelOn*/
          r[6]
        ) : (
          /*ariaLabelOff*/
          r[7]
        )
      )
    },
    {
      "data-aria-label-on": (
        /*ariaLabelOn*/
        r[6]
      )
    },
    {
      "data-aria-label-off": (
        /*ariaLabelOff*/
        r[7]
      )
    },
    {
      "aria-describedby": (
        /*ariaDescribedby*/
        r[25]
      )
    },
    { href: (
      /*href*/
      r[11]
    ) },
    /*actionProp*/
    r[21],
    /*internalAttrs*/
    r[20],
    /*$$restProps*/
    r[29]
  ];
  var s = (
    /*component*/
    r[13]
  );
  function a(o, A) {
    let l = {
      $$slots: { default: [NL] },
      $$scope: { ctx: o }
    };
    for (let u = 0; u < i.length; u += 1)
      l = ze(l, i[u]);
    return A !== void 0 && A[0] & /*tag, ripple, color, $$restProps, addClass, removeClass, addStyle, forwardEvents, use, className, isUninitializedValue, pressed, touch, displayFlex, size, context, action, internalClasses, internalStyles, style, ariaLabelOn, ariaLabelOff, ariaDescribedby, href, actionProp, internalAttrs*/
    1073504255 && (l = ze(l, Et(i, [
      A[0] & /*tag*/
      16384 && { tag: (
        /*tag*/
        o[14]
      ) },
      A[0] & /*ripple, color, $$restProps, addClass, removeClass, addStyle, forwardEvents, use*/
      1010827314 && {
        use: [
          [
            io,
            {
              ripple: (
                /*ripple*/
                o[4]
              ),
              unbounded: !0,
              color: (
                /*color*/
                o[5]
              ),
              disabled: !!/*$$restProps*/
              o[29].disabled,
              addClass: (
                /*addClass*/
                o[26]
              ),
              removeClass: (
                /*removeClass*/
                o[27]
              ),
              addStyle: (
                /*addStyle*/
                o[28]
              )
            }
          ],
          /*forwardEvents*/
          o[22],
          .../*use*/
          o[1]
        ]
      },
      A[0] & /*className, isUninitializedValue, pressed, touch, displayFlex, size, context, action, internalClasses*/
      25433861 && {
        class: ht({
          [
            /*className*/
            o[2]
          ]: !0,
          "mdc-icon-button": !0,
          "mdc-icon-button--on": !/*isUninitializedValue*/
          o[23](
            /*pressed*/
            o[0]
          ) && /*pressed*/
          o[0],
          "mdc-icon-button--touch": (
            /*touch*/
            o[8]
          ),
          "mdc-icon-button--display-flex": (
            /*displayFlex*/
            o[9]
          ),
          "smui-icon-button--size-button": (
            /*size*/
            o[10] === "button"
          ),
          "smui-icon-button--size-mini": (
            /*size*/
            o[10] === "mini"
          ),
          "mdc-icon-button--reduced-size": (
            /*size*/
            o[10] === "mini" || /*size*/
            o[10] === "button"
          ),
          "mdc-card__action": (
            /*context*/
            o[24] === "card:action"
          ),
          "mdc-card__action--icon": (
            /*context*/
            o[24] === "card:action"
          ),
          "mdc-top-app-bar__navigation-icon": (
            /*context*/
            o[24] === "top-app-bar:navigation"
          ),
          "mdc-top-app-bar__action-item": (
            /*context*/
            o[24] === "top-app-bar:action"
          ),
          "mdc-snackbar__dismiss": (
            /*context*/
            o[24] === "snackbar:actions"
          ),
          "mdc-data-table__pagination-button": (
            /*context*/
            o[24] === "data-table:pagination"
          ),
          "mdc-data-table__sort-icon-button": (
            /*context*/
            o[24] === "data-table:sortable-header-cell"
          ),
          "mdc-dialog__close": (
            /*context*/
            (o[24] === "dialog:header" || /*context*/
            o[24] === "dialog:sheet") && /*action*/
            o[12] === "close"
          ),
          .../*internalClasses*/
          o[18]
        })
      },
      A[0] & /*internalStyles, style*/
      524296 && {
        style: Object.entries(
          /*internalStyles*/
          o[19]
        ).map(Mm).concat([
          /*style*/
          o[3]
        ]).join(" ")
      },
      A[0] & /*isUninitializedValue, pressed*/
      8388609 && {
        "aria-pressed": /*isUninitializedValue*/ o[23](
          /*pressed*/
          o[0]
        ) ? null : (
          /*pressed*/
          o[0] ? "true" : "false"
        )
      },
      A[0] & /*pressed, ariaLabelOn, ariaLabelOff*/
      193 && {
        "aria-label": (
          /*pressed*/
          o[0] ? (
            /*ariaLabelOn*/
            o[6]
          ) : (
            /*ariaLabelOff*/
            o[7]
          )
        )
      },
      A[0] & /*ariaLabelOn*/
      64 && {
        "data-aria-label-on": (
          /*ariaLabelOn*/
          o[6]
        )
      },
      A[0] & /*ariaLabelOff*/
      128 && {
        "data-aria-label-off": (
          /*ariaLabelOff*/
          o[7]
        )
      },
      A[0] & /*ariaDescribedby*/
      33554432 && {
        "aria-describedby": (
          /*ariaDescribedby*/
          o[25]
        )
      },
      A[0] & /*href*/
      2048 && { href: (
        /*href*/
        o[11]
      ) },
      A[0] & /*actionProp*/
      2097152 && Vt(
        /*actionProp*/
        o[21]
      ),
      A[0] & /*internalAttrs*/
      1048576 && Vt(
        /*internalAttrs*/
        o[20]
      ),
      A[0] & /*$$restProps*/
      536870912 && Vt(
        /*$$restProps*/
        o[29]
      )
    ]))), { props: l };
  }
  return s && (e = An(s, a(r)), r[34](e), e.$on(
    "click",
    /*click_handler*/
    r[35]
  ), e.$on(
    "click",
    /*click_handler_1*/
    r[36]
  )), {
    c() {
      e && Ve(e.$$.fragment), t = Or();
    },
    m(o, A) {
      e && Ke(e, o, A), ke(o, t, A), n = !0;
    },
    p(o, A) {
      if (A[0] & /*component*/
      8192 && s !== (s = /*component*/
      o[13])) {
        if (e) {
          er();
          const l = e;
          ge(l.$$.fragment, 1, 0, () => {
            $e(l, 1);
          }), tr();
        }
        s ? (e = An(s, a(o, A)), o[34](e), e.$on(
          "click",
          /*click_handler*/
          o[35]
        ), e.$on(
          "click",
          /*click_handler_1*/
          o[36]
        ), Ve(e.$$.fragment), fe(e.$$.fragment, 1), Ke(e, t.parentNode, t)) : e = null;
      } else if (s) {
        const l = A[0] & /*tag, ripple, color, $$restProps, addClass, removeClass, addStyle, forwardEvents, use, className, isUninitializedValue, pressed, touch, displayFlex, size, context, action, internalClasses, internalStyles, style, ariaLabelOn, ariaLabelOff, ariaDescribedby, href, actionProp, internalAttrs*/
        1073504255 ? Et(i, [
          A[0] & /*tag*/
          16384 && { tag: (
            /*tag*/
            o[14]
          ) },
          A[0] & /*ripple, color, $$restProps, addClass, removeClass, addStyle, forwardEvents, use*/
          1010827314 && {
            use: [
              [
                io,
                {
                  ripple: (
                    /*ripple*/
                    o[4]
                  ),
                  unbounded: !0,
                  color: (
                    /*color*/
                    o[5]
                  ),
                  disabled: !!/*$$restProps*/
                  o[29].disabled,
                  addClass: (
                    /*addClass*/
                    o[26]
                  ),
                  removeClass: (
                    /*removeClass*/
                    o[27]
                  ),
                  addStyle: (
                    /*addStyle*/
                    o[28]
                  )
                }
              ],
              /*forwardEvents*/
              o[22],
              .../*use*/
              o[1]
            ]
          },
          A[0] & /*className, isUninitializedValue, pressed, touch, displayFlex, size, context, action, internalClasses*/
          25433861 && {
            class: ht({
              [
                /*className*/
                o[2]
              ]: !0,
              "mdc-icon-button": !0,
              "mdc-icon-button--on": !/*isUninitializedValue*/
              o[23](
                /*pressed*/
                o[0]
              ) && /*pressed*/
              o[0],
              "mdc-icon-button--touch": (
                /*touch*/
                o[8]
              ),
              "mdc-icon-button--display-flex": (
                /*displayFlex*/
                o[9]
              ),
              "smui-icon-button--size-button": (
                /*size*/
                o[10] === "button"
              ),
              "smui-icon-button--size-mini": (
                /*size*/
                o[10] === "mini"
              ),
              "mdc-icon-button--reduced-size": (
                /*size*/
                o[10] === "mini" || /*size*/
                o[10] === "button"
              ),
              "mdc-card__action": (
                /*context*/
                o[24] === "card:action"
              ),
              "mdc-card__action--icon": (
                /*context*/
                o[24] === "card:action"
              ),
              "mdc-top-app-bar__navigation-icon": (
                /*context*/
                o[24] === "top-app-bar:navigation"
              ),
              "mdc-top-app-bar__action-item": (
                /*context*/
                o[24] === "top-app-bar:action"
              ),
              "mdc-snackbar__dismiss": (
                /*context*/
                o[24] === "snackbar:actions"
              ),
              "mdc-data-table__pagination-button": (
                /*context*/
                o[24] === "data-table:pagination"
              ),
              "mdc-data-table__sort-icon-button": (
                /*context*/
                o[24] === "data-table:sortable-header-cell"
              ),
              "mdc-dialog__close": (
                /*context*/
                (o[24] === "dialog:header" || /*context*/
                o[24] === "dialog:sheet") && /*action*/
                o[12] === "close"
              ),
              .../*internalClasses*/
              o[18]
            })
          },
          A[0] & /*internalStyles, style*/
          524296 && {
            style: Object.entries(
              /*internalStyles*/
              o[19]
            ).map(Mm).concat([
              /*style*/
              o[3]
            ]).join(" ")
          },
          A[0] & /*isUninitializedValue, pressed*/
          8388609 && {
            "aria-pressed": /*isUninitializedValue*/ o[23](
              /*pressed*/
              o[0]
            ) ? null : (
              /*pressed*/
              o[0] ? "true" : "false"
            )
          },
          A[0] & /*pressed, ariaLabelOn, ariaLabelOff*/
          193 && {
            "aria-label": (
              /*pressed*/
              o[0] ? (
                /*ariaLabelOn*/
                o[6]
              ) : (
                /*ariaLabelOff*/
                o[7]
              )
            )
          },
          A[0] & /*ariaLabelOn*/
          64 && {
            "data-aria-label-on": (
              /*ariaLabelOn*/
              o[6]
            )
          },
          A[0] & /*ariaLabelOff*/
          128 && {
            "data-aria-label-off": (
              /*ariaLabelOff*/
              o[7]
            )
          },
          A[0] & /*ariaDescribedby*/
          33554432 && {
            "aria-describedby": (
              /*ariaDescribedby*/
              o[25]
            )
          },
          A[0] & /*href*/
          2048 && { href: (
            /*href*/
            o[11]
          ) },
          A[0] & /*actionProp*/
          2097152 && Vt(
            /*actionProp*/
            o[21]
          ),
          A[0] & /*internalAttrs*/
          1048576 && Vt(
            /*internalAttrs*/
            o[20]
          ),
          A[0] & /*$$restProps*/
          536870912 && Vt(
            /*$$restProps*/
            o[29]
          )
        ]) : {};
        A[0] & /*touch*/
        256 | A[1] & /*$$scope*/
        64 && (l.$$scope = { dirty: A, ctx: o }), e.$set(l);
      }
    },
    i(o) {
      n || (e && fe(e.$$.fragment, o), n = !0);
    },
    o(o) {
      e && ge(e.$$.fragment, o), n = !1;
    },
    d(o) {
      o && xe(t), r[34](null), e && $e(e, o);
    }
  };
}
const Mm = ([r, e]) => `${r}: ${e};`;
function QL(r, e, t) {
  let n;
  const i = [
    "use",
    "class",
    "style",
    "ripple",
    "color",
    "toggle",
    "pressed",
    "ariaLabelOn",
    "ariaLabelOff",
    "touch",
    "displayFlex",
    "size",
    "href",
    "action",
    "component",
    "tag",
    "getElement"
  ];
  let s = xt(e, i), { $$slots: a = {}, $$scope: o } = e;
  const A = Kr(yr());
  let l = () => {
  };
  function u(de) {
    return de === l;
  }
  let { use: c = [] } = e, { class: h = "" } = e, { style: f = "" } = e, { ripple: d = !0 } = e, { color: p = void 0 } = e, { toggle: v = !1 } = e, { pressed: m = l } = e, { ariaLabelOn: b = void 0 } = e, { ariaLabelOff: w = void 0 } = e, { touch: B = !1 } = e, { displayFlex: _ = !0 } = e, { size: x = "normal" } = e, { href: C = void 0 } = e, { action: F = void 0 } = e, N, D, T = {}, E = {}, L = {}, S = pn("SMUI:icon-button:context"), X = pn("SMUI:icon-button:aria-describedby"), { component: z = Ni } = e, { tag: R = z === Ni ? C == null ? "button" : "a" : void 0 } = e, V = s.disabled;
  Pr("SMUI:icon:context", "icon-button");
  let O = null;
  fo(() => {
    D && D.destroy();
  });
  function J(de) {
    return de in T ? T[de] : ue().classList.contains(de);
  }
  function Z(de) {
    T[de] || t(18, T[de] = !0, T);
  }
  function U(de) {
    (!(de in T) || T[de]) && t(18, T[de] = !1, T);
  }
  function P(de, Ce) {
    E[de] != Ce && (Ce === "" || Ce == null ? (delete E[de], t(19, E)) : t(19, E[de] = Ce, E));
  }
  function H(de) {
    var Ce;
    return de in L ? (Ce = L[de]) !== null && Ce !== void 0 ? Ce : null : ue().getAttribute(de);
  }
  function $(de, Ce) {
    L[de] !== Ce && t(20, L[de] = Ce, L);
  }
  function ie(de) {
    t(0, m = de.isOn);
  }
  function ue() {
    return N.getElement();
  }
  function he(de) {
    yt[de ? "unshift" : "push"](() => {
      N = de, t(16, N);
    });
  }
  const ve = () => D && D.handleClick(), Le = () => S === "top-app-bar:navigation" && pr(ue(), "SMUITopAppBarIconButton:nav");
  return r.$$set = (de) => {
    e = ze(ze({}, e), Nr(de)), t(29, s = xt(e, i)), "use" in de && t(1, c = de.use), "class" in de && t(2, h = de.class), "style" in de && t(3, f = de.style), "ripple" in de && t(4, d = de.ripple), "color" in de && t(5, p = de.color), "toggle" in de && t(30, v = de.toggle), "pressed" in de && t(0, m = de.pressed), "ariaLabelOn" in de && t(6, b = de.ariaLabelOn), "ariaLabelOff" in de && t(7, w = de.ariaLabelOff), "touch" in de && t(8, B = de.touch), "displayFlex" in de && t(9, _ = de.displayFlex), "size" in de && t(10, x = de.size), "href" in de && t(11, C = de.href), "action" in de && t(12, F = de.action), "component" in de && t(13, z = de.component), "tag" in de && t(14, R = de.tag), "$$scope" in de && t(37, o = de.$$scope);
  }, r.$$.update = () => {
    if (r.$$.dirty[0] & /*action*/
    4096 && t(21, n = (() => {
      if (S === "data-table:pagination")
        switch (F) {
          case "first-page":
            return { "data-first-page": "true" };
          case "prev-page":
            return { "data-prev-page": "true" };
          case "next-page":
            return { "data-next-page": "true" };
          case "last-page":
            return { "data-last-page": "true" };
          default:
            return { "data-action": "true" };
        }
      else return S === "dialog:header" || S === "dialog:sheet" ? { "data-mdc-dialog-action": F } : { action: F };
    })()), V !== s.disabled) {
      if (N) {
        const de = ue();
        "blur" in de && de.blur();
      }
      t(31, V = s.disabled);
    }
    r.$$.dirty[0] & /*element, toggle, instance*/
    1073938432 | r.$$.dirty[1] & /*oldToggle*/
    2 && N && ue() && v !== O && (v && !D ? (t(17, D = new AL({
      addClass: Z,
      hasClass: J,
      notifyChange: (de) => {
        ie(de), pr(ue(), "SMUIIconButtonToggle:change", de, void 0, !0);
      },
      removeClass: U,
      getAttr: H,
      setAttr: $
    })), D.init()) : !v && D && (D.destroy(), t(17, D = void 0), t(18, T = {}), t(20, L = {})), t(32, O = v)), r.$$.dirty[0] & /*instance, pressed*/
    131073 && D && !u(m) && D.isOn() !== m && D.toggle(m);
  }, [
    m,
    c,
    h,
    f,
    d,
    p,
    b,
    w,
    B,
    _,
    x,
    C,
    F,
    z,
    R,
    ue,
    N,
    D,
    T,
    E,
    L,
    n,
    A,
    u,
    S,
    X,
    Z,
    U,
    P,
    s,
    v,
    V,
    O,
    a,
    he,
    ve,
    Le,
    o
  ];
}
class FE extends jt {
  constructor(e) {
    super(), Pt(
      this,
      e,
      QL,
      OL,
      Mt,
      {
        use: 1,
        class: 2,
        style: 3,
        ripple: 4,
        color: 5,
        toggle: 30,
        pressed: 0,
        ariaLabelOn: 6,
        ariaLabelOff: 7,
        touch: 8,
        displayFlex: 9,
        size: 10,
        href: 11,
        action: 12,
        component: 13,
        tag: 14,
        getElement: 15
      },
      null,
      [-1, -1]
    );
  }
  get use() {
    return this.$$.ctx[1];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[2];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get style() {
    return this.$$.ctx[3];
  }
  set style(e) {
    this.$$set({ style: e }), pe();
  }
  get ripple() {
    return this.$$.ctx[4];
  }
  set ripple(e) {
    this.$$set({ ripple: e }), pe();
  }
  get color() {
    return this.$$.ctx[5];
  }
  set color(e) {
    this.$$set({ color: e }), pe();
  }
  get toggle() {
    return this.$$.ctx[30];
  }
  set toggle(e) {
    this.$$set({ toggle: e }), pe();
  }
  get pressed() {
    return this.$$.ctx[0];
  }
  set pressed(e) {
    this.$$set({ pressed: e }), pe();
  }
  get ariaLabelOn() {
    return this.$$.ctx[6];
  }
  set ariaLabelOn(e) {
    this.$$set({ ariaLabelOn: e }), pe();
  }
  get ariaLabelOff() {
    return this.$$.ctx[7];
  }
  set ariaLabelOff(e) {
    this.$$set({ ariaLabelOff: e }), pe();
  }
  get touch() {
    return this.$$.ctx[8];
  }
  set touch(e) {
    this.$$set({ touch: e }), pe();
  }
  get displayFlex() {
    return this.$$.ctx[9];
  }
  set displayFlex(e) {
    this.$$set({ displayFlex: e }), pe();
  }
  get size() {
    return this.$$.ctx[10];
  }
  set size(e) {
    this.$$set({ size: e }), pe();
  }
  get href() {
    return this.$$.ctx[11];
  }
  set href(e) {
    this.$$set({ href: e }), pe();
  }
  get action() {
    return this.$$.ctx[12];
  }
  set action(e) {
    this.$$set({ action: e }), pe();
  }
  get component() {
    return this.$$.ctx[13];
  }
  set component(e) {
    this.$$set({ component: e }), pe();
  }
  get tag() {
    return this.$$.ctx[14];
  }
  set tag(e) {
    this.$$set({ tag: e }), pe();
  }
  get getElement() {
    return this.$$.ctx[15];
  }
}
Ht(FE, { use: {}, class: {}, style: {}, ripple: { type: "Boolean" }, color: {}, toggle: { type: "Boolean" }, pressed: {}, ariaLabelOn: {}, ariaLabelOff: {}, touch: { type: "Boolean" }, displayFlex: { type: "Boolean" }, size: {}, href: {}, action: {}, component: {}, tag: {} }, ["default"], ["getElement"], !0);
function TE(r) {
  return Object.entries(r).map(([e, t]) => `--${e}:${t}`).join(";");
}
function DL(r) {
  Pi(r, "svelte-4hwpwb", "svg.custom-icon-button-wrapper{padding:.25rem}.mdc-icon-button.smui-icon-button--size-button, .mdc-icon-button.smui-icon-button--size-button svg{width:var(--button-size)!important;height:var(--button-size)!important}");
}
function ML(r) {
  let e, t;
  return e = new tg({
    props: {
      icon: (
        /*icon*/
        r[0]
      ),
      fillColor: (
        /*color*/
        r[1]
      ),
      class: "custom-icon-button-wrapper"
    }
  }), {
    c() {
      Ve(e.$$.fragment);
    },
    m(n, i) {
      Ke(e, n, i), t = !0;
    },
    p(n, i) {
      const s = {};
      i & /*icon*/
      1 && (s.icon = /*icon*/
      n[0]), i & /*color*/
      2 && (s.fillColor = /*color*/
      n[1]), e.$set(s);
    },
    i(n) {
      t || (fe(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ge(e.$$.fragment, n), t = !1;
    },
    d(n) {
      $e(e, n);
    }
  };
}
function RL(r) {
  let e, t;
  return e = new FE({
    props: {
      size: "button",
      style: (
        /*cssDynamicStyles*/
        r[3]
      ),
      class: (
        /*className*/
        r[2]
      ),
      $$slots: { default: [ML] },
      $$scope: { ctx: r }
    }
  }), e.$on(
    "click",
    /*click_handler*/
    r[6]
  ), {
    c() {
      Ve(e.$$.fragment);
    },
    m(n, i) {
      Ke(e, n, i), t = !0;
    },
    p(n, [i]) {
      const s = {};
      i & /*cssDynamicStyles*/
      8 && (s.style = /*cssDynamicStyles*/
      n[3]), i & /*className*/
      4 && (s.class = /*className*/
      n[2]), i & /*$$scope, icon, color*/
      131 && (s.$$scope = { dirty: i, ctx: n }), e.$set(s);
    },
    i(n) {
      t || (fe(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ge(e.$$.fragment, n), t = !1;
    },
    d(n) {
      $e(e, n);
    }
  };
}
function PL(r) {
  return r === "small" ? "42px" : r === "large" ? "56px" : "48px";
}
function HL(r, e, t) {
  let n, { icon: i } = e, { size: s = "medium" } = e, { color: a = "primary" } = e, { class: o = "" } = e;
  const A = { "button-size": "" };
  function l(u) {
    Sa.call(this, r, u);
  }
  return r.$$set = (u) => {
    "icon" in u && t(0, i = u.icon), "size" in u && t(4, s = u.size), "color" in u && t(1, a = u.color), "class" in u && t(2, o = u.class);
  }, r.$$.update = () => {
    r.$$.dirty & /*size*/
    16 && t(5, A["button-size"] = PL(s), A), r.$$.dirty & /*cssFixedStyles*/
    32 && t(3, n = TE(A));
  }, [i, a, o, n, s, A, l];
}
class us extends jt {
  constructor(e) {
    super(), Pt(this, e, HL, RL, Mt, { icon: 0, size: 4, color: 1, class: 2 }, DL);
  }
  get icon() {
    return this.$$.ctx[0];
  }
  set icon(e) {
    this.$$set({ icon: e }), pe();
  }
  get size() {
    return this.$$.ctx[4];
  }
  set size(e) {
    this.$$set({ size: e }), pe();
  }
  get color() {
    return this.$$.ctx[1];
  }
  set color(e) {
    this.$$set({ color: e }), pe();
  }
  get class() {
    return this.$$.ctx[2];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
}
Ht(us, { icon: {}, size: {}, color: {}, class: {} }, [], [], !0);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var Wi = {
  ANIMATE: "mdc-drawer--animate",
  CLOSING: "mdc-drawer--closing",
  DISMISSIBLE: "mdc-drawer--dismissible",
  MODAL: "mdc-drawer--modal",
  OPEN: "mdc-drawer--open",
  OPENING: "mdc-drawer--opening",
  ROOT: "mdc-drawer"
}, jL = {
  APP_CONTENT_SELECTOR: ".mdc-drawer-app-content",
  CLOSE_EVENT: "MDCDrawer:closed",
  OPEN_EVENT: "MDCDrawer:opened",
  SCRIM_SELECTOR: ".mdc-drawer-scrim",
  LIST_SELECTOR: ".mdc-list,.mdc-deprecated-list",
  LIST_ITEM_ACTIVATED_SELECTOR: ".mdc-list-item--activated,.mdc-deprecated-list-item--activated"
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var xE = (
  /** @class */
  function(r) {
    Zi(e, r);
    function e(t) {
      var n = r.call(this, Jr(Jr({}, e.defaultAdapter), t)) || this;
      return n.animationFrame = 0, n.animationTimer = 0, n;
    }
    return Object.defineProperty(e, "strings", {
      get: function() {
        return jL;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "cssClasses", {
      get: function() {
        return Wi;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
          },
          removeClass: function() {
          },
          hasClass: function() {
            return !1;
          },
          elementHasClass: function() {
            return !1;
          },
          notifyClose: function() {
          },
          notifyOpen: function() {
          },
          saveFocus: function() {
          },
          restoreFocus: function() {
          },
          focusActiveNavigationItem: function() {
          },
          trapFocus: function() {
          },
          releaseFocus: function() {
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.destroy = function() {
      this.animationFrame && cancelAnimationFrame(this.animationFrame), this.animationTimer && clearTimeout(this.animationTimer);
    }, e.prototype.open = function() {
      var t = this;
      this.isOpen() || this.isOpening() || this.isClosing() || (this.adapter.addClass(Wi.OPEN), this.adapter.addClass(Wi.ANIMATE), this.runNextAnimationFrame(function() {
        t.adapter.addClass(Wi.OPENING);
      }), this.adapter.saveFocus());
    }, e.prototype.close = function() {
      !this.isOpen() || this.isOpening() || this.isClosing() || this.adapter.addClass(Wi.CLOSING);
    }, e.prototype.isOpen = function() {
      return this.adapter.hasClass(Wi.OPEN);
    }, e.prototype.isOpening = function() {
      return this.adapter.hasClass(Wi.OPENING) || this.adapter.hasClass(Wi.ANIMATE);
    }, e.prototype.isClosing = function() {
      return this.adapter.hasClass(Wi.CLOSING);
    }, e.prototype.handleKeydown = function(t) {
      var n = t.keyCode, i = t.key, s = i === "Escape" || n === 27;
      s && this.close();
    }, e.prototype.handleTransitionEnd = function(t) {
      var n = Wi.OPENING, i = Wi.CLOSING, s = Wi.OPEN, a = Wi.ANIMATE, o = Wi.ROOT, A = this.isElement(t.target) && this.adapter.elementHasClass(t.target, o);
      A && (this.isClosing() ? (this.adapter.removeClass(s), this.closed(), this.adapter.restoreFocus(), this.adapter.notifyClose()) : (this.adapter.focusActiveNavigationItem(), this.opened(), this.adapter.notifyOpen()), this.adapter.removeClass(a), this.adapter.removeClass(n), this.adapter.removeClass(i));
    }, e.prototype.opened = function() {
    }, e.prototype.closed = function() {
    }, e.prototype.runNextAnimationFrame = function(t) {
      var n = this;
      cancelAnimationFrame(this.animationFrame), this.animationFrame = requestAnimationFrame(function() {
        n.animationFrame = 0, clearTimeout(n.animationTimer), n.animationTimer = setTimeout(t, 0);
      });
    }, e.prototype.isElement = function(t) {
      return !!t.classList;
    }, e;
  }(La)
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var KL = (
  /** @class */
  function(r) {
    Zi(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.handleScrimClick = function() {
      this.close();
    }, e.prototype.opened = function() {
      this.adapter.trapFocus();
    }, e.prototype.closed = function() {
      this.adapter.releaseFocus();
    }, e;
  }(xE)
);
function $L(r) {
  let e, t, n, i, s, a;
  const o = (
    /*#slots*/
    r[15].default
  ), A = Nt(
    o,
    r,
    /*$$scope*/
    r[14],
    null
  );
  let l = [
    {
      class: t = ht({
        [
          /*className*/
          r[1]
        ]: !0,
        "mdc-drawer": !0,
        "mdc-drawer--dismissible": (
          /*variant*/
          r[2] === "dismissible"
        ),
        "mdc-drawer--modal": (
          /*variant*/
          r[2] === "modal"
        ),
        "smui-drawer__absolute": (
          /*variant*/
          r[2] === "modal" && !/*fixed*/
          r[3]
        ),
        .../*internalClasses*/
        r[6]
      })
    },
    /*$$restProps*/
    r[8]
  ], u = {};
  for (let c = 0; c < l.length; c += 1)
    u = ze(u, l[c]);
  return {
    c() {
      e = We("aside"), A && A.c(), Ut(e, u);
    },
    m(c, h) {
      ke(c, e, h), A && A.m(e, null), r[16](e), i = !0, s || (a = [
        Bt(n = xr.call(
          null,
          e,
          /*use*/
          r[0]
        )),
        Bt(
          /*forwardEvents*/
          r[7].call(null, e)
        ),
        pt(e, "keydown", function() {
          ar(
            /*instance*/
            r[4] && /*instance*/
            r[4].handleKeydown.bind(
              /*instance*/
              r[4]
            )
          ) && /*instance*/
          (r[4] && /*instance*/
          r[4].handleKeydown.bind(
            /*instance*/
            r[4]
          )).apply(this, arguments);
        }),
        pt(e, "transitionend", function() {
          ar(
            /*instance*/
            r[4] && /*instance*/
            r[4].handleTransitionEnd.bind(
              /*instance*/
              r[4]
            )
          ) && /*instance*/
          (r[4] && /*instance*/
          r[4].handleTransitionEnd.bind(
            /*instance*/
            r[4]
          )).apply(this, arguments);
        })
      ], s = !0);
    },
    p(c, [h]) {
      r = c, A && A.p && (!i || h & /*$$scope*/
      16384) && Qt(
        A,
        o,
        r,
        /*$$scope*/
        r[14],
        i ? Ot(
          o,
          /*$$scope*/
          r[14],
          h,
          null
        ) : Dt(
          /*$$scope*/
          r[14]
        ),
        null
      ), Ut(e, u = Et(l, [
        (!i || h & /*className, variant, fixed, internalClasses*/
        78 && t !== (t = ht({
          [
            /*className*/
            r[1]
          ]: !0,
          "mdc-drawer": !0,
          "mdc-drawer--dismissible": (
            /*variant*/
            r[2] === "dismissible"
          ),
          "mdc-drawer--modal": (
            /*variant*/
            r[2] === "modal"
          ),
          "smui-drawer__absolute": (
            /*variant*/
            r[2] === "modal" && !/*fixed*/
            r[3]
          ),
          .../*internalClasses*/
          r[6]
        }))) && { class: t },
        h & /*$$restProps*/
        256 && /*$$restProps*/
        r[8]
      ])), n && ar(n.update) && h & /*use*/
      1 && n.update.call(
        null,
        /*use*/
        r[0]
      );
    },
    i(c) {
      i || (fe(A, c), i = !0);
    },
    o(c) {
      ge(A, c), i = !1;
    },
    d(c) {
      c && xe(e), A && A.d(c), r[16](null), s = !1, fr(a);
    }
  };
}
function VL(r, e, t) {
  const n = ["use", "class", "variant", "open", "fixed", "setOpen", "isOpen", "getElement"];
  let i = xt(e, n), { $$slots: s = {}, $$scope: a } = e;
  const { FocusTrap: o } = gL, A = Kr(yr());
  let { use: l = [] } = e, { class: u = "" } = e, { variant: c = void 0 } = e, { open: h = !1 } = e, { fixed: f = !0 } = e, d, p, v = {}, m = null, b, w = !1;
  Pr("SMUI:list:nav", !0), Pr("SMUI:list:item:nav", !0), Pr("SMUI:list:wrapFocus", !0);
  let B = c;
  ui(() => {
    b = new o(
      d,
      {
        // Component handles focusing on active nav item.
        skipInitialFocus: !0
      }
    ), t(4, p = _()), p && p.init();
  }), fo(() => {
    p && p.destroy(), w && w.removeEventListener("SMUIDrawerScrim:click", N);
  });
  function _() {
    var S, X;
    w && w.removeEventListener("SMUIDrawerScrim:click", N), c === "modal" && (w = (X = (S = d.parentNode) === null || S === void 0 ? void 0 : S.querySelector(".mdc-drawer-scrim")) !== null && X !== void 0 ? X : !1, w && w.addEventListener("SMUIDrawerScrim:click", N));
    const z = c === "dismissible" ? xE : c === "modal" ? KL : void 0;
    return z ? new z({
      addClass: C,
      removeClass: F,
      hasClass: x,
      elementHasClass: (R, V) => R.classList.contains(V),
      saveFocus: () => m = document.activeElement,
      restoreFocus: () => {
        m && "focus" in m && d.contains(document.activeElement) && m.focus();
      },
      focusActiveNavigationItem: () => {
        const R = d.querySelector(".mdc-list-item--activated,.mdc-deprecated-list-item--activated");
        R && R.focus();
      },
      notifyClose: () => {
        t(9, h = !1), pr(d, "SMUIDrawer:closed", void 0, void 0, !0);
      },
      notifyOpen: () => {
        t(9, h = !0), pr(d, "SMUIDrawer:opened", void 0, void 0, !0);
      },
      trapFocus: () => b.trapFocus(),
      releaseFocus: () => b.releaseFocus()
    }) : void 0;
  }
  function x(S) {
    return S in v ? v[S] : E().classList.contains(S);
  }
  function C(S) {
    v[S] || t(6, v[S] = !0, v);
  }
  function F(S) {
    (!(S in v) || v[S]) && t(6, v[S] = !1, v);
  }
  function N() {
    p && "handleScrimClick" in p && p.handleScrimClick();
  }
  function D(S) {
    t(9, h = S);
  }
  function T() {
    return h;
  }
  function E() {
    return d;
  }
  function L(S) {
    yt[S ? "unshift" : "push"](() => {
      d = S, t(5, d);
    });
  }
  return r.$$set = (S) => {
    e = ze(ze({}, e), Nr(S)), t(8, i = xt(e, n)), "use" in S && t(0, l = S.use), "class" in S && t(1, u = S.class), "variant" in S && t(2, c = S.variant), "open" in S && t(9, h = S.open), "fixed" in S && t(3, f = S.fixed), "$$scope" in S && t(14, a = S.$$scope);
  }, r.$$.update = () => {
    r.$$.dirty & /*oldVariant, variant, instance*/
    8212 && B !== c && (t(13, B = c), p && p.destroy(), t(6, v = {}), t(4, p = _()), p && p.init()), r.$$.dirty & /*instance, open*/
    528 && p && p.isOpen() !== h && (h ? p.open() : p.close());
  }, [
    l,
    u,
    c,
    f,
    p,
    d,
    v,
    A,
    i,
    h,
    D,
    T,
    E,
    B,
    a,
    s,
    L
  ];
}
class kE extends jt {
  constructor(e) {
    super(), Pt(this, e, VL, $L, Mt, {
      use: 0,
      class: 1,
      variant: 2,
      open: 9,
      fixed: 3,
      setOpen: 10,
      isOpen: 11,
      getElement: 12
    });
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[1];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get variant() {
    return this.$$.ctx[2];
  }
  set variant(e) {
    this.$$set({ variant: e }), pe();
  }
  get open() {
    return this.$$.ctx[9];
  }
  set open(e) {
    this.$$set({ open: e }), pe();
  }
  get fixed() {
    return this.$$.ctx[3];
  }
  set fixed(e) {
    this.$$set({ fixed: e }), pe();
  }
  get setOpen() {
    return this.$$.ctx[10];
  }
  get isOpen() {
    return this.$$.ctx[11];
  }
  get getElement() {
    return this.$$.ctx[12];
  }
}
Ht(kE, { use: {}, class: {}, variant: {}, open: { type: "Boolean" }, fixed: { type: "Boolean" } }, ["default"], ["setOpen", "isOpen", "getElement"], !0);
function zL(r) {
  let e;
  const t = (
    /*#slots*/
    r[11].default
  ), n = Nt(
    t,
    r,
    /*$$scope*/
    r[13],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, s) {
      n && n.m(i, s), e = !0;
    },
    p(i, s) {
      n && n.p && (!e || s & /*$$scope*/
      8192) && Qt(
        n,
        t,
        i,
        /*$$scope*/
        i[13],
        e ? Ot(
          t,
          /*$$scope*/
          i[13],
          s,
          null
        ) : Dt(
          /*$$scope*/
          i[13]
        ),
        null
      );
    },
    i(i) {
      e || (fe(n, i), e = !0);
    },
    o(i) {
      ge(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function GL(r) {
  let e, t, n;
  const i = [
    { tag: (
      /*tag*/
      r[3]
    ) },
    {
      use: [
        /*forwardEvents*/
        r[8],
        .../*use*/
        r[0]
      ]
    },
    {
      class: ht({
        [
          /*className*/
          r[1]
        ]: !0,
        [
          /*smuiClass*/
          r[6]
        ]: !0,
        .../*smuiClassMap*/
        r[5]
      })
    },
    /*props*/
    r[7],
    /*$$restProps*/
    r[9]
  ];
  var s = (
    /*component*/
    r[2]
  );
  function a(o, A) {
    let l = {
      $$slots: { default: [zL] },
      $$scope: { ctx: o }
    };
    for (let u = 0; u < i.length; u += 1)
      l = ze(l, i[u]);
    return A !== void 0 && A & /*tag, forwardEvents, use, className, smuiClass, smuiClassMap, props, $$restProps*/
    1003 && (l = ze(l, Et(i, [
      A & /*tag*/
      8 && { tag: (
        /*tag*/
        o[3]
      ) },
      A & /*forwardEvents, use*/
      257 && {
        use: [
          /*forwardEvents*/
          o[8],
          .../*use*/
          o[0]
        ]
      },
      A & /*className, smuiClass, smuiClassMap*/
      98 && {
        class: ht({
          [
            /*className*/
            o[1]
          ]: !0,
          [
            /*smuiClass*/
            o[6]
          ]: !0,
          .../*smuiClassMap*/
          o[5]
        })
      },
      A & /*props*/
      128 && Vt(
        /*props*/
        o[7]
      ),
      A & /*$$restProps*/
      512 && Vt(
        /*$$restProps*/
        o[9]
      )
    ]))), { props: l };
  }
  return s && (e = An(s, a(r)), r[12](e)), {
    c() {
      e && Ve(e.$$.fragment), t = Or();
    },
    m(o, A) {
      e && Ke(e, o, A), ke(o, t, A), n = !0;
    },
    p(o, [A]) {
      if (A & /*component*/
      4 && s !== (s = /*component*/
      o[2])) {
        if (e) {
          er();
          const l = e;
          ge(l.$$.fragment, 1, 0, () => {
            $e(l, 1);
          }), tr();
        }
        s ? (e = An(s, a(o, A)), o[12](e), Ve(e.$$.fragment), fe(e.$$.fragment, 1), Ke(e, t.parentNode, t)) : e = null;
      } else if (s) {
        const l = A & /*tag, forwardEvents, use, className, smuiClass, smuiClassMap, props, $$restProps*/
        1003 ? Et(i, [
          A & /*tag*/
          8 && { tag: (
            /*tag*/
            o[3]
          ) },
          A & /*forwardEvents, use*/
          257 && {
            use: [
              /*forwardEvents*/
              o[8],
              .../*use*/
              o[0]
            ]
          },
          A & /*className, smuiClass, smuiClassMap*/
          98 && {
            class: ht({
              [
                /*className*/
                o[1]
              ]: !0,
              [
                /*smuiClass*/
                o[6]
              ]: !0,
              .../*smuiClassMap*/
              o[5]
            })
          },
          A & /*props*/
          128 && Vt(
            /*props*/
            o[7]
          ),
          A & /*$$restProps*/
          512 && Vt(
            /*$$restProps*/
            o[9]
          )
        ]) : {};
        A & /*$$scope*/
        8192 && (l.$$scope = { dirty: A, ctx: o }), e.$set(l);
      }
    },
    i(o) {
      n || (e && fe(e.$$.fragment, o), n = !0);
    },
    o(o) {
      e && ge(e.$$.fragment, o), n = !1;
    },
    d(o) {
      o && xe(t), r[12](null), e && $e(e, o);
    }
  };
}
const ro = {
  component: Ni,
  tag: "div",
  class: "",
  classMap: {},
  contexts: {},
  props: {}
};
function qL(r, e, t) {
  const n = ["use", "class", "component", "tag", "getElement"];
  let i = xt(e, n), { $$slots: s = {}, $$scope: a } = e, { use: o = [] } = e, { class: A = "" } = e, l;
  const u = ro.class, c = {}, h = [], f = ro.contexts, d = ro.props;
  let { component: p = ro.component } = e, { tag: v = p === Ni ? ro.tag : void 0 } = e;
  Object.entries(ro.classMap).forEach(([B, _]) => {
    const x = pn(_);
    x && "subscribe" in x && h.push(x.subscribe((C) => {
      t(5, c[B] = C, c);
    }));
  });
  const m = Kr(yr());
  for (let B in f)
    f.hasOwnProperty(B) && Pr(B, f[B]);
  fo(() => {
    for (const B of h)
      B();
  });
  function b() {
    return l.getElement();
  }
  function w(B) {
    yt[B ? "unshift" : "push"](() => {
      l = B, t(4, l);
    });
  }
  return r.$$set = (B) => {
    e = ze(ze({}, e), Nr(B)), t(9, i = xt(e, n)), "use" in B && t(0, o = B.use), "class" in B && t(1, A = B.class), "component" in B && t(2, p = B.component), "tag" in B && t(3, v = B.tag), "$$scope" in B && t(13, a = B.$$scope);
  }, [
    o,
    A,
    p,
    v,
    l,
    c,
    u,
    d,
    m,
    i,
    b,
    s,
    w,
    a
  ];
}
class LE extends jt {
  constructor(e) {
    super(), Pt(this, e, qL, GL, Mt, {
      use: 0,
      class: 1,
      component: 2,
      tag: 3,
      getElement: 10
    });
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[1];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get component() {
    return this.$$.ctx[2];
  }
  set component(e) {
    this.$$set({ component: e }), pe();
  }
  get tag() {
    return this.$$.ctx[3];
  }
  set tag(e) {
    this.$$set({ tag: e }), pe();
  }
  get getElement() {
    return this.$$.ctx[10];
  }
}
Ht(LE, { use: {}, class: {}, component: {}, tag: {} }, ["default"], ["getElement"], !0);
const Zy = Object.assign({}, ro);
function Ua(r) {
  return new Proxy(LE, {
    construct: function(e, t) {
      return Object.assign(ro, Zy, r), new e(...t);
    },
    get: function(e, t) {
      return Object.assign(ro, Zy, r), e[t];
    }
  });
}
const WL = Ua({
  class: "mdc-drawer-app-content",
  tag: "div"
}), XL = Ua({
  class: "mdc-drawer__content",
  tag: "div"
}), JL = Ua({
  class: "mdc-drawer__header",
  tag: "div"
}), YL = Ua({
  class: "mdc-drawer__title",
  tag: "h1"
}), ZL = Ua({
  class: "mdc-drawer__subtitle",
  tag: "h2"
});
function eU(r) {
  let e;
  const t = (
    /*#slots*/
    r[10].default
  ), n = Nt(
    t,
    r,
    /*$$scope*/
    r[12],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, s) {
      n && n.m(i, s), e = !0;
    },
    p(i, s) {
      n && n.p && (!e || s & /*$$scope*/
      4096) && Qt(
        n,
        t,
        i,
        /*$$scope*/
        i[12],
        e ? Ot(
          t,
          /*$$scope*/
          i[12],
          s,
          null
        ) : Dt(
          /*$$scope*/
          i[12]
        ),
        null
      );
    },
    i(i) {
      e || (fe(n, i), e = !0);
    },
    o(i) {
      ge(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function tU(r) {
  let e, t, n;
  const i = [
    { tag: (
      /*tag*/
      r[4]
    ) },
    {
      use: [
        /*forwardEvents*/
        r[6],
        .../*use*/
        r[0]
      ]
    },
    {
      class: ht({
        [
          /*className*/
          r[1]
        ]: !0,
        "mdc-drawer-scrim": !0,
        "smui-drawer-scrim__absolute": !/*fixed*/
        r[2]
      })
    },
    /*$$restProps*/
    r[8]
  ];
  var s = (
    /*component*/
    r[3]
  );
  function a(o, A) {
    let l = {
      $$slots: { default: [eU] },
      $$scope: { ctx: o }
    };
    for (let u = 0; u < i.length; u += 1)
      l = ze(l, i[u]);
    return A !== void 0 && A & /*tag, forwardEvents, use, className, fixed, $$restProps*/
    343 && (l = ze(l, Et(i, [
      A & /*tag*/
      16 && { tag: (
        /*tag*/
        o[4]
      ) },
      A & /*forwardEvents, use*/
      65 && {
        use: [
          /*forwardEvents*/
          o[6],
          .../*use*/
          o[0]
        ]
      },
      A & /*className, fixed*/
      6 && {
        class: ht({
          [
            /*className*/
            o[1]
          ]: !0,
          "mdc-drawer-scrim": !0,
          "smui-drawer-scrim__absolute": !/*fixed*/
          o[2]
        })
      },
      A & /*$$restProps*/
      256 && Vt(
        /*$$restProps*/
        o[8]
      )
    ]))), { props: l };
  }
  return s && (e = An(s, a(r)), r[11](e), e.$on(
    "click",
    /*handleClick*/
    r[7]
  )), {
    c() {
      e && Ve(e.$$.fragment), t = Or();
    },
    m(o, A) {
      e && Ke(e, o, A), ke(o, t, A), n = !0;
    },
    p(o, [A]) {
      if (A & /*component*/
      8 && s !== (s = /*component*/
      o[3])) {
        if (e) {
          er();
          const l = e;
          ge(l.$$.fragment, 1, 0, () => {
            $e(l, 1);
          }), tr();
        }
        s ? (e = An(s, a(o, A)), o[11](e), e.$on(
          "click",
          /*handleClick*/
          o[7]
        ), Ve(e.$$.fragment), fe(e.$$.fragment, 1), Ke(e, t.parentNode, t)) : e = null;
      } else if (s) {
        const l = A & /*tag, forwardEvents, use, className, fixed, $$restProps*/
        343 ? Et(i, [
          A & /*tag*/
          16 && { tag: (
            /*tag*/
            o[4]
          ) },
          A & /*forwardEvents, use*/
          65 && {
            use: [
              /*forwardEvents*/
              o[6],
              .../*use*/
              o[0]
            ]
          },
          A & /*className, fixed*/
          6 && {
            class: ht({
              [
                /*className*/
                o[1]
              ]: !0,
              "mdc-drawer-scrim": !0,
              "smui-drawer-scrim__absolute": !/*fixed*/
              o[2]
            })
          },
          A & /*$$restProps*/
          256 && Vt(
            /*$$restProps*/
            o[8]
          )
        ]) : {};
        A & /*$$scope*/
        4096 && (l.$$scope = { dirty: A, ctx: o }), e.$set(l);
      }
    },
    i(o) {
      n || (e && fe(e.$$.fragment, o), n = !0);
    },
    o(o) {
      e && ge(e.$$.fragment, o), n = !1;
    },
    d(o) {
      o && xe(t), r[11](null), e && $e(e, o);
    }
  };
}
function rU(r, e, t) {
  const n = ["use", "class", "fixed", "component", "tag", "getElement"];
  let i = xt(e, n), { $$slots: s = {}, $$scope: a } = e;
  const o = Kr(yr());
  let { use: A = [] } = e, { class: l = "" } = e, { fixed: u = !0 } = e, c, { component: h = Ni } = e, { tag: f = h === Ni ? "div" : void 0 } = e;
  function d(m) {
    pr(p(), "SMUIDrawerScrim:click", m);
  }
  function p() {
    return c.getElement();
  }
  function v(m) {
    yt[m ? "unshift" : "push"](() => {
      c = m, t(5, c);
    });
  }
  return r.$$set = (m) => {
    e = ze(ze({}, e), Nr(m)), t(8, i = xt(e, n)), "use" in m && t(0, A = m.use), "class" in m && t(1, l = m.class), "fixed" in m && t(2, u = m.fixed), "component" in m && t(3, h = m.component), "tag" in m && t(4, f = m.tag), "$$scope" in m && t(12, a = m.$$scope);
  }, [
    A,
    l,
    u,
    h,
    f,
    c,
    o,
    d,
    i,
    p,
    s,
    v,
    a
  ];
}
class nU extends jt {
  constructor(e) {
    super(), Pt(this, e, rU, tU, Mt, {
      use: 0,
      class: 1,
      fixed: 2,
      component: 3,
      tag: 4,
      getElement: 9
    });
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[1];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get fixed() {
    return this.$$.ctx[2];
  }
  set fixed(e) {
    this.$$set({ fixed: e }), pe();
  }
  get component() {
    return this.$$.ctx[3];
  }
  set component(e) {
    this.$$set({ component: e }), pe();
  }
  get tag() {
    return this.$$.ctx[4];
  }
  set tag(e) {
    this.$$set({ tag: e }), pe();
  }
  get getElement() {
    return this.$$.ctx[9];
  }
}
Ht(nU, { use: {}, class: {}, fixed: { type: "Boolean" }, component: {}, tag: {} }, ["default"], ["getElement"], !0);
const UE = {
  isOpen: !1,
  title: "",
  description: "",
  component: void 0,
  componentProps: void 0
}, rg = ia(UE);
function NE({
  title: r,
  description: e,
  component: t,
  componentProps: n
}) {
  rg.update(() => ({
    isOpen: !0,
    title: r,
    description: e || "",
    component: t,
    componentProps: n
  }));
}
function OE() {
  rg.update(() => UE);
}
function iU({
  title: r,
  description: e,
  component: t,
  componentProps: n
}) {
  bn(rg).isOpen ? OE() : NE({ title: r, description: e, component: t, componentProps: n });
}
const sU = {
  //state
  drawer: rg,
  //actions
  handleOpenDrawer: NE,
  handleCloseDrawer: OE,
  handleSwitchDrawer: iU
};
function aU(r) {
  Pi(r, "svelte-5syy2s", `#custom-drawer.svelte-5syy2s .mdc-drawer--dismissible{left:initial;right:0;border-right-width:0;border-left-width:1px;border-right-style:none;border-left-style:solid
	}#custom-drawer.svelte-5syy2s .mdc-drawer.mdc-drawer--open:not(.mdc-drawer--closing) + .mdc-drawer-app-content{margin-right:256px;margin-left:0}#custom-drawer.svelte-5syy2s .mdc-drawer__content{overflow:hidden}#custom-drawer.svelte-5syy2s .mdc-drawer--animate{transform:translateX(100%)
	}#custom-drawer.svelte-5syy2s .mdc-drawer--opening{transform:translateX(0);transition-duration:250ms
	}#custom-drawer.svelte-5syy2s .mdc-drawer--closing{transform:translateX(100%)
	}#custom-drawer.svelte-5syy2s,#custom-drawer.svelte-5syy2s .app-content{height:100%}`);
}
function oU(r) {
  let e = (
    /*$drawer*/
    r[0].title + ""
  ), t;
  return {
    c() {
      t = ir(e);
    },
    m(n, i) {
      ke(n, t, i);
    },
    p(n, i) {
      i & /*$drawer*/
      1 && e !== (e = /*$drawer*/
      n[0].title + "") && Ds(t, e);
    },
    d(n) {
      n && xe(t);
    }
  };
}
function AU(r) {
  let e = (
    /*$drawer*/
    r[0].description + ""
  ), t;
  return {
    c() {
      t = ir(e);
    },
    m(n, i) {
      ke(n, t, i);
    },
    p(n, i) {
      i & /*$drawer*/
      1 && e !== (e = /*$drawer*/
      n[0].description + "") && Ds(t, e);
    },
    d(n) {
      n && xe(t);
    }
  };
}
function lU(r) {
  let e, t, n, i;
  return e = new YL({
    props: {
      $$slots: { default: [oU] },
      $$scope: { ctx: r }
    }
  }), n = new ZL({
    props: {
      $$slots: { default: [AU] },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      Ve(e.$$.fragment), t = tt(), Ve(n.$$.fragment);
    },
    m(s, a) {
      Ke(e, s, a), ke(s, t, a), Ke(n, s, a), i = !0;
    },
    p(s, a) {
      const o = {};
      a & /*$$scope, $drawer*/
      33 && (o.$$scope = { dirty: a, ctx: s }), e.$set(o);
      const A = {};
      a & /*$$scope, $drawer*/
      33 && (A.$$scope = { dirty: a, ctx: s }), n.$set(A);
    },
    i(s) {
      i || (fe(e.$$.fragment, s), fe(n.$$.fragment, s), i = !0);
    },
    o(s) {
      ge(e.$$.fragment, s), ge(n.$$.fragment, s), i = !1;
    },
    d(s) {
      s && xe(t), $e(e, s), $e(n, s);
    }
  };
}
function ew(r) {
  let e, t, n;
  const i = [
    /*$drawer*/
    r[0].componentProps
  ];
  var s = (
    /*InnerComponent*/
    r[1]
  );
  function a(o, A) {
    let l = {};
    for (let u = 0; u < i.length; u += 1)
      l = ze(l, i[u]);
    return A !== void 0 && A & /*$drawer*/
    1 && (l = ze(l, Et(i, [Vt(
      /*$drawer*/
      o[0].componentProps
    )]))), { props: l };
  }
  return s && (e = An(s, a(r))), {
    c() {
      e && Ve(e.$$.fragment), t = Or();
    },
    m(o, A) {
      e && Ke(e, o, A), ke(o, t, A), n = !0;
    },
    p(o, A) {
      if (A & /*InnerComponent*/
      2 && s !== (s = /*InnerComponent*/
      o[1])) {
        if (e) {
          er();
          const l = e;
          ge(l.$$.fragment, 1, 0, () => {
            $e(l, 1);
          }), tr();
        }
        s ? (e = An(s, a(o, A)), Ve(e.$$.fragment), fe(e.$$.fragment, 1), Ke(e, t.parentNode, t)) : e = null;
      } else if (s) {
        const l = A & /*$drawer*/
        1 ? Et(i, [Vt(
          /*$drawer*/
          o[0].componentProps
        )]) : {};
        e.$set(l);
      }
    },
    i(o) {
      n || (e && fe(e.$$.fragment, o), n = !0);
    },
    o(o) {
      e && ge(e.$$.fragment, o), n = !1;
    },
    d(o) {
      o && xe(t), e && $e(e, o);
    }
  };
}
function uU(r) {
  let e, t, n = (
    /*$drawer*/
    r[0].component && ew(r)
  );
  return {
    c() {
      n && n.c(), e = Or();
    },
    m(i, s) {
      n && n.m(i, s), ke(i, e, s), t = !0;
    },
    p(i, s) {
      /*$drawer*/
      i[0].component ? n ? (n.p(i, s), s & /*$drawer*/
      1 && fe(n, 1)) : (n = ew(i), n.c(), fe(n, 1), n.m(e.parentNode, e)) : n && (er(), ge(n, 1, 1, () => {
        n = null;
      }), tr());
    },
    i(i) {
      t || (fe(n), t = !0);
    },
    o(i) {
      ge(n), t = !1;
    },
    d(i) {
      i && xe(e), n && n.d(i);
    }
  };
}
function cU(r) {
  let e, t, n, i;
  return e = new JL({
    props: {
      $$slots: { default: [lU] },
      $$scope: { ctx: r }
    }
  }), n = new XL({
    props: {
      $$slots: { default: [uU] },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      Ve(e.$$.fragment), t = tt(), Ve(n.$$.fragment);
    },
    m(s, a) {
      Ke(e, s, a), ke(s, t, a), Ke(n, s, a), i = !0;
    },
    p(s, a) {
      const o = {};
      a & /*$$scope, $drawer*/
      33 && (o.$$scope = { dirty: a, ctx: s }), e.$set(o);
      const A = {};
      a & /*$$scope, InnerComponent, $drawer*/
      35 && (A.$$scope = { dirty: a, ctx: s }), n.$set(A);
    },
    i(s) {
      i || (fe(e.$$.fragment, s), fe(n.$$.fragment, s), i = !0);
    },
    o(s) {
      ge(e.$$.fragment, s), ge(n.$$.fragment, s), i = !1;
    },
    d(s) {
      s && xe(t), $e(e, s), $e(n, s);
    }
  };
}
function fU(r) {
  let e;
  const t = (
    /*#slots*/
    r[3].default
  ), n = Nt(
    t,
    r,
    /*$$scope*/
    r[5],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, s) {
      n && n.m(i, s), e = !0;
    },
    p(i, s) {
      n && n.p && (!e || s & /*$$scope*/
      32) && Qt(
        n,
        t,
        i,
        /*$$scope*/
        i[5],
        e ? Ot(
          t,
          /*$$scope*/
          i[5],
          s,
          null
        ) : Dt(
          /*$$scope*/
          i[5]
        ),
        null
      );
    },
    i(i) {
      e || (fe(n, i), e = !0);
    },
    o(i) {
      ge(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function hU(r) {
  let e, t, n, i, s, a;
  function o(l) {
    r[4](l);
  }
  let A = {
    variant: "dismissible",
    $$slots: { default: [cU] },
    $$scope: { ctx: r }
  };
  return (
    /*$drawer*/
    r[0].isOpen !== void 0 && (A.open = /*$drawer*/
    r[0].isOpen), t = new kE({ props: A }), yt.push(() => Gn(t, "open", o)), s = new WL({
      props: {
        class: "app-content",
        $$slots: { default: [fU] },
        $$scope: { ctx: r }
      }
    }), {
      c() {
        e = We("div"), Ve(t.$$.fragment), i = tt(), Ve(s.$$.fragment), Me(e, "id", "custom-drawer"), Me(e, "class", "svelte-5syy2s");
      },
      m(l, u) {
        ke(l, e, u), Ke(t, e, null), je(e, i), Ke(s, e, null), a = !0;
      },
      p(l, [u]) {
        const c = {};
        u & /*$$scope, InnerComponent, $drawer*/
        35 && (c.$$scope = { dirty: u, ctx: l }), !n && u & /*$drawer*/
        1 && (n = !0, c.open = /*$drawer*/
        l[0].isOpen, zn(() => n = !1)), t.$set(c);
        const h = {};
        u & /*$$scope*/
        32 && (h.$$scope = { dirty: u, ctx: l }), s.$set(h);
      },
      i(l) {
        a || (fe(t.$$.fragment, l), fe(s.$$.fragment, l), a = !0);
      },
      o(l) {
        ge(t.$$.fragment, l), ge(s.$$.fragment, l), a = !1;
      },
      d(l) {
        l && xe(e), $e(t), $e(s);
      }
    }
  );
}
function dU(r, e, t) {
  let n, i, { $$slots: s = {}, $$scope: a } = e;
  const { drawer: o } = sU;
  GA(r, o, (l) => t(0, i = l));
  function A(l) {
    r.$$.not_equal(i.isOpen, l) && (i.isOpen = l, o.set(i));
  }
  return r.$$set = (l) => {
    "$$scope" in l && t(5, a = l.$$scope);
  }, r.$$.update = () => {
    r.$$.dirty & /*$drawer*/
    1 && t(1, n = i.component || null);
  }, [i, n, o, s, A, a];
}
class pU extends jt {
  constructor(e) {
    super(), Pt(this, e, dU, hU, Mt, {}, aU);
  }
}
Ht(pU, {}, ["default"], [], !0);
const gU = "/oscd-plugins/auto-doc/fonts.css", mU = "/oscd-plugins/auto-doc/theme.css", vU = "/oscd-plugins/auto-doc/bare.css";
var bU = ((r) => (r.GOOSE = "GOOSE", r.MMS = "MMS", r.SampledValues = "SampledValues", r.Unknown = "Unknown", r))(bU || {});
function H2(r, e, t) {
  let n = r.createElementNS(r.documentElement.namespaceURI, e);
  return Object.entries(t).filter(([i, s]) => s !== null).forEach(([i, s]) => n.setAttribute(i, s)), n;
}
function yU(r) {
  let e = new XMLSerializer().serializeToString(r);
  return e.startsWith("<?xml") ? e : `<?xml version="1.0" encoding="UTF-8"?>
` + e;
}
function wU(r) {
  var e, t;
  return r.old === void 0 && ((e = r.new) == null ? void 0 : e.parent) !== void 0 && ((t = r.new) == null ? void 0 : t.element) !== void 0;
}
function BU(r) {
  var e, t;
  return ((e = r.old) == null ? void 0 : e.parent) !== void 0 && ((t = r.old) == null ? void 0 : t.element) !== void 0 && r.new === void 0;
}
function CU(r) {
  var e, t, n, i;
  return ((e = r.old) == null ? void 0 : e.parent) !== void 0 && ((t = r.old) == null ? void 0 : t.element) !== void 0 && ((n = r.new) == null ? void 0 : n.parent) !== void 0 && ((i = r.new) == null ? void 0 : i.element) == null;
}
function _U(r) {
  var e, t, n, i;
  return ((e = r.old) == null ? void 0 : e.parent) === void 0 && ((t = r.old) == null ? void 0 : t.element) !== void 0 && ((n = r.new) == null ? void 0 : n.parent) === void 0 && ((i = r.new) == null ? void 0 : i.element) !== void 0;
}
function EU(r) {
  return r.old === void 0 && r.new === void 0 && r.element !== void 0 && r.newAttributes !== void 0 && r.oldAttributes !== void 0;
}
function SU(r, e) {
  let t = {};
  return Array.from(r.attributes).forEach((n) => {
    t[n.name] = n.value;
  }), { element: r, oldAttributes: t, newAttributes: e };
}
function ng(r, e = "user", t) {
  return new CustomEvent("editor-action", { bubbles: !0, composed: !0, ...t, detail: { action: r, initiator: e, ...t == null ? void 0 : t.detail } });
}
function IU(r, e, t) {
  return new CustomEvent("open-doc", { bubbles: !0, composed: !0, ...t, detail: { doc: r, docName: e, ...t == null ? void 0 : t.detail } });
}
function FU(r) {
  function e() {
    return Reflect.construct(HTMLElement, [], new.target);
  }
  return e.prototype = Object.create(HTMLElement.prototype), e.prototype.pluginInstance = void 0, e.prototype.localDoc = void 0, e.prototype.localDocName = void 0, e.prototype.localEditCount = -1, Object.defineProperty(e.prototype, "doc", { get: function() {
    return this.localDoc;
  }, set: function(t) {
    this.localDoc = t, this.pluginInstance && this.pluginInstance.$set({ xmlDocument: t });
  } }), Object.defineProperty(e.prototype, "docName", { get: function() {
    return this.localDocName;
  }, set: function(t) {
    this.localDocName = t;
  } }), Object.defineProperty(e.prototype, "editCount", { get: function() {
    return this.localEditCount;
  }, set: function(t) {
    this.localEditCount = t, this.pluginInstance && this.pluginInstance.$set({ editCount: t });
  } }), e.prototype.connectedCallback = function() {
    this.pluginInstance = new r({ target: this.attachShadow({ mode: "open" }), props: { xmlDocument: this.localDoc, pluginHostElement: this, editCount: this.localEditCount } });
  }, e;
}
function TU(r) {
  function e() {
    return Reflect.construct(HTMLElement, [], new.target);
  }
  return e.prototype = Object.create(HTMLElement.prototype), e.prototype.pluginInstance = void 0, e.prototype.run = function() {
    return this.pluginInstance.run();
  }, e.prototype.connectedCallback = function() {
    this.pluginInstance = new r({ target: this.attachShadow({ mode: "open" }) });
  }, e;
}
function xU(r) {
  function e() {
    return Reflect.construct(HTMLElement, [], this.constructor);
  }
  return e.prototype = Object.create(HTMLElement.prototype), e.prototype.pluginInstance = null, e.prototype.connectedCallback = function() {
    this.pluginInstance = new r({ target: this.attachShadow({ mode: "open" }) });
  }, e;
}
function kU(r) {
  console.warn("TODO onCreate", r);
}
function LU(r) {
  r.new.parent.insertBefore(r.new.element, r.new.reference ?? null);
}
function UU(r) {
  r.old.reference || (r.old.reference = r.old.element.nextSibling), r.old.element.parentNode === r.old.parent && r.old.parent.removeChild(r.old.element);
}
function NU(r) {
  console.warn("TODO onReplace", r);
}
function OU(r) {
  for (let e of Array.from(r.element.attributes)) r.element.removeAttributeNode(e);
  for (let [e, t] of Object.entries(r.newAttributes)) r.element.setAttribute(e, t ?? "");
}
function QU(r, e) {
  r.doc = e.detail.doc, r.docName = e.detail.docName;
}
function DU(r) {
  if (!r.doc) return;
  let e = yU(r.doc), t = new Blob([e], { type: "application/xml" }), n = URL.createObjectURL(t), i = document.createElement("a");
  i.href = n, i.download = r.docName || "file.xml", document.body.appendChild(i), i.click(), document.body.removeChild(i), URL.revokeObjectURL(n);
}
function MU(r, e) {
  let { action: t } = e.detail;
  CU(t) && kU(t), wU(t) && LU(t), BU(t) && UU(t), _U(t) && NU(t), EU(t) && OU(t), r.editCount++;
}
function RU(r, e) {
  customElements.define("stand-alone-plugin", r);
  let t = document.createElement("stand-alone-plugin");
  document.body.appendChild(t), e === "editor" && PU(t);
}
function PU(r) {
  document.addEventListener("open-doc", (e) => QU(r, e)), document.addEventListener("save-doc", () => DU(r)), document.addEventListener("editor-action", (e) => MU(r, e));
}
function HU({ pluginType: r, isStandAlone: e, pluginComponent: t }) {
  let n = { editor: FU(t), menu: TU(t), validator: xU(t) };
  return e ? RU(n[r], r) : n[r];
}
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var PA = {
  FIXED_CLASS: "mdc-top-app-bar--fixed",
  FIXED_SCROLLED_CLASS: "mdc-top-app-bar--fixed-scrolled",
  SHORT_CLASS: "mdc-top-app-bar--short",
  SHORT_COLLAPSED_CLASS: "mdc-top-app-bar--short-collapsed",
  SHORT_HAS_ACTION_ITEM_CLASS: "mdc-top-app-bar--short-has-action-item"
}, ep = {
  DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,
  MAX_TOP_APP_BAR_HEIGHT: 128
}, jU = {
  ACTION_ITEM_SELECTOR: ".mdc-top-app-bar__action-item",
  NAVIGATION_EVENT: "MDCTopAppBar:nav",
  NAVIGATION_ICON_SELECTOR: ".mdc-top-app-bar__navigation-icon",
  ROOT_SELECTOR: ".mdc-top-app-bar",
  TITLE_SELECTOR: ".mdc-top-app-bar__title"
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var j2 = (
  /** @class */
  function(r) {
    Zi(e, r);
    function e(t) {
      return r.call(this, Jr(Jr({}, e.defaultAdapter), t)) || this;
    }
    return Object.defineProperty(e, "strings", {
      get: function() {
        return jU;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "cssClasses", {
      get: function() {
        return PA;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "numbers", {
      get: function() {
        return ep;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "defaultAdapter", {
      /**
       * See {@link MDCTopAppBarAdapter} for typing information on parameters and return types.
       */
      get: function() {
        return {
          addClass: function() {
          },
          removeClass: function() {
          },
          hasClass: function() {
            return !1;
          },
          setStyle: function() {
          },
          getTopAppBarHeight: function() {
            return 0;
          },
          notifyNavigationIconClicked: function() {
          },
          getViewportScrollY: function() {
            return 0;
          },
          getTotalActionItems: function() {
            return 0;
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.handleTargetScroll = function() {
    }, e.prototype.handleWindowResize = function() {
    }, e.prototype.handleNavigationClick = function() {
      this.adapter.notifyNavigationIconClicked();
    }, e;
  }(La)
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var Gh = 0, j1 = (
  /** @class */
  function(r) {
    Zi(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n.wasDocked = !0, n.isDockedShowing = !0, n.currentAppBarOffsetTop = 0, n.isCurrentlyBeingResized = !1, n.resizeThrottleId = Gh, n.resizeDebounceId = Gh, n.lastScrollPosition = n.adapter.getViewportScrollY(), n.topAppBarHeight = n.adapter.getTopAppBarHeight(), n;
    }
    return e.prototype.destroy = function() {
      r.prototype.destroy.call(this), this.adapter.setStyle("top", "");
    }, e.prototype.handleTargetScroll = function() {
      var t = Math.max(this.adapter.getViewportScrollY(), 0), n = t - this.lastScrollPosition;
      this.lastScrollPosition = t, this.isCurrentlyBeingResized || (this.currentAppBarOffsetTop -= n, this.currentAppBarOffsetTop > 0 ? this.currentAppBarOffsetTop = 0 : Math.abs(this.currentAppBarOffsetTop) > this.topAppBarHeight && (this.currentAppBarOffsetTop = -this.topAppBarHeight), this.moveTopAppBar());
    }, e.prototype.handleWindowResize = function() {
      var t = this;
      this.resizeThrottleId || (this.resizeThrottleId = setTimeout(function() {
        t.resizeThrottleId = Gh, t.throttledResizeHandler();
      }, ep.DEBOUNCE_THROTTLE_RESIZE_TIME_MS)), this.isCurrentlyBeingResized = !0, this.resizeDebounceId && clearTimeout(this.resizeDebounceId), this.resizeDebounceId = setTimeout(function() {
        t.handleTargetScroll(), t.isCurrentlyBeingResized = !1, t.resizeDebounceId = Gh;
      }, ep.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
    }, e.prototype.checkForUpdate = function() {
      var t = -this.topAppBarHeight, n = this.currentAppBarOffsetTop < 0, i = this.currentAppBarOffsetTop > t, s = n && i;
      if (s)
        this.wasDocked = !1;
      else if (this.wasDocked) {
        if (this.isDockedShowing !== i)
          return this.isDockedShowing = i, !0;
      } else return this.wasDocked = !0, !0;
      return s;
    }, e.prototype.moveTopAppBar = function() {
      if (this.checkForUpdate()) {
        var t = this.currentAppBarOffsetTop;
        Math.abs(t) >= this.topAppBarHeight && (t = -ep.MAX_TOP_APP_BAR_HEIGHT), this.adapter.setStyle("top", t + "px");
      }
    }, e.prototype.throttledResizeHandler = function() {
      var t = this.adapter.getTopAppBarHeight();
      this.topAppBarHeight !== t && (this.wasDocked = !1, this.currentAppBarOffsetTop -= this.topAppBarHeight - t, this.topAppBarHeight = t), this.handleTargetScroll();
    }, e;
  }(j2)
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var KU = (
  /** @class */
  function(r) {
    Zi(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.wasScrolled = !1, t;
    }
    return e.prototype.handleTargetScroll = function() {
      var t = this.adapter.getViewportScrollY();
      t <= 0 ? this.wasScrolled && (this.adapter.removeClass(PA.FIXED_SCROLLED_CLASS), this.wasScrolled = !1) : this.wasScrolled || (this.adapter.addClass(PA.FIXED_SCROLLED_CLASS), this.wasScrolled = !0);
    }, e;
  }(j1)
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var $U = (
  /** @class */
  function(r) {
    Zi(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return n.collapsed = !1, n.isAlwaysCollapsed = !1, n;
    }
    return Object.defineProperty(e.prototype, "isCollapsed", {
      // Public visibility for backward compatibility.
      get: function() {
        return this.collapsed;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.init = function() {
      r.prototype.init.call(this), this.adapter.getTotalActionItems() > 0 && this.adapter.addClass(PA.SHORT_HAS_ACTION_ITEM_CLASS), this.setAlwaysCollapsed(this.adapter.hasClass(PA.SHORT_COLLAPSED_CLASS));
    }, e.prototype.setAlwaysCollapsed = function(t) {
      this.isAlwaysCollapsed = !!t, this.isAlwaysCollapsed ? this.collapse() : this.maybeCollapseBar();
    }, e.prototype.getAlwaysCollapsed = function() {
      return this.isAlwaysCollapsed;
    }, e.prototype.handleTargetScroll = function() {
      this.maybeCollapseBar();
    }, e.prototype.maybeCollapseBar = function() {
      if (!this.isAlwaysCollapsed) {
        var t = this.adapter.getViewportScrollY();
        t <= 0 ? this.collapsed && this.uncollapse() : this.collapsed || this.collapse();
      }
    }, e.prototype.uncollapse = function() {
      this.adapter.removeClass(PA.SHORT_COLLAPSED_CLASS), this.collapsed = !1;
    }, e.prototype.collapse = function() {
      this.adapter.addClass(PA.SHORT_COLLAPSED_CLASS), this.collapsed = !0;
    }, e;
  }(j2)
);
const { window: tw } = Lk;
function VU(r) {
  let e, t, n, i, s, a, o;
  const A = (
    /*#slots*/
    r[22].default
  ), l = Nt(
    A,
    r,
    /*$$scope*/
    r[21],
    null
  );
  let u = [
    {
      class: t = ht({
        [
          /*className*/
          r[2]
        ]: !0,
        "mdc-top-app-bar": !0,
        "mdc-top-app-bar--short": (
          /*variant*/
          r[4] === "short"
        ),
        "mdc-top-app-bar--short-collapsed": (
          /*collapsed*/
          r[0]
        ),
        "mdc-top-app-bar--fixed": (
          /*variant*/
          r[4] === "fixed"
        ),
        "smui-top-app-bar--static": (
          /*variant*/
          r[4] === "static"
        ),
        "smui-top-app-bar--color-secondary": (
          /*color*/
          r[5] === "secondary"
        ),
        "mdc-top-app-bar--prominent": (
          /*prominent*/
          r[6]
        ),
        "mdc-top-app-bar--dense": (
          /*dense*/
          r[7]
        ),
        .../*internalClasses*/
        r[11]
      })
    },
    {
      style: n = Object.entries(
        /*internalStyles*/
        r[12]
      ).map(rw).concat([
        /*style*/
        r[3]
      ]).join(" ")
    },
    /*$$restProps*/
    r[15]
  ], c = {};
  for (let h = 0; h < u.length; h += 1)
    c = ze(c, u[h]);
  return {
    c() {
      e = We("header"), l && l.c(), Ut(e, c);
    },
    m(h, f) {
      ke(h, e, f), l && l.m(e, null), r[25](e), s = !0, a || (o = [
        pt(
          tw,
          "resize",
          /*resize_handler*/
          r[23]
        ),
        pt(
          tw,
          "scroll",
          /*scroll_handler*/
          r[24]
        ),
        Bt(i = xr.call(
          null,
          e,
          /*use*/
          r[1]
        )),
        Bt(
          /*forwardEvents*/
          r[13].call(null, e)
        ),
        pt(
          e,
          "SMUITopAppBarIconButton:nav",
          /*SMUITopAppBarIconButton_nav_handler*/
          r[26]
        )
      ], a = !0);
    },
    p(h, f) {
      l && l.p && (!s || f[0] & /*$$scope*/
      2097152) && Qt(
        l,
        A,
        h,
        /*$$scope*/
        h[21],
        s ? Ot(
          A,
          /*$$scope*/
          h[21],
          f,
          null
        ) : Dt(
          /*$$scope*/
          h[21]
        ),
        null
      ), Ut(e, c = Et(u, [
        (!s || f[0] & /*className, variant, collapsed, color, prominent, dense, internalClasses*/
        2293 && t !== (t = ht({
          [
            /*className*/
            h[2]
          ]: !0,
          "mdc-top-app-bar": !0,
          "mdc-top-app-bar--short": (
            /*variant*/
            h[4] === "short"
          ),
          "mdc-top-app-bar--short-collapsed": (
            /*collapsed*/
            h[0]
          ),
          "mdc-top-app-bar--fixed": (
            /*variant*/
            h[4] === "fixed"
          ),
          "smui-top-app-bar--static": (
            /*variant*/
            h[4] === "static"
          ),
          "smui-top-app-bar--color-secondary": (
            /*color*/
            h[5] === "secondary"
          ),
          "mdc-top-app-bar--prominent": (
            /*prominent*/
            h[6]
          ),
          "mdc-top-app-bar--dense": (
            /*dense*/
            h[7]
          ),
          .../*internalClasses*/
          h[11]
        }))) && { class: t },
        (!s || f[0] & /*internalStyles, style*/
        4104 && n !== (n = Object.entries(
          /*internalStyles*/
          h[12]
        ).map(rw).concat([
          /*style*/
          h[3]
        ]).join(" "))) && { style: n },
        f[0] & /*$$restProps*/
        32768 && /*$$restProps*/
        h[15]
      ])), i && ar(i.update) && f[0] & /*use*/
      2 && i.update.call(
        null,
        /*use*/
        h[1]
      );
    },
    i(h) {
      s || (fe(l, h), s = !0);
    },
    o(h) {
      ge(l, h), s = !1;
    },
    d(h) {
      h && xe(e), l && l.d(h), r[25](null), a = !1, fr(o);
    }
  };
}
const rw = ([r, e]) => `${r}: ${e};`;
function zU(r, e, t) {
  const n = [
    "use",
    "class",
    "style",
    "variant",
    "color",
    "collapsed",
    "prominent",
    "dense",
    "scrollTarget",
    "getPropStore",
    "getElement"
  ];
  let i = xt(e, n), { $$slots: s = {}, $$scope: a } = e;
  const o = Kr(yr());
  let A = () => {
  };
  function l(H) {
    return H === A;
  }
  let { use: u = [] } = e, { class: c = "" } = e, { style: h = "" } = e, { variant: f = "standard" } = e, { color: d = "primary" } = e, { collapsed: p = A } = e;
  const v = !l(p) && !!p;
  l(p) && (p = !1);
  let { prominent: m = !1 } = e, { dense: b = !1 } = e, { scrollTarget: w = void 0 } = e, B, _, x = {}, C = {}, F, N = P2({ variant: f, prominent: m, dense: b }, (H) => {
    t(18, F = H);
  }), D, T = f;
  ui(() => (t(9, _ = E()), _.init(), () => {
    _.destroy();
  }));
  function E() {
    const H = {
      static: j2,
      short: $U,
      fixed: KU,
      standard: j1
    }[f] || j1;
    return new H({
      hasClass: L,
      addClass: S,
      removeClass: X,
      setStyle: z,
      getTopAppBarHeight: () => B.clientHeight,
      notifyNavigationIconClicked: () => pr(B, "SMUITopAppBar:nav", void 0, void 0, !0),
      getViewportScrollY: () => w == null ? window.pageYOffset : w.scrollTop,
      getTotalActionItems: () => B.querySelectorAll(".mdc-top-app-bar__action-item").length
    });
  }
  function L(H) {
    return H in x ? x[H] : O().classList.contains(H);
  }
  function S(H) {
    x[H] || t(11, x[H] = !0, x);
  }
  function X(H) {
    (!(H in x) || x[H]) && t(11, x[H] = !1, x);
  }
  function z(H, $) {
    C[H] != $ && ($ === "" || $ == null ? (delete C[H], t(12, C), t(20, T), t(4, f), t(9, _)) : t(12, C[H] = $, C));
  }
  function R() {
    _ && (_.handleTargetScroll(), f === "short" && t(0, p = "isCollapsed" in _ && _.isCollapsed));
  }
  function V() {
    return N;
  }
  function O() {
    return B;
  }
  const J = () => f !== "short" && f !== "fixed" && _ && _.handleWindowResize(), Z = () => w == null && R();
  function U(H) {
    yt[H ? "unshift" : "push"](() => {
      B = H, t(10, B);
    });
  }
  const P = () => _ && _.handleNavigationClick();
  return r.$$set = (H) => {
    e = ze(ze({}, e), Nr(H)), t(15, i = xt(e, n)), "use" in H && t(1, u = H.use), "class" in H && t(2, c = H.class), "style" in H && t(3, h = H.style), "variant" in H && t(4, f = H.variant), "color" in H && t(5, d = H.color), "collapsed" in H && t(0, p = H.collapsed), "prominent" in H && t(6, m = H.prominent), "dense" in H && t(7, b = H.dense), "scrollTarget" in H && t(8, w = H.scrollTarget), "$$scope" in H && t(21, a = H.$$scope);
  }, r.$$.update = () => {
    r.$$.dirty[0] & /*propStoreSet, variant, prominent, dense*/
    262352 && F && F({ variant: f, prominent: m, dense: b }), r.$$.dirty[0] & /*oldVariant, variant, instance*/
    1049104 && T !== f && _ && (t(20, T = f), _.destroy(), t(11, x = {}), t(12, C = {}), t(9, _ = E()), _.init()), r.$$.dirty[0] & /*instance, variant*/
    528 && _ && f === "short" && "setAlwaysCollapsed" in _ && _.setAlwaysCollapsed(v), r.$$.dirty[0] & /*oldScrollTarget, scrollTarget*/
    524544 && D !== w && (D && D.removeEventListener("scroll", R), w && w.addEventListener("scroll", R), t(19, D = w));
  }, [
    p,
    u,
    c,
    h,
    f,
    d,
    m,
    b,
    w,
    _,
    B,
    x,
    C,
    o,
    R,
    i,
    V,
    O,
    F,
    D,
    T,
    a,
    s,
    J,
    Z,
    U,
    P
  ];
}
class QE extends jt {
  constructor(e) {
    super(), Pt(
      this,
      e,
      zU,
      VU,
      Mt,
      {
        use: 1,
        class: 2,
        style: 3,
        variant: 4,
        color: 5,
        collapsed: 0,
        prominent: 6,
        dense: 7,
        scrollTarget: 8,
        getPropStore: 16,
        getElement: 17
      },
      null,
      [-1, -1]
    );
  }
  get use() {
    return this.$$.ctx[1];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[2];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get style() {
    return this.$$.ctx[3];
  }
  set style(e) {
    this.$$set({ style: e }), pe();
  }
  get variant() {
    return this.$$.ctx[4];
  }
  set variant(e) {
    this.$$set({ variant: e }), pe();
  }
  get color() {
    return this.$$.ctx[5];
  }
  set color(e) {
    this.$$set({ color: e }), pe();
  }
  get collapsed() {
    return this.$$.ctx[0];
  }
  set collapsed(e) {
    this.$$set({ collapsed: e }), pe();
  }
  get prominent() {
    return this.$$.ctx[6];
  }
  set prominent(e) {
    this.$$set({ prominent: e }), pe();
  }
  get dense() {
    return this.$$.ctx[7];
  }
  set dense(e) {
    this.$$set({ dense: e }), pe();
  }
  get scrollTarget() {
    return this.$$.ctx[8];
  }
  set scrollTarget(e) {
    this.$$set({ scrollTarget: e }), pe();
  }
  get getPropStore() {
    return this.$$.ctx[16];
  }
  get getElement() {
    return this.$$.ctx[17];
  }
}
Ht(QE, { use: {}, class: {}, style: {}, variant: {}, color: {}, collapsed: {}, prominent: { type: "Boolean" }, dense: { type: "Boolean" }, scrollTarget: {} }, ["default"], ["getPropStore", "getElement"], !0);
const GU = Ua({
  class: "mdc-top-app-bar__row",
  tag: "div"
});
function qU(r) {
  let e, t, n, i, s, a;
  const o = (
    /*#slots*/
    r[9].default
  ), A = Nt(
    o,
    r,
    /*$$scope*/
    r[8],
    null
  );
  let l = [
    {
      class: t = ht({
        [
          /*className*/
          r[1]
        ]: !0,
        "mdc-top-app-bar__section": !0,
        "mdc-top-app-bar__section--align-start": (
          /*align*/
          r[2] === "start"
        ),
        "mdc-top-app-bar__section--align-end": (
          /*align*/
          r[2] === "end"
        )
      })
    },
    /*toolbar*/
    r[3] ? { role: "toolbar" } : {},
    /*$$restProps*/
    r[6]
  ], u = {};
  for (let c = 0; c < l.length; c += 1)
    u = ze(u, l[c]);
  return {
    c() {
      e = We("section"), A && A.c(), Ut(e, u);
    },
    m(c, h) {
      ke(c, e, h), A && A.m(e, null), r[10](e), i = !0, s || (a = [
        Bt(n = xr.call(
          null,
          e,
          /*use*/
          r[0]
        )),
        Bt(
          /*forwardEvents*/
          r[5].call(null, e)
        )
      ], s = !0);
    },
    p(c, [h]) {
      A && A.p && (!i || h & /*$$scope*/
      256) && Qt(
        A,
        o,
        c,
        /*$$scope*/
        c[8],
        i ? Ot(
          o,
          /*$$scope*/
          c[8],
          h,
          null
        ) : Dt(
          /*$$scope*/
          c[8]
        ),
        null
      ), Ut(e, u = Et(l, [
        (!i || h & /*className, align*/
        6 && t !== (t = ht({
          [
            /*className*/
            c[1]
          ]: !0,
          "mdc-top-app-bar__section": !0,
          "mdc-top-app-bar__section--align-start": (
            /*align*/
            c[2] === "start"
          ),
          "mdc-top-app-bar__section--align-end": (
            /*align*/
            c[2] === "end"
          )
        }))) && { class: t },
        h & /*toolbar*/
        8 && /*toolbar*/
        (c[3] ? { role: "toolbar" } : {}),
        h & /*$$restProps*/
        64 && /*$$restProps*/
        c[6]
      ])), n && ar(n.update) && h & /*use*/
      1 && n.update.call(
        null,
        /*use*/
        c[0]
      );
    },
    i(c) {
      i || (fe(A, c), i = !0);
    },
    o(c) {
      ge(A, c), i = !1;
    },
    d(c) {
      c && xe(e), A && A.d(c), r[10](null), s = !1, fr(a);
    }
  };
}
function WU(r, e, t) {
  const n = ["use", "class", "align", "toolbar", "getElement"];
  let i = xt(e, n), { $$slots: s = {}, $$scope: a } = e;
  const o = Kr(yr());
  let { use: A = [] } = e, { class: l = "" } = e, { align: u = "start" } = e, { toolbar: c = !1 } = e, h;
  Pr("SMUI:icon-button:context", c ? "top-app-bar:action" : "top-app-bar:navigation"), Pr("SMUI:button:context", c ? "top-app-bar:action" : "top-app-bar:navigation");
  function f() {
    return h;
  }
  function d(p) {
    yt[p ? "unshift" : "push"](() => {
      h = p, t(4, h);
    });
  }
  return r.$$set = (p) => {
    e = ze(ze({}, e), Nr(p)), t(6, i = xt(e, n)), "use" in p && t(0, A = p.use), "class" in p && t(1, l = p.class), "align" in p && t(2, u = p.align), "toolbar" in p && t(3, c = p.toolbar), "$$scope" in p && t(8, a = p.$$scope);
  }, [
    A,
    l,
    u,
    c,
    h,
    o,
    i,
    f,
    a,
    s,
    d
  ];
}
class K1 extends jt {
  constructor(e) {
    super(), Pt(this, e, WU, qU, Mt, {
      use: 0,
      class: 1,
      align: 2,
      toolbar: 3,
      getElement: 7
    });
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[1];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get align() {
    return this.$$.ctx[2];
  }
  set align(e) {
    this.$$set({ align: e }), pe();
  }
  get toolbar() {
    return this.$$.ctx[3];
  }
  set toolbar(e) {
    this.$$set({ toolbar: e }), pe();
  }
  get getElement() {
    return this.$$.ctx[7];
  }
}
Ht(K1, { use: {}, class: {}, align: {}, toolbar: { type: "Boolean" } }, ["default"], ["getElement"], !0);
const XU = Ua({
  class: "mdc-top-app-bar__title",
  tag: "span"
});
function JU(r) {
  let e;
  const t = (
    /*#slots*/
    r[12].default
  ), n = Nt(
    t,
    r,
    /*$$scope*/
    r[14],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, s) {
      n && n.m(i, s), e = !0;
    },
    p(i, s) {
      n && n.p && (!e || s & /*$$scope*/
      16384) && Qt(
        n,
        t,
        i,
        /*$$scope*/
        i[14],
        e ? Ot(
          t,
          /*$$scope*/
          i[14],
          s,
          null
        ) : Dt(
          /*$$scope*/
          i[14]
        ),
        null
      );
    },
    i(i) {
      e || (fe(n, i), e = !0);
    },
    o(i) {
      ge(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function YU(r) {
  let e, t, n;
  const i = [
    { tag: (
      /*tag*/
      r[3]
    ) },
    {
      use: [
        /*forwardEvents*/
        r[7],
        .../*use*/
        r[0]
      ]
    },
    {
      class: ht({
        [
          /*className*/
          r[1]
        ]: !0,
        [
          /*adjustClass*/
          r[6]
        ]: !0
      })
    },
    /*$$restProps*/
    r[8]
  ];
  var s = (
    /*component*/
    r[2]
  );
  function a(o, A) {
    let l = {
      $$slots: { default: [JU] },
      $$scope: { ctx: o }
    };
    for (let u = 0; u < i.length; u += 1)
      l = ze(l, i[u]);
    return A !== void 0 && A & /*tag, forwardEvents, use, className, adjustClass, $$restProps*/
    459 && (l = ze(l, Et(i, [
      A & /*tag*/
      8 && { tag: (
        /*tag*/
        o[3]
      ) },
      A & /*forwardEvents, use*/
      129 && {
        use: [
          /*forwardEvents*/
          o[7],
          .../*use*/
          o[0]
        ]
      },
      A & /*className, adjustClass*/
      66 && {
        class: ht({
          [
            /*className*/
            o[1]
          ]: !0,
          [
            /*adjustClass*/
            o[6]
          ]: !0
        })
      },
      A & /*$$restProps*/
      256 && Vt(
        /*$$restProps*/
        o[8]
      )
    ]))), { props: l };
  }
  return s && (e = An(s, a(r)), r[13](e)), {
    c() {
      e && Ve(e.$$.fragment), t = Or();
    },
    m(o, A) {
      e && Ke(e, o, A), ke(o, t, A), n = !0;
    },
    p(o, [A]) {
      if (A & /*component*/
      4 && s !== (s = /*component*/
      o[2])) {
        if (e) {
          er();
          const l = e;
          ge(l.$$.fragment, 1, 0, () => {
            $e(l, 1);
          }), tr();
        }
        s ? (e = An(s, a(o, A)), o[13](e), Ve(e.$$.fragment), fe(e.$$.fragment, 1), Ke(e, t.parentNode, t)) : e = null;
      } else if (s) {
        const l = A & /*tag, forwardEvents, use, className, adjustClass, $$restProps*/
        459 ? Et(i, [
          A & /*tag*/
          8 && { tag: (
            /*tag*/
            o[3]
          ) },
          A & /*forwardEvents, use*/
          129 && {
            use: [
              /*forwardEvents*/
              o[7],
              .../*use*/
              o[0]
            ]
          },
          A & /*className, adjustClass*/
          66 && {
            class: ht({
              [
                /*className*/
                o[1]
              ]: !0,
              [
                /*adjustClass*/
                o[6]
              ]: !0
            })
          },
          A & /*$$restProps*/
          256 && Vt(
            /*$$restProps*/
            o[8]
          )
        ]) : {};
        A & /*$$scope*/
        16384 && (l.$$scope = { dirty: A, ctx: o }), e.$set(l);
      }
    },
    i(o) {
      n || (e && fe(e.$$.fragment, o), n = !0);
    },
    o(o) {
      e && ge(e.$$.fragment, o), n = !1;
    },
    d(o) {
      o && xe(t), r[13](null), e && $e(e, o);
    }
  };
}
function ZU(r, e, t) {
  let n, i;
  const s = ["use", "class", "topAppBar", "component", "tag", "getElement"];
  let a = xt(e, s), o, A = sr, l = () => (A(), A = Zp(n, (_) => t(11, o = _)), n);
  r.$$.on_destroy.push(() => A());
  let { $$slots: u = {}, $$scope: c } = e;
  const h = Kr(yr());
  let { use: f = [] } = e, { class: d = "" } = e, { topAppBar: p } = e, v, { component: m = Ni } = e, { tag: b = m === Ni ? "main" : void 0 } = e;
  function w() {
    return v.getElement();
  }
  function B(_) {
    yt[_ ? "unshift" : "push"](() => {
      v = _, t(5, v);
    });
  }
  return r.$$set = (_) => {
    e = ze(ze({}, e), Nr(_)), t(8, a = xt(e, s)), "use" in _ && t(0, f = _.use), "class" in _ && t(1, d = _.class), "topAppBar" in _ && t(9, p = _.topAppBar), "component" in _ && t(2, m = _.component), "tag" in _ && t(3, b = _.tag), "$$scope" in _ && t(14, c = _.$$scope);
  }, r.$$.update = () => {
    r.$$.dirty & /*topAppBar*/
    512 && l(t(4, n = p && p.getPropStore())), r.$$.dirty & /*propStore, $propStore*/
    2064 && t(6, i = !n || o.variant === "static" ? "" : o.variant === "short" ? "mdc-top-app-bar--short-fixed-adjust" : o.prominent && o.dense ? "mdc-top-app-bar--dense-prominent-fixed-adjust" : o.prominent ? "mdc-top-app-bar--prominent-fixed-adjust" : o.dense ? "mdc-top-app-bar--dense-fixed-adjust" : "mdc-top-app-bar--fixed-adjust");
  }, [
    f,
    d,
    m,
    b,
    n,
    v,
    i,
    h,
    a,
    p,
    w,
    o,
    u,
    B,
    c
  ];
}
class eN extends jt {
  constructor(e) {
    super(), Pt(this, e, ZU, YU, Mt, {
      use: 0,
      class: 1,
      topAppBar: 9,
      component: 2,
      tag: 3,
      getElement: 10
    });
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[1];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get topAppBar() {
    return this.$$.ctx[9];
  }
  set topAppBar(e) {
    this.$$set({ topAppBar: e }), pe();
  }
  get component() {
    return this.$$.ctx[2];
  }
  set component(e) {
    this.$$set({ component: e }), pe();
  }
  get tag() {
    return this.$$.ctx[3];
  }
  set tag(e) {
    this.$$set({ tag: e }), pe();
  }
  get getElement() {
    return this.$$.ctx[10];
  }
}
Ht(eN, { use: {}, class: {}, topAppBar: {}, component: {}, tag: {} }, ["default"], ["getElement"], !0);
function tN(r) {
  Pi(r, "svelte-a9zr3a", ".editor-buttons.svelte-a9zr3a{display:flex;gap:.5rem}");
}
function rN(r) {
  let e;
  return {
    c() {
      e = ir("Dev Menu Bar");
    },
    m(t, n) {
      ke(t, e, n);
    },
    d(t) {
      t && xe(e);
    }
  };
}
function nN(r) {
  let e, t;
  return e = new XU({
    props: {
      $$slots: { default: [rN] },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      Ve(e.$$.fragment);
    },
    m(n, i) {
      Ke(e, n, i), t = !0;
    },
    p(n, i) {
      const s = {};
      i & /*$$scope*/
      32 && (s.$$scope = { dirty: i, ctx: n }), e.$set(s);
    },
    i(n) {
      t || (fe(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ge(e.$$.fragment, n), t = !1;
    },
    d(n) {
      $e(e, n);
    }
  };
}
function nw(r) {
  let e, t, n, i, s, a, o, A, l;
  return t = new us({
    props: { icon: "upload_file", color: "white" }
  }), t.$on(
    "click",
    /*handleUpload*/
    r[2]
  ), a = new us({
    props: { icon: "download", color: "white" }
  }), a.$on("click", AN), {
    c() {
      e = We("div"), Ve(t.$$.fragment), n = tt(), i = We("input"), s = tt(), Ve(a.$$.fragment), Me(i, "type", "file"), Rk(i, "display", "none"), Me(i, "accept", ".scd"), Me(i, "name", "xmlDocument"), Me(e, "class", "editor-buttons svelte-a9zr3a");
    },
    m(u, c) {
      ke(u, e, c), Ke(t, e, null), je(e, n), je(e, i), r[4](i), je(e, s), Ke(a, e, null), o = !0, A || (l = pt(
        i,
        "change",
        /*handleFileChange*/
        r[3]
      ), A = !0);
    },
    p: sr,
    i(u) {
      o || (fe(t.$$.fragment, u), fe(a.$$.fragment, u), o = !0);
    },
    o(u) {
      ge(t.$$.fragment, u), ge(a.$$.fragment, u), o = !1;
    },
    d(u) {
      u && xe(e), $e(t), r[4](null), $e(a), A = !1, l();
    }
  };
}
function iN(r) {
  let e, t, n = (
    /*pluginType*/
    r[0] && /*pluginType*/
    r[0] === "editor" && nw(r)
  );
  return {
    c() {
      n && n.c(), e = Or();
    },
    m(i, s) {
      n && n.m(i, s), ke(i, e, s), t = !0;
    },
    p(i, s) {
      /*pluginType*/
      i[0] && /*pluginType*/
      i[0] === "editor" ? n ? (n.p(i, s), s & /*pluginType*/
      1 && fe(n, 1)) : (n = nw(i), n.c(), fe(n, 1), n.m(e.parentNode, e)) : n && (er(), ge(n, 1, 1, () => {
        n = null;
      }), tr());
    },
    i(i) {
      t || (fe(n), t = !0);
    },
    o(i) {
      ge(n), t = !1;
    },
    d(i) {
      i && xe(e), n && n.d(i);
    }
  };
}
function sN(r) {
  let e, t, n, i;
  return e = new K1({
    props: {
      $$slots: { default: [nN] },
      $$scope: { ctx: r }
    }
  }), n = new K1({
    props: {
      align: "end",
      toolbar: !0,
      $$slots: { default: [iN] },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      Ve(e.$$.fragment), t = tt(), Ve(n.$$.fragment);
    },
    m(s, a) {
      Ke(e, s, a), ke(s, t, a), Ke(n, s, a), i = !0;
    },
    p(s, a) {
      const o = {};
      a & /*$$scope*/
      32 && (o.$$scope = { dirty: a, ctx: s }), e.$set(o);
      const A = {};
      a & /*$$scope, fileInput, pluginType*/
      35 && (A.$$scope = { dirty: a, ctx: s }), n.$set(A);
    },
    i(s) {
      i || (fe(e.$$.fragment, s), fe(n.$$.fragment, s), i = !0);
    },
    o(s) {
      ge(e.$$.fragment, s), ge(n.$$.fragment, s), i = !1;
    },
    d(s) {
      s && xe(t), $e(e, s), $e(n, s);
    }
  };
}
function aN(r) {
  let e, t;
  return e = new GU({
    props: {
      $$slots: { default: [sN] },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      Ve(e.$$.fragment);
    },
    m(n, i) {
      Ke(e, n, i), t = !0;
    },
    p(n, i) {
      const s = {};
      i & /*$$scope, fileInput, pluginType*/
      35 && (s.$$scope = { dirty: i, ctx: n }), e.$set(s);
    },
    i(n) {
      t || (fe(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ge(e.$$.fragment, n), t = !1;
    },
    d(n) {
      $e(e, n);
    }
  };
}
function oN(r) {
  let e, t;
  return e = new QE({
    props: {
      variant: "static",
      color: "primary",
      $$slots: { default: [aN] },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      Ve(e.$$.fragment);
    },
    m(n, i) {
      Ke(e, n, i), t = !0;
    },
    p(n, [i]) {
      const s = {};
      i & /*$$scope, fileInput, pluginType*/
      35 && (s.$$scope = { dirty: i, ctx: n }), e.$set(s);
    },
    i(n) {
      t || (fe(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ge(e.$$.fragment, n), t = !1;
    },
    d(n) {
      $e(e, n);
    }
  };
}
function AN() {
  document.dispatchEvent(new Event("save-doc"));
}
function lN(r, e, t) {
  let { pluginType: n = void 0 } = e, i;
  function s() {
    i.click();
  }
  async function a(A) {
    var d;
    const u = (d = A.target.files) == null ? void 0 : d[0];
    if (!u) return;
    const c = await u.text(), h = u.name, f = new DOMParser().parseFromString(c, "application/xml");
    document.dispatchEvent(IU(f, h));
  }
  function o(A) {
    yt[A ? "unshift" : "push"](() => {
      i = A, t(1, i);
    });
  }
  return r.$$set = (A) => {
    "pluginType" in A && t(0, n = A.pluginType);
  }, [n, i, s, a, o];
}
class DE extends jt {
  constructor(e) {
    super(), Pt(this, e, lN, oN, Mt, { pluginType: 0 }, tN);
  }
  get pluginType() {
    return this.$$.ctx[0];
  }
  set pluginType(e) {
    this.$$set({ pluginType: e }), pe();
  }
}
Ht(DE, { pluginType: {} }, [], [], !0);
function uN(r) {
  Pi(r, "svelte-v32xo8", 'tscd-theme.svelte-v32xo8{font-family:"Roboto", sans-serif;height:var(--global-height);display:block;position:relative;background-color:var(--global-background-color)}');
}
function iw(r) {
  let e, t;
  return e = new DE({
    props: { pluginType: (
      /*pluginType*/
      r[0]
    ) }
  }), {
    c() {
      Ve(e.$$.fragment);
    },
    m(n, i) {
      Ke(e, n, i), t = !0;
    },
    p(n, i) {
      const s = {};
      i & /*pluginType*/
      1 && (s.pluginType = /*pluginType*/
      n[0]), e.$set(s);
    },
    i(n) {
      t || (fe(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ge(e.$$.fragment, n), t = !1;
    },
    d(n) {
      $e(e, n);
    }
  };
}
function cN(r) {
  let e, t, n, i, s, a, o, A, l, u = (
    /*mode*/
    r[1].isStandAlone && iw(r)
  );
  const c = (
    /*#slots*/
    r[8].default
  ), h = Nt(
    c,
    r,
    /*$$scope*/
    r[7],
    null
  );
  return {
    c() {
      e = We("link"), t = tt(), n = We("link"), i = tt(), s = We("link"), a = tt(), u && u.c(), o = tt(), A = We("tscd-theme"), h && h.c(), Me(e, "rel", "stylesheet"), Me(
        e,
        "href",
        /*fontCss*/
        r[3]
      ), Me(n, "rel", "stylesheet"), Me(
        n,
        "href",
        /*themeCss*/
        r[4]
      ), Me(s, "rel", "stylesheet"), Me(
        s,
        "href",
        /*svelteMaterialUiCss*/
        r[5]
      ), qc(
        A,
        "style",
        /*cssDynamicStyles*/
        r[2]
      ), qc(A, "class", "svelte-v32xo8");
    },
    m(f, d) {
      ke(f, e, d), ke(f, t, d), ke(f, n, d), ke(f, i, d), ke(f, s, d), ke(f, a, d), u && u.m(f, d), ke(f, o, d), ke(f, A, d), h && h.m(A, null), l = !0;
    },
    p(f, [d]) {
      /*mode*/
      f[1].isStandAlone ? u ? (u.p(f, d), d & /*mode*/
      2 && fe(u, 1)) : (u = iw(f), u.c(), fe(u, 1), u.m(o.parentNode, o)) : u && (er(), ge(u, 1, 1, () => {
        u = null;
      }), tr()), h && h.p && (!l || d & /*$$scope*/
      128) && Qt(
        h,
        c,
        f,
        /*$$scope*/
        f[7],
        l ? Ot(
          c,
          /*$$scope*/
          f[7],
          d,
          null
        ) : Dt(
          /*$$scope*/
          f[7]
        ),
        null
      ), (!l || d & /*cssDynamicStyles*/
      4) && qc(
        A,
        "style",
        /*cssDynamicStyles*/
        f[2]
      );
    },
    i(f) {
      l || (fe(u), fe(h, f), l = !0);
    },
    o(f) {
      ge(u), ge(h, f), l = !1;
    },
    d(f) {
      f && (xe(e), xe(t), xe(n), xe(i), xe(s), xe(a), xe(o), xe(A)), u && u.d(f), h && h.d(f);
    }
  };
}
function fN(r) {
  return r.isStorybook ? "inherit" : "calc(100vh - var(--header-height))";
}
function hN(r) {
  return r.isStorybook ? "0px" : r.isStandAlone ? "64px" : "112px";
}
function dN(r) {
  return r.isStorybook ? "inherit" : "var(--mdc-theme-surface)";
}
function pN(r, e, t) {
  let n, i, { $$slots: s = {}, $$scope: a } = e, { pluginType: o = void 0 } = e;
  const A = new URL(import.meta.url), l = new URL(gU, A).href, u = new URL(mU, A).href, c = new URL(vU, A).href, h = {
    "header-height": "",
    "global-height": "",
    "global-background-color": ""
  };
  return r.$$set = (f) => {
    "pluginType" in f && t(0, o = f.pluginType), "$$scope" in f && t(7, a = f.$$scope);
  }, r.$$.update = () => {
    r.$$.dirty & /*mode*/
    2 && n.isStandAlone && Promise.resolve().then(() => xj), r.$$.dirty & /*mode*/
    2 && t(6, h["header-height"] = hN(n), h), r.$$.dirty & /*mode*/
    2 && t(6, h["global-height"] = fN(n), h), r.$$.dirty & /*mode*/
    2 && t(6, h["global-background-color"] = dN(n), h), r.$$.dirty & /*cssFixedStyles*/
    64 && t(2, i = TE(h));
  }, t(1, n = {
    isStandAlone: !1,
    isStorybook: !1
  }), [
    o,
    n,
    i,
    l,
    u,
    c,
    h,
    a,
    s
  ];
}
class ME extends jt {
  constructor(e) {
    super(), Pt(this, e, pN, cN, Mt, { pluginType: 0 }, uN);
  }
  get pluginType() {
    return this.$$.ctx[0];
  }
  set pluginType(e) {
    this.$$set({ pluginType: e }), pe();
  }
}
Ht(ME, { pluginType: {} }, ["default"], [], !0);
function gN(r, e) {
  if (r instanceof RegExp) return { keys: !1, pattern: r };
  var t, n, i, s, a = [], o = "", A = r.split("/");
  for (A[0] || A.shift(); i = A.shift(); )
    t = i[0], t === "*" ? (a.push("wild"), o += "/(.*)") : t === ":" ? (n = i.indexOf("?", 1), s = i.indexOf(".", 1), a.push(i.substring(1, ~n ? n : ~s ? s : i.length)), o += ~n && !~s ? "(?:/([^/]+?))?" : "/([^/]+?)", ~s && (o += (~n ? "?" : "") + "\\" + i.substring(s))) : o += "/" + i;
  return {
    keys: a,
    pattern: new RegExp("^" + o + "/?$", "i")
  };
}
function mN(r) {
  let e, t, n;
  const i = [
    /*props*/
    r[2]
  ];
  var s = (
    /*component*/
    r[0]
  );
  function a(o, A) {
    let l = {};
    for (let u = 0; u < i.length; u += 1)
      l = ze(l, i[u]);
    return A !== void 0 && A & /*props*/
    4 && (l = ze(l, Et(i, [Vt(
      /*props*/
      o[2]
    )]))), { props: l };
  }
  return s && (e = An(s, a(r)), e.$on(
    "routeEvent",
    /*routeEvent_handler_1*/
    r[7]
  )), {
    c() {
      e && Ve(e.$$.fragment), t = Or();
    },
    m(o, A) {
      e && Ke(e, o, A), ke(o, t, A), n = !0;
    },
    p(o, A) {
      if (A & /*component*/
      1 && s !== (s = /*component*/
      o[0])) {
        if (e) {
          er();
          const l = e;
          ge(l.$$.fragment, 1, 0, () => {
            $e(l, 1);
          }), tr();
        }
        s ? (e = An(s, a(o, A)), e.$on(
          "routeEvent",
          /*routeEvent_handler_1*/
          o[7]
        ), Ve(e.$$.fragment), fe(e.$$.fragment, 1), Ke(e, t.parentNode, t)) : e = null;
      } else if (s) {
        const l = A & /*props*/
        4 ? Et(i, [Vt(
          /*props*/
          o[2]
        )]) : {};
        e.$set(l);
      }
    },
    i(o) {
      n || (e && fe(e.$$.fragment, o), n = !0);
    },
    o(o) {
      e && ge(e.$$.fragment, o), n = !1;
    },
    d(o) {
      o && xe(t), e && $e(e, o);
    }
  };
}
function vN(r) {
  let e, t, n;
  const i = [
    { params: (
      /*componentParams*/
      r[1]
    ) },
    /*props*/
    r[2]
  ];
  var s = (
    /*component*/
    r[0]
  );
  function a(o, A) {
    let l = {};
    for (let u = 0; u < i.length; u += 1)
      l = ze(l, i[u]);
    return A !== void 0 && A & /*componentParams, props*/
    6 && (l = ze(l, Et(i, [
      A & /*componentParams*/
      2 && { params: (
        /*componentParams*/
        o[1]
      ) },
      A & /*props*/
      4 && Vt(
        /*props*/
        o[2]
      )
    ]))), { props: l };
  }
  return s && (e = An(s, a(r)), e.$on(
    "routeEvent",
    /*routeEvent_handler*/
    r[6]
  )), {
    c() {
      e && Ve(e.$$.fragment), t = Or();
    },
    m(o, A) {
      e && Ke(e, o, A), ke(o, t, A), n = !0;
    },
    p(o, A) {
      if (A & /*component*/
      1 && s !== (s = /*component*/
      o[0])) {
        if (e) {
          er();
          const l = e;
          ge(l.$$.fragment, 1, 0, () => {
            $e(l, 1);
          }), tr();
        }
        s ? (e = An(s, a(o, A)), e.$on(
          "routeEvent",
          /*routeEvent_handler*/
          o[6]
        ), Ve(e.$$.fragment), fe(e.$$.fragment, 1), Ke(e, t.parentNode, t)) : e = null;
      } else if (s) {
        const l = A & /*componentParams, props*/
        6 ? Et(i, [
          A & /*componentParams*/
          2 && { params: (
            /*componentParams*/
            o[1]
          ) },
          A & /*props*/
          4 && Vt(
            /*props*/
            o[2]
          )
        ]) : {};
        e.$set(l);
      }
    },
    i(o) {
      n || (e && fe(e.$$.fragment, o), n = !0);
    },
    o(o) {
      e && ge(e.$$.fragment, o), n = !1;
    },
    d(o) {
      o && xe(t), e && $e(e, o);
    }
  };
}
function bN(r) {
  let e, t, n, i;
  const s = [vN, mN], a = [];
  function o(A, l) {
    return (
      /*componentParams*/
      A[1] ? 0 : 1
    );
  }
  return e = o(r), t = a[e] = s[e](r), {
    c() {
      t.c(), n = Or();
    },
    m(A, l) {
      a[e].m(A, l), ke(A, n, l), i = !0;
    },
    p(A, [l]) {
      let u = e;
      e = o(A), e === u ? a[e].p(A, l) : (er(), ge(a[u], 1, 1, () => {
        a[u] = null;
      }), tr(), t = a[e], t ? t.p(A, l) : (t = a[e] = s[e](A), t.c()), fe(t, 1), t.m(n.parentNode, n));
    },
    i(A) {
      i || (fe(t), i = !0);
    },
    o(A) {
      ge(t), i = !1;
    },
    d(A) {
      A && xe(n), a[e].d(A);
    }
  };
}
function sw() {
  const r = window.location.href.indexOf("#/");
  let e = r > -1 ? window.location.href.substr(r + 1) : "/";
  const t = e.indexOf("?");
  let n = "";
  return t > -1 && (n = e.substr(t + 1), e = e.substr(0, t)), { location: e, querystring: n };
}
const K2 = P2(
  null,
  // eslint-disable-next-line prefer-arrow-callback
  function(e) {
    e(sw());
    const t = () => {
      e(sw());
    };
    return window.addEventListener("hashchange", t, !1), function() {
      window.removeEventListener("hashchange", t, !1);
    };
  }
);
IE(K2, (r) => r.location);
IE(K2, (r) => r.querystring);
const aw = ia(void 0);
async function $1(r) {
  if (!r || r.length < 1 || r.charAt(0) != "/" && r.indexOf("#/") !== 0)
    throw Error("Invalid parameter location");
  await M2(), history.replaceState(
    {
      ...history.state,
      __svelte_spa_router_scrollX: window.scrollX,
      __svelte_spa_router_scrollY: window.scrollY
    },
    void 0
  ), window.location.hash = (r.charAt(0) == "#" ? "" : "#") + r;
}
function yN(r) {
  r ? window.scrollTo(r.__svelte_spa_router_scrollX, r.__svelte_spa_router_scrollY) : window.scrollTo(0, 0);
}
function wN(r, e, t) {
  let { routes: n = {} } = e, { prefix: i = "" } = e, { restoreScrollState: s = !1 } = e;
  class a {
    /**
    * Initializes the object and creates a regular expression from the path, using regexparam.
    *
    * @param {string} path - Path to the route (must start with '/' or '*')
    * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped
    */
    constructor(_, x) {
      if (!x || typeof x != "function" && (typeof x != "object" || x._sveltesparouter !== !0))
        throw Error("Invalid component object");
      if (!_ || typeof _ == "string" && (_.length < 1 || _.charAt(0) != "/" && _.charAt(0) != "*") || typeof _ == "object" && !(_ instanceof RegExp))
        throw Error('Invalid value for "path" argument - strings must start with / or *');
      const { pattern: C, keys: F } = gN(_);
      this.path = _, typeof x == "object" && x._sveltesparouter === !0 ? (this.component = x.component, this.conditions = x.conditions || [], this.userData = x.userData, this.props = x.props || {}) : (this.component = () => Promise.resolve(x), this.conditions = [], this.props = {}), this._pattern = C, this._keys = F;
    }
    /**
    * Checks if `path` matches the current route.
    * If there's a match, will return the list of parameters from the URL (if any).
    * In case of no match, the method will return `null`.
    *
    * @param {string} path - Path to test
    * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
    */
    match(_) {
      if (i) {
        if (typeof i == "string")
          if (_.startsWith(i))
            _ = _.substr(i.length) || "/";
          else
            return null;
        else if (i instanceof RegExp) {
          const N = _.match(i);
          if (N && N[0])
            _ = _.substr(N[0].length) || "/";
          else
            return null;
        }
      }
      const x = this._pattern.exec(_);
      if (x === null)
        return null;
      if (this._keys === !1)
        return x;
      const C = {};
      let F = 0;
      for (; F < this._keys.length; ) {
        try {
          C[this._keys[F]] = decodeURIComponent(x[F + 1] || "") || null;
        } catch {
          C[this._keys[F]] = null;
        }
        F++;
      }
      return C;
    }
    /**
    * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events
    * @typedef {Object} RouteDetail
    * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)
    * @property {string} location - Location path
    * @property {string} querystring - Querystring from the hash
    * @property {object} [userData] - Custom data passed by the user
    * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)
    * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)
    */
    /**
    * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
    * 
    * @param {RouteDetail} detail - Route detail
    * @returns {boolean} Returns true if all the conditions succeeded
    */
    async checkConditions(_) {
      for (let x = 0; x < this.conditions.length; x++)
        if (!await this.conditions[x](_))
          return !1;
      return !0;
    }
  }
  const o = [];
  n instanceof Map ? n.forEach((B, _) => {
    o.push(new a(_, B));
  }) : Object.keys(n).forEach((B) => {
    o.push(new a(B, n[B]));
  });
  let A = null, l = null, u = {};
  const c = eg();
  async function h(B, _) {
    await M2(), c(B, _);
  }
  let f = null, d = null;
  s && (d = (B) => {
    B.state && (B.state.__svelte_spa_router_scrollY || B.state.__svelte_spa_router_scrollX) ? f = B.state : f = null;
  }, window.addEventListener("popstate", d), jk(() => {
    yN(f);
  }));
  let p = null, v = null;
  const m = K2.subscribe(async (B) => {
    p = B;
    let _ = 0;
    for (; _ < o.length; ) {
      const x = o[_].match(B.location);
      if (!x) {
        _++;
        continue;
      }
      const C = {
        route: o[_].path,
        location: B.location,
        querystring: B.querystring,
        userData: o[_].userData,
        params: x && typeof x == "object" && Object.keys(x).length ? x : null
      };
      if (!await o[_].checkConditions(C)) {
        t(0, A = null), v = null, h("conditionsFailed", C);
        return;
      }
      h("routeLoading", Object.assign({}, C));
      const F = o[_].component;
      if (v != F) {
        F.loading ? (t(0, A = F.loading), v = F, t(1, l = F.loadingParams), t(2, u = {}), h("routeLoaded", Object.assign({}, C, {
          component: A,
          name: A.name,
          params: l
        }))) : (t(0, A = null), v = null);
        const N = await F();
        if (B != p)
          return;
        t(0, A = N && N.default || N), v = F;
      }
      x && typeof x == "object" && Object.keys(x).length ? t(1, l = x) : t(1, l = null), t(2, u = o[_].props), h("routeLoaded", Object.assign({}, C, {
        component: A,
        name: A.name,
        params: l
      })).then(() => {
        aw.set(l);
      });
      return;
    }
    t(0, A = null), v = null, aw.set(void 0);
  });
  fo(() => {
    m(), d && window.removeEventListener("popstate", d);
  });
  function b(B) {
    Sa.call(this, r, B);
  }
  function w(B) {
    Sa.call(this, r, B);
  }
  return r.$$set = (B) => {
    "routes" in B && t(3, n = B.routes), "prefix" in B && t(4, i = B.prefix), "restoreScrollState" in B && t(5, s = B.restoreScrollState);
  }, r.$$.update = () => {
    r.$$.dirty & /*restoreScrollState*/
    32 && (history.scrollRestoration = s ? "manual" : "auto");
  }, [
    A,
    l,
    u,
    n,
    i,
    s,
    b,
    w
  ];
}
class RE extends jt {
  constructor(e) {
    super(), Pt(this, e, wN, bN, Mt, {
      routes: 3,
      prefix: 4,
      restoreScrollState: 5
    });
  }
  get routes() {
    return this.$$.ctx[3];
  }
  set routes(e) {
    this.$$set({ routes: e }), pe();
  }
  get prefix() {
    return this.$$.ctx[4];
  }
  set prefix(e) {
    this.$$set({ prefix: e }), pe();
  }
  get restoreScrollState() {
    return this.$$.ctx[5];
  }
  set restoreScrollState(e) {
    this.$$set({ restoreScrollState: e }), pe();
  }
}
Ht(RE, { routes: {}, prefix: {}, restoreScrollState: { type: "Boolean" } }, [], [], !0);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var yc = {
  ANIM_CHECKED_INDETERMINATE: "mdc-checkbox--anim-checked-indeterminate",
  ANIM_CHECKED_UNCHECKED: "mdc-checkbox--anim-checked-unchecked",
  ANIM_INDETERMINATE_CHECKED: "mdc-checkbox--anim-indeterminate-checked",
  ANIM_INDETERMINATE_UNCHECKED: "mdc-checkbox--anim-indeterminate-unchecked",
  ANIM_UNCHECKED_CHECKED: "mdc-checkbox--anim-unchecked-checked",
  ANIM_UNCHECKED_INDETERMINATE: "mdc-checkbox--anim-unchecked-indeterminate",
  BACKGROUND: "mdc-checkbox__background",
  CHECKED: "mdc-checkbox--checked",
  CHECKMARK: "mdc-checkbox__checkmark",
  CHECKMARK_PATH: "mdc-checkbox__checkmark-path",
  DISABLED: "mdc-checkbox--disabled",
  INDETERMINATE: "mdc-checkbox--indeterminate",
  MIXEDMARK: "mdc-checkbox__mixedmark",
  NATIVE_CONTROL: "mdc-checkbox__native-control",
  ROOT: "mdc-checkbox",
  SELECTED: "mdc-checkbox--selected",
  UPGRADED: "mdc-checkbox--upgraded"
}, Cs = {
  ARIA_CHECKED_ATTR: "aria-checked",
  ARIA_CHECKED_INDETERMINATE_VALUE: "mixed",
  DATA_INDETERMINATE_ATTR: "data-indeterminate",
  NATIVE_CONTROL_SELECTOR: ".mdc-checkbox__native-control",
  TRANSITION_STATE_CHECKED: "checked",
  TRANSITION_STATE_INDETERMINATE: "indeterminate",
  TRANSITION_STATE_INIT: "init",
  TRANSITION_STATE_UNCHECKED: "unchecked"
}, ow = {
  ANIM_END_LATCH_MS: 250
};
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var BN = (
  /** @class */
  function(r) {
    Zi(e, r);
    function e(t) {
      var n = r.call(this, Jr(Jr({}, e.defaultAdapter), t)) || this;
      return n.currentCheckState = Cs.TRANSITION_STATE_INIT, n.currentAnimationClass = "", n.animEndLatchTimer = 0, n.enableAnimationEndHandler = !1, n;
    }
    return Object.defineProperty(e, "cssClasses", {
      get: function() {
        return yc;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "strings", {
      get: function() {
        return Cs;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "numbers", {
      get: function() {
        return ow;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
          },
          forceLayout: function() {
          },
          hasNativeControl: function() {
            return !1;
          },
          isAttachedToDOM: function() {
            return !1;
          },
          isChecked: function() {
            return !1;
          },
          isIndeterminate: function() {
            return !1;
          },
          removeClass: function() {
          },
          removeNativeControlAttr: function() {
          },
          setNativeControlAttr: function() {
          },
          setNativeControlDisabled: function() {
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.init = function() {
      this.currentCheckState = this.determineCheckState(), this.updateAriaChecked(), this.adapter.addClass(yc.UPGRADED);
    }, e.prototype.destroy = function() {
      clearTimeout(this.animEndLatchTimer);
    }, e.prototype.setDisabled = function(t) {
      this.adapter.setNativeControlDisabled(t), t ? this.adapter.addClass(yc.DISABLED) : this.adapter.removeClass(yc.DISABLED);
    }, e.prototype.handleAnimationEnd = function() {
      var t = this;
      this.enableAnimationEndHandler && (clearTimeout(this.animEndLatchTimer), this.animEndLatchTimer = setTimeout(function() {
        t.adapter.removeClass(t.currentAnimationClass), t.enableAnimationEndHandler = !1;
      }, ow.ANIM_END_LATCH_MS));
    }, e.prototype.handleChange = function() {
      this.transitionCheckState();
    }, e.prototype.transitionCheckState = function() {
      if (this.adapter.hasNativeControl()) {
        var t = this.currentCheckState, n = this.determineCheckState();
        if (t !== n) {
          this.updateAriaChecked();
          var i = Cs.TRANSITION_STATE_UNCHECKED, s = yc.SELECTED;
          n === i ? this.adapter.removeClass(s) : this.adapter.addClass(s), this.currentAnimationClass.length > 0 && (clearTimeout(this.animEndLatchTimer), this.adapter.forceLayout(), this.adapter.removeClass(this.currentAnimationClass)), this.currentAnimationClass = this.getTransitionAnimationClass(t, n), this.currentCheckState = n, this.adapter.isAttachedToDOM() && this.currentAnimationClass.length > 0 && (this.adapter.addClass(this.currentAnimationClass), this.enableAnimationEndHandler = !0);
        }
      }
    }, e.prototype.determineCheckState = function() {
      var t = Cs.TRANSITION_STATE_INDETERMINATE, n = Cs.TRANSITION_STATE_CHECKED, i = Cs.TRANSITION_STATE_UNCHECKED;
      return this.adapter.isIndeterminate() ? t : this.adapter.isChecked() ? n : i;
    }, e.prototype.getTransitionAnimationClass = function(t, n) {
      var i = Cs.TRANSITION_STATE_INIT, s = Cs.TRANSITION_STATE_CHECKED, a = Cs.TRANSITION_STATE_UNCHECKED, o = e.cssClasses, A = o.ANIM_UNCHECKED_CHECKED, l = o.ANIM_UNCHECKED_INDETERMINATE, u = o.ANIM_CHECKED_UNCHECKED, c = o.ANIM_CHECKED_INDETERMINATE, h = o.ANIM_INDETERMINATE_CHECKED, f = o.ANIM_INDETERMINATE_UNCHECKED;
      switch (t) {
        case i:
          return n === a ? "" : n === s ? h : f;
        case a:
          return n === s ? A : l;
        case s:
          return n === a ? u : c;
        default:
          return n === s ? h : f;
      }
    }, e.prototype.updateAriaChecked = function() {
      this.adapter.isIndeterminate() ? this.adapter.setNativeControlAttr(Cs.ARIA_CHECKED_ATTR, Cs.ARIA_CHECKED_INDETERMINATE_VALUE) : this.adapter.removeNativeControlAttr(Cs.ARIA_CHECKED_ATTR);
    }, e;
  }(La)
);
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var kn = {
  CELL: "mdc-data-table__cell",
  CELL_NUMERIC: "mdc-data-table__cell--numeric",
  CONTENT: "mdc-data-table__content",
  HEADER_CELL: "mdc-data-table__header-cell",
  HEADER_CELL_LABEL: "mdc-data-table__header-cell-label",
  HEADER_CELL_SORTED: "mdc-data-table__header-cell--sorted",
  HEADER_CELL_SORTED_DESCENDING: "mdc-data-table__header-cell--sorted-descending",
  HEADER_CELL_WITH_SORT: "mdc-data-table__header-cell--with-sort",
  HEADER_CELL_WRAPPER: "mdc-data-table__header-cell-wrapper",
  HEADER_ROW: "mdc-data-table__header-row",
  HEADER_ROW_CHECKBOX: "mdc-data-table__header-row-checkbox",
  IN_PROGRESS: "mdc-data-table--in-progress",
  LINEAR_PROGRESS: "mdc-data-table__linear-progress",
  PAGINATION_ROWS_PER_PAGE_LABEL: "mdc-data-table__pagination-rows-per-page-label",
  PAGINATION_ROWS_PER_PAGE_SELECT: "mdc-data-table__pagination-rows-per-page-select",
  PROGRESS_INDICATOR: "mdc-data-table__progress-indicator",
  ROOT: "mdc-data-table",
  ROW: "mdc-data-table__row",
  ROW_CHECKBOX: "mdc-data-table__row-checkbox",
  ROW_SELECTED: "mdc-data-table__row--selected",
  SORT_ICON_BUTTON: "mdc-data-table__sort-icon-button",
  SORT_STATUS_LABEL: "mdc-data-table__sort-status-label",
  TABLE_CONTAINER: "mdc-data-table__table-container"
}, Aw = {
  ARIA_SELECTED: "aria-selected",
  ARIA_SORT: "aria-sort"
}, CN = {
  COLUMN_ID: "data-column-id",
  ROW_ID: "data-row-id"
}, qh = {
  CONTENT: "." + kn.CONTENT,
  HEADER_CELL: "." + kn.HEADER_CELL,
  HEADER_CELL_WITH_SORT: "." + kn.HEADER_CELL_WITH_SORT,
  HEADER_ROW: "." + kn.HEADER_ROW,
  HEADER_ROW_CHECKBOX: "." + kn.HEADER_ROW_CHECKBOX,
  PROGRESS_INDICATOR: "." + kn.PROGRESS_INDICATOR,
  ROW: "." + kn.ROW,
  ROW_CHECKBOX: "." + kn.ROW_CHECKBOX,
  ROW_SELECTED: "." + kn.ROW_SELECTED,
  SORT_ICON_BUTTON: "." + kn.SORT_ICON_BUTTON,
  SORT_STATUS_LABEL: "." + kn.SORT_STATUS_LABEL
}, SA = {
  ARIA_SELECTED: Aw.ARIA_SELECTED,
  ARIA_SORT: Aw.ARIA_SORT,
  DATA_ROW_ID_ATTR: CN.ROW_ID,
  HEADER_ROW_CHECKBOX_SELECTOR: qh.HEADER_ROW_CHECKBOX,
  ROW_CHECKBOX_SELECTOR: qh.ROW_CHECKBOX,
  ROW_SELECTED_SELECTOR: qh.ROW_SELECTED,
  ROW_SELECTOR: qh.ROW
}, As;
(function(r) {
  r.ASCENDING = "ascending", r.DESCENDING = "descending", r.NONE = "none", r.OTHER = "other";
})(As || (As = {}));
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var _N = (
  /** @class */
  function(r) {
    Zi(e, r);
    function e(t) {
      return r.call(this, Jr(Jr({}, e.defaultAdapter), t)) || this;
    }
    return Object.defineProperty(e, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
          },
          addClassAtRowIndex: function() {
          },
          getAttributeByHeaderCellIndex: function() {
            return "";
          },
          getHeaderCellCount: function() {
            return 0;
          },
          getHeaderCellElements: function() {
            return [];
          },
          getRowCount: function() {
            return 0;
          },
          getRowElements: function() {
            return [];
          },
          getRowIdAtIndex: function() {
            return "";
          },
          getRowIndexByChildElement: function() {
            return 0;
          },
          getSelectedRowCount: function() {
            return 0;
          },
          getTableContainerHeight: function() {
            return 0;
          },
          getTableHeaderHeight: function() {
            return 0;
          },
          isCheckboxAtRowIndexChecked: function() {
            return !1;
          },
          isHeaderRowCheckboxChecked: function() {
            return !1;
          },
          isRowsSelectable: function() {
            return !1;
          },
          notifyRowSelectionChanged: function() {
          },
          notifySelectedAll: function() {
          },
          notifySortAction: function() {
          },
          notifyUnselectedAll: function() {
          },
          notifyRowClick: function() {
          },
          registerHeaderRowCheckbox: function() {
          },
          registerRowCheckboxes: function() {
          },
          removeClass: function() {
          },
          removeClassAtRowIndex: function() {
          },
          removeClassNameByHeaderCellIndex: function() {
          },
          setAttributeAtRowIndex: function() {
          },
          setAttributeByHeaderCellIndex: function() {
          },
          setClassNameByHeaderCellIndex: function() {
          },
          setHeaderRowCheckboxChecked: function() {
          },
          setHeaderRowCheckboxIndeterminate: function() {
          },
          setProgressIndicatorStyles: function() {
          },
          setRowCheckboxCheckedAtIndex: function() {
          },
          setSortStatusLabelByHeaderCellIndex: function() {
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.layout = function() {
      this.adapter.isRowsSelectable() && (this.adapter.registerHeaderRowCheckbox(), this.adapter.registerRowCheckboxes(), this.setHeaderRowCheckboxState());
    }, e.prototype.layoutAsync = function() {
      return Jk(this, void 0, void 0, function() {
        return Yk(this, function(t) {
          switch (t.label) {
            case 0:
              return this.adapter.isRowsSelectable() ? [4, this.adapter.registerHeaderRowCheckbox()] : [3, 3];
            case 1:
              return t.sent(), [4, this.adapter.registerRowCheckboxes()];
            case 2:
              t.sent(), this.setHeaderRowCheckboxState(), t.label = 3;
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.getRows = function() {
      return this.adapter.getRowElements();
    }, e.prototype.getHeaderCells = function() {
      return this.adapter.getHeaderCellElements();
    }, e.prototype.setSelectedRowIds = function(t) {
      for (var n = 0; n < this.adapter.getRowCount(); n++) {
        var i = this.adapter.getRowIdAtIndex(n), s = !1;
        i && t.indexOf(i) >= 0 && (s = !0), this.adapter.setRowCheckboxCheckedAtIndex(n, s), this.selectRowAtIndex(n, s);
      }
      this.setHeaderRowCheckboxState();
    }, e.prototype.getRowIds = function() {
      for (var t = [], n = 0; n < this.adapter.getRowCount(); n++)
        t.push(this.adapter.getRowIdAtIndex(n));
      return t;
    }, e.prototype.getSelectedRowIds = function() {
      for (var t = [], n = 0; n < this.adapter.getRowCount(); n++)
        this.adapter.isCheckboxAtRowIndexChecked(n) && t.push(this.adapter.getRowIdAtIndex(n));
      return t;
    }, e.prototype.handleHeaderRowCheckboxChange = function() {
      for (var t = this.adapter.isHeaderRowCheckboxChecked(), n = 0; n < this.adapter.getRowCount(); n++)
        this.adapter.setRowCheckboxCheckedAtIndex(n, t), this.selectRowAtIndex(n, t);
      t ? this.adapter.notifySelectedAll() : this.adapter.notifyUnselectedAll();
    }, e.prototype.handleRowCheckboxChange = function(t) {
      var n = this.adapter.getRowIndexByChildElement(t.target);
      if (n !== -1) {
        var i = this.adapter.isCheckboxAtRowIndexChecked(n);
        this.selectRowAtIndex(n, i), this.setHeaderRowCheckboxState();
        var s = this.adapter.getRowIdAtIndex(n);
        this.adapter.notifyRowSelectionChanged({ rowId: s, rowIndex: n, selected: i });
      }
    }, e.prototype.handleSortAction = function(t) {
      for (var n = t.columnId, i = t.columnIndex, s = t.headerCell, a = 0; a < this.adapter.getHeaderCellCount(); a++)
        a !== i && (this.adapter.removeClassNameByHeaderCellIndex(a, kn.HEADER_CELL_SORTED), this.adapter.removeClassNameByHeaderCellIndex(a, kn.HEADER_CELL_SORTED_DESCENDING), this.adapter.setAttributeByHeaderCellIndex(a, SA.ARIA_SORT, As.NONE), this.adapter.setSortStatusLabelByHeaderCellIndex(a, As.NONE));
      this.adapter.setClassNameByHeaderCellIndex(i, kn.HEADER_CELL_SORTED);
      var o = this.adapter.getAttributeByHeaderCellIndex(i, SA.ARIA_SORT), A = As.NONE;
      o === As.ASCENDING ? (this.adapter.setClassNameByHeaderCellIndex(i, kn.HEADER_CELL_SORTED_DESCENDING), this.adapter.setAttributeByHeaderCellIndex(i, SA.ARIA_SORT, As.DESCENDING), A = As.DESCENDING) : o === As.DESCENDING ? (this.adapter.removeClassNameByHeaderCellIndex(i, kn.HEADER_CELL_SORTED_DESCENDING), this.adapter.setAttributeByHeaderCellIndex(i, SA.ARIA_SORT, As.ASCENDING), A = As.ASCENDING) : (this.adapter.setAttributeByHeaderCellIndex(i, SA.ARIA_SORT, As.ASCENDING), A = As.ASCENDING), this.adapter.setSortStatusLabelByHeaderCellIndex(i, A), this.adapter.notifySortAction({
        columnId: n,
        columnIndex: i,
        headerCell: s,
        sortValue: A
      });
    }, e.prototype.handleRowClick = function(t) {
      var n = t.rowId, i = t.row;
      this.adapter.notifyRowClick({
        rowId: n,
        row: i
      });
    }, e.prototype.showProgress = function() {
      var t = this.adapter.getTableHeaderHeight(), n = this.adapter.getTableContainerHeight() - t, i = t;
      this.adapter.setProgressIndicatorStyles({
        height: n + "px",
        top: i + "px"
      }), this.adapter.addClass(kn.IN_PROGRESS);
    }, e.prototype.hideProgress = function() {
      this.adapter.removeClass(kn.IN_PROGRESS);
    }, e.prototype.setHeaderRowCheckboxState = function() {
      this.adapter.getSelectedRowCount() === 0 ? (this.adapter.setHeaderRowCheckboxChecked(!1), this.adapter.setHeaderRowCheckboxIndeterminate(!1)) : this.adapter.getSelectedRowCount() === this.adapter.getRowCount() ? (this.adapter.setHeaderRowCheckboxChecked(!0), this.adapter.setHeaderRowCheckboxIndeterminate(!1)) : (this.adapter.setHeaderRowCheckboxIndeterminate(!0), this.adapter.setHeaderRowCheckboxChecked(!1));
    }, e.prototype.selectRowAtIndex = function(t, n) {
      n ? (this.adapter.addClassAtRowIndex(t, kn.ROW_SELECTED), this.adapter.setAttributeAtRowIndex(t, SA.ARIA_SELECTED, "true")) : (this.adapter.removeClassAtRowIndex(t, kn.ROW_SELECTED), this.adapter.setAttributeAtRowIndex(t, SA.ARIA_SELECTED, "false"));
    }, e;
  }(La)
);
const EN = (r) => ({}), lw = (r) => ({}), SN = (r) => ({}), uw = (r) => ({});
function cw(r) {
  let e, t, n, i, s;
  const a = (
    /*#slots*/
    r[36].progress
  ), o = Nt(
    a,
    r,
    /*$$scope*/
    r[35],
    uw
  );
  return {
    c() {
      e = We("div"), t = We("div"), n = tt(), o && o.c(), Me(t, "class", "mdc-data-table__scrim"), Me(e, "class", "mdc-data-table__progress-indicator"), Me(e, "style", i = Object.entries(
        /*progressIndicatorStyles*/
        r[13]
      ).map(fw).join(" "));
    },
    m(A, l) {
      ke(A, e, l), je(e, t), je(e, n), o && o.m(e, null), s = !0;
    },
    p(A, l) {
      o && o.p && (!s || l[1] & /*$$scope*/
      16) && Qt(
        o,
        a,
        A,
        /*$$scope*/
        A[35],
        s ? Ot(
          a,
          /*$$scope*/
          A[35],
          l,
          SN
        ) : Dt(
          /*$$scope*/
          A[35]
        ),
        uw
      ), (!s || l[0] & /*progressIndicatorStyles*/
      8192 && i !== (i = Object.entries(
        /*progressIndicatorStyles*/
        A[13]
      ).map(fw).join(" "))) && Me(e, "style", i);
    },
    i(A) {
      s || (fe(o, A), s = !0);
    },
    o(A) {
      ge(o, A), s = !1;
    },
    d(A) {
      A && xe(e), o && o.d(A);
    }
  };
}
function IN(r) {
  let e, t, n, i, s, a, o, A, l, u, c, h, f, d;
  const p = (
    /*#slots*/
    r[36].default
  ), v = Nt(
    p,
    r,
    /*$$scope*/
    r[35],
    null
  );
  let m = [
    {
      class: i = ht({
        [
          /*table$class*/
          r[6]
        ]: !0,
        "mdc-data-table__table": !0
      })
    },
    on(
      /*$$restProps*/
      r[25],
      "table$"
    )
  ], b = {};
  for (let D = 0; D < m.length; D += 1)
    b = ze(b, m[D]);
  let w = [
    {
      class: a = ht({
        [
          /*container$class*/
          r[4]
        ]: !0,
        "mdc-data-table__table-container": !0
      })
    },
    on(
      /*$$restProps*/
      r[25],
      "container$"
    )
  ], B = {};
  for (let D = 0; D < w.length; D += 1)
    B = ze(B, w[D]);
  let _ = (
    /*$$slots*/
    r[24].progress && cw(r)
  );
  const x = (
    /*#slots*/
    r[36].paginate
  ), C = Nt(
    x,
    r,
    /*$$scope*/
    r[35],
    lw
  );
  let F = [
    {
      class: u = ht({
        [
          /*className*/
          r[1]
        ]: !0,
        "mdc-data-table": !0,
        "mdc-data-table--sticky-header": (
          /*stickyHeader*/
          r[2]
        ),
        .../*internalClasses*/
        r[12]
      })
    },
    Ia(
      /*$$restProps*/
      r[25],
      ["container$", "table$"]
    )
  ], N = {};
  for (let D = 0; D < F.length; D += 1)
    N = ze(N, F[D]);
  return {
    c() {
      e = We("div"), t = We("div"), n = We("table"), v && v.c(), A = tt(), _ && _.c(), l = tt(), C && C.c(), Ut(n, b), Ut(t, B), Ut(e, N);
    },
    m(D, T) {
      ke(D, e, T), je(e, t), je(t, n), v && v.m(n, null), r[37](t), je(e, A), _ && _.m(e, null), je(e, l), C && C.m(e, null), r[38](e), h = !0, f || (d = [
        Bt(s = xr.call(
          null,
          n,
          /*table$use*/
          r[5]
        )),
        Bt(o = xr.call(
          null,
          t,
          /*container$use*/
          r[3]
        )),
        Bt(c = xr.call(
          null,
          e,
          /*use*/
          r[0]
        )),
        Bt(
          /*forwardEvents*/
          r[15].call(null, e)
        ),
        pt(
          e,
          "SMUICheckbox:mount",
          /*SMUICheckbox_mount_handler*/
          r[39]
        ),
        pt(
          e,
          "SMUIDataTableHeader:mount",
          /*handleHeaderMount*/
          r[19]
        ),
        pt(
          e,
          "SMUIDataTableHeader:unmount",
          /*SMUIDataTableHeader_unmount_handler*/
          r[40]
        ),
        pt(
          e,
          "SMUIDataTableBody:mount",
          /*handleBodyMount*/
          r[20]
        ),
        pt(
          e,
          "SMUIDataTableBody:unmount",
          /*SMUIDataTableBody_unmount_handler*/
          r[41]
        ),
        pt(
          e,
          "SMUIDataTableHeaderCheckbox:change",
          /*SMUIDataTableHeaderCheckbox_change_handler*/
          r[42]
        ),
        pt(
          e,
          "SMUIDataTableHeader:click",
          /*handleHeaderRowClick*/
          r[22]
        ),
        pt(
          e,
          "SMUIDataTableRow:click",
          /*handleRowClick*/
          r[23]
        ),
        pt(
          e,
          "SMUIDataTableBodyCheckbox:change",
          /*handleBodyCheckboxChange*/
          r[21]
        )
      ], f = !0);
    },
    p(D, T) {
      v && v.p && (!h || T[1] & /*$$scope*/
      16) && Qt(
        v,
        p,
        D,
        /*$$scope*/
        D[35],
        h ? Ot(
          p,
          /*$$scope*/
          D[35],
          T,
          null
        ) : Dt(
          /*$$scope*/
          D[35]
        ),
        null
      ), Ut(n, b = Et(m, [
        (!h || T[0] & /*table$class*/
        64 && i !== (i = ht({
          [
            /*table$class*/
            D[6]
          ]: !0,
          "mdc-data-table__table": !0
        }))) && { class: i },
        T[0] & /*$$restProps*/
        33554432 && on(
          /*$$restProps*/
          D[25],
          "table$"
        )
      ])), s && ar(s.update) && T[0] & /*table$use*/
      32 && s.update.call(
        null,
        /*table$use*/
        D[5]
      ), Ut(t, B = Et(w, [
        (!h || T[0] & /*container$class*/
        16 && a !== (a = ht({
          [
            /*container$class*/
            D[4]
          ]: !0,
          "mdc-data-table__table-container": !0
        }))) && { class: a },
        T[0] & /*$$restProps*/
        33554432 && on(
          /*$$restProps*/
          D[25],
          "container$"
        )
      ])), o && ar(o.update) && T[0] & /*container$use*/
      8 && o.update.call(
        null,
        /*container$use*/
        D[3]
      ), /*$$slots*/
      D[24].progress ? _ ? (_.p(D, T), T[0] & /*$$slots*/
      16777216 && fe(_, 1)) : (_ = cw(D), _.c(), fe(_, 1), _.m(e, l)) : _ && (er(), ge(_, 1, 1, () => {
        _ = null;
      }), tr()), C && C.p && (!h || T[1] & /*$$scope*/
      16) && Qt(
        C,
        x,
        D,
        /*$$scope*/
        D[35],
        h ? Ot(
          x,
          /*$$scope*/
          D[35],
          T,
          EN
        ) : Dt(
          /*$$scope*/
          D[35]
        ),
        lw
      ), Ut(e, N = Et(F, [
        (!h || T[0] & /*className, stickyHeader, internalClasses*/
        4102 && u !== (u = ht({
          [
            /*className*/
            D[1]
          ]: !0,
          "mdc-data-table": !0,
          "mdc-data-table--sticky-header": (
            /*stickyHeader*/
            D[2]
          ),
          .../*internalClasses*/
          D[12]
        }))) && { class: u },
        T[0] & /*$$restProps*/
        33554432 && Ia(
          /*$$restProps*/
          D[25],
          ["container$", "table$"]
        )
      ])), c && ar(c.update) && T[0] & /*use*/
      1 && c.update.call(
        null,
        /*use*/
        D[0]
      );
    },
    i(D) {
      h || (fe(v, D), fe(_), fe(C, D), h = !0);
    },
    o(D) {
      ge(v, D), ge(_), ge(C, D), h = !1;
    },
    d(D) {
      D && xe(e), v && v.d(D), r[37](null), _ && _.d(), C && C.d(D), r[38](null), f = !1, fr(d);
    }
  };
}
const fw = ([r, e]) => `${r}: ${e};`;
function FN(r, e, t) {
  const n = [
    "use",
    "class",
    "stickyHeader",
    "sortable",
    "sort",
    "sortDirection",
    "sortAscendingAriaLabel",
    "sortDescendingAriaLabel",
    "container$use",
    "container$class",
    "table$use",
    "table$class",
    "layout",
    "getElement"
  ];
  let i = xt(e, n), s, a, o, { $$slots: A = {}, $$scope: l } = e;
  const u = D2(A), { closest: c } = EE, h = Kr(yr());
  let { use: f = [] } = e, { class: d = "" } = e, { stickyHeader: p = !1 } = e, { sortable: v = !1 } = e, { sort: m = null } = e, { sortDirection: b = "ascending" } = e, { sortAscendingAriaLabel: w = "sorted, ascending" } = e, { sortDescendingAriaLabel: B = "sorted, descending" } = e, { container$use: _ = [] } = e, { container$class: x = "" } = e, { table$use: C = [] } = e, { table$class: F = "" } = e, N, D, T, E, L, S = {}, X = { height: "auto", top: "initial" }, z = pn("SMUI:addLayoutListener"), R, V = !1, O = ia(!1);
  GA(r, O, (re) => t(34, s = re));
  let J = ia(m);
  GA(r, J, (re) => t(45, o = re));
  let Z = ia(b);
  GA(r, Z, (re) => t(44, a = re)), Pr("SMUI:checkbox:context", "data-table"), Pr("SMUI:linear-progress:context", "data-table"), Pr("SMUI:linear-progress:closed", O), Pr("SMUI:data-table:sortable", v), Pr("SMUI:data-table:sort", J), Pr("SMUI:data-table:sortDirection", Z), Pr("SMUI:data-table:sortAscendingAriaLabel", w), Pr("SMUI:data-table:sortDescendingAriaLabel", B), z && (R = z(Ce));
  let U;
  ui(() => (t(7, D = new _N({
    addClass: ie,
    removeClass: ue,
    getHeaderCellElements: () => {
      var re;
      return (re = E == null ? void 0 : E.cells.map((ce) => ce.element)) !== null && re !== void 0 ? re : [];
    },
    getHeaderCellCount: () => {
      var re;
      return (re = E == null ? void 0 : E.cells.length) !== null && re !== void 0 ? re : 0;
    },
    getAttributeByHeaderCellIndex: (re, ce) => {
      var le;
      return (le = E == null ? void 0 : E.orderedCells[re].getAttr(ce)) !== null && le !== void 0 ? le : null;
    },
    setAttributeByHeaderCellIndex: (re, ce, le) => {
      E == null || E.orderedCells[re].addAttr(ce, le);
    },
    setClassNameByHeaderCellIndex: (re, ce) => {
      E == null || E.orderedCells[re].addClass(ce);
    },
    removeClassNameByHeaderCellIndex: (re, ce) => {
      E == null || E.orderedCells[re].removeClass(ce);
    },
    notifySortAction: (re) => {
      t(26, m = re.columnId), t(27, b = re.sortValue), pr(Qe(), "SMUIDataTable:sorted", re, void 0, !0);
    },
    getTableContainerHeight: () => T.getBoundingClientRect().height,
    getTableHeaderHeight: () => {
      const re = Qe().querySelector(".mdc-data-table__header-row");
      if (!re)
        throw new Error("MDCDataTable: Table header element not found.");
      return re.getBoundingClientRect().height;
    },
    setProgressIndicatorStyles: (re) => {
      t(13, X = re);
    },
    addClassAtRowIndex: (re, ce) => {
      L == null || L.orderedRows[re].addClass(ce);
    },
    getRowCount: () => {
      var re;
      return (re = L == null ? void 0 : L.rows.length) !== null && re !== void 0 ? re : 0;
    },
    getRowElements: () => {
      var re;
      return (re = L == null ? void 0 : L.rows.map((ce) => ce.element)) !== null && re !== void 0 ? re : [];
    },
    getRowIdAtIndex: (re) => {
      var ce;
      return (ce = L == null ? void 0 : L.orderedRows[re].rowId) !== null && ce !== void 0 ? ce : null;
    },
    getRowIndexByChildElement: (re) => {
      var ce;
      return (ce = L == null ? void 0 : L.orderedRows.map((le) => le.element).indexOf(c(re, ".mdc-data-table__row"))) !== null && ce !== void 0 ? ce : -1;
    },
    getSelectedRowCount: () => {
      var re;
      return (re = L == null ? void 0 : L.rows.filter((ce) => ce.selected).length) !== null && re !== void 0 ? re : 0;
    },
    isCheckboxAtRowIndexChecked: (re) => {
      const ce = L == null ? void 0 : L.orderedRows[re].checkbox;
      return ce ? ce.checked : !1;
    },
    isHeaderRowCheckboxChecked: () => {
      const re = E == null ? void 0 : E.checkbox;
      return re ? re.checked : !1;
    },
    isRowsSelectable: () => !!Qe().querySelector(".mdc-data-table__row-checkbox") || !!Qe().querySelector(".mdc-data-table__header-row-checkbox"),
    notifyRowSelectionChanged: (re) => {
      const ce = L == null ? void 0 : L.orderedRows[re.rowIndex];
      ce && pr(
        Qe(),
        "SMUIDataTable:rowSelectionChanged",
        {
          row: ce.element,
          rowId: ce.rowId,
          rowIndex: re.rowIndex,
          selected: re.selected
        },
        void 0,
        !0
      );
    },
    notifySelectedAll: () => {
      he(!1), pr(Qe(), "SMUIDataTable:selectedAll", void 0, void 0, !0);
    },
    notifyUnselectedAll: () => {
      he(!1), pr(Qe(), "SMUIDataTable:unselectedAll", void 0, void 0, !0);
    },
    notifyRowClick: (re) => {
      pr(Qe(), "SMUIDataTable:rowClick", re, void 0, !0);
    },
    registerHeaderRowCheckbox: () => {
    },
    // Handled automatically.
    registerRowCheckboxes: () => {
    },
    // Handled automatically.
    removeClassAtRowIndex: (re, ce) => {
      L == null || L.orderedRows[re].removeClass(ce);
    },
    setAttributeAtRowIndex: (re, ce, le) => {
      L == null || L.orderedRows[re].addAttr(ce, le);
    },
    setHeaderRowCheckboxChecked: (re) => {
      const ce = E == null ? void 0 : E.checkbox;
      ce && (ce.checked = re);
    },
    setHeaderRowCheckboxIndeterminate: he,
    setRowCheckboxCheckedAtIndex: (re, ce) => {
      const le = L == null ? void 0 : L.orderedRows[re].checkbox;
      le && (le.checked = ce);
    },
    setSortStatusLabelByHeaderCellIndex: (re, ce) => {
    }
    // Handled automatically.
  })), D.init(), D.layout(), t(14, V = !0), () => {
    D.destroy();
  })), fo(() => {
    R && R();
  });
  function P(re) {
    t(10, E = re.detail);
  }
  function H(re) {
    t(11, L = re.detail);
  }
  function $(re) {
    D && D.handleRowCheckboxChange(re);
  }
  function ie(re) {
    S[re] || t(12, S[re] = !0, S);
  }
  function ue(re) {
    (!(re in S) || S[re]) && t(12, S[re] = !1, S);
  }
  function he(re) {
    const ce = E == null ? void 0 : E.checkbox;
    ce && (ce.indeterminate = re);
  }
  function ve(re) {
    if (!D || !re.detail.target)
      return;
    const ce = c(re.detail.target, ".mdc-data-table__header-cell--with-sort");
    ce && de(ce);
  }
  function Le(re) {
    if (!D || !re.detail.target)
      return;
    const ce = c(re.detail.target, ".mdc-data-table__row");
    ce && D && D.handleRowClick({ rowId: re.detail.rowId, row: ce });
  }
  function de(re) {
    var ce, le;
    const Te = (ce = E == null ? void 0 : E.orderedCells) !== null && ce !== void 0 ? ce : [], Oe = Te.map((Ge) => Ge.element).indexOf(re);
    if (Oe === -1)
      return;
    const Ue = (le = Te[Oe].columnId) !== null && le !== void 0 ? le : null;
    D.handleSortAction({ columnId: Ue, columnIndex: Oe, headerCell: re });
  }
  function Ce() {
    return D.layout();
  }
  function Qe() {
    return N;
  }
  function M(re) {
    yt[re ? "unshift" : "push"](() => {
      T = re, t(9, T);
    });
  }
  function Ae(re) {
    yt[re ? "unshift" : "push"](() => {
      N = re, t(8, N);
    });
  }
  const G = () => D && V && D.layout(), ne = () => t(10, E = void 0), ee = () => t(11, L = void 0), ae = () => D && D.handleHeaderRowCheckboxChange();
  return r.$$set = (re) => {
    e = ze(ze({}, e), Nr(re)), t(25, i = xt(e, n)), "use" in re && t(0, f = re.use), "class" in re && t(1, d = re.class), "stickyHeader" in re && t(2, p = re.stickyHeader), "sortable" in re && t(28, v = re.sortable), "sort" in re && t(26, m = re.sort), "sortDirection" in re && t(27, b = re.sortDirection), "sortAscendingAriaLabel" in re && t(29, w = re.sortAscendingAriaLabel), "sortDescendingAriaLabel" in re && t(30, B = re.sortDescendingAriaLabel), "container$use" in re && t(3, _ = re.container$use), "container$class" in re && t(4, x = re.container$class), "table$use" in re && t(5, C = re.table$use), "table$class" in re && t(6, F = re.table$class), "$$scope" in re && t(35, l = re.$$scope);
  }, r.$$.update = () => {
    r.$$.dirty[0] & /*sort*/
    67108864 && D1(J, o = m, o), r.$$.dirty[0] & /*sortDirection*/
    134217728 && D1(Z, a = b, a), r.$$.dirty[0] & /*instance*/
    128 | r.$$.dirty[1] & /*previousProgressClosed, $progressClosed*/
    12 && u.progress && D && U !== s && (t(33, U = s), s ? D.hideProgress() : D.showProgress());
  }, [
    f,
    d,
    p,
    _,
    x,
    C,
    F,
    D,
    N,
    T,
    E,
    L,
    S,
    X,
    V,
    h,
    O,
    J,
    Z,
    P,
    H,
    $,
    ve,
    Le,
    u,
    i,
    m,
    b,
    v,
    w,
    B,
    Ce,
    Qe,
    U,
    s,
    l,
    A,
    M,
    Ae,
    G,
    ne,
    ee,
    ae
  ];
}
class PE extends jt {
  constructor(e) {
    super(), Pt(
      this,
      e,
      FN,
      IN,
      Mt,
      {
        use: 0,
        class: 1,
        stickyHeader: 2,
        sortable: 28,
        sort: 26,
        sortDirection: 27,
        sortAscendingAriaLabel: 29,
        sortDescendingAriaLabel: 30,
        container$use: 3,
        container$class: 4,
        table$use: 5,
        table$class: 6,
        layout: 31,
        getElement: 32
      },
      null,
      [-1, -1]
    );
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[1];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get stickyHeader() {
    return this.$$.ctx[2];
  }
  set stickyHeader(e) {
    this.$$set({ stickyHeader: e }), pe();
  }
  get sortable() {
    return this.$$.ctx[28];
  }
  set sortable(e) {
    this.$$set({ sortable: e }), pe();
  }
  get sort() {
    return this.$$.ctx[26];
  }
  set sort(e) {
    this.$$set({ sort: e }), pe();
  }
  get sortDirection() {
    return this.$$.ctx[27];
  }
  set sortDirection(e) {
    this.$$set({ sortDirection: e }), pe();
  }
  get sortAscendingAriaLabel() {
    return this.$$.ctx[29];
  }
  set sortAscendingAriaLabel(e) {
    this.$$set({ sortAscendingAriaLabel: e }), pe();
  }
  get sortDescendingAriaLabel() {
    return this.$$.ctx[30];
  }
  set sortDescendingAriaLabel(e) {
    this.$$set({ sortDescendingAriaLabel: e }), pe();
  }
  get container$use() {
    return this.$$.ctx[3];
  }
  set container$use(e) {
    this.$$set({ container$use: e }), pe();
  }
  get container$class() {
    return this.$$.ctx[4];
  }
  set container$class(e) {
    this.$$set({ container$class: e }), pe();
  }
  get table$use() {
    return this.$$.ctx[5];
  }
  set table$use(e) {
    this.$$set({ table$use: e }), pe();
  }
  get table$class() {
    return this.$$.ctx[6];
  }
  set table$class(e) {
    this.$$set({ table$class: e }), pe();
  }
  get layout() {
    return this.$$.ctx[31];
  }
  get getElement() {
    return this.$$.ctx[32];
  }
}
Ht(PE, { use: {}, class: {}, stickyHeader: { type: "Boolean" }, sortable: { type: "Boolean" }, sort: {}, sortDirection: {}, sortAscendingAriaLabel: {}, sortDescendingAriaLabel: {}, container$use: {}, container$class: {}, table$use: {}, table$class: {} }, ["default", "progress", "paginate"], ["layout", "getElement"], !0);
function TN(r) {
  let e, t, n, i, s;
  const a = (
    /*#slots*/
    r[10].default
  ), o = Nt(
    a,
    r,
    /*$$scope*/
    r[9],
    null
  );
  let A = [
    /*$$restProps*/
    r[7]
  ], l = {};
  for (let u = 0; u < A.length; u += 1)
    l = ze(l, A[u]);
  return {
    c() {
      e = We("thead"), o && o.c(), Ut(e, l);
    },
    m(u, c) {
      ke(u, e, c), o && o.m(e, null), r[11](e), n = !0, i || (s = [
        Bt(t = xr.call(
          null,
          e,
          /*use*/
          r[0]
        )),
        Bt(
          /*forwardEvents*/
          r[3].call(null, e)
        ),
        pt(
          e,
          "SMUICheckbox:mount",
          /*handleCheckboxMount*/
          r[4]
        ),
        pt(
          e,
          "SMUICheckbox:unmount",
          /*SMUICheckbox_unmount_handler*/
          r[12]
        ),
        pt(
          e,
          "SMUIDataTableCell:mount",
          /*handleCellMount*/
          r[5]
        ),
        pt(
          e,
          "SMUIDataTableCell:unmount",
          /*handleCellUnmount*/
          r[6]
        )
      ], i = !0);
    },
    p(u, [c]) {
      o && o.p && (!n || c & /*$$scope*/
      512) && Qt(
        o,
        a,
        u,
        /*$$scope*/
        u[9],
        n ? Ot(
          a,
          /*$$scope*/
          u[9],
          c,
          null
        ) : Dt(
          /*$$scope*/
          u[9]
        ),
        null
      ), Ut(e, l = Et(A, [c & /*$$restProps*/
      128 && /*$$restProps*/
      u[7]])), t && ar(t.update) && c & /*use*/
      1 && t.update.call(
        null,
        /*use*/
        u[0]
      );
    },
    i(u) {
      n || (fe(o, u), n = !0);
    },
    o(u) {
      ge(o, u), n = !1;
    },
    d(u) {
      u && xe(e), o && o.d(u), r[11](null), i = !1, fr(s);
    }
  };
}
function xN(r, e, t) {
  const n = ["use", "getElement"];
  let i = xt(e, n), { $$slots: s = {}, $$scope: a } = e;
  const o = Kr(yr());
  let { use: A = [] } = e, l, u, c = [];
  const h = /* @__PURE__ */ new WeakMap();
  Pr("SMUI:data-table:row:header", !0), ui(() => {
    const B = {
      get cells() {
        return c;
      },
      get orderedCells() {
        return v();
      },
      get checkbox() {
        return u;
      }
    };
    return pr(m(), "SMUIDataTableHeader:mount", B), () => {
      pr(m(), "SMUIDataTableHeader:unmount", B);
    };
  });
  function f(B) {
    t(2, u = B.detail);
  }
  function d(B) {
    c.push(B.detail), h.set(B.detail.element, B.detail), B.stopPropagation();
  }
  function p(B) {
    const _ = c.indexOf(B.detail);
    _ !== -1 && (c.splice(_, 1), c = c), h.delete(B.detail.element), B.stopPropagation();
  }
  function v() {
    return [...m().querySelectorAll(".mdc-data-table__header-cell")].map((B) => h.get(B)).filter((B) => B && B._smui_data_table_header_cell_accessor);
  }
  function m() {
    return l;
  }
  function b(B) {
    yt[B ? "unshift" : "push"](() => {
      l = B, t(1, l);
    });
  }
  const w = () => t(2, u = void 0);
  return r.$$set = (B) => {
    e = ze(ze({}, e), Nr(B)), t(7, i = xt(e, n)), "use" in B && t(0, A = B.use), "$$scope" in B && t(9, a = B.$$scope);
  }, [
    A,
    l,
    u,
    o,
    f,
    d,
    p,
    i,
    m,
    a,
    s,
    b,
    w
  ];
}
class HE extends jt {
  constructor(e) {
    super(), Pt(this, e, xN, TN, Mt, { use: 0, getElement: 8 });
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get getElement() {
    return this.$$.ctx[8];
  }
}
Ht(HE, { use: {} }, ["default"], ["getElement"], !0);
function kN(r) {
  let e, t, n, i, s, a;
  const o = (
    /*#slots*/
    r[9].default
  ), A = Nt(
    o,
    r,
    /*$$scope*/
    r[8],
    null
  );
  let l = [
    {
      class: t = ht({
        [
          /*className*/
          r[1]
        ]: !0,
        "mdc-data-table__content": !0
      })
    },
    /*$$restProps*/
    r[6]
  ], u = {};
  for (let c = 0; c < l.length; c += 1)
    u = ze(u, l[c]);
  return {
    c() {
      e = We("tbody"), A && A.c(), Ut(e, u);
    },
    m(c, h) {
      ke(c, e, h), A && A.m(e, null), r[10](e), i = !0, s || (a = [
        Bt(n = xr.call(
          null,
          e,
          /*use*/
          r[0]
        )),
        Bt(
          /*forwardEvents*/
          r[3].call(null, e)
        ),
        pt(
          e,
          "SMUIDataTableRow:mount",
          /*handleRowMount*/
          r[4]
        ),
        pt(
          e,
          "SMUIDataTableRow:unmount",
          /*handleRowUnmount*/
          r[5]
        )
      ], s = !0);
    },
    p(c, [h]) {
      A && A.p && (!i || h & /*$$scope*/
      256) && Qt(
        A,
        o,
        c,
        /*$$scope*/
        c[8],
        i ? Ot(
          o,
          /*$$scope*/
          c[8],
          h,
          null
        ) : Dt(
          /*$$scope*/
          c[8]
        ),
        null
      ), Ut(e, u = Et(l, [
        (!i || h & /*className*/
        2 && t !== (t = ht({
          [
            /*className*/
            c[1]
          ]: !0,
          "mdc-data-table__content": !0
        }))) && { class: t },
        h & /*$$restProps*/
        64 && /*$$restProps*/
        c[6]
      ])), n && ar(n.update) && h & /*use*/
      1 && n.update.call(
        null,
        /*use*/
        c[0]
      );
    },
    i(c) {
      i || (fe(A, c), i = !0);
    },
    o(c) {
      ge(A, c), i = !1;
    },
    d(c) {
      c && xe(e), A && A.d(c), r[10](null), s = !1, fr(a);
    }
  };
}
function LN(r, e, t) {
  const n = ["use", "class", "getElement"];
  let i = xt(e, n), { $$slots: s = {}, $$scope: a } = e;
  const o = Kr(yr());
  let { use: A = [] } = e, { class: l = "" } = e, u, c = [];
  const h = /* @__PURE__ */ new WeakMap();
  Pr("SMUI:data-table:row:header", !1), ui(() => {
    const b = {
      get rows() {
        return c;
      },
      get orderedRows() {
        return p();
      }
    };
    return pr(v(), "SMUIDataTableBody:mount", b), () => {
      pr(v(), "SMUIDataTableBody:unmount", b);
    };
  });
  function f(b) {
    c.push(b.detail), h.set(b.detail.element, b.detail), b.stopPropagation();
  }
  function d(b) {
    const w = c.indexOf(b.detail);
    w !== -1 && (c.splice(w, 1), c = c), h.delete(b.detail.element), b.stopPropagation();
  }
  function p() {
    return [...v().querySelectorAll(".mdc-data-table__row")].map((b) => h.get(b)).filter((b) => b && b._smui_data_table_row_accessor);
  }
  function v() {
    return u;
  }
  function m(b) {
    yt[b ? "unshift" : "push"](() => {
      u = b, t(2, u);
    });
  }
  return r.$$set = (b) => {
    e = ze(ze({}, e), Nr(b)), t(6, i = xt(e, n)), "use" in b && t(0, A = b.use), "class" in b && t(1, l = b.class), "$$scope" in b && t(8, a = b.$$scope);
  }, [
    A,
    l,
    u,
    o,
    f,
    d,
    i,
    v,
    a,
    s,
    m
  ];
}
class jE extends jt {
  constructor(e) {
    super(), Pt(this, e, LN, kN, Mt, { use: 0, class: 1, getElement: 7 });
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[1];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get getElement() {
    return this.$$.ctx[7];
  }
}
Ht(jE, { use: {}, class: {} }, ["default"], ["getElement"], !0);
function UN(r) {
  let e, t, n, i, s, a, o;
  const A = (
    /*#slots*/
    r[15].default
  ), l = Nt(
    A,
    r,
    /*$$scope*/
    r[14],
    null
  );
  let u = [
    {
      class: t = ht({
        [
          /*className*/
          r[1]
        ]: !0,
        "mdc-data-table__header-row": (
          /*header*/
          r[7]
        ),
        "mdc-data-table__row": !/*header*/
        r[7],
        "mdc-data-table__row--selected": !/*header*/
        r[7] && /*checkbox*/
        r[3] && /*checkbox*/
        r[3].checked,
        .../*internalClasses*/
        r[4]
      })
    },
    {
      "aria-selected": n = /*checkbox*/
      r[3] ? (
        /*checkbox*/
        r[3].checked ? "true" : "false"
      ) : void 0
    },
    /*internalAttrs*/
    r[5],
    /*$$restProps*/
    r[11]
  ], c = {};
  for (let h = 0; h < u.length; h += 1)
    c = ze(c, u[h]);
  return {
    c() {
      e = We("tr"), l && l.c(), Ut(e, c);
    },
    m(h, f) {
      ke(h, e, f), l && l.m(e, null), r[16](e), s = !0, a || (o = [
        Bt(i = xr.call(
          null,
          e,
          /*use*/
          r[0]
        )),
        Bt(
          /*forwardEvents*/
          r[6].call(null, e)
        ),
        pt(
          e,
          "click",
          /*click_handler*/
          r[17]
        ),
        pt(
          e,
          "SMUICheckbox:mount",
          /*handleCheckboxMount*/
          r[8]
        ),
        pt(
          e,
          "SMUICheckbox:unmount",
          /*SMUICheckbox_unmount_handler*/
          r[18]
        )
      ], a = !0);
    },
    p(h, [f]) {
      l && l.p && (!s || f & /*$$scope*/
      16384) && Qt(
        l,
        A,
        h,
        /*$$scope*/
        h[14],
        s ? Ot(
          A,
          /*$$scope*/
          h[14],
          f,
          null
        ) : Dt(
          /*$$scope*/
          h[14]
        ),
        null
      ), Ut(e, c = Et(u, [
        (!s || f & /*className, checkbox, internalClasses*/
        26 && t !== (t = ht({
          [
            /*className*/
            h[1]
          ]: !0,
          "mdc-data-table__header-row": (
            /*header*/
            h[7]
          ),
          "mdc-data-table__row": !/*header*/
          h[7],
          "mdc-data-table__row--selected": !/*header*/
          h[7] && /*checkbox*/
          h[3] && /*checkbox*/
          h[3].checked,
          .../*internalClasses*/
          h[4]
        }))) && { class: t },
        (!s || f & /*checkbox*/
        8 && n !== (n = /*checkbox*/
        h[3] ? (
          /*checkbox*/
          h[3].checked ? "true" : "false"
        ) : void 0)) && { "aria-selected": n },
        f & /*internalAttrs*/
        32 && /*internalAttrs*/
        h[5],
        f & /*$$restProps*/
        2048 && /*$$restProps*/
        h[11]
      ])), i && ar(i.update) && f & /*use*/
      1 && i.update.call(
        null,
        /*use*/
        h[0]
      );
    },
    i(h) {
      s || (fe(l, h), s = !0);
    },
    o(h) {
      ge(l, h), s = !1;
    },
    d(h) {
      h && xe(e), l && l.d(h), r[16](null), a = !1, fr(o);
    }
  };
}
let NN = 0;
function ON(r, e, t) {
  const n = ["use", "class", "rowId", "getElement"];
  let i = xt(e, n), { $$slots: s = {}, $$scope: a } = e;
  const o = Kr(yr());
  let { use: A = [] } = e, { class: l = "" } = e, { rowId: u = "SMUI-data-table-row-" + NN++ } = e, c, h, f = {}, d = {}, p = pn("SMUI:data-table:row:header");
  ui(() => {
    const T = p ? {
      _smui_data_table_row_accessor: !1,
      get element() {
        return C();
      },
      get checkbox() {
        return h;
      },
      get rowId() {
      },
      get selected() {
        var E;
        return (E = h && h.checked) !== null && E !== void 0 ? E : !1;
      },
      addClass: m,
      removeClass: b,
      getAttr: w,
      addAttr: B
    } : {
      _smui_data_table_row_accessor: !0,
      get element() {
        return C();
      },
      get checkbox() {
        return h;
      },
      get rowId() {
        return u;
      },
      get selected() {
        var E;
        return (E = h && h.checked) !== null && E !== void 0 ? E : !1;
      },
      addClass: m,
      removeClass: b,
      getAttr: w,
      addAttr: B
    };
    return pr(C(), "SMUIDataTableRow:mount", T), () => {
      pr(C(), "SMUIDataTableRow:unmount", T);
    };
  });
  function v(T) {
    t(3, h = T.detail);
  }
  function m(T) {
    f[T] || t(4, f[T] = !0, f);
  }
  function b(T) {
    (!(T in f) || f[T]) && t(4, f[T] = !1, f);
  }
  function w(T) {
    var E;
    return T in d ? (E = d[T]) !== null && E !== void 0 ? E : null : C().getAttribute(T);
  }
  function B(T, E) {
    d[T] !== E && t(5, d[T] = E, d);
  }
  function _(T) {
    pr(C(), "SMUIDataTableHeader:click", T);
  }
  function x(T) {
    pr(C(), "SMUIDataTableRow:click", { rowId: u, target: T.target });
  }
  function C() {
    return c;
  }
  function F(T) {
    yt[T ? "unshift" : "push"](() => {
      c = T, t(2, c);
    });
  }
  const N = (T) => p ? _(T) : x(T), D = () => t(3, h = void 0);
  return r.$$set = (T) => {
    e = ze(ze({}, e), Nr(T)), t(11, i = xt(e, n)), "use" in T && t(0, A = T.use), "class" in T && t(1, l = T.class), "rowId" in T && t(12, u = T.rowId), "$$scope" in T && t(14, a = T.$$scope);
  }, [
    A,
    l,
    c,
    h,
    f,
    d,
    o,
    p,
    v,
    _,
    x,
    i,
    u,
    C,
    a,
    s,
    F,
    N,
    D
  ];
}
class $2 extends jt {
  constructor(e) {
    super(), Pt(this, e, ON, UN, Mt, {
      use: 0,
      class: 1,
      rowId: 12,
      getElement: 13
    });
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[1];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get rowId() {
    return this.$$.ctx[12];
  }
  set rowId(e) {
    this.$$set({ rowId: e }), pe();
  }
  get getElement() {
    return this.$$.ctx[13];
  }
}
Ht($2, { use: {}, class: {}, rowId: {} }, ["default"], ["getElement"], !0);
function QN(r) {
  let e, t, n, i, s, a;
  const o = (
    /*#slots*/
    r[22].default
  ), A = Nt(
    o,
    r,
    /*$$scope*/
    r[21],
    null
  );
  let l = [
    {
      class: t = ht({
        [
          /*className*/
          r[1]
        ]: !0,
        "mdc-data-table__cell": !0,
        "mdc-data-table__cell--numeric": (
          /*numeric*/
          r[2]
        ),
        "mdc-data-table__cell--checkbox": (
          /*checkbox*/
          r[3]
        ),
        .../*internalClasses*/
        r[7]
      })
    },
    /*internalAttrs*/
    r[8],
    /*$$restProps*/
    r[19]
  ], u = {};
  for (let c = 0; c < l.length; c += 1)
    u = ze(u, l[c]);
  return {
    c() {
      e = We("td"), A && A.c(), Ut(e, u);
    },
    m(c, h) {
      ke(c, e, h), A && A.m(e, null), r[25](e), i = !0, s || (a = [
        Bt(n = xr.call(
          null,
          e,
          /*use*/
          r[0]
        )),
        Bt(
          /*forwardEvents*/
          r[11].call(null, e)
        ),
        pt(
          e,
          "change",
          /*change_handler_1*/
          r[26]
        )
      ], s = !0);
    },
    p(c, h) {
      A && A.p && (!i || h & /*$$scope*/
      2097152) && Qt(
        A,
        o,
        c,
        /*$$scope*/
        c[21],
        i ? Ot(
          o,
          /*$$scope*/
          c[21],
          h,
          null
        ) : Dt(
          /*$$scope*/
          c[21]
        ),
        null
      ), Ut(e, u = Et(l, [
        (!i || h & /*className, numeric, checkbox, internalClasses*/
        142 && t !== (t = ht({
          [
            /*className*/
            c[1]
          ]: !0,
          "mdc-data-table__cell": !0,
          "mdc-data-table__cell--numeric": (
            /*numeric*/
            c[2]
          ),
          "mdc-data-table__cell--checkbox": (
            /*checkbox*/
            c[3]
          ),
          .../*internalClasses*/
          c[7]
        }))) && { class: t },
        h & /*internalAttrs*/
        256 && /*internalAttrs*/
        c[8],
        h & /*$$restProps*/
        524288 && /*$$restProps*/
        c[19]
      ])), n && ar(n.update) && h & /*use*/
      1 && n.update.call(
        null,
        /*use*/
        c[0]
      );
    },
    i(c) {
      i || (fe(A, c), i = !0);
    },
    o(c) {
      ge(A, c), i = !1;
    },
    d(c) {
      c && xe(e), A && A.d(c), r[25](null), s = !1, fr(a);
    }
  };
}
function DN(r) {
  let e, t, n, i, s, a, o, A, l;
  const u = [RN, MN], c = [];
  function h(p, v) {
    return (
      /*sortable*/
      p[5] ? 0 : 1
    );
  }
  t = h(r), n = c[t] = u[t](r);
  let f = [
    {
      class: i = ht({
        [
          /*className*/
          r[1]
        ]: !0,
        "mdc-data-table__header-cell": !0,
        "mdc-data-table__header-cell--numeric": (
          /*numeric*/
          r[2]
        ),
        "mdc-data-table__header-cell--checkbox": (
          /*checkbox*/
          r[3]
        ),
        "mdc-data-table__header-cell--with-sort": (
          /*sortable*/
          r[5]
        ),
        "mdc-data-table__header-cell--sorted": (
          /*sortable*/
          r[5] && /*$sort*/
          r[9] === /*columnId*/
          r[4]
        ),
        .../*internalClasses*/
        r[7]
      })
    },
    { role: "columnheader" },
    { scope: "col" },
    { "data-column-id": (
      /*columnId*/
      r[4]
    ) },
    {
      "aria-sort": s = /*sortable*/
      r[5] ? (
        /*$sort*/
        r[9] === /*columnId*/
        r[4] ? (
          /*$sortDirection*/
          r[10]
        ) : "none"
      ) : void 0
    },
    /*internalAttrs*/
    r[8],
    /*$$restProps*/
    r[19]
  ], d = {};
  for (let p = 0; p < f.length; p += 1)
    d = ze(d, f[p]);
  return {
    c() {
      e = We("th"), n.c(), Ut(e, d);
    },
    m(p, v) {
      ke(p, e, v), c[t].m(e, null), r[23](e), o = !0, A || (l = [
        Bt(a = xr.call(
          null,
          e,
          /*use*/
          r[0]
        )),
        Bt(
          /*forwardEvents*/
          r[11].call(null, e)
        ),
        pt(
          e,
          "change",
          /*change_handler*/
          r[24]
        )
      ], A = !0);
    },
    p(p, v) {
      let m = t;
      t = h(p), t === m ? c[t].p(p, v) : (er(), ge(c[m], 1, 1, () => {
        c[m] = null;
      }), tr(), n = c[t], n ? n.p(p, v) : (n = c[t] = u[t](p), n.c()), fe(n, 1), n.m(e, null)), Ut(e, d = Et(f, [
        (!o || v & /*className, numeric, checkbox, sortable, $sort, columnId, internalClasses*/
        702 && i !== (i = ht({
          [
            /*className*/
            p[1]
          ]: !0,
          "mdc-data-table__header-cell": !0,
          "mdc-data-table__header-cell--numeric": (
            /*numeric*/
            p[2]
          ),
          "mdc-data-table__header-cell--checkbox": (
            /*checkbox*/
            p[3]
          ),
          "mdc-data-table__header-cell--with-sort": (
            /*sortable*/
            p[5]
          ),
          "mdc-data-table__header-cell--sorted": (
            /*sortable*/
            p[5] && /*$sort*/
            p[9] === /*columnId*/
            p[4]
          ),
          .../*internalClasses*/
          p[7]
        }))) && { class: i },
        { role: "columnheader" },
        { scope: "col" },
        (!o || v & /*columnId*/
        16) && { "data-column-id": (
          /*columnId*/
          p[4]
        ) },
        (!o || v & /*sortable, $sort, columnId, $sortDirection*/
        1584 && s !== (s = /*sortable*/
        p[5] ? (
          /*$sort*/
          p[9] === /*columnId*/
          p[4] ? (
            /*$sortDirection*/
            p[10]
          ) : "none"
        ) : void 0)) && { "aria-sort": s },
        v & /*internalAttrs*/
        256 && /*internalAttrs*/
        p[8],
        v & /*$$restProps*/
        524288 && /*$$restProps*/
        p[19]
      ])), a && ar(a.update) && v & /*use*/
      1 && a.update.call(
        null,
        /*use*/
        p[0]
      );
    },
    i(p) {
      o || (fe(n), o = !0);
    },
    o(p) {
      ge(n), o = !1;
    },
    d(p) {
      p && xe(e), c[t].d(), r[23](null), A = !1, fr(l);
    }
  };
}
function MN(r) {
  let e;
  const t = (
    /*#slots*/
    r[22].default
  ), n = Nt(
    t,
    r,
    /*$$scope*/
    r[21],
    null
  );
  return {
    c() {
      n && n.c();
    },
    m(i, s) {
      n && n.m(i, s), e = !0;
    },
    p(i, s) {
      n && n.p && (!e || s & /*$$scope*/
      2097152) && Qt(
        n,
        t,
        i,
        /*$$scope*/
        i[21],
        e ? Ot(
          t,
          /*$$scope*/
          i[21],
          s,
          null
        ) : Dt(
          /*$$scope*/
          i[21]
        ),
        null
      );
    },
    i(i) {
      e || (fe(n, i), e = !0);
    },
    o(i) {
      ge(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function RN(r) {
  let e, t, n, i = (
    /*$sort*/
    (r[9] === /*columnId*/
    r[4] ? (
      /*$sortDirection*/
      r[10] === "ascending" ? (
        /*sortAscendingAriaLabel*/
        r[15]
      ) : (
        /*sortDescendingAriaLabel*/
        r[16]
      )
    ) : "") + ""
  ), s, a, o;
  const A = (
    /*#slots*/
    r[22].default
  ), l = Nt(
    A,
    r,
    /*$$scope*/
    r[21],
    null
  );
  return {
    c() {
      e = We("div"), l && l.c(), t = tt(), n = We("div"), s = ir(i), Me(n, "class", "mdc-data-table__sort-status-label"), Me(n, "aria-hidden", "true"), Me(n, "id", a = /*columnId*/
      r[4] + "-status-label"), Me(e, "class", "mdc-data-table__header-cell-wrapper");
    },
    m(u, c) {
      ke(u, e, c), l && l.m(e, null), je(e, t), je(e, n), je(n, s), o = !0;
    },
    p(u, c) {
      l && l.p && (!o || c & /*$$scope*/
      2097152) && Qt(
        l,
        A,
        u,
        /*$$scope*/
        u[21],
        o ? Ot(
          A,
          /*$$scope*/
          u[21],
          c,
          null
        ) : Dt(
          /*$$scope*/
          u[21]
        ),
        null
      ), (!o || c & /*$sort, columnId, $sortDirection*/
      1552) && i !== (i = /*$sort*/
      (u[9] === /*columnId*/
      u[4] ? (
        /*$sortDirection*/
        u[10] === "ascending" ? (
          /*sortAscendingAriaLabel*/
          u[15]
        ) : (
          /*sortDescendingAriaLabel*/
          u[16]
        )
      ) : "") + "") && Ds(s, i), (!o || c & /*columnId*/
      16 && a !== (a = /*columnId*/
      u[4] + "-status-label")) && Me(n, "id", a);
    },
    i(u) {
      o || (fe(l, u), o = !0);
    },
    o(u) {
      ge(l, u), o = !1;
    },
    d(u) {
      u && xe(e), l && l.d(u);
    }
  };
}
function PN(r) {
  let e, t, n, i;
  const s = [DN, QN], a = [];
  function o(A, l) {
    return (
      /*header*/
      A[12] ? 0 : 1
    );
  }
  return e = o(r), t = a[e] = s[e](r), {
    c() {
      t.c(), n = Or();
    },
    m(A, l) {
      a[e].m(A, l), ke(A, n, l), i = !0;
    },
    p(A, [l]) {
      t.p(A, l);
    },
    i(A) {
      i || (fe(t), i = !0);
    },
    o(A) {
      ge(t), i = !1;
    },
    d(A) {
      A && xe(n), a[e].d(A);
    }
  };
}
let HN = 0;
function jN(r, e, t) {
  const n = ["use", "class", "numeric", "checkbox", "columnId", "sortable", "getElement"];
  let i = xt(e, n), s, a, { $$slots: o = {}, $$scope: A } = e;
  const l = Kr(yr());
  let u = pn("SMUI:data-table:row:header"), { use: c = [] } = e, { class: h = "" } = e, { numeric: f = !1 } = e, { checkbox: d = !1 } = e, { columnId: p = u ? "SMUI-data-table-column-" + HN++ : "SMUI-data-table-unused" } = e, { sortable: v = pn("SMUI:data-table:sortable") } = e, m, b = {}, w = {}, B = pn("SMUI:data-table:sort");
  GA(r, B, (O) => t(9, s = O));
  let _ = pn("SMUI:data-table:sortDirection");
  GA(r, _, (O) => t(10, a = O));
  let x = pn("SMUI:data-table:sortAscendingAriaLabel"), C = pn("SMUI:data-table:sortDescendingAriaLabel");
  v && (Pr("SMUI:label:context", "data-table:sortable-header-cell"), Pr("SMUI:icon-button:context", "data-table:sortable-header-cell"), Pr("SMUI:icon-button:aria-describedby", p + "-status-label")), ui(() => {
    const O = u ? {
      _smui_data_table_header_cell_accessor: !0,
      get element() {
        return S();
      },
      get columnId() {
        return p;
      },
      addClass: F,
      removeClass: N,
      getAttr: D,
      addAttr: T
    } : {
      _smui_data_table_header_cell_accessor: !1,
      get element() {
        return S();
      },
      get columnId() {
      },
      addClass: F,
      removeClass: N,
      getAttr: D,
      addAttr: T
    };
    return pr(S(), "SMUIDataTableCell:mount", O), () => {
      pr(S(), "SMUIDataTableCell:unmount", O);
    };
  });
  function F(O) {
    b[O] || t(7, b[O] = !0, b);
  }
  function N(O) {
    (!(O in b) || b[O]) && t(7, b[O] = !1, b);
  }
  function D(O) {
    var J;
    return O in w ? (J = w[O]) !== null && J !== void 0 ? J : null : S().getAttribute(O);
  }
  function T(O, J) {
    w[O] !== J && t(8, w[O] = J, w);
  }
  function E(O) {
    pr(S(), "SMUIDataTableHeaderCheckbox:change", O);
  }
  function L(O) {
    pr(S(), "SMUIDataTableBodyCheckbox:change", O);
  }
  function S() {
    return m;
  }
  function X(O) {
    yt[O ? "unshift" : "push"](() => {
      m = O, t(6, m);
    });
  }
  const z = (O) => d && E(O);
  function R(O) {
    yt[O ? "unshift" : "push"](() => {
      m = O, t(6, m);
    });
  }
  const V = (O) => d && L(O);
  return r.$$set = (O) => {
    e = ze(ze({}, e), Nr(O)), t(19, i = xt(e, n)), "use" in O && t(0, c = O.use), "class" in O && t(1, h = O.class), "numeric" in O && t(2, f = O.numeric), "checkbox" in O && t(3, d = O.checkbox), "columnId" in O && t(4, p = O.columnId), "sortable" in O && t(5, v = O.sortable), "$$scope" in O && t(21, A = O.$$scope);
  }, [
    c,
    h,
    f,
    d,
    p,
    v,
    m,
    b,
    w,
    s,
    a,
    l,
    u,
    B,
    _,
    x,
    C,
    E,
    L,
    i,
    S,
    A,
    o,
    X,
    z,
    R,
    V
  ];
}
class ra extends jt {
  constructor(e) {
    super(), Pt(this, e, jN, PN, Mt, {
      use: 0,
      class: 1,
      numeric: 2,
      checkbox: 3,
      columnId: 4,
      sortable: 5,
      getElement: 20
    });
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[1];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get numeric() {
    return this.$$.ctx[2];
  }
  set numeric(e) {
    this.$$set({ numeric: e }), pe();
  }
  get checkbox() {
    return this.$$.ctx[3];
  }
  set checkbox(e) {
    this.$$set({ checkbox: e }), pe();
  }
  get columnId() {
    return this.$$.ctx[4];
  }
  set columnId(e) {
    this.$$set({ columnId: e }), pe();
  }
  get sortable() {
    return this.$$.ctx[5];
  }
  set sortable(e) {
    this.$$set({ sortable: e }), pe();
  }
  get getElement() {
    return this.$$.ctx[20];
  }
}
Ht(ra, { use: {}, class: {}, numeric: { type: "Boolean" }, checkbox: { type: "Boolean" }, columnId: {}, sortable: {} }, ["default"], ["getElement"], !0);
const KN = (r) => ({}), hw = (r) => ({}), $N = (r) => ({}), dw = (r) => ({});
function pw(r) {
  let e, t;
  const n = (
    /*#slots*/
    r[10].rowsPerPage
  ), i = Nt(
    n,
    r,
    /*$$scope*/
    r[9],
    dw
  );
  return {
    c() {
      e = We("div"), i && i.c(), Me(e, "class", "mdc-data-table__pagination-rows-per-page");
    },
    m(s, a) {
      ke(s, e, a), i && i.m(e, null), t = !0;
    },
    p(s, a) {
      i && i.p && (!t || a & /*$$scope*/
      512) && Qt(
        i,
        n,
        s,
        /*$$scope*/
        s[9],
        t ? Ot(
          n,
          /*$$scope*/
          s[9],
          a,
          $N
        ) : Dt(
          /*$$scope*/
          s[9]
        ),
        dw
      );
    },
    i(s) {
      t || (fe(i, s), t = !0);
    },
    o(s) {
      ge(i, s), t = !1;
    },
    d(s) {
      s && xe(e), i && i.d(s);
    }
  };
}
function gw(r) {
  let e, t;
  const n = (
    /*#slots*/
    r[10].total
  ), i = Nt(
    n,
    r,
    /*$$scope*/
    r[9],
    hw
  );
  return {
    c() {
      e = We("div"), i && i.c(), Me(e, "class", "mdc-data-table__pagination-total");
    },
    m(s, a) {
      ke(s, e, a), i && i.m(e, null), t = !0;
    },
    p(s, a) {
      i && i.p && (!t || a & /*$$scope*/
      512) && Qt(
        i,
        n,
        s,
        /*$$scope*/
        s[9],
        t ? Ot(
          n,
          /*$$scope*/
          s[9],
          a,
          KN
        ) : Dt(
          /*$$scope*/
          s[9]
        ),
        hw
      );
    },
    i(s) {
      t || (fe(i, s), t = !0);
    },
    o(s) {
      ge(i, s), t = !1;
    },
    d(s) {
      s && xe(e), i && i.d(s);
    }
  };
}
function VN(r) {
  let e, t, n, i, s, a, o, A, l, u, c, h, f = (
    /*$$slots*/
    r[7].rowsPerPage && pw(r)
  ), d = (
    /*$$slots*/
    r[7].total && gw(r)
  );
  const p = (
    /*#slots*/
    r[10].default
  ), v = Nt(
    p,
    r,
    /*$$scope*/
    r[9],
    null
  );
  let m = [
    {
      class: a = ht({
        [
          /*trailing$class*/
          r[3]
        ]: !0,
        "mdc-data-table__pagination-trailing": !0
      })
    },
    on(
      /*$$restProps*/
      r[6],
      "trailing$"
    )
  ], b = {};
  for (let _ = 0; _ < m.length; _ += 1)
    b = ze(b, m[_]);
  let w = [
    {
      class: A = ht({
        [
          /*className*/
          r[1]
        ]: !0,
        "mdc-data-table__pagination": !0
      })
    },
    Ia(
      /*$$restProps*/
      r[6],
      ["trailing$"]
    )
  ], B = {};
  for (let _ = 0; _ < w.length; _ += 1)
    B = ze(B, w[_]);
  return {
    c() {
      e = We("div"), t = We("div"), f && f.c(), n = tt(), i = We("div"), d && d.c(), s = tt(), v && v.c(), Me(i, "class", "mdc-data-table__pagination-navigation"), Ut(t, b), Ut(e, B);
    },
    m(_, x) {
      ke(_, e, x), je(e, t), f && f.m(t, null), je(t, n), je(t, i), d && d.m(i, null), je(i, s), v && v.m(i, null), r[11](e), u = !0, c || (h = [
        Bt(o = xr.call(
          null,
          t,
          /*trailing$use*/
          r[2]
        )),
        Bt(l = xr.call(
          null,
          e,
          /*use*/
          r[0]
        )),
        Bt(
          /*forwardEvents*/
          r[5].call(null, e)
        )
      ], c = !0);
    },
    p(_, [x]) {
      /*$$slots*/
      _[7].rowsPerPage ? f ? (f.p(_, x), x & /*$$slots*/
      128 && fe(f, 1)) : (f = pw(_), f.c(), fe(f, 1), f.m(t, n)) : f && (er(), ge(f, 1, 1, () => {
        f = null;
      }), tr()), /*$$slots*/
      _[7].total ? d ? (d.p(_, x), x & /*$$slots*/
      128 && fe(d, 1)) : (d = gw(_), d.c(), fe(d, 1), d.m(i, s)) : d && (er(), ge(d, 1, 1, () => {
        d = null;
      }), tr()), v && v.p && (!u || x & /*$$scope*/
      512) && Qt(
        v,
        p,
        _,
        /*$$scope*/
        _[9],
        u ? Ot(
          p,
          /*$$scope*/
          _[9],
          x,
          null
        ) : Dt(
          /*$$scope*/
          _[9]
        ),
        null
      ), Ut(t, b = Et(m, [
        (!u || x & /*trailing$class*/
        8 && a !== (a = ht({
          [
            /*trailing$class*/
            _[3]
          ]: !0,
          "mdc-data-table__pagination-trailing": !0
        }))) && { class: a },
        x & /*$$restProps*/
        64 && on(
          /*$$restProps*/
          _[6],
          "trailing$"
        )
      ])), o && ar(o.update) && x & /*trailing$use*/
      4 && o.update.call(
        null,
        /*trailing$use*/
        _[2]
      ), Ut(e, B = Et(w, [
        (!u || x & /*className*/
        2 && A !== (A = ht({
          [
            /*className*/
            _[1]
          ]: !0,
          "mdc-data-table__pagination": !0
        }))) && { class: A },
        x & /*$$restProps*/
        64 && Ia(
          /*$$restProps*/
          _[6],
          ["trailing$"]
        )
      ])), l && ar(l.update) && x & /*use*/
      1 && l.update.call(
        null,
        /*use*/
        _[0]
      );
    },
    i(_) {
      u || (fe(f), fe(d), fe(v, _), u = !0);
    },
    o(_) {
      ge(f), ge(d), ge(v, _), u = !1;
    },
    d(_) {
      _ && xe(e), f && f.d(), d && d.d(), v && v.d(_), r[11](null), c = !1, fr(h);
    }
  };
}
function zN(r, e, t) {
  const n = ["use", "class", "trailing$use", "trailing$class", "getElement"];
  let i = xt(e, n), { $$slots: s = {}, $$scope: a } = e;
  const o = D2(s), A = Kr(yr());
  let { use: l = [] } = e, { class: u = "" } = e, { trailing$use: c = [] } = e, { trailing$class: h = "" } = e, f;
  Pr("SMUI:label:context", "data-table:pagination"), Pr("SMUI:select:context", "data-table:pagination"), Pr("SMUI:icon-button:context", "data-table:pagination");
  function d() {
    return f;
  }
  function p(v) {
    yt[v ? "unshift" : "push"](() => {
      f = v, t(4, f);
    });
  }
  return r.$$set = (v) => {
    e = ze(ze({}, e), Nr(v)), t(6, i = xt(e, n)), "use" in v && t(0, l = v.use), "class" in v && t(1, u = v.class), "trailing$use" in v && t(2, c = v.trailing$use), "trailing$class" in v && t(3, h = v.trailing$class), "$$scope" in v && t(9, a = v.$$scope);
  }, [
    l,
    u,
    c,
    h,
    f,
    A,
    i,
    o,
    d,
    a,
    s,
    p
  ];
}
class GN extends jt {
  constructor(e) {
    super(), Pt(this, e, zN, VN, Mt, {
      use: 0,
      class: 1,
      trailing$use: 2,
      trailing$class: 3,
      getElement: 8
    });
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[1];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get trailing$use() {
    return this.$$.ctx[2];
  }
  set trailing$use(e) {
    this.$$set({ trailing$use: e }), pe();
  }
  get trailing$class() {
    return this.$$.ctx[3];
  }
  set trailing$class(e) {
    this.$$set({ trailing$class: e }), pe();
  }
  get getElement() {
    return this.$$.ctx[8];
  }
}
Ht(GN, { use: {}, class: {}, trailing$use: {}, trailing$class: {} }, ["rowsPerPage", "total", "default"], ["getElement"], !0);
function qN(r) {
  let e, t, n, i, s, a, o, A, l, u, c, h, f, d, p, v, m = [
    {
      class: n = ht({
        [
          /*input$class*/
          r[9]
        ]: !0,
        "mdc-checkbox__native-control": !0
      })
    },
    { type: "checkbox" },
    /*inputProps*/
    r[20],
    { disabled: (
      /*disabled*/
      r[1]
    ) },
    {
      __value: i = /*isUninitializedValue*/
      r[19](
        /*valueKey*/
        r[7]
      ) ? (
        /*value*/
        r[6]
      ) : (
        /*valueKey*/
        r[7]
      )
    },
    {
      "data-indeterminate": s = !/*isUninitializedValue*/
      r[19](
        /*indeterminate*/
        r[0]
      ) && /*indeterminate*/
      r[0] ? "true" : void 0
    },
    /*nativeControlAttrs*/
    r[16],
    on(
      /*$$restProps*/
      r[26],
      "input$"
    )
  ], b = {};
  for (let _ = 0; _ < m.length; _ += 1)
    b = ze(b, m[_]);
  let w = [
    {
      class: c = ht({
        [
          /*className*/
          r[3]
        ]: !0,
        "mdc-checkbox": !0,
        "mdc-checkbox--disabled": (
          /*disabled*/
          r[1]
        ),
        "mdc-checkbox--touch": (
          /*touch*/
          r[5]
        ),
        "mdc-data-table__header-row-checkbox": (
          /*context*/
          r[21] === "data-table" && /*dataTableHeader*/
          r[22]
        ),
        "mdc-data-table__row-checkbox": (
          /*context*/
          r[21] === "data-table" && !/*dataTableHeader*/
          r[22]
        ),
        .../*internalClasses*/
        r[14]
      })
    },
    {
      style: h = Object.entries(
        /*internalStyles*/
        r[15]
      ).map(mw).concat([
        /*style*/
        r[4]
      ]).join(" ")
    },
    Ia(
      /*$$restProps*/
      r[26],
      ["input$"]
    )
  ], B = {};
  for (let _ = 0; _ < w.length; _ += 1)
    B = ze(B, w[_]);
  return {
    c() {
      e = We("div"), t = We("input"), o = tt(), A = We("div"), A.innerHTML = '<svg class="mdc-checkbox__checkmark" viewBox="0 0 24 24"><path class="mdc-checkbox__checkmark-path" fill="none" d="M1.73,12.91 8.1,19.28 22.79,4.59"></path></svg> <div class="mdc-checkbox__mixedmark"></div>', l = tt(), u = We("div"), Ut(t, b), Me(A, "class", "mdc-checkbox__background"), Me(u, "class", "mdc-checkbox__ripple"), Ut(e, B);
    },
    m(_, x) {
      ke(_, e, x), je(e, t), t.autofocus && t.focus(), r[36](t), t.checked = /*nativeChecked*/
      r[12], je(e, o), je(e, A), je(e, l), je(e, u), r[38](e), p || (v = [
        Bt(a = xr.call(
          null,
          t,
          /*input$use*/
          r[8]
        )),
        pt(
          t,
          "change",
          /*input_change_handler*/
          r[37]
        ),
        pt(
          t,
          "blur",
          /*blur_handler*/
          r[34]
        ),
        pt(
          t,
          "focus",
          /*focus_handler*/
          r[35]
        ),
        Bt(f = xr.call(
          null,
          e,
          /*use*/
          r[2]
        )),
        Bt(
          /*forwardEvents*/
          r[18].call(null, e)
        ),
        Bt(d = io.call(null, e, {
          unbounded: !0,
          addClass: (
            /*addClass*/
            r[23]
          ),
          removeClass: (
            /*removeClass*/
            r[24]
          ),
          addStyle: (
            /*addStyle*/
            r[25]
          ),
          active: (
            /*rippleActive*/
            r[17]
          ),
          eventTarget: (
            /*checkbox*/
            r[11]
          )
        })),
        pt(
          e,
          "animationend",
          /*animationend_handler*/
          r[39]
        )
      ], p = !0);
    },
    p(_, x) {
      Ut(t, b = Et(m, [
        x[0] & /*input$class*/
        512 && n !== (n = ht({
          [
            /*input$class*/
            _[9]
          ]: !0,
          "mdc-checkbox__native-control": !0
        })) && { class: n },
        { type: "checkbox" },
        /*inputProps*/
        _[20],
        x[0] & /*disabled*/
        2 && { disabled: (
          /*disabled*/
          _[1]
        ) },
        x[0] & /*valueKey, value*/
        192 && i !== (i = /*isUninitializedValue*/
        _[19](
          /*valueKey*/
          _[7]
        ) ? (
          /*value*/
          _[6]
        ) : (
          /*valueKey*/
          _[7]
        )) && { __value: i },
        x[0] & /*indeterminate*/
        1 && s !== (s = !/*isUninitializedValue*/
        _[19](
          /*indeterminate*/
          _[0]
        ) && /*indeterminate*/
        _[0] ? "true" : void 0) && {
          "data-indeterminate": s
        },
        x[0] & /*nativeControlAttrs*/
        65536 && /*nativeControlAttrs*/
        _[16],
        x[0] & /*$$restProps*/
        67108864 && on(
          /*$$restProps*/
          _[26],
          "input$"
        )
      ])), a && ar(a.update) && x[0] & /*input$use*/
      256 && a.update.call(
        null,
        /*input$use*/
        _[8]
      ), x[0] & /*nativeChecked*/
      4096 && (t.checked = /*nativeChecked*/
      _[12]), Ut(e, B = Et(w, [
        x[0] & /*className, disabled, touch, internalClasses*/
        16426 && c !== (c = ht({
          [
            /*className*/
            _[3]
          ]: !0,
          "mdc-checkbox": !0,
          "mdc-checkbox--disabled": (
            /*disabled*/
            _[1]
          ),
          "mdc-checkbox--touch": (
            /*touch*/
            _[5]
          ),
          "mdc-data-table__header-row-checkbox": (
            /*context*/
            _[21] === "data-table" && /*dataTableHeader*/
            _[22]
          ),
          "mdc-data-table__row-checkbox": (
            /*context*/
            _[21] === "data-table" && !/*dataTableHeader*/
            _[22]
          ),
          .../*internalClasses*/
          _[14]
        })) && { class: c },
        x[0] & /*internalStyles, style*/
        32784 && h !== (h = Object.entries(
          /*internalStyles*/
          _[15]
        ).map(mw).concat([
          /*style*/
          _[4]
        ]).join(" ")) && { style: h },
        x[0] & /*$$restProps*/
        67108864 && Ia(
          /*$$restProps*/
          _[26],
          ["input$"]
        )
      ])), f && ar(f.update) && x[0] & /*use*/
      4 && f.update.call(
        null,
        /*use*/
        _[2]
      ), d && ar(d.update) && x[0] & /*rippleActive, checkbox*/
      133120 && d.update.call(null, {
        unbounded: !0,
        addClass: (
          /*addClass*/
          _[23]
        ),
        removeClass: (
          /*removeClass*/
          _[24]
        ),
        addStyle: (
          /*addStyle*/
          _[25]
        ),
        active: (
          /*rippleActive*/
          _[17]
        ),
        eventTarget: (
          /*checkbox*/
          _[11]
        )
      });
    },
    i: sr,
    o: sr,
    d(_) {
      _ && xe(e), r[36](null), r[38](null), p = !1, fr(v);
    }
  };
}
const mw = ([r, e]) => `${r}: ${e};`;
function WN(r, e, t) {
  const n = [
    "use",
    "class",
    "style",
    "disabled",
    "touch",
    "indeterminate",
    "group",
    "checked",
    "value",
    "valueKey",
    "input$use",
    "input$class",
    "getId",
    "getElement"
  ];
  let i = xt(e, n);
  var s;
  const a = Kr(yr());
  let o = () => {
  };
  function A(Ce) {
    return Ce === o;
  }
  let { use: l = [] } = e, { class: u = "" } = e, { style: c = "" } = e, { disabled: h = !1 } = e, { touch: f = !1 } = e, { indeterminate: d = o } = e, { group: p = o } = e, { checked: v = o } = e, { value: m = null } = e, { valueKey: b = o } = e, { input$use: w = [] } = e, { input$class: B = "" } = e, _, x, C, F = {}, N = {}, D = {}, T = !1, E = (s = pn("SMUI:generic:input:props")) !== null && s !== void 0 ? s : {}, L = A(p) ? A(v) ? !1 : v ?? void 0 : p.indexOf(m) !== -1, S = pn("SMUI:checkbox:context"), X = pn("SMUI:data-table:row:header"), z = v, R = A(p) ? [] : [...p], V = L;
  ui(() => {
    t(11, C.indeterminate = !A(d) && d, C), t(10, x = new BN({
      addClass: O,
      forceLayout: () => _.offsetWidth,
      hasNativeControl: () => !0,
      isAttachedToDOM: () => !!_.parentNode,
      isChecked: () => L ?? !1,
      isIndeterminate: () => A(d) ? !1 : d,
      removeClass: J,
      removeNativeControlAttr: P,
      setNativeControlAttr: U,
      setNativeControlDisabled: (Qe) => t(1, h = Qe)
    }));
    const Ce = {
      _smui_checkbox_accessor: !0,
      get element() {
        return $();
      },
      get checked() {
        return L ?? !1;
      },
      set checked(Qe) {
        L !== Qe && t(12, L = Qe);
      },
      get indeterminate() {
        return A(d) ? !1 : d;
      },
      set indeterminate(Qe) {
        t(0, d = Qe);
      },
      activateRipple() {
        h || t(17, T = !0);
      },
      deactivateRipple() {
        t(17, T = !1);
      }
    };
    return pr(_, "SMUIGenericInput:mount", Ce), pr(_, "SMUICheckbox:mount", Ce), x.init(), () => {
      pr(_, "SMUIGenericInput:unmount", Ce), pr(_, "SMUICheckbox:unmount", Ce), x.destroy();
    };
  });
  function O(Ce) {
    F[Ce] || t(14, F[Ce] = !0, F);
  }
  function J(Ce) {
    (!(Ce in F) || F[Ce]) && t(14, F[Ce] = !1, F);
  }
  function Z(Ce, Qe) {
    N[Ce] != Qe && (Qe === "" || Qe == null ? (delete N[Ce], t(15, N)) : t(15, N[Ce] = Qe, N));
  }
  function U(Ce, Qe) {
    D[Ce] !== Qe && t(16, D[Ce] = Qe, D);
  }
  function P(Ce) {
    (!(Ce in D) || D[Ce] != null) && t(16, D[Ce] = void 0, D);
  }
  function H() {
    return E && E.id;
  }
  function $() {
    return _;
  }
  function ie(Ce) {
    Sa.call(this, r, Ce);
  }
  function ue(Ce) {
    Sa.call(this, r, Ce);
  }
  function he(Ce) {
    yt[Ce ? "unshift" : "push"](() => {
      C = Ce, t(11, C), t(27, p), t(33, V), t(12, L), t(6, m), t(32, R), t(28, v), t(31, z), t(0, d), t(10, x);
    });
  }
  function ve() {
    L = this.checked, t(12, L), t(27, p), t(33, V), t(6, m), t(32, R), t(28, v), t(31, z), t(0, d), t(11, C), t(10, x);
  }
  function Le(Ce) {
    yt[Ce ? "unshift" : "push"](() => {
      _ = Ce, t(13, _);
    });
  }
  const de = () => x && x.handleAnimationEnd();
  return r.$$set = (Ce) => {
    e = ze(ze({}, e), Nr(Ce)), t(26, i = xt(e, n)), "use" in Ce && t(2, l = Ce.use), "class" in Ce && t(3, u = Ce.class), "style" in Ce && t(4, c = Ce.style), "disabled" in Ce && t(1, h = Ce.disabled), "touch" in Ce && t(5, f = Ce.touch), "indeterminate" in Ce && t(0, d = Ce.indeterminate), "group" in Ce && t(27, p = Ce.group), "checked" in Ce && t(28, v = Ce.checked), "value" in Ce && t(6, m = Ce.value), "valueKey" in Ce && t(7, b = Ce.valueKey), "input$use" in Ce && t(8, w = Ce.input$use), "input$class" in Ce && t(9, B = Ce.input$class);
  }, r.$$.update = () => {
    if (r.$$.dirty[0] & /*group, nativeChecked, value, checked, indeterminate, checkbox, instance*/
    402660417 | r.$$.dirty[1] & /*previousNativeChecked, previousGroup, previousChecked*/
    7) {
      let Ce = !1;
      if (!A(p))
        if (V !== L) {
          const Qe = p.indexOf(m);
          L && Qe === -1 ? (p.push(m), t(27, p), t(33, V), t(12, L), t(6, m), t(32, R), t(28, v), t(31, z), t(0, d), t(11, C), t(10, x)) : !L && Qe !== -1 && (p.splice(Qe, 1), t(27, p), t(33, V), t(12, L), t(6, m), t(32, R), t(28, v), t(31, z), t(0, d), t(11, C), t(10, x)), Ce = !0;
        } else {
          const Qe = R.indexOf(m), M = p.indexOf(m);
          Qe > -1 && M === -1 ? (t(12, L = !1), Ce = !0) : M > -1 && Qe === -1 && (t(12, L = !0), Ce = !0);
        }
      A(v) ? !!V != !!L && (Ce = !0) : v !== (L ?? null) && (v === z ? (t(28, v = L ?? null), A(d) || t(0, d = !1)) : t(12, L = v ?? void 0), Ce = !0), C && (A(d) ? C.indeterminate && (t(11, C.indeterminate = !1, C), Ce = !0) : !d && C.indeterminate ? (t(11, C.indeterminate = !1, C), Ce = !0) : d && !C.indeterminate && (t(11, C.indeterminate = !0, C), Ce = !0)), t(31, z = v), t(32, R = A(p) ? [] : [...p]), t(33, V = L), Ce && x && x.handleChange();
    }
  }, [
    d,
    h,
    l,
    u,
    c,
    f,
    m,
    b,
    w,
    B,
    x,
    C,
    L,
    _,
    F,
    N,
    D,
    T,
    a,
    A,
    E,
    S,
    X,
    O,
    J,
    Z,
    i,
    p,
    v,
    H,
    $,
    z,
    R,
    V,
    ie,
    ue,
    he,
    ve,
    Le,
    de
  ];
}
class Of extends jt {
  constructor(e) {
    super(), Pt(
      this,
      e,
      WN,
      qN,
      Mt,
      {
        use: 2,
        class: 3,
        style: 4,
        disabled: 1,
        touch: 5,
        indeterminate: 0,
        group: 27,
        checked: 28,
        value: 6,
        valueKey: 7,
        input$use: 8,
        input$class: 9,
        getId: 29,
        getElement: 30
      },
      null,
      [-1, -1]
    );
  }
  get use() {
    return this.$$.ctx[2];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[3];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get style() {
    return this.$$.ctx[4];
  }
  set style(e) {
    this.$$set({ style: e }), pe();
  }
  get disabled() {
    return this.$$.ctx[1];
  }
  set disabled(e) {
    this.$$set({ disabled: e }), pe();
  }
  get touch() {
    return this.$$.ctx[5];
  }
  set touch(e) {
    this.$$set({ touch: e }), pe();
  }
  get indeterminate() {
    return this.$$.ctx[0];
  }
  set indeterminate(e) {
    this.$$set({ indeterminate: e }), pe();
  }
  get group() {
    return this.$$.ctx[27];
  }
  set group(e) {
    this.$$set({ group: e }), pe();
  }
  get checked() {
    return this.$$.ctx[28];
  }
  set checked(e) {
    this.$$set({ checked: e }), pe();
  }
  get value() {
    return this.$$.ctx[6];
  }
  set value(e) {
    this.$$set({ value: e }), pe();
  }
  get valueKey() {
    return this.$$.ctx[7];
  }
  set valueKey(e) {
    this.$$set({ valueKey: e }), pe();
  }
  get input$use() {
    return this.$$.ctx[8];
  }
  set input$use(e) {
    this.$$set({ input$use: e }), pe();
  }
  get input$class() {
    return this.$$.ctx[9];
  }
  set input$class(e) {
    this.$$set({ input$class: e }), pe();
  }
  get getId() {
    return this.$$.ctx[29];
  }
  get getElement() {
    return this.$$.ctx[30];
  }
}
Ht(Of, { use: {}, class: {}, style: {}, disabled: { type: "Boolean" }, touch: { type: "Boolean" }, indeterminate: {}, group: {}, checked: {}, value: {}, valueKey: {}, input$use: {}, input$class: {} }, [], ["getId", "getElement"], !0);
function XN(r) {
  Pi(r, "svelte-la0cmf", ".table-container.svelte-la0cmf{width:100%;display:flex;flex-direction:column;align-items:center}.table-container.svelte-la0cmf .mdc-data-table{width:95%}.table-container.svelte-la0cmf .mdc-data-table__table-container,.table-container.svelte-la0cmf .mdc-data-table__header-cell{background-color:rgb(255, 255, 255)}.table-container.svelte-la0cmf .mdc-data-table__header-cell:nth-child(1){width:1%}.table-container.svelte-la0cmf .mdc-data-table__header-cell:nth-child(2){width:25%}.table-container.svelte-la0cmf .mdc-data-table__header-cell:nth-child(3){width:15%}.table-container.svelte-la0cmf .mdc-data-table__header-cell:nth-child(4){width:40%}.table-container.svelte-la0cmf .mdc-data-table__header-cell:last-child{width:1%}.table-container.svelte-la0cmf .mdc-data-table__table-container,.table-container.svelte-la0cmf .mdc-data-table{border-radius:10px}.table-container.svelte-la0cmf .mdc-data-table__cell{overflow-y:visible}");
}
function vw(r, e, t) {
  const n = r.slice();
  return n[12] = e[t], n;
}
function JN(r) {
  let e, t;
  return e = new PE({
    props: {
      $$slots: { default: [gO] },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      Ve(e.$$.fragment);
    },
    m(n, i) {
      Ke(e, n, i), t = !0;
    },
    p(n, i) {
      const s = {};
      i & /*$$scope, allTemplates, selectedTemplates*/
      32771 && (s.$$scope = { dirty: i, ctx: n }), e.$set(s);
    },
    i(n) {
      t || (fe(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ge(e.$$.fragment, n), t = !1;
    },
    d(n) {
      $e(e, n);
    }
  };
}
function YN(r) {
  let e;
  return {
    c() {
      e = We("div"), e.textContent = "There are currently no templates available";
    },
    m(t, n) {
      ke(t, e, n);
    },
    p: sr,
    i: sr,
    o: sr,
    d(t) {
      t && xe(e);
    }
  };
}
function ZN(r) {
  let e, t;
  return e = new Of({}), {
    c() {
      Ve(e.$$.fragment);
    },
    m(n, i) {
      Ke(e, n, i), t = !0;
    },
    i(n) {
      t || (fe(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ge(e.$$.fragment, n), t = !1;
    },
    d(n) {
      $e(e, n);
    }
  };
}
function eO(r) {
  let e;
  return {
    c() {
      e = ir("Name");
    },
    m(t, n) {
      ke(t, e, n);
    },
    d(t) {
      t && xe(e);
    }
  };
}
function tO(r) {
  let e;
  return {
    c() {
      e = ir("Last Edited");
    },
    m(t, n) {
      ke(t, e, n);
    },
    d(t) {
      t && xe(e);
    }
  };
}
function rO(r) {
  let e;
  return {
    c() {
      e = ir("Description");
    },
    m(t, n) {
      ke(t, e, n);
    },
    d(t) {
      t && xe(e);
    }
  };
}
function nO(r) {
  let e, t, n, i, s, a, o, A, l, u;
  return e = new ra({
    props: {
      checkbox: !0,
      $$slots: { default: [ZN] },
      $$scope: { ctx: r }
    }
  }), n = new ra({
    props: {
      class: "big",
      $$slots: { default: [eO] },
      $$scope: { ctx: r }
    }
  }), s = new ra({
    props: {
      $$slots: { default: [tO] },
      $$scope: { ctx: r }
    }
  }), o = new ra({
    props: {
      $$slots: { default: [rO] },
      $$scope: { ctx: r }
    }
  }), l = new ra({}), {
    c() {
      Ve(e.$$.fragment), t = tt(), Ve(n.$$.fragment), i = tt(), Ve(s.$$.fragment), a = tt(), Ve(o.$$.fragment), A = tt(), Ve(l.$$.fragment);
    },
    m(c, h) {
      Ke(e, c, h), ke(c, t, h), Ke(n, c, h), ke(c, i, h), Ke(s, c, h), ke(c, a, h), Ke(o, c, h), ke(c, A, h), Ke(l, c, h), u = !0;
    },
    p(c, h) {
      const f = {};
      h & /*$$scope*/
      32768 && (f.$$scope = { dirty: h, ctx: c }), e.$set(f);
      const d = {};
      h & /*$$scope*/
      32768 && (d.$$scope = { dirty: h, ctx: c }), n.$set(d);
      const p = {};
      h & /*$$scope*/
      32768 && (p.$$scope = { dirty: h, ctx: c }), s.$set(p);
      const v = {};
      h & /*$$scope*/
      32768 && (v.$$scope = { dirty: h, ctx: c }), o.$set(v);
    },
    i(c) {
      u || (fe(e.$$.fragment, c), fe(n.$$.fragment, c), fe(s.$$.fragment, c), fe(o.$$.fragment, c), fe(l.$$.fragment, c), u = !0);
    },
    o(c) {
      ge(e.$$.fragment, c), ge(n.$$.fragment, c), ge(s.$$.fragment, c), ge(o.$$.fragment, c), ge(l.$$.fragment, c), u = !1;
    },
    d(c) {
      c && (xe(t), xe(i), xe(a), xe(A)), $e(e, c), $e(n, c), $e(s, c), $e(o, c), $e(l, c);
    }
  };
}
function iO(r) {
  let e, t;
  return e = new $2({
    props: {
      $$slots: { default: [nO] },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      Ve(e.$$.fragment);
    },
    m(n, i) {
      Ke(e, n, i), t = !0;
    },
    p(n, i) {
      const s = {};
      i & /*$$scope*/
      32768 && (s.$$scope = { dirty: i, ctx: n }), e.$set(s);
    },
    i(n) {
      t || (fe(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ge(e.$$.fragment, n), t = !1;
    },
    d(n) {
      $e(e, n);
    }
  };
}
function sO(r) {
  let e, t, n;
  function i(a) {
    r[6](a);
  }
  let s = {
    value: (
      /*template*/
      r[12]
    ),
    valueKey: (
      /*template*/
      r[12].name
    )
  };
  return (
    /*selectedTemplates*/
    r[1] !== void 0 && (s.group = /*selectedTemplates*/
    r[1]), e = new Of({ props: s }), yt.push(() => Gn(e, "group", i)), {
      c() {
        Ve(e.$$.fragment);
      },
      m(a, o) {
        Ke(e, a, o), n = !0;
      },
      p(a, o) {
        const A = {};
        o & /*allTemplates*/
        1 && (A.value = /*template*/
        a[12]), o & /*allTemplates*/
        1 && (A.valueKey = /*template*/
        a[12].name), !t && o & /*selectedTemplates*/
        2 && (t = !0, A.group = /*selectedTemplates*/
        a[1], zn(() => t = !1)), e.$set(A);
      },
      i(a) {
        n || (fe(e.$$.fragment, a), n = !0);
      },
      o(a) {
        ge(e.$$.fragment, a), n = !1;
      },
      d(a) {
        $e(e, a);
      }
    }
  );
}
function aO(r) {
  let e, t;
  return e = new V2({
    props: {
      text: (
        /*template*/
        r[12].name
      ),
      maxChars: 40,
      tooltipPosition: "top"
    }
  }), {
    c() {
      Ve(e.$$.fragment);
    },
    m(n, i) {
      Ke(e, n, i), t = !0;
    },
    p(n, i) {
      const s = {};
      i & /*allTemplates*/
      1 && (s.text = /*template*/
      n[12].name), e.$set(s);
    },
    i(n) {
      t || (fe(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ge(e.$$.fragment, n), t = !1;
    },
    d(n) {
      $e(e, n);
    }
  };
}
function oO(r) {
  let e = yw(
    /*template*/
    r[12].lastEdited
  ) + "", t;
  return {
    c() {
      t = ir(e);
    },
    m(n, i) {
      ke(n, t, i);
    },
    p(n, i) {
      i & /*allTemplates*/
      1 && e !== (e = yw(
        /*template*/
        n[12].lastEdited
      ) + "") && Ds(t, e);
    },
    d(n) {
      n && xe(t);
    }
  };
}
function AO(r) {
  let e, t;
  return e = new V2({
    props: {
      text: (
        /*template*/
        r[12].description
      ),
      maxChars: 100,
      tooltipPosition: "top"
    }
  }), {
    c() {
      Ve(e.$$.fragment);
    },
    m(n, i) {
      Ke(e, n, i), t = !0;
    },
    p(n, i) {
      const s = {};
      i & /*allTemplates*/
      1 && (s.text = /*template*/
      n[12].description), e.$set(s);
    },
    i(n) {
      t || (fe(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ge(e.$$.fragment, n), t = !1;
    },
    d(n) {
      $e(e, n);
    }
  };
}
function lO(r) {
  let e, t;
  function n() {
    return (
      /*click_handler*/
      r[7](
        /*template*/
        r[12]
      )
    );
  }
  return e = new us({ props: { icon: "edit", color: "black" } }), e.$on("click", n), {
    c() {
      Ve(e.$$.fragment);
    },
    m(i, s) {
      Ke(e, i, s), t = !0;
    },
    p(i, s) {
      r = i;
    },
    i(i) {
      t || (fe(e.$$.fragment, i), t = !0);
    },
    o(i) {
      ge(e.$$.fragment, i), t = !1;
    },
    d(i) {
      $e(e, i);
    }
  };
}
function uO(r) {
  let e, t;
  function n() {
    return (
      /*click_handler_1*/
      r[8](
        /*template*/
        r[12]
      )
    );
  }
  return e = new us({
    props: { icon: "delete", color: "black" }
  }), e.$on("click", n), {
    c() {
      Ve(e.$$.fragment);
    },
    m(i, s) {
      Ke(e, i, s), t = !0;
    },
    p(i, s) {
      r = i;
    },
    i(i) {
      t || (fe(e.$$.fragment, i), t = !0);
    },
    o(i) {
      ge(e.$$.fragment, i), t = !1;
    },
    d(i) {
      $e(e, i);
    }
  };
}
function cO(r) {
  let e, t;
  function n() {
    return (
      /*click_handler_2*/
      r[9](
        /*template*/
        r[12]
      )
    );
  }
  return e = new us({
    props: { icon: "content_copy", color: "black" }
  }), e.$on("click", n), {
    c() {
      Ve(e.$$.fragment);
    },
    m(i, s) {
      Ke(e, i, s), t = !0;
    },
    p(i, s) {
      r = i;
    },
    i(i) {
      t || (fe(e.$$.fragment, i), t = !0);
    },
    o(i) {
      ge(e.$$.fragment, i), t = !1;
    },
    d(i) {
      $e(e, i);
    }
  };
}
function fO(r) {
  let e, t;
  function n() {
    return (
      /*click_handler_3*/
      r[10](
        /*template*/
        r[12]
      )
    );
  }
  return e = new us({
    props: { icon: "download", color: "black" }
  }), e.$on("click", n), {
    c() {
      Ve(e.$$.fragment);
    },
    m(i, s) {
      Ke(e, i, s), t = !0;
    },
    p(i, s) {
      r = i;
    },
    i(i) {
      t || (fe(e.$$.fragment, i), t = !0);
    },
    o(i) {
      ge(e.$$.fragment, i), t = !1;
    },
    d(i) {
      $e(e, i);
    }
  };
}
function hO(r) {
  let e, t, n, i, s, a, o, A, l;
  return t = new cu({
    props: {
      text: "Edit",
      $$slots: { default: [lO] },
      $$scope: { ctx: r }
    }
  }), i = new cu({
    props: {
      text: "Delete",
      $$slots: { default: [uO] },
      $$scope: { ctx: r }
    }
  }), a = new cu({
    props: {
      text: "Duplicate",
      $$slots: { default: [cO] },
      $$scope: { ctx: r }
    }
  }), A = new cu({
    props: {
      text: "Download",
      position: "left",
      $$slots: { default: [fO] },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      e = We("div"), Ve(t.$$.fragment), n = tt(), Ve(i.$$.fragment), s = tt(), Ve(a.$$.fragment), o = tt(), Ve(A.$$.fragment), Me(e, "class", "action-btns");
    },
    m(u, c) {
      ke(u, e, c), Ke(t, e, null), je(e, n), Ke(i, e, null), je(e, s), Ke(a, e, null), je(e, o), Ke(A, e, null), l = !0;
    },
    p(u, c) {
      const h = {};
      c & /*$$scope, allTemplates*/
      32769 && (h.$$scope = { dirty: c, ctx: u }), t.$set(h);
      const f = {};
      c & /*$$scope, allTemplates*/
      32769 && (f.$$scope = { dirty: c, ctx: u }), i.$set(f);
      const d = {};
      c & /*$$scope, allTemplates*/
      32769 && (d.$$scope = { dirty: c, ctx: u }), a.$set(d);
      const p = {};
      c & /*$$scope, allTemplates*/
      32769 && (p.$$scope = { dirty: c, ctx: u }), A.$set(p);
    },
    i(u) {
      l || (fe(t.$$.fragment, u), fe(i.$$.fragment, u), fe(a.$$.fragment, u), fe(A.$$.fragment, u), l = !0);
    },
    o(u) {
      ge(t.$$.fragment, u), ge(i.$$.fragment, u), ge(a.$$.fragment, u), ge(A.$$.fragment, u), l = !1;
    },
    d(u) {
      u && xe(e), $e(t), $e(i), $e(a), $e(A);
    }
  };
}
function dO(r) {
  let e, t, n, i, s, a, o, A, l, u, c;
  return e = new ra({
    props: {
      checkbox: !0,
      $$slots: { default: [sO] },
      $$scope: { ctx: r }
    }
  }), n = new ra({
    props: {
      $$slots: { default: [aO] },
      $$scope: { ctx: r }
    }
  }), s = new ra({
    props: {
      $$slots: { default: [oO] },
      $$scope: { ctx: r }
    }
  }), o = new ra({
    props: {
      $$slots: { default: [AO] },
      $$scope: { ctx: r }
    }
  }), l = new ra({
    props: {
      $$slots: { default: [hO] },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      Ve(e.$$.fragment), t = tt(), Ve(n.$$.fragment), i = tt(), Ve(s.$$.fragment), a = tt(), Ve(o.$$.fragment), A = tt(), Ve(l.$$.fragment), u = tt();
    },
    m(h, f) {
      Ke(e, h, f), ke(h, t, f), Ke(n, h, f), ke(h, i, f), Ke(s, h, f), ke(h, a, f), Ke(o, h, f), ke(h, A, f), Ke(l, h, f), ke(h, u, f), c = !0;
    },
    p(h, f) {
      const d = {};
      f & /*$$scope, allTemplates, selectedTemplates*/
      32771 && (d.$$scope = { dirty: f, ctx: h }), e.$set(d);
      const p = {};
      f & /*$$scope, allTemplates*/
      32769 && (p.$$scope = { dirty: f, ctx: h }), n.$set(p);
      const v = {};
      f & /*$$scope, allTemplates*/
      32769 && (v.$$scope = { dirty: f, ctx: h }), s.$set(v);
      const m = {};
      f & /*$$scope, allTemplates*/
      32769 && (m.$$scope = { dirty: f, ctx: h }), o.$set(m);
      const b = {};
      f & /*$$scope, allTemplates*/
      32769 && (b.$$scope = { dirty: f, ctx: h }), l.$set(b);
    },
    i(h) {
      c || (fe(e.$$.fragment, h), fe(n.$$.fragment, h), fe(s.$$.fragment, h), fe(o.$$.fragment, h), fe(l.$$.fragment, h), c = !0);
    },
    o(h) {
      ge(e.$$.fragment, h), ge(n.$$.fragment, h), ge(s.$$.fragment, h), ge(o.$$.fragment, h), ge(l.$$.fragment, h), c = !1;
    },
    d(h) {
      h && (xe(t), xe(i), xe(a), xe(A), xe(u)), $e(e, h), $e(n, h), $e(s, h), $e(o, h), $e(l, h);
    }
  };
}
function bw(r) {
  let e, t;
  return e = new $2({
    props: {
      $$slots: { default: [dO] },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      Ve(e.$$.fragment);
    },
    m(n, i) {
      Ke(e, n, i), t = !0;
    },
    p(n, i) {
      const s = {};
      i & /*$$scope, allTemplates, selectedTemplates*/
      32771 && (s.$$scope = { dirty: i, ctx: n }), e.$set(s);
    },
    i(n) {
      t || (fe(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ge(e.$$.fragment, n), t = !1;
    },
    d(n) {
      $e(e, n);
    }
  };
}
function pO(r) {
  let e, t, n = Iu(
    /*allTemplates*/
    r[0]
  ), i = [];
  for (let a = 0; a < n.length; a += 1)
    i[a] = bw(vw(r, n, a));
  const s = (a) => ge(i[a], 1, 1, () => {
    i[a] = null;
  });
  return {
    c() {
      for (let a = 0; a < i.length; a += 1)
        i[a].c();
      e = Or();
    },
    m(a, o) {
      for (let A = 0; A < i.length; A += 1)
        i[A] && i[A].m(a, o);
      ke(a, e, o), t = !0;
    },
    p(a, o) {
      if (o & /*downloadTemplateContent, allTemplates, duplicateTemplate, deleteTemplate, editTemplate, formatDate, selectedTemplates*/
      63) {
        n = Iu(
          /*allTemplates*/
          a[0]
        );
        let A;
        for (A = 0; A < n.length; A += 1) {
          const l = vw(a, n, A);
          i[A] ? (i[A].p(l, o), fe(i[A], 1)) : (i[A] = bw(l), i[A].c(), fe(i[A], 1), i[A].m(e.parentNode, e));
        }
        for (er(), A = n.length; A < i.length; A += 1)
          s(A);
        tr();
      }
    },
    i(a) {
      if (!t) {
        for (let o = 0; o < n.length; o += 1)
          fe(i[o]);
        t = !0;
      }
    },
    o(a) {
      i = i.filter(Boolean);
      for (let o = 0; o < i.length; o += 1)
        ge(i[o]);
      t = !1;
    },
    d(a) {
      a && xe(e), Ok(i, a);
    }
  };
}
function gO(r) {
  let e, t, n, i;
  return e = new HE({
    props: {
      $$slots: { default: [iO] },
      $$scope: { ctx: r }
    }
  }), n = new jE({
    props: {
      $$slots: { default: [pO] },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      Ve(e.$$.fragment), t = tt(), Ve(n.$$.fragment);
    },
    m(s, a) {
      Ke(e, s, a), ke(s, t, a), Ke(n, s, a), i = !0;
    },
    p(s, a) {
      const o = {};
      a & /*$$scope*/
      32768 && (o.$$scope = { dirty: a, ctx: s }), e.$set(o);
      const A = {};
      a & /*$$scope, allTemplates, selectedTemplates*/
      32771 && (A.$$scope = { dirty: a, ctx: s }), n.$set(A);
    },
    i(s) {
      i || (fe(e.$$.fragment, s), fe(n.$$.fragment, s), i = !0);
    },
    o(s) {
      ge(e.$$.fragment, s), ge(n.$$.fragment, s), i = !1;
    },
    d(s) {
      s && xe(t), $e(e, s), $e(n, s);
    }
  };
}
function mO(r) {
  let e, t, n, i;
  const s = [YN, JN], a = [];
  function o(A, l) {
    return (
      /*allTemplates*/
      A[0].length === 0 ? 0 : 1
    );
  }
  return t = o(r), n = a[t] = s[t](r), {
    c() {
      e = We("div"), n.c(), Me(e, "class", "table-container svelte-la0cmf");
    },
    m(A, l) {
      ke(A, e, l), a[t].m(e, null), i = !0;
    },
    p(A, [l]) {
      let u = t;
      t = o(A), t === u ? a[t].p(A, l) : (er(), ge(a[u], 1, 1, () => {
        a[u] = null;
      }), tr(), n = a[t], n ? n.p(A, l) : (n = a[t] = s[t](A), n.c()), fe(n, 1), n.m(e, null));
    },
    i(A) {
      i || (fe(n), i = !0);
    },
    o(A) {
      ge(n), i = !1;
    },
    d(A) {
      A && xe(e), a[t].d();
    }
  };
}
function vO(r) {
  return Number.isNaN(r.getTime());
}
function yw(r, e = "-") {
  return vO(r) ? e : `${yO(r)}, ${bO(r)}`;
}
function bO(r) {
  const e = { hour: "numeric", minute: "2-digit" };
  return new Intl.DateTimeFormat("en-US", e).format(r);
}
function yO(r) {
  const e = {
    month: "2-digit",
    day: "2-digit",
    year: "numeric"
  };
  return new Date(r).toLocaleDateString("de-DE", e);
}
function wO(r, e, t) {
  let { allTemplates: n } = e;
  const i = eg();
  let s = [];
  function a(p) {
    i("templateDelete", { templateId: p });
  }
  function o(p) {
    i("templateDownload", { templateId: p });
  }
  function A(p) {
    i("editTemplate", { templateId: p });
  }
  function l(p) {
    i("duplicateTemplate", { templateId: p });
  }
  function u(p) {
    s = p, t(1, s);
  }
  const c = (p) => {
    A(p.id);
  }, h = (p) => {
    a(p.id);
  }, f = (p) => {
    l(p.id);
  }, d = (p) => {
    o(p.id);
  };
  return r.$$set = (p) => {
    "allTemplates" in p && t(0, n = p.allTemplates);
  }, [
    n,
    s,
    a,
    o,
    A,
    l,
    u,
    c,
    h,
    f,
    d
  ];
}
class KE extends jt {
  constructor(e) {
    super(), Pt(this, e, wO, mO, Mt, { allTemplates: 0 }, XN);
  }
  get allTemplates() {
    return this.$$.ctx[0];
  }
  set allTemplates(e) {
    this.$$set({ allTemplates: e }), pe();
  }
}
Ht(KE, { allTemplates: {} }, [], [], !0);
function BO(r) {
  Pi(r, "svelte-1xdp4b2", ".tooltip-container.svelte-1xdp4b2{position:relative;display:inline-block}.tooltip.svelte-1xdp4b2{position:absolute;padding:0.5em 1em;background-color:#333;color:white;font-size:0.875rem;border-radius:4px;white-space:nowrap;z-index:10;opacity:0;transform:translateY(10px);transition:opacity 0.2s ease, transform 0.2s ease;max-width:500px;text-wrap:auto}.tooltip.top.svelte-1xdp4b2{bottom:100%;left:50%;transform:translate(-50%, -10px)}.tooltip.bottom.svelte-1xdp4b2{top:100%;left:50%;transform:translate(-50%, 10px)}.tooltip.left.svelte-1xdp4b2{right:100%;top:50%;transform:translate(-10px, -50%)}.tooltip.right.svelte-1xdp4b2{left:100%;top:50%;transform:translate(10px, -50%)}.tooltip.visible.svelte-1xdp4b2{opacity:1;transform:translateY(0)}");
}
function ww(r) {
  let e, t, n;
  return {
    c() {
      e = We("div"), t = ir(
        /*text*/
        r[0]
      ), Me(e, "class", n = "tooltip " + /*position*/
      r[1] + " visible svelte-1xdp4b2");
    },
    m(i, s) {
      ke(i, e, s), je(e, t);
    },
    p(i, s) {
      s & /*text*/
      1 && Ds(
        t,
        /*text*/
        i[0]
      ), s & /*position*/
      2 && n !== (n = "tooltip " + /*position*/
      i[1] + " visible svelte-1xdp4b2") && Me(e, "class", n);
    },
    d(i) {
      i && xe(e);
    }
  };
}
function CO(r) {
  let e, t, n, i, s;
  const a = (
    /*#slots*/
    r[7].default
  ), o = Nt(
    a,
    r,
    /*$$scope*/
    r[6],
    null
  );
  let A = (
    /*isTooltipVisible*/
    r[2] && ww(r)
  );
  return {
    c() {
      e = We("div"), o && o.c(), t = tt(), A && A.c(), Me(e, "class", "tooltip-container svelte-1xdp4b2"), Me(e, "role", "tooltip");
    },
    m(l, u) {
      ke(l, e, u), o && o.m(e, null), je(e, t), A && A.m(e, null), n = !0, i || (s = [
        pt(
          e,
          "mouseenter",
          /*showTooltip*/
          r[3]
        ),
        pt(
          e,
          "mouseleave",
          /*hideTooltip*/
          r[4]
        )
      ], i = !0);
    },
    p(l, [u]) {
      o && o.p && (!n || u & /*$$scope*/
      64) && Qt(
        o,
        a,
        l,
        /*$$scope*/
        l[6],
        n ? Ot(
          a,
          /*$$scope*/
          l[6],
          u,
          null
        ) : Dt(
          /*$$scope*/
          l[6]
        ),
        null
      ), /*isTooltipVisible*/
      l[2] ? A ? A.p(l, u) : (A = ww(l), A.c(), A.m(e, null)) : A && (A.d(1), A = null);
    },
    i(l) {
      n || (fe(o, l), n = !0);
    },
    o(l) {
      ge(o, l), n = !1;
    },
    d(l) {
      l && xe(e), o && o.d(l), A && A.d(), i = !1, fr(s);
    }
  };
}
function _O(r, e, t) {
  let { $$slots: n = {}, $$scope: i } = e, { text: s = "" } = e, { position: a = "top" } = e, { delayInMS: o = 500 } = e, A = !1, l;
  const u = () => {
    l = setTimeout(
      () => {
        t(2, A = !0);
      },
      o
    );
  }, c = () => {
    clearTimeout(l), t(2, A = !1);
  };
  return fo(() => {
    clearTimeout(l);
  }), r.$$set = (h) => {
    "text" in h && t(0, s = h.text), "position" in h && t(1, a = h.position), "delayInMS" in h && t(5, o = h.delayInMS), "$$scope" in h && t(6, i = h.$$scope);
  }, [
    s,
    a,
    A,
    u,
    c,
    o,
    i,
    n
  ];
}
class cu extends jt {
  constructor(e) {
    super(), Pt(this, e, _O, CO, Mt, { text: 0, position: 1, delayInMS: 5 }, BO);
  }
  get text() {
    return this.$$.ctx[0];
  }
  set text(e) {
    this.$$set({ text: e }), pe();
  }
  get position() {
    return this.$$.ctx[1];
  }
  set position(e) {
    this.$$set({ position: e }), pe();
  }
  get delayInMS() {
    return this.$$.ctx[5];
  }
  set delayInMS(e) {
    this.$$set({ delayInMS: e }), pe();
  }
}
Ht(cu, { text: {}, position: {}, delayInMS: {} }, ["default"], [], !0);
function EO(r) {
  let e, t;
  return {
    c() {
      e = We("span"), t = ir(
        /*text*/
        r[0]
      );
    },
    m(n, i) {
      ke(n, e, i), je(e, t);
    },
    p(n, i) {
      i & /*text*/
      1 && Ds(
        t,
        /*text*/
        n[0]
      );
    },
    i: sr,
    o: sr,
    d(n) {
      n && xe(e);
    }
  };
}
function SO(r) {
  let e, t;
  return e = new cu({
    props: {
      text: (
        /*text*/
        r[0]
      ),
      position: (
        /*tooltipPosition*/
        r[1]
      ),
      delayInMS: (
        /*tooltipDelayInMS*/
        r[2]
      ),
      $$slots: { default: [IO] },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      Ve(e.$$.fragment);
    },
    m(n, i) {
      Ke(e, n, i), t = !0;
    },
    p(n, i) {
      const s = {};
      i & /*text*/
      1 && (s.text = /*text*/
      n[0]), i & /*tooltipPosition*/
      2 && (s.position = /*tooltipPosition*/
      n[1]), i & /*tooltipDelayInMS*/
      4 && (s.delayInMS = /*tooltipDelayInMS*/
      n[2]), i & /*$$scope*/
      64 && (s.$$scope = { dirty: i, ctx: n }), e.$set(s);
    },
    i(n) {
      t || (fe(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ge(e.$$.fragment, n), t = !1;
    },
    d(n) {
      $e(e, n);
    }
  };
}
function IO(r) {
  let e;
  return {
    c() {
      e = We("span"), e.textContent = `${/*truncatedText*/
      r[4]}`;
    },
    m(t, n) {
      ke(t, e, n);
    },
    p: sr,
    d(t) {
      t && xe(e);
    }
  };
}
function FO(r) {
  let e, t, n, i;
  const s = [SO, EO], a = [];
  function o(A, l) {
    return (
      /*isTextToBeTruncated*/
      A[3] ? 0 : 1
    );
  }
  return e = o(r), t = a[e] = s[e](r), {
    c() {
      t.c(), n = Or();
    },
    m(A, l) {
      a[e].m(A, l), ke(A, n, l), i = !0;
    },
    p(A, [l]) {
      t.p(A, l);
    },
    i(A) {
      i || (fe(t), i = !0);
    },
    o(A) {
      ge(t), i = !1;
    },
    d(A) {
      A && xe(n), a[e].d(A);
    }
  };
}
function TO(r, e, t) {
  let { text: n = "" } = e, { maxChars: i = 50 } = e, { tooltipPosition: s = "top" } = e, { tooltipDelayInMS: a = 300 } = e, o = n.length > i, A = o ? `${n.slice(0, i)}...` : n;
  return r.$$set = (l) => {
    "text" in l && t(0, n = l.text), "maxChars" in l && t(5, i = l.maxChars), "tooltipPosition" in l && t(1, s = l.tooltipPosition), "tooltipDelayInMS" in l && t(2, a = l.tooltipDelayInMS);
  }, [
    n,
    s,
    a,
    o,
    A,
    i
  ];
}
class V2 extends jt {
  constructor(e) {
    super(), Pt(this, e, TO, FO, Mt, {
      text: 0,
      maxChars: 5,
      tooltipPosition: 1,
      tooltipDelayInMS: 2
    });
  }
  get text() {
    return this.$$.ctx[0];
  }
  set text(e) {
    this.$$set({ text: e }), pe();
  }
  get maxChars() {
    return this.$$.ctx[5];
  }
  set maxChars(e) {
    this.$$set({ maxChars: e }), pe();
  }
  get tooltipPosition() {
    return this.$$.ctx[1];
  }
  set tooltipPosition(e) {
    this.$$set({ tooltipPosition: e }), pe();
  }
  get tooltipDelayInMS() {
    return this.$$.ctx[2];
  }
  set tooltipDelayInMS(e) {
    this.$$set({ tooltipDelayInMS: e }), pe();
  }
}
Ht(V2, { text: {}, maxChars: {}, tooltipPosition: {}, tooltipDelayInMS: {} }, [], [], !0);
function Bw(r) {
  let e;
  return {
    c() {
      e = We("div"), Me(e, "class", "mdc-button__touch");
    },
    m(t, n) {
      ke(t, e, n);
    },
    d(t) {
      t && xe(e);
    }
  };
}
function xO(r) {
  let e, t, n, i;
  const s = (
    /*#slots*/
    r[28].default
  ), a = Nt(
    s,
    r,
    /*$$scope*/
    r[30],
    null
  );
  let o = (
    /*touch*/
    r[6] && Bw()
  );
  return {
    c() {
      e = We("div"), t = tt(), a && a.c(), o && o.c(), n = Or(), Me(e, "class", "mdc-button__ripple");
    },
    m(A, l) {
      ke(A, e, l), ke(A, t, l), a && a.m(A, l), o && o.m(A, l), ke(A, n, l), i = !0;
    },
    p(A, l) {
      a && a.p && (!i || l[0] & /*$$scope*/
      1073741824) && Qt(
        a,
        s,
        A,
        /*$$scope*/
        A[30],
        i ? Ot(
          s,
          /*$$scope*/
          A[30],
          l,
          null
        ) : Dt(
          /*$$scope*/
          A[30]
        ),
        null
      ), /*touch*/
      A[6] ? o || (o = Bw(), o.c(), o.m(n.parentNode, n)) : o && (o.d(1), o = null);
    },
    i(A) {
      i || (fe(a, A), i = !0);
    },
    o(A) {
      ge(a, A), i = !1;
    },
    d(A) {
      A && (xe(e), xe(t), xe(n)), a && a.d(A), o && o.d(A);
    }
  };
}
function kO(r) {
  let e, t, n;
  const i = [
    { tag: (
      /*tag*/
      r[10]
    ) },
    {
      use: [
        [
          io,
          {
            ripple: (
              /*ripple*/
              r[3]
            ),
            unbounded: !1,
            color: (
              /*color*/
              r[4]
            ),
            disabled: !!/*$$restProps*/
            r[23].disabled,
            addClass: (
              /*addClass*/
              r[19]
            ),
            removeClass: (
              /*removeClass*/
              r[20]
            ),
            addStyle: (
              /*addStyle*/
              r[21]
            )
          }
        ],
        /*forwardEvents*/
        r[17],
        .../*use*/
        r[0]
      ]
    },
    {
      class: ht({
        [
          /*className*/
          r[1]
        ]: !0,
        "mdc-button": !0,
        "mdc-button--raised": (
          /*variant*/
          r[5] === "raised"
        ),
        "mdc-button--unelevated": (
          /*variant*/
          r[5] === "unelevated"
        ),
        "mdc-button--outlined": (
          /*variant*/
          r[5] === "outlined"
        ),
        "smui-button--color-secondary": (
          /*color*/
          r[4] === "secondary"
        ),
        "mdc-button--touch": (
          /*touch*/
          r[6]
        ),
        "mdc-card__action": (
          /*context*/
          r[18] === "card:action"
        ),
        "mdc-card__action--button": (
          /*context*/
          r[18] === "card:action"
        ),
        "mdc-dialog__button": (
          /*context*/
          r[18] === "dialog:action"
        ),
        "mdc-top-app-bar__navigation-icon": (
          /*context*/
          r[18] === "top-app-bar:navigation"
        ),
        "mdc-top-app-bar__action-item": (
          /*context*/
          r[18] === "top-app-bar:action"
        ),
        "mdc-snackbar__action": (
          /*context*/
          r[18] === "snackbar:actions"
        ),
        "mdc-banner__secondary-action": (
          /*context*/
          r[18] === "banner" && /*secondary*/
          r[8]
        ),
        "mdc-banner__primary-action": (
          /*context*/
          r[18] === "banner" && !/*secondary*/
          r[8]
        ),
        "mdc-tooltip__action": (
          /*context*/
          r[18] === "tooltip:rich-actions"
        ),
        .../*internalClasses*/
        r[12]
      })
    },
    {
      style: Object.entries(
        /*internalStyles*/
        r[13]
      ).map(Rm).concat([
        /*style*/
        r[2]
      ]).join(" ")
    },
    /*actionProp*/
    r[16],
    /*defaultProp*/
    r[15],
    /*secondaryProp*/
    r[14],
    { href: (
      /*href*/
      r[7]
    ) },
    /*$$restProps*/
    r[23]
  ];
  var s = (
    /*component*/
    r[9]
  );
  function a(o, A) {
    let l = {
      $$slots: { default: [xO] },
      $$scope: { ctx: o }
    };
    for (let u = 0; u < i.length; u += 1)
      l = ze(l, i[u]);
    return A !== void 0 && A[0] & /*tag, ripple, color, $$restProps, addClass, removeClass, addStyle, forwardEvents, use, className, variant, touch, context, secondary, internalClasses, internalStyles, style, actionProp, defaultProp, secondaryProp, href*/
    12580351 && (l = ze(l, Et(i, [
      A[0] & /*tag*/
      1024 && { tag: (
        /*tag*/
        o[10]
      ) },
      A[0] & /*ripple, color, $$restProps, addClass, removeClass, addStyle, forwardEvents, use*/
      12189721 && {
        use: [
          [
            io,
            {
              ripple: (
                /*ripple*/
                o[3]
              ),
              unbounded: !1,
              color: (
                /*color*/
                o[4]
              ),
              disabled: !!/*$$restProps*/
              o[23].disabled,
              addClass: (
                /*addClass*/
                o[19]
              ),
              removeClass: (
                /*removeClass*/
                o[20]
              ),
              addStyle: (
                /*addStyle*/
                o[21]
              )
            }
          ],
          /*forwardEvents*/
          o[17],
          .../*use*/
          o[0]
        ]
      },
      A[0] & /*className, variant, color, touch, context, secondary, internalClasses*/
      266610 && {
        class: ht({
          [
            /*className*/
            o[1]
          ]: !0,
          "mdc-button": !0,
          "mdc-button--raised": (
            /*variant*/
            o[5] === "raised"
          ),
          "mdc-button--unelevated": (
            /*variant*/
            o[5] === "unelevated"
          ),
          "mdc-button--outlined": (
            /*variant*/
            o[5] === "outlined"
          ),
          "smui-button--color-secondary": (
            /*color*/
            o[4] === "secondary"
          ),
          "mdc-button--touch": (
            /*touch*/
            o[6]
          ),
          "mdc-card__action": (
            /*context*/
            o[18] === "card:action"
          ),
          "mdc-card__action--button": (
            /*context*/
            o[18] === "card:action"
          ),
          "mdc-dialog__button": (
            /*context*/
            o[18] === "dialog:action"
          ),
          "mdc-top-app-bar__navigation-icon": (
            /*context*/
            o[18] === "top-app-bar:navigation"
          ),
          "mdc-top-app-bar__action-item": (
            /*context*/
            o[18] === "top-app-bar:action"
          ),
          "mdc-snackbar__action": (
            /*context*/
            o[18] === "snackbar:actions"
          ),
          "mdc-banner__secondary-action": (
            /*context*/
            o[18] === "banner" && /*secondary*/
            o[8]
          ),
          "mdc-banner__primary-action": (
            /*context*/
            o[18] === "banner" && !/*secondary*/
            o[8]
          ),
          "mdc-tooltip__action": (
            /*context*/
            o[18] === "tooltip:rich-actions"
          ),
          .../*internalClasses*/
          o[12]
        })
      },
      A[0] & /*internalStyles, style*/
      8196 && {
        style: Object.entries(
          /*internalStyles*/
          o[13]
        ).map(Rm).concat([
          /*style*/
          o[2]
        ]).join(" ")
      },
      A[0] & /*actionProp*/
      65536 && Vt(
        /*actionProp*/
        o[16]
      ),
      A[0] & /*defaultProp*/
      32768 && Vt(
        /*defaultProp*/
        o[15]
      ),
      A[0] & /*secondaryProp*/
      16384 && Vt(
        /*secondaryProp*/
        o[14]
      ),
      A[0] & /*href*/
      128 && { href: (
        /*href*/
        o[7]
      ) },
      A[0] & /*$$restProps*/
      8388608 && Vt(
        /*$$restProps*/
        o[23]
      )
    ]))), { props: l };
  }
  return s && (e = An(s, a(r)), r[29](e), e.$on(
    "click",
    /*handleClick*/
    r[22]
  )), {
    c() {
      e && Ve(e.$$.fragment), t = Or();
    },
    m(o, A) {
      e && Ke(e, o, A), ke(o, t, A), n = !0;
    },
    p(o, A) {
      if (A[0] & /*component*/
      512 && s !== (s = /*component*/
      o[9])) {
        if (e) {
          er();
          const l = e;
          ge(l.$$.fragment, 1, 0, () => {
            $e(l, 1);
          }), tr();
        }
        s ? (e = An(s, a(o, A)), o[29](e), e.$on(
          "click",
          /*handleClick*/
          o[22]
        ), Ve(e.$$.fragment), fe(e.$$.fragment, 1), Ke(e, t.parentNode, t)) : e = null;
      } else if (s) {
        const l = A[0] & /*tag, ripple, color, $$restProps, addClass, removeClass, addStyle, forwardEvents, use, className, variant, touch, context, secondary, internalClasses, internalStyles, style, actionProp, defaultProp, secondaryProp, href*/
        12580351 ? Et(i, [
          A[0] & /*tag*/
          1024 && { tag: (
            /*tag*/
            o[10]
          ) },
          A[0] & /*ripple, color, $$restProps, addClass, removeClass, addStyle, forwardEvents, use*/
          12189721 && {
            use: [
              [
                io,
                {
                  ripple: (
                    /*ripple*/
                    o[3]
                  ),
                  unbounded: !1,
                  color: (
                    /*color*/
                    o[4]
                  ),
                  disabled: !!/*$$restProps*/
                  o[23].disabled,
                  addClass: (
                    /*addClass*/
                    o[19]
                  ),
                  removeClass: (
                    /*removeClass*/
                    o[20]
                  ),
                  addStyle: (
                    /*addStyle*/
                    o[21]
                  )
                }
              ],
              /*forwardEvents*/
              o[17],
              .../*use*/
              o[0]
            ]
          },
          A[0] & /*className, variant, color, touch, context, secondary, internalClasses*/
          266610 && {
            class: ht({
              [
                /*className*/
                o[1]
              ]: !0,
              "mdc-button": !0,
              "mdc-button--raised": (
                /*variant*/
                o[5] === "raised"
              ),
              "mdc-button--unelevated": (
                /*variant*/
                o[5] === "unelevated"
              ),
              "mdc-button--outlined": (
                /*variant*/
                o[5] === "outlined"
              ),
              "smui-button--color-secondary": (
                /*color*/
                o[4] === "secondary"
              ),
              "mdc-button--touch": (
                /*touch*/
                o[6]
              ),
              "mdc-card__action": (
                /*context*/
                o[18] === "card:action"
              ),
              "mdc-card__action--button": (
                /*context*/
                o[18] === "card:action"
              ),
              "mdc-dialog__button": (
                /*context*/
                o[18] === "dialog:action"
              ),
              "mdc-top-app-bar__navigation-icon": (
                /*context*/
                o[18] === "top-app-bar:navigation"
              ),
              "mdc-top-app-bar__action-item": (
                /*context*/
                o[18] === "top-app-bar:action"
              ),
              "mdc-snackbar__action": (
                /*context*/
                o[18] === "snackbar:actions"
              ),
              "mdc-banner__secondary-action": (
                /*context*/
                o[18] === "banner" && /*secondary*/
                o[8]
              ),
              "mdc-banner__primary-action": (
                /*context*/
                o[18] === "banner" && !/*secondary*/
                o[8]
              ),
              "mdc-tooltip__action": (
                /*context*/
                o[18] === "tooltip:rich-actions"
              ),
              .../*internalClasses*/
              o[12]
            })
          },
          A[0] & /*internalStyles, style*/
          8196 && {
            style: Object.entries(
              /*internalStyles*/
              o[13]
            ).map(Rm).concat([
              /*style*/
              o[2]
            ]).join(" ")
          },
          A[0] & /*actionProp*/
          65536 && Vt(
            /*actionProp*/
            o[16]
          ),
          A[0] & /*defaultProp*/
          32768 && Vt(
            /*defaultProp*/
            o[15]
          ),
          A[0] & /*secondaryProp*/
          16384 && Vt(
            /*secondaryProp*/
            o[14]
          ),
          A[0] & /*href*/
          128 && { href: (
            /*href*/
            o[7]
          ) },
          A[0] & /*$$restProps*/
          8388608 && Vt(
            /*$$restProps*/
            o[23]
          )
        ]) : {};
        A[0] & /*$$scope, touch*/
        1073741888 && (l.$$scope = { dirty: A, ctx: o }), e.$set(l);
      }
    },
    i(o) {
      n || (e && fe(e.$$.fragment, o), n = !0);
    },
    o(o) {
      e && ge(e.$$.fragment, o), n = !1;
    },
    d(o) {
      o && xe(t), r[29](null), e && $e(e, o);
    }
  };
}
const Rm = ([r, e]) => `${r}: ${e};`;
function LO(r, e, t) {
  let n, i, s;
  const a = [
    "use",
    "class",
    "style",
    "ripple",
    "color",
    "variant",
    "touch",
    "href",
    "action",
    "defaultAction",
    "secondary",
    "component",
    "tag",
    "getElement"
  ];
  let o = xt(e, a), { $$slots: A = {}, $$scope: l } = e;
  const u = Kr(yr());
  let { use: c = [] } = e, { class: h = "" } = e, { style: f = "" } = e, { ripple: d = !0 } = e, { color: p = "primary" } = e, { variant: v = "text" } = e, { touch: m = !1 } = e, { href: b = void 0 } = e, { action: w = "close" } = e, { defaultAction: B = !1 } = e, { secondary: _ = !1 } = e, x, C = {}, F = {}, N = pn("SMUI:button:context"), { component: D = Ni } = e, { tag: T = D === Ni ? b == null ? "button" : "a" : void 0 } = e, E = o.disabled;
  Pr("SMUI:label:context", "button"), Pr("SMUI:icon:context", "button");
  function L(O) {
    C[O] || t(12, C[O] = !0, C);
  }
  function S(O) {
    (!(O in C) || C[O]) && t(12, C[O] = !1, C);
  }
  function X(O, J) {
    F[O] != J && (J === "" || J == null ? (delete F[O], t(13, F)) : t(13, F[O] = J, F));
  }
  function z() {
    N === "banner" && pr(R(), _ ? "SMUIBannerButton:secondaryActionClick" : "SMUIBannerButton:primaryActionClick");
  }
  function R() {
    return x.getElement();
  }
  function V(O) {
    yt[O ? "unshift" : "push"](() => {
      x = O, t(11, x);
    });
  }
  return r.$$set = (O) => {
    t(31, e = ze(ze({}, e), Nr(O))), t(23, o = xt(e, a)), "use" in O && t(0, c = O.use), "class" in O && t(1, h = O.class), "style" in O && t(2, f = O.style), "ripple" in O && t(3, d = O.ripple), "color" in O && t(4, p = O.color), "variant" in O && t(5, v = O.variant), "touch" in O && t(6, m = O.touch), "href" in O && t(7, b = O.href), "action" in O && t(24, w = O.action), "defaultAction" in O && t(25, B = O.defaultAction), "secondary" in O && t(8, _ = O.secondary), "component" in O && t(9, D = O.component), "tag" in O && t(10, T = O.tag), "$$scope" in O && t(30, l = O.$$scope);
  }, r.$$.update = () => {
    if (t(16, n = N === "dialog:action" && w != null ? { "data-mdc-dialog-action": w } : { action: e.action }), t(15, i = N === "dialog:action" && B ? { "data-mdc-dialog-button-default": "" } : { default: e.default }), t(14, s = N === "banner" ? {} : { secondary: e.secondary }), E !== o.disabled) {
      if (x) {
        const O = R();
        "blur" in O && O.blur();
      }
      t(27, E = o.disabled);
    }
  }, e = Nr(e), [
    c,
    h,
    f,
    d,
    p,
    v,
    m,
    b,
    _,
    D,
    T,
    x,
    C,
    F,
    s,
    i,
    n,
    u,
    N,
    L,
    S,
    X,
    z,
    o,
    w,
    B,
    R,
    E,
    A,
    V,
    l
  ];
}
class Xo extends jt {
  constructor(e) {
    super(), Pt(
      this,
      e,
      LO,
      kO,
      Mt,
      {
        use: 0,
        class: 1,
        style: 2,
        ripple: 3,
        color: 4,
        variant: 5,
        touch: 6,
        href: 7,
        action: 24,
        defaultAction: 25,
        secondary: 8,
        component: 9,
        tag: 10,
        getElement: 26
      },
      null,
      [-1, -1]
    );
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[1];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get style() {
    return this.$$.ctx[2];
  }
  set style(e) {
    this.$$set({ style: e }), pe();
  }
  get ripple() {
    return this.$$.ctx[3];
  }
  set ripple(e) {
    this.$$set({ ripple: e }), pe();
  }
  get color() {
    return this.$$.ctx[4];
  }
  set color(e) {
    this.$$set({ color: e }), pe();
  }
  get variant() {
    return this.$$.ctx[5];
  }
  set variant(e) {
    this.$$set({ variant: e }), pe();
  }
  get touch() {
    return this.$$.ctx[6];
  }
  set touch(e) {
    this.$$set({ touch: e }), pe();
  }
  get href() {
    return this.$$.ctx[7];
  }
  set href(e) {
    this.$$set({ href: e }), pe();
  }
  get action() {
    return this.$$.ctx[24];
  }
  set action(e) {
    this.$$set({ action: e }), pe();
  }
  get defaultAction() {
    return this.$$.ctx[25];
  }
  set defaultAction(e) {
    this.$$set({ defaultAction: e }), pe();
  }
  get secondary() {
    return this.$$.ctx[8];
  }
  set secondary(e) {
    this.$$set({ secondary: e }), pe();
  }
  get component() {
    return this.$$.ctx[9];
  }
  set component(e) {
    this.$$set({ component: e }), pe();
  }
  get tag() {
    return this.$$.ctx[10];
  }
  set tag(e) {
    this.$$set({ tag: e }), pe();
  }
  get getElement() {
    return this.$$.ctx[26];
  }
}
Ht(Xo, { use: {}, class: {}, style: {}, ripple: { type: "Boolean" }, color: {}, variant: {}, touch: { type: "Boolean" }, href: {}, action: {}, defaultAction: { type: "Boolean" }, secondary: { type: "Boolean" }, component: {}, tag: {} }, ["default"], ["getElement"], !0);
function UO(r) {
  let e, t, n, i, s, a;
  const o = (
    /*#slots*/
    r[8].default
  ), A = Nt(
    o,
    r,
    /*$$scope*/
    r[7],
    null
  );
  let l = [
    {
      class: t = ht({
        [
          /*className*/
          r[1]
        ]: !0,
        "smui-button__group": !0,
        "smui-button__group--raised": (
          /*variant*/
          r[2] === "raised"
        )
      })
    },
    /*$$restProps*/
    r[5]
  ], u = {};
  for (let c = 0; c < l.length; c += 1)
    u = ze(u, l[c]);
  return {
    c() {
      e = We("div"), A && A.c(), Ut(e, u);
    },
    m(c, h) {
      ke(c, e, h), A && A.m(e, null), r[9](e), i = !0, s || (a = [
        Bt(n = xr.call(
          null,
          e,
          /*use*/
          r[0]
        )),
        Bt(
          /*forwardEvents*/
          r[4].call(null, e)
        )
      ], s = !0);
    },
    p(c, [h]) {
      A && A.p && (!i || h & /*$$scope*/
      128) && Qt(
        A,
        o,
        c,
        /*$$scope*/
        c[7],
        i ? Ot(
          o,
          /*$$scope*/
          c[7],
          h,
          null
        ) : Dt(
          /*$$scope*/
          c[7]
        ),
        null
      ), Ut(e, u = Et(l, [
        (!i || h & /*className, variant*/
        6 && t !== (t = ht({
          [
            /*className*/
            c[1]
          ]: !0,
          "smui-button__group": !0,
          "smui-button__group--raised": (
            /*variant*/
            c[2] === "raised"
          )
        }))) && { class: t },
        h & /*$$restProps*/
        32 && /*$$restProps*/
        c[5]
      ])), n && ar(n.update) && h & /*use*/
      1 && n.update.call(
        null,
        /*use*/
        c[0]
      );
    },
    i(c) {
      i || (fe(A, c), i = !0);
    },
    o(c) {
      ge(A, c), i = !1;
    },
    d(c) {
      c && xe(e), A && A.d(c), r[9](null), s = !1, fr(a);
    }
  };
}
function NO(r, e, t) {
  const n = ["use", "class", "variant", "getElement"];
  let i = xt(e, n), { $$slots: s = {}, $$scope: a } = e;
  const o = Kr(yr());
  let { use: A = [] } = e, { class: l = "" } = e, { variant: u = "text" } = e, c;
  function h() {
    return c;
  }
  function f(d) {
    yt[d ? "unshift" : "push"](() => {
      c = d, t(3, c);
    });
  }
  return r.$$set = (d) => {
    e = ze(ze({}, e), Nr(d)), t(5, i = xt(e, n)), "use" in d && t(0, A = d.use), "class" in d && t(1, l = d.class), "variant" in d && t(2, u = d.variant), "$$scope" in d && t(7, a = d.$$scope);
  }, [
    A,
    l,
    u,
    c,
    o,
    i,
    h,
    a,
    s,
    f
  ];
}
class OO extends jt {
  constructor(e) {
    super(), Pt(this, e, NO, UO, Mt, {
      use: 0,
      class: 1,
      variant: 2,
      getElement: 6
    });
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[1];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get variant() {
    return this.$$.ctx[2];
  }
  set variant(e) {
    this.$$set({ variant: e }), pe();
  }
  get getElement() {
    return this.$$.ctx[6];
  }
}
Ht(OO, { use: {}, class: {}, variant: {} }, ["default"], ["getElement"], !0);
function ii(r) {
  this.content = r;
}
ii.prototype = {
  constructor: ii,
  find: function(r) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === r) return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(r) {
    var e = this.find(r);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(r, e, t) {
    var n = t && t != r ? this.remove(t) : this, i = n.find(r), s = n.content.slice();
    return i == -1 ? s.push(t || r, e) : (s[i + 1] = e, t && (s[i] = t)), new ii(s);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(r) {
    var e = this.find(r);
    if (e == -1) return this;
    var t = this.content.slice();
    return t.splice(e, 2), new ii(t);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(r, e) {
    return new ii([r, e].concat(this.remove(r).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(r, e) {
    var t = this.remove(r).content.slice();
    return t.push(r, e), new ii(t);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(r, e, t) {
    var n = this.remove(e), i = n.content.slice(), s = n.find(r);
    return i.splice(s == -1 ? i.length : s, 0, e, t), new ii(i);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(r) {
    for (var e = 0; e < this.content.length; e += 2)
      r(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(r) {
    return r = ii.from(r), r.size ? new ii(r.content.concat(this.subtract(r).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(r) {
    return r = ii.from(r), r.size ? new ii(this.subtract(r).content.concat(r.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(r) {
    var e = this;
    r = ii.from(r);
    for (var t = 0; t < r.content.length; t += 2)
      e = e.remove(r.content[t]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var r = {};
    return this.forEach(function(e, t) {
      r[e] = t;
    }), r;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
ii.from = function(r) {
  if (r instanceof ii) return r;
  var e = [];
  if (r) for (var t in r) e.push(t, r[t]);
  return new ii(e);
};
function $E(r, e, t) {
  for (let n = 0; ; n++) {
    if (n == r.childCount || n == e.childCount)
      return r.childCount == e.childCount ? null : t;
    let i = r.child(n), s = e.child(n);
    if (i == s) {
      t += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(s))
      return t;
    if (i.isText && i.text != s.text) {
      for (let a = 0; i.text[a] == s.text[a]; a++)
        t++;
      return t;
    }
    if (i.content.size || s.content.size) {
      let a = $E(i.content, s.content, t + 1);
      if (a != null)
        return a;
    }
    t += i.nodeSize;
  }
}
function VE(r, e, t, n) {
  for (let i = r.childCount, s = e.childCount; ; ) {
    if (i == 0 || s == 0)
      return i == s ? null : { a: t, b: n };
    let a = r.child(--i), o = e.child(--s), A = a.nodeSize;
    if (a == o) {
      t -= A, n -= A;
      continue;
    }
    if (!a.sameMarkup(o))
      return { a: t, b: n };
    if (a.isText && a.text != o.text) {
      let l = 0, u = Math.min(a.text.length, o.text.length);
      for (; l < u && a.text[a.text.length - l - 1] == o.text[o.text.length - l - 1]; )
        l++, t--, n--;
      return { a: t, b: n };
    }
    if (a.content.size || o.content.size) {
      let l = VE(a.content, o.content, t - 1, n - 1);
      if (l)
        return l;
    }
    t -= A, n -= A;
  }
}
class Ye {
  /**
  @internal
  */
  constructor(e, t) {
    if (this.content = e, this.size = t || 0, t == null)
      for (let n = 0; n < e.length; n++)
        this.size += e[n].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, t, n, i = 0, s) {
    for (let a = 0, o = 0; o < t; a++) {
      let A = this.content[a], l = o + A.nodeSize;
      if (l > e && n(A, i + o, s || null, a) !== !1 && A.content.size) {
        let u = o + 1;
        A.nodesBetween(Math.max(0, e - u), Math.min(A.content.size, t - u), n, i + u);
      }
      o = l;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, t, n, i) {
    let s = "", a = !0;
    return this.nodesBetween(e, t, (o, A) => {
      let l = o.isText ? o.text.slice(Math.max(e, A) - A, t - A) : o.isLeaf ? i ? typeof i == "function" ? i(o) : i : o.type.spec.leafText ? o.type.spec.leafText(o) : "" : "";
      o.isBlock && (o.isLeaf && l || o.isTextblock) && n && (a ? a = !1 : s += n), s += l;
    }, 0), s;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let t = this.lastChild, n = e.firstChild, i = this.content.slice(), s = 0;
    for (t.isText && t.sameMarkup(n) && (i[i.length - 1] = t.withText(t.text + n.text), s = 1); s < e.content.length; s++)
      i.push(e.content[s]);
    return new Ye(i, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, t = this.size) {
    if (e == 0 && t == this.size)
      return this;
    let n = [], i = 0;
    if (t > e)
      for (let s = 0, a = 0; a < t; s++) {
        let o = this.content[s], A = a + o.nodeSize;
        A > e && ((a < e || A > t) && (o.isText ? o = o.cut(Math.max(0, e - a), Math.min(o.text.length, t - a)) : o = o.cut(Math.max(0, e - a - 1), Math.min(o.content.size, t - a - 1))), n.push(o), i += o.nodeSize), a = A;
      }
    return new Ye(n, i);
  }
  /**
  @internal
  */
  cutByIndex(e, t) {
    return e == t ? Ye.empty : e == 0 && t == this.content.length ? this : new Ye(this.content.slice(e, t));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, t) {
    let n = this.content[e];
    if (n == t)
      return this;
    let i = this.content.slice(), s = this.size + t.nodeSize - n.nodeSize;
    return i[e] = t, new Ye(i, s);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new Ye([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new Ye(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let t = 0; t < this.content.length; t++)
      if (!this.content[t].eq(e.content[t]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let t = this.content[e];
    if (!t)
      throw new RangeError("Index " + e + " out of range for " + this);
    return t;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let t = 0, n = 0; t < this.content.length; t++) {
      let i = this.content[t];
      e(i, n, t), n += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, t = 0) {
    return $E(this, e, t);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, t = this.size, n = e.size) {
    return VE(this, e, t, n);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e, t = -1) {
    if (e == 0)
      return Wh(0, e);
    if (e == this.size)
      return Wh(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let n = 0, i = 0; ; n++) {
      let s = this.child(n), a = i + s.nodeSize;
      if (a >= e)
        return a == e || t > 0 ? Wh(n + 1, a) : Wh(n, i);
      i = a;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return Ye.empty;
    if (!Array.isArray(t))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Ye(t.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return Ye.empty;
    let t, n = 0;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      n += s.nodeSize, i && s.isText && e[i - 1].sameMarkup(s) ? (t || (t = e.slice(0, i)), t[t.length - 1] = s.withText(t[t.length - 1].text + s.text)) : t && t.push(s);
    }
    return new Ye(t || e, n);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return Ye.empty;
    if (e instanceof Ye)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new Ye([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
Ye.empty = new Ye([], 0);
const Pm = { index: 0, offset: 0 };
function Wh(r, e) {
  return Pm.index = r, Pm.offset = e, Pm;
}
function yp(r, e) {
  if (r === e)
    return !0;
  if (!(r && typeof r == "object") || !(e && typeof e == "object"))
    return !1;
  let t = Array.isArray(r);
  if (Array.isArray(e) != t)
    return !1;
  if (t) {
    if (r.length != e.length)
      return !1;
    for (let n = 0; n < r.length; n++)
      if (!yp(r[n], e[n]))
        return !1;
  } else {
    for (let n in r)
      if (!(n in e) || !yp(r[n], e[n]))
        return !1;
    for (let n in e)
      if (!(n in r))
        return !1;
  }
  return !0;
}
let Ur = class V1 {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.attrs = t;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let t, n = !1;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (this.eq(s))
        return e;
      if (this.type.excludes(s.type))
        t || (t = e.slice(0, i));
      else {
        if (s.type.excludes(this.type))
          return e;
        !n && s.type.rank > this.type.rank && (t || (t = e.slice(0, i)), t.push(this), n = !0), t && t.push(s);
      }
    }
    return t || (t = e.slice()), n || t.push(this), t;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return e.slice(0, t).concat(e.slice(t + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && yp(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let n = e.marks[t.type];
    if (!n)
      throw new RangeError(`There is no mark type ${t.type} in this schema`);
    let i = n.create(t.attrs);
    return n.checkAttrs(i.attrs), i;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, t) {
    if (e == t)
      return !0;
    if (e.length != t.length)
      return !1;
    for (let n = 0; n < e.length; n++)
      if (!e[n].eq(t[n]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return V1.none;
    if (e instanceof V1)
      return [e];
    let t = e.slice();
    return t.sort((n, i) => n.type.rank - i.type.rank), t;
  }
};
Ur.none = [];
class wp extends Error {
}
class lt {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, t, n) {
    this.content = e, this.openStart = t, this.openEnd = n;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, t) {
    let n = GE(this.content, e + this.openStart, t);
    return n && new lt(n, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, t) {
    return new lt(zE(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return lt.empty;
    let n = t.openStart || 0, i = t.openEnd || 0;
    if (typeof n != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new lt(Ye.fromJSON(e, t.content), n, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, t = !0) {
    let n = 0, i = 0;
    for (let s = e.firstChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.firstChild)
      n++;
    for (let s = e.lastChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.lastChild)
      i++;
    return new lt(e, n, i);
  }
}
lt.empty = new lt(Ye.empty, 0, 0);
function zE(r, e, t) {
  let { index: n, offset: i } = r.findIndex(e), s = r.maybeChild(n), { index: a, offset: o } = r.findIndex(t);
  if (i == e || s.isText) {
    if (o != t && !r.child(a).isText)
      throw new RangeError("Removing non-flat range");
    return r.cut(0, e).append(r.cut(t));
  }
  if (n != a)
    throw new RangeError("Removing non-flat range");
  return r.replaceChild(n, s.copy(zE(s.content, e - i - 1, t - i - 1)));
}
function GE(r, e, t, n) {
  let { index: i, offset: s } = r.findIndex(e), a = r.maybeChild(i);
  if (s == e || a.isText)
    return r.cut(0, e).append(t).append(r.cut(e));
  let o = GE(a.content, e - s - 1, t);
  return o && r.replaceChild(i, a.copy(o));
}
function QO(r, e, t) {
  if (t.openStart > r.depth)
    throw new wp("Inserted content deeper than insertion position");
  if (r.depth - t.openStart != e.depth - t.openEnd)
    throw new wp("Inconsistent open depths");
  return qE(r, e, t, 0);
}
function qE(r, e, t, n) {
  let i = r.index(n), s = r.node(n);
  if (i == e.index(n) && n < r.depth - t.openStart) {
    let a = qE(r, e, t, n + 1);
    return s.copy(s.content.replaceChild(i, a));
  } else if (t.content.size)
    if (!t.openStart && !t.openEnd && r.depth == n && e.depth == n) {
      let a = r.parent, o = a.content;
      return WA(a, o.cut(0, r.parentOffset).append(t.content).append(o.cut(e.parentOffset)));
    } else {
      let { start: a, end: o } = DO(t, r);
      return WA(s, XE(r, a, o, e, n));
    }
  else return WA(s, Bp(r, e, n));
}
function WE(r, e) {
  if (!e.type.compatibleContent(r.type))
    throw new wp("Cannot join " + e.type.name + " onto " + r.type.name);
}
function z1(r, e, t) {
  let n = r.node(t);
  return WE(n, e.node(t)), n;
}
function qA(r, e) {
  let t = e.length - 1;
  t >= 0 && r.isText && r.sameMarkup(e[t]) ? e[t] = r.withText(e[t].text + r.text) : e.push(r);
}
function Xc(r, e, t, n) {
  let i = (e || r).node(t), s = 0, a = e ? e.index(t) : i.childCount;
  r && (s = r.index(t), r.depth > t ? s++ : r.textOffset && (qA(r.nodeAfter, n), s++));
  for (let o = s; o < a; o++)
    qA(i.child(o), n);
  e && e.depth == t && e.textOffset && qA(e.nodeBefore, n);
}
function WA(r, e) {
  return r.type.checkContent(e), r.copy(e);
}
function XE(r, e, t, n, i) {
  let s = r.depth > i && z1(r, e, i + 1), a = n.depth > i && z1(t, n, i + 1), o = [];
  return Xc(null, r, i, o), s && a && e.index(i) == t.index(i) ? (WE(s, a), qA(WA(s, XE(r, e, t, n, i + 1)), o)) : (s && qA(WA(s, Bp(r, e, i + 1)), o), Xc(e, t, i, o), a && qA(WA(a, Bp(t, n, i + 1)), o)), Xc(n, null, i, o), new Ye(o);
}
function Bp(r, e, t) {
  let n = [];
  if (Xc(null, r, t, n), r.depth > t) {
    let i = z1(r, e, t + 1);
    qA(WA(i, Bp(r, e, t + 1)), n);
  }
  return Xc(e, null, t, n), new Ye(n);
}
function DO(r, e) {
  let t = e.depth - r.openStart, i = e.node(t).copy(r.content);
  for (let s = t - 1; s >= 0; s--)
    i = e.node(s).copy(Ye.from(i));
  return {
    start: i.resolveNoCache(r.openStart + t),
    end: i.resolveNoCache(i.content.size - r.openEnd - t)
  };
}
class gf {
  /**
  @internal
  */
  constructor(e, t, n) {
    this.pos = e, this.path = t, this.parentOffset = n, this.depth = t.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, t = this.index(this.depth);
    if (t == e.childCount)
      return null;
    let n = this.pos - this.path[this.path.length - 1], i = e.child(t);
    return n ? e.child(t).cut(n) : i;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1];
    return t ? this.parent.child(e).cut(0, t) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, t) {
    t = this.resolveDepth(t);
    let n = this.path[t * 3], i = t == 0 ? 0 : this.path[t * 3 - 1] + 1;
    for (let s = 0; s < e; s++)
      i += n.child(s).nodeSize;
    return i;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, t = this.index();
    if (e.content.size == 0)
      return Ur.none;
    if (this.textOffset)
      return e.child(t).marks;
    let n = e.maybeChild(t - 1), i = e.maybeChild(t);
    if (!n) {
      let o = n;
      n = i, i = o;
    }
    let s = n.marks;
    for (var a = 0; a < s.length; a++)
      s[a].type.spec.inclusive === !1 && (!i || !s[a].isInSet(i.marks)) && (s = s[a--].removeFromSet(s));
    return s;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let t = this.parent.maybeChild(this.index());
    if (!t || !t.isInline)
      return null;
    let n = t.marks, i = e.parent.maybeChild(e.index());
    for (var s = 0; s < n.length; s++)
      n[s].type.spec.inclusive === !1 && (!i || !n[s].isInSet(i.marks)) && (n = n[s--].removeFromSet(n));
    return n;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let t = this.depth; t > 0; t--)
      if (this.start(t) <= e && this.end(t) >= e)
        return t;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, t) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let n = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); n >= 0; n--)
      if (e.pos <= this.end(n) && (!t || t(this.node(n))))
        return new Cp(this, e, n);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 1; t <= this.depth; t++)
      e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, t) {
    if (!(t >= 0 && t <= e.content.size))
      throw new RangeError("Position " + t + " out of range");
    let n = [], i = 0, s = t;
    for (let a = e; ; ) {
      let { index: o, offset: A } = a.content.findIndex(s), l = s - A;
      if (n.push(a, o, i + A), !l || (a = a.child(o), a.isText))
        break;
      s = l - 1, i += A + 1;
    }
    return new gf(t, n, s);
  }
  /**
  @internal
  */
  static resolveCached(e, t) {
    let n = Cw.get(e);
    if (n)
      for (let s = 0; s < n.elts.length; s++) {
        let a = n.elts[s];
        if (a.pos == t)
          return a;
      }
    else
      Cw.set(e, n = new MO());
    let i = n.elts[n.i] = gf.resolve(e, t);
    return n.i = (n.i + 1) % RO, i;
  }
}
class MO {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const RO = 12, Cw = /* @__PURE__ */ new WeakMap();
class Cp {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, t, n) {
    this.$from = e, this.$to = t, this.depth = n;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const PO = /* @__PURE__ */ Object.create(null);
let Jo = class G1 {
  /**
  @internal
  */
  constructor(e, t, n, i = Ur.none) {
    this.type = e, this.attrs = t, this.marks = i, this.content = n || Ye.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, t, n, i = 0) {
    this.content.nodesBetween(e, t, n, i, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(e, t, n, i) {
    return this.content.textBetween(e, t, n, i);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, t, n) {
    return this.type == e && yp(this.attrs, t || e.defaultAttrs || PO) && Ur.sameSet(this.marks, n || Ur.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new G1(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new G1(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, t = this.content.size) {
    return e == 0 && t == this.content.size ? this : this.copy(this.content.cut(e, t));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, t = this.content.size, n = !1) {
    if (e == t)
      return lt.empty;
    let i = this.resolve(e), s = this.resolve(t), a = n ? 0 : i.sharedDepth(t), o = i.start(a), l = i.node(a).content.cut(i.pos - o, s.pos - o);
    return new lt(l, i.depth - a, s.depth - a);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, t, n) {
    return QO(this.resolve(e), this.resolve(t), n);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let t = this; ; ) {
      let { index: n, offset: i } = t.content.findIndex(e);
      if (t = t.maybeChild(n), !t)
        return null;
      if (i == e || t.isText)
        return t;
      e -= i + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: t, offset: n } = this.content.findIndex(e);
    return { node: this.content.maybeChild(t), index: t, offset: n };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: t, offset: n } = this.content.findIndex(e);
    if (n < e)
      return { node: this.content.child(t), index: t, offset: n };
    let i = this.content.child(t - 1);
    return { node: i, index: t - 1, offset: n - i.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return gf.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return gf.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, t, n) {
    let i = !1;
    return t > e && this.nodesBetween(e, t, (s) => (n.isInSet(s.marks) && (i = !0), !i)), i;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), JE(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let t = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!t)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return t;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, t, n = Ye.empty, i = 0, s = n.childCount) {
    let a = this.contentMatchAt(e).matchFragment(n, i, s), o = a && a.matchFragment(this.content, t);
    if (!o || !o.validEnd)
      return !1;
    for (let A = i; A < s; A++)
      if (!this.type.allowsMarks(n.child(A).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, t, n, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let s = this.contentMatchAt(e).matchType(n), a = s && s.matchFragment(this.content, t);
    return a ? a.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = Ur.none;
    for (let t = 0; t < this.marks.length; t++) {
      let n = this.marks[t];
      n.type.checkAttrs(n.attrs), e = n.addToSet(e);
    }
    if (!Ur.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((t) => t.type.name)}`);
    this.content.forEach((t) => t.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((t) => t.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Node.fromJSON");
    let n;
    if (t.marks) {
      if (!Array.isArray(t.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      n = t.marks.map(e.markFromJSON);
    }
    if (t.type == "text") {
      if (typeof t.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(t.text, n);
    }
    let i = Ye.fromJSON(e, t.content), s = e.nodeType(t.type).create(t.attrs, i, n);
    return s.type.checkAttrs(s.attrs), s;
  }
};
Jo.prototype.text = void 0;
let HO = class q1 extends Jo {
  /**
  @internal
  */
  constructor(e, t, n, i) {
    if (super(e, t, null, i), !n)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = n;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : JE(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, t) {
    return this.text.slice(e, t);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new q1(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new q1(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, t = this.text.length) {
    return e == 0 && t == this.text.length ? this : this.withText(this.text.slice(e, t));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
};
function JE(r, e) {
  for (let t = r.length - 1; t >= 0; t--)
    e = r[t].type.name + "(" + e + ")";
  return e;
}
class al {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, t) {
    let n = new jO(e, t);
    if (n.next == null)
      return al.empty;
    let i = YE(n);
    n.next && n.err("Unexpected trailing text");
    let s = WO(qO(i));
    return XO(s, n), s;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let t = 0; t < this.next.length; t++)
      if (this.next[t].type == e)
        return this.next[t].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, t = 0, n = e.childCount) {
    let i = this;
    for (let s = t; i && s < n; s++)
      i = i.matchType(e.child(s).type);
    return i;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: t } = this.next[e];
      if (!(t.isText || t.hasRequiredAttrs()))
        return t;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let t = 0; t < this.next.length; t++)
      for (let n = 0; n < e.next.length; n++)
        if (this.next[t].type == e.next[n].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, t = !1, n = 0) {
    let i = [this];
    function s(a, o) {
      let A = a.matchFragment(e, n);
      if (A && (!t || A.validEnd))
        return Ye.from(o.map((l) => l.createAndFill()));
      for (let l = 0; l < a.next.length; l++) {
        let { type: u, next: c } = a.next[l];
        if (!(u.isText || u.hasRequiredAttrs()) && i.indexOf(c) == -1) {
          i.push(c);
          let h = s(c, o.concat(u));
          if (h)
            return h;
        }
      }
      return null;
    }
    return s(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let n = 0; n < this.wrapCache.length; n += 2)
      if (this.wrapCache[n] == e)
        return this.wrapCache[n + 1];
    let t = this.computeWrapping(e);
    return this.wrapCache.push(e, t), t;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let t = /* @__PURE__ */ Object.create(null), n = [{ match: this, type: null, via: null }];
    for (; n.length; ) {
      let i = n.shift(), s = i.match;
      if (s.matchType(e)) {
        let a = [];
        for (let o = i; o.type; o = o.via)
          a.push(o.type);
        return a.reverse();
      }
      for (let a = 0; a < s.next.length; a++) {
        let { type: o, next: A } = s.next[a];
        !o.isLeaf && !o.hasRequiredAttrs() && !(o.name in t) && (!i.type || A.validEnd) && (n.push({ match: o.contentMatch, type: o, via: i }), t[o.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function t(n) {
      e.push(n);
      for (let i = 0; i < n.next.length; i++)
        e.indexOf(n.next[i].next) == -1 && t(n.next[i].next);
    }
    return t(this), e.map((n, i) => {
      let s = i + (n.validEnd ? "*" : " ") + " ";
      for (let a = 0; a < n.next.length; a++)
        s += (a ? ", " : "") + n.next[a].type.name + "->" + e.indexOf(n.next[a].next);
      return s;
    }).join(`
`);
  }
}
al.empty = new al(!0);
class jO {
  constructor(e, t) {
    this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function YE(r) {
  let e = [];
  do
    e.push(KO(r));
  while (r.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function KO(r) {
  let e = [];
  do
    e.push($O(r));
  while (r.next && r.next != ")" && r.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function $O(r) {
  let e = GO(r);
  for (; ; )
    if (r.eat("+"))
      e = { type: "plus", expr: e };
    else if (r.eat("*"))
      e = { type: "star", expr: e };
    else if (r.eat("?"))
      e = { type: "opt", expr: e };
    else if (r.eat("{"))
      e = VO(r, e);
    else
      break;
  return e;
}
function _w(r) {
  /\D/.test(r.next) && r.err("Expected number, got '" + r.next + "'");
  let e = Number(r.next);
  return r.pos++, e;
}
function VO(r, e) {
  let t = _w(r), n = t;
  return r.eat(",") && (r.next != "}" ? n = _w(r) : n = -1), r.eat("}") || r.err("Unclosed braced range"), { type: "range", min: t, max: n, expr: e };
}
function zO(r, e) {
  let t = r.nodeTypes, n = t[e];
  if (n)
    return [n];
  let i = [];
  for (let s in t) {
    let a = t[s];
    a.isInGroup(e) && i.push(a);
  }
  return i.length == 0 && r.err("No node type or group '" + e + "' found"), i;
}
function GO(r) {
  if (r.eat("(")) {
    let e = YE(r);
    return r.eat(")") || r.err("Missing closing paren"), e;
  } else if (/\W/.test(r.next))
    r.err("Unexpected token '" + r.next + "'");
  else {
    let e = zO(r, r.next).map((t) => (r.inline == null ? r.inline = t.isInline : r.inline != t.isInline && r.err("Mixing inline and block content"), { type: "name", value: t }));
    return r.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function qO(r) {
  let e = [[]];
  return i(s(r, 0), t()), e;
  function t() {
    return e.push([]) - 1;
  }
  function n(a, o, A) {
    let l = { term: A, to: o };
    return e[a].push(l), l;
  }
  function i(a, o) {
    a.forEach((A) => A.to = o);
  }
  function s(a, o) {
    if (a.type == "choice")
      return a.exprs.reduce((A, l) => A.concat(s(l, o)), []);
    if (a.type == "seq")
      for (let A = 0; ; A++) {
        let l = s(a.exprs[A], o);
        if (A == a.exprs.length - 1)
          return l;
        i(l, o = t());
      }
    else if (a.type == "star") {
      let A = t();
      return n(o, A), i(s(a.expr, A), A), [n(A)];
    } else if (a.type == "plus") {
      let A = t();
      return i(s(a.expr, o), A), i(s(a.expr, A), A), [n(A)];
    } else {
      if (a.type == "opt")
        return [n(o)].concat(s(a.expr, o));
      if (a.type == "range") {
        let A = o;
        for (let l = 0; l < a.min; l++) {
          let u = t();
          i(s(a.expr, A), u), A = u;
        }
        if (a.max == -1)
          i(s(a.expr, A), A);
        else
          for (let l = a.min; l < a.max; l++) {
            let u = t();
            n(A, u), i(s(a.expr, A), u), A = u;
          }
        return [n(A)];
      } else {
        if (a.type == "name")
          return [n(o, void 0, a.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function ZE(r, e) {
  return e - r;
}
function Ew(r, e) {
  let t = [];
  return n(e), t.sort(ZE);
  function n(i) {
    let s = r[i];
    if (s.length == 1 && !s[0].term)
      return n(s[0].to);
    t.push(i);
    for (let a = 0; a < s.length; a++) {
      let { term: o, to: A } = s[a];
      !o && t.indexOf(A) == -1 && n(A);
    }
  }
}
function WO(r) {
  let e = /* @__PURE__ */ Object.create(null);
  return t(Ew(r, 0));
  function t(n) {
    let i = [];
    n.forEach((a) => {
      r[a].forEach(({ term: o, to: A }) => {
        if (!o)
          return;
        let l;
        for (let u = 0; u < i.length; u++)
          i[u][0] == o && (l = i[u][1]);
        Ew(r, A).forEach((u) => {
          l || i.push([o, l = []]), l.indexOf(u) == -1 && l.push(u);
        });
      });
    });
    let s = e[n.join(",")] = new al(n.indexOf(r.length - 1) > -1);
    for (let a = 0; a < i.length; a++) {
      let o = i[a][1].sort(ZE);
      s.next.push({ type: i[a][0], next: e[o.join(",")] || t(o) });
    }
    return s;
  }
}
function XO(r, e) {
  for (let t = 0, n = [r]; t < n.length; t++) {
    let i = n[t], s = !i.validEnd, a = [];
    for (let o = 0; o < i.next.length; o++) {
      let { type: A, next: l } = i.next[o];
      a.push(A.name), s && !(A.isText || A.hasRequiredAttrs()) && (s = !1), n.indexOf(l) == -1 && n.push(l);
    }
    s && e.err("Only non-generatable nodes (" + a.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function eS(r) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in r) {
    let n = r[t];
    if (!n.hasDefault)
      return null;
    e[t] = n.default;
  }
  return e;
}
function tS(r, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n in r) {
    let i = e && e[n];
    if (i === void 0) {
      let s = r[n];
      if (s.hasDefault)
        i = s.default;
      else
        throw new RangeError("No value supplied for attribute " + n);
    }
    t[n] = i;
  }
  return t;
}
function rS(r, e, t, n) {
  for (let i in e)
    if (!(i in r))
      throw new RangeError(`Unsupported attribute ${i} for ${t} of type ${i}`);
  for (let i in r) {
    let s = r[i];
    s.validate && s.validate(e[i]);
  }
}
function nS(r, e) {
  let t = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let n in e)
      t[n] = new YO(r, n, e[n]);
  return t;
}
let Sw = class iS {
  /**
  @internal
  */
  constructor(e, t, n) {
    this.name = e, this.schema = t, this.spec = n, this.markSet = null, this.groups = n.group ? n.group.split(" ") : [], this.attrs = nS(e, n.attrs), this.defaultAttrs = eS(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(n.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == al.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : tS(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, t, n) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Jo(this, this.computeAttrs(e), Ye.from(t), Ur.setFrom(n));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, t, n) {
    return t = Ye.from(t), this.checkContent(t), new Jo(this, this.computeAttrs(e), t, Ur.setFrom(n));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, t, n) {
    if (e = this.computeAttrs(e), t = Ye.from(t), t.size) {
      let a = this.contentMatch.fillBefore(t);
      if (!a)
        return null;
      t = a.append(t);
    }
    let i = this.contentMatch.matchFragment(t), s = i && i.fillBefore(Ye.empty, !0);
    return s ? new Jo(this, e, t.append(s), Ur.setFrom(n)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let t = this.contentMatch.matchFragment(e);
    if (!t || !t.validEnd)
      return !1;
    for (let n = 0; n < e.childCount; n++)
      if (!this.allowsMarks(e.child(n).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    rS(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let t = 0; t < e.length; t++)
      if (!this.allowsMarkType(e[t].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let t;
    for (let n = 0; n < e.length; n++)
      this.allowsMarkType(e[n].type) ? t && t.push(e[n]) : t || (t = e.slice(0, n));
    return t ? t.length ? t : Ur.none : e;
  }
  /**
  @internal
  */
  static compile(e, t) {
    let n = /* @__PURE__ */ Object.create(null);
    e.forEach((s, a) => n[s] = new iS(s, t, a));
    let i = t.spec.topNode || "doc";
    if (!n[i])
      throw new RangeError("Schema is missing its top node type ('" + i + "')");
    if (!n.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let s in n.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return n;
  }
};
function JO(r, e, t) {
  let n = t.split("|");
  return (i) => {
    let s = i === null ? "null" : typeof i;
    if (n.indexOf(s) < 0)
      throw new RangeError(`Expected value of type ${n} for attribute ${e} on type ${r}, got ${s}`);
  };
}
class YO {
  constructor(e, t, n) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(n, "default"), this.default = n.default, this.validate = typeof n.validate == "string" ? JO(e, t, n.validate) : n.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class ig {
  /**
  @internal
  */
  constructor(e, t, n, i) {
    this.name = e, this.rank = t, this.schema = n, this.spec = i, this.attrs = nS(e, i.attrs), this.excluded = null;
    let s = eS(this.attrs);
    this.instance = s ? new Ur(this, s) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new Ur(this, tS(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, t) {
    let n = /* @__PURE__ */ Object.create(null), i = 0;
    return e.forEach((s, a) => n[s] = new ig(s, i++, t, a)), n;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var t = 0; t < e.length; t++)
      e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].type == this)
        return e[t];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    rS(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class sS {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let t = this.spec = {};
    for (let i in e)
      t[i] = e[i];
    t.nodes = ii.from(e.nodes), t.marks = ii.from(e.marks || {}), this.nodes = Sw.compile(this.spec.nodes, this), this.marks = ig.compile(this.spec.marks, this);
    let n = /* @__PURE__ */ Object.create(null);
    for (let i in this.nodes) {
      if (i in this.marks)
        throw new RangeError(i + " can not be both a node and a mark");
      let s = this.nodes[i], a = s.spec.content || "", o = s.spec.marks;
      if (s.contentMatch = n[a] || (n[a] = al.parse(a, this.nodes)), s.inlineContent = s.contentMatch.inlineContent, s.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!s.isInline || !s.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = s;
      }
      s.markSet = o == "_" ? null : o ? Iw(this, o.split(" ")) : o == "" || !s.inlineContent ? [] : null;
    }
    for (let i in this.marks) {
      let s = this.marks[i], a = s.spec.excludes;
      s.excluded = a == null ? [s] : a == "" ? [] : Iw(this, a.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, t = null, n, i) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof Sw) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(t, n, i);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, t) {
    let n = this.nodes.text;
    return new HO(n, n.defaultAttrs, e, Ur.setFrom(t));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, t) {
    return typeof e == "string" && (e = this.marks[e]), e.create(t);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(e) {
    return Jo.fromJSON(this, e);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(e) {
    return Ur.fromJSON(this, e);
  }
  /**
  @internal
  */
  nodeType(e) {
    let t = this.nodes[e];
    if (!t)
      throw new RangeError("Unknown node type: " + e);
    return t;
  }
}
function Iw(r, e) {
  let t = [];
  for (let n = 0; n < e.length; n++) {
    let i = e[n], s = r.marks[i], a = s;
    if (s)
      t.push(s);
    else
      for (let o in r.marks) {
        let A = r.marks[o];
        (i == "_" || A.spec.group && A.spec.group.split(" ").indexOf(i) > -1) && t.push(a = A);
      }
    if (!a)
      throw new SyntaxError("Unknown mark type: '" + e[n] + "'");
  }
  return t;
}
function ZO(r) {
  return r.tag != null;
}
function e6(r) {
  return r.style != null;
}
let Jc = class W1 {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, t) {
    this.schema = e, this.rules = t, this.tags = [], this.styles = [];
    let n = this.matchedStyles = [];
    t.forEach((i) => {
      if (ZO(i))
        this.tags.push(i);
      else if (e6(i)) {
        let s = /[^=]*/.exec(i.style)[0];
        n.indexOf(s) < 0 && n.push(s), this.styles.push(i);
      }
    }), this.normalizeLists = !this.tags.some((i) => {
      if (!/^(ul|ol)\b/.test(i.tag) || !i.node)
        return !1;
      let s = e.nodes[i.node];
      return s.contentMatch.matchType(s);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, t = {}) {
    let n = new Tw(this, t, !1);
    return n.addAll(e, Ur.none, t.from, t.to), n.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, t = {}) {
    let n = new Tw(this, t, !0);
    return n.addAll(e, Ur.none, t.from, t.to), lt.maxOpen(n.finish());
  }
  /**
  @internal
  */
  matchTag(e, t, n) {
    for (let i = n ? this.tags.indexOf(n) + 1 : 0; i < this.tags.length; i++) {
      let s = this.tags[i];
      if (n6(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || t.matchesContext(s.context))) {
        if (s.getAttrs) {
          let a = s.getAttrs(e);
          if (a === !1)
            continue;
          s.attrs = a || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, t, n, i) {
    for (let s = i ? this.styles.indexOf(i) + 1 : 0; s < this.styles.length; s++) {
      let a = this.styles[s], o = a.style;
      if (!(o.indexOf(e) != 0 || a.context && !n.matchesContext(a.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      o.length > e.length && (o.charCodeAt(e.length) != 61 || o.slice(e.length + 1) != t))) {
        if (a.getAttrs) {
          let A = a.getAttrs(t);
          if (A === !1)
            continue;
          a.attrs = A || void 0;
        }
        return a;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let t = [];
    function n(i) {
      let s = i.priority == null ? 50 : i.priority, a = 0;
      for (; a < t.length; a++) {
        let o = t[a];
        if ((o.priority == null ? 50 : o.priority) < s)
          break;
      }
      t.splice(a, 0, i);
    }
    for (let i in e.marks) {
      let s = e.marks[i].spec.parseDOM;
      s && s.forEach((a) => {
        n(a = xw(a)), a.mark || a.ignore || a.clearMark || (a.mark = i);
      });
    }
    for (let i in e.nodes) {
      let s = e.nodes[i].spec.parseDOM;
      s && s.forEach((a) => {
        n(a = xw(a)), a.node || a.ignore || a.mark || (a.node = i);
      });
    }
    return t;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new W1(e, W1.schemaRules(e)));
  }
};
const aS = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, t6 = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, oS = { ol: !0, ul: !0 }, mf = 1, X1 = 2, Yc = 4;
function Fw(r, e, t) {
  return e != null ? (e ? mf : 0) | (e === "full" ? X1 : 0) : r && r.whitespace == "pre" ? mf | X1 : t & ~Yc;
}
class Xh {
  constructor(e, t, n, i, s, a) {
    this.type = e, this.attrs = t, this.marks = n, this.solid = i, this.options = a, this.content = [], this.activeMarks = Ur.none, this.match = s || (a & Yc ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let t = this.type.contentMatch.fillBefore(Ye.from(e));
      if (t)
        this.match = this.type.contentMatch.matchFragment(t);
      else {
        let n = this.type.contentMatch, i;
        return (i = n.findWrapping(e.type)) ? (this.match = n, i) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & mf)) {
      let n = this.content[this.content.length - 1], i;
      if (n && n.isText && (i = /[ \t\r\n\u000c]+$/.exec(n.text))) {
        let s = n;
        n.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - i[0].length));
      }
    }
    let t = Ye.from(this.content);
    return !e && this.match && (t = t.append(this.match.fillBefore(Ye.empty, !0))), this.type ? this.type.create(this.attrs, t, this.marks) : t;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !aS.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class Tw {
  constructor(e, t, n) {
    this.parser = e, this.options = t, this.isOpen = n, this.open = 0, this.localPreserveWS = !1;
    let i = t.topNode, s, a = Fw(null, t.preserveWhitespace, 0) | (n ? Yc : 0);
    i ? s = new Xh(i.type, i.attrs, Ur.none, !0, t.topMatch || i.type.contentMatch, a) : n ? s = new Xh(null, null, Ur.none, !0, null, a) : s = new Xh(e.schema.topNodeType, null, Ur.none, !0, null, a), this.nodes = [s], this.find = t.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, t) {
    e.nodeType == 3 ? this.addTextNode(e, t) : e.nodeType == 1 && this.addElement(e, t);
  }
  addTextNode(e, t) {
    let n = e.nodeValue, i = this.top, s = i.options & X1 ? "full" : this.localPreserveWS || (i.options & mf) > 0;
    if (s === "full" || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(n)) {
      if (s)
        s !== "full" ? n = n.replace(/\r?\n|\r/g, " ") : n = n.replace(/\r\n?/g, `
`);
      else if (n = n.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(n) && this.open == this.nodes.length - 1) {
        let a = i.content[i.content.length - 1], o = e.previousSibling;
        (!a || o && o.nodeName == "BR" || a.isText && /[ \t\r\n\u000c]$/.test(a.text)) && (n = n.slice(1));
      }
      n && this.insertNode(this.parser.schema.text(n), t), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, t, n) {
    let i = this.localPreserveWS, s = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
    let a = e.nodeName.toLowerCase(), o;
    oS.hasOwnProperty(a) && this.parser.normalizeLists && r6(e);
    let A = this.options.ruleFromNode && this.options.ruleFromNode(e) || (o = this.parser.matchTag(e, this, n));
    e: if (A ? A.ignore : t6.hasOwnProperty(a))
      this.findInside(e), this.ignoreFallback(e, t);
    else if (!A || A.skip || A.closeParent) {
      A && A.closeParent ? this.open = Math.max(0, this.open - 1) : A && A.skip.nodeType && (e = A.skip);
      let l, u = this.needsBlock;
      if (aS.hasOwnProperty(a))
        s.content.length && s.content[0].isInline && this.open && (this.open--, s = this.top), l = !0, s.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, t);
        break e;
      }
      let c = A && A.skip ? t : this.readStyles(e, t);
      c && this.addAll(e, c), l && this.sync(s), this.needsBlock = u;
    } else {
      let l = this.readStyles(e, t);
      l && this.addElementByRule(e, A, l, A.consuming === !1 ? o : void 0);
    }
    this.localPreserveWS = i;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, t) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), t);
  }
  // Called for ignored nodes
  ignoreFallback(e, t) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), t);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, t) {
    let n = e.style;
    if (n && n.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let s = this.parser.matchedStyles[i], a = n.getPropertyValue(s);
        if (a)
          for (let o = void 0; ; ) {
            let A = this.parser.matchStyle(s, a, this, o);
            if (!A)
              break;
            if (A.ignore)
              return null;
            if (A.clearMark ? t = t.filter((l) => !A.clearMark(l)) : t = t.concat(this.parser.schema.marks[A.mark].create(A.attrs)), A.consuming === !1)
              o = A;
            else
              break;
          }
      }
    return t;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, t, n, i) {
    let s, a;
    if (t.node)
      if (a = this.parser.schema.nodes[t.node], a.isLeaf)
        this.insertNode(a.create(t.attrs), n) || this.leafFallback(e, n);
      else {
        let A = this.enter(a, t.attrs || null, n, t.preserveWhitespace);
        A && (s = !0, n = A);
      }
    else {
      let A = this.parser.schema.marks[t.mark];
      n = n.concat(A.create(t.attrs));
    }
    let o = this.top;
    if (a && a.isLeaf)
      this.findInside(e);
    else if (i)
      this.addElement(e, n, i);
    else if (t.getContent)
      this.findInside(e), t.getContent(e, this.parser.schema).forEach((A) => this.insertNode(A, n));
    else {
      let A = e;
      typeof t.contentElement == "string" ? A = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? A = t.contentElement(e) : t.contentElement && (A = t.contentElement), this.findAround(e, A, !0), this.addAll(A, n), this.findAround(e, A, !1);
    }
    s && this.sync(o) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, t, n, i) {
    let s = n || 0;
    for (let a = n ? e.childNodes[n] : e.firstChild, o = i == null ? null : e.childNodes[i]; a != o; a = a.nextSibling, ++s)
      this.findAtPoint(e, s), this.addDOM(a, t);
    this.findAtPoint(e, s);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, t) {
    let n, i;
    for (let s = this.open; s >= 0; s--) {
      let a = this.nodes[s], o = a.findWrapping(e);
      if (o && (!n || n.length > o.length) && (n = o, i = a, !o.length) || a.solid)
        break;
    }
    if (!n)
      return null;
    this.sync(i);
    for (let s = 0; s < n.length; s++)
      t = this.enterInner(n[s], null, t, !1);
    return t;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, t) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let i = this.textblockFromContext();
      i && (t = this.enterInner(i, null, t));
    }
    let n = this.findPlace(e, t);
    if (n) {
      this.closeExtra();
      let i = this.top;
      i.match && (i.match = i.match.matchType(e.type));
      let s = Ur.none;
      for (let a of n.concat(e.marks))
        (i.type ? i.type.allowsMarkType(a.type) : kw(a.type, e.type)) && (s = a.addToSet(s));
      return i.content.push(e.mark(s)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, t, n, i) {
    let s = this.findPlace(e.create(t), n);
    return s && (s = this.enterInner(e, t, n, !0, i)), s;
  }
  // Open a node of the given type
  enterInner(e, t, n, i = !1, s) {
    this.closeExtra();
    let a = this.top;
    a.match = a.match && a.match.matchType(e);
    let o = Fw(e, s, a.options);
    a.options & Yc && a.content.length == 0 && (o |= Yc);
    let A = Ur.none;
    return n = n.filter((l) => (a.type ? a.type.allowsMarkType(l.type) : kw(l.type, e)) ? (A = l.addToSet(A), !1) : !0), this.nodes.push(new Xh(e, t, A, i, null, o)), this.open++, n;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let t = this.nodes.length - 1;
    if (t > this.open) {
      for (; t > this.open; t--)
        this.nodes[t - 1].content.push(this.nodes[t].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let t = this.open; t >= 0; t--) {
      if (this.nodes[t] == e)
        return this.open = t, !0;
      this.localPreserveWS && (this.nodes[t].options |= mf);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let t = this.open; t >= 0; t--) {
      let n = this.nodes[t].content;
      for (let i = n.length - 1; i >= 0; i--)
        e += n[i].nodeSize;
      t && e++;
    }
    return e;
  }
  findAtPoint(e, t) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e && this.find[n].offset == t && (this.find[n].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos);
  }
  findAround(e, t, n) {
    if (e != t && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && t.compareDocumentPosition(this.find[i].node) & (n ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let t = e.split("/"), n = this.options.context, i = !this.isOpen && (!n || n.parent.type == this.nodes[0].type), s = -(n ? n.depth + 1 : 0) + (i ? 0 : 1), a = (o, A) => {
      for (; o >= 0; o--) {
        let l = t[o];
        if (l == "") {
          if (o == t.length - 1 || o == 0)
            continue;
          for (; A >= s; A--)
            if (a(o - 1, A))
              return !0;
          return !1;
        } else {
          let u = A > 0 || A == 0 && i ? this.nodes[A].type : n && A >= s ? n.node(A - s).type : null;
          if (!u || u.name != l && !u.isInGroup(l))
            return !1;
          A--;
        }
      }
      return !0;
    };
    return a(t.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let t = e.depth; t >= 0; t--) {
        let n = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;
        if (n && n.isTextblock && n.defaultAttrs)
          return n;
      }
    for (let t in this.parser.schema.nodes) {
      let n = this.parser.schema.nodes[t];
      if (n.isTextblock && n.defaultAttrs)
        return n;
    }
  }
}
function r6(r) {
  for (let e = r.firstChild, t = null; e; e = e.nextSibling) {
    let n = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    n && oS.hasOwnProperty(n) && t ? (t.appendChild(e), e = t) : n == "li" ? t = e : n && (t = null);
  }
}
function n6(r, e) {
  return (r.matches || r.msMatchesSelector || r.webkitMatchesSelector || r.mozMatchesSelector).call(r, e);
}
function xw(r) {
  let e = {};
  for (let t in r)
    e[t] = r[t];
  return e;
}
function kw(r, e) {
  let t = e.schema.nodes;
  for (let n in t) {
    let i = t[n];
    if (!i.allowsMarkType(r))
      continue;
    let s = [], a = (o) => {
      s.push(o);
      for (let A = 0; A < o.edgeCount; A++) {
        let { type: l, next: u } = o.edge(A);
        if (l == e || s.indexOf(u) < 0 && a(u))
          return !0;
      }
    };
    if (a(i.contentMatch))
      return !0;
  }
}
class ul {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, t) {
    this.nodes = e, this.marks = t;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, t = {}, n) {
    n || (n = Hm(t).createDocumentFragment());
    let i = n, s = [];
    return e.forEach((a) => {
      if (s.length || a.marks.length) {
        let o = 0, A = 0;
        for (; o < s.length && A < a.marks.length; ) {
          let l = a.marks[A];
          if (!this.marks[l.type.name]) {
            A++;
            continue;
          }
          if (!l.eq(s[o][0]) || l.type.spec.spanning === !1)
            break;
          o++, A++;
        }
        for (; o < s.length; )
          i = s.pop()[1];
        for (; A < a.marks.length; ) {
          let l = a.marks[A++], u = this.serializeMark(l, a.isInline, t);
          u && (s.push([l, i]), i.appendChild(u.dom), i = u.contentDOM || u.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(a, t));
    }), n;
  }
  /**
  @internal
  */
  serializeNodeInner(e, t) {
    let { dom: n, contentDOM: i } = tp(Hm(t), this.nodes[e.type.name](e), null, e.attrs);
    if (i) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, t, i);
    }
    return n;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, t = {}) {
    let n = this.serializeNodeInner(e, t);
    for (let i = e.marks.length - 1; i >= 0; i--) {
      let s = this.serializeMark(e.marks[i], e.isInline, t);
      s && ((s.contentDOM || s.dom).appendChild(n), n = s.dom);
    }
    return n;
  }
  /**
  @internal
  */
  serializeMark(e, t, n = {}) {
    let i = this.marks[e.type.name];
    return i && tp(Hm(n), i(e, t), null, e.attrs);
  }
  static renderSpec(e, t, n = null, i) {
    return tp(e, t, n, i);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new ul(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let t = Lw(e.nodes);
    return t.text || (t.text = (n) => n.text), t;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return Lw(e.marks);
  }
}
function Lw(r) {
  let e = {};
  for (let t in r) {
    let n = r[t].spec.toDOM;
    n && (e[t] = n);
  }
  return e;
}
function Hm(r) {
  return r.document || window.document;
}
const Uw = /* @__PURE__ */ new WeakMap();
function i6(r) {
  let e = Uw.get(r);
  return e === void 0 && Uw.set(r, e = s6(r)), e;
}
function s6(r) {
  let e = null;
  function t(n) {
    if (n && typeof n == "object")
      if (Array.isArray(n))
        if (typeof n[0] == "string")
          e || (e = []), e.push(n);
        else
          for (let i = 0; i < n.length; i++)
            t(n[i]);
      else
        for (let i in n)
          t(n[i]);
  }
  return t(r), e;
}
function tp(r, e, t, n) {
  if (typeof e == "string")
    return { dom: r.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let i = e[0], s;
  if (typeof i != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (n && (s = i6(n)) && s.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let a = i.indexOf(" ");
  a > 0 && (t = i.slice(0, a), i = i.slice(a + 1));
  let o, A = t ? r.createElementNS(t, i) : r.createElement(i), l = e[1], u = 1;
  if (l && typeof l == "object" && l.nodeType == null && !Array.isArray(l)) {
    u = 2;
    for (let c in l)
      if (l[c] != null) {
        let h = c.indexOf(" ");
        h > 0 ? A.setAttributeNS(c.slice(0, h), c.slice(h + 1), l[c]) : A.setAttribute(c, l[c]);
      }
  }
  for (let c = u; c < e.length; c++) {
    let h = e[c];
    if (h === 0) {
      if (c < e.length - 1 || c > u)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: A, contentDOM: A };
    } else {
      let { dom: f, contentDOM: d } = tp(r, h, t, n);
      if (A.appendChild(f), d) {
        if (o)
          throw new RangeError("Multiple content holes");
        o = d;
      }
    }
  }
  return { dom: A, contentDOM: o };
}
const AS = 65535, lS = Math.pow(2, 16);
function a6(r, e) {
  return r + e * lS;
}
function Nw(r) {
  return r & AS;
}
function o6(r) {
  return (r - (r & AS)) / lS;
}
const uS = 1, cS = 2, rp = 4, fS = 8;
class J1 {
  /**
  @internal
  */
  constructor(e, t, n) {
    this.pos = e, this.delInfo = t, this.recover = n;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & fS) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (uS | rp)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (cS | rp)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & rp) > 0;
  }
}
class ls {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, t = !1) {
    if (this.ranges = e, this.inverted = t, !e.length && ls.empty)
      return ls.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let t = 0, n = Nw(e);
    if (!this.inverted)
      for (let i = 0; i < n; i++)
        t += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[n * 3] + t + o6(e);
  }
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  map(e, t = 1) {
    return this._map(e, t, !0);
  }
  /**
  @internal
  */
  _map(e, t, n) {
    let i = 0, s = this.inverted ? 2 : 1, a = this.inverted ? 1 : 2;
    for (let o = 0; o < this.ranges.length; o += 3) {
      let A = this.ranges[o] - (this.inverted ? i : 0);
      if (A > e)
        break;
      let l = this.ranges[o + s], u = this.ranges[o + a], c = A + l;
      if (e <= c) {
        let h = l ? e == A ? -1 : e == c ? 1 : t : t, f = A + i + (h < 0 ? 0 : u);
        if (n)
          return f;
        let d = e == (t < 0 ? A : c) ? null : a6(o / 3, e - A), p = e == A ? cS : e == c ? uS : rp;
        return (t < 0 ? e != A : e != c) && (p |= fS), new J1(f, p, d);
      }
      i += u - l;
    }
    return n ? e + i : new J1(e + i, 0, null);
  }
  /**
  @internal
  */
  touches(e, t) {
    let n = 0, i = Nw(t), s = this.inverted ? 2 : 1, a = this.inverted ? 1 : 2;
    for (let o = 0; o < this.ranges.length; o += 3) {
      let A = this.ranges[o] - (this.inverted ? n : 0);
      if (A > e)
        break;
      let l = this.ranges[o + s], u = A + l;
      if (e <= u && o == i * 3)
        return !0;
      n += this.ranges[o + a] - l;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let t = this.inverted ? 2 : 1, n = this.inverted ? 1 : 2;
    for (let i = 0, s = 0; i < this.ranges.length; i += 3) {
      let a = this.ranges[i], o = a - (this.inverted ? s : 0), A = a + (this.inverted ? 0 : s), l = this.ranges[i + t], u = this.ranges[i + n];
      e(o, o + l, A, A + u), s += u - l;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new ls(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? ls.empty : new ls(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
ls.empty = new ls([]);
class yu {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e = [], t, n = 0, i = e.length) {
    this.maps = e, this.mirror = t, this.from = n, this.to = i;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, t = this.maps.length) {
    return new yu(this.maps, this.mirror, e, t);
  }
  /**
  @internal
  */
  copy() {
    return new yu(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, t) {
    this.to = this.maps.push(e), t != null && this.setMirror(this.maps.length - 1, t);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let t = 0, n = this.maps.length; t < e.maps.length; t++) {
      let i = e.getMirror(t);
      this.appendMap(e.maps[t], i != null && i < t ? n + i : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let t = 0; t < this.mirror.length; t++)
        if (this.mirror[t] == e)
          return this.mirror[t + (t % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, t) {
    this.mirror || (this.mirror = []), this.mirror.push(e, t);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let t = e.maps.length - 1, n = this.maps.length + e.maps.length; t >= 0; t--) {
      let i = e.getMirror(t);
      this.appendMap(e.maps[t].invert(), i != null && i > t ? n - i - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new yu();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, t = 1) {
    if (this.mirror)
      return this._map(e, t, !0);
    for (let n = this.from; n < this.to; n++)
      e = this.maps[n].map(e, t);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  /**
  @internal
  */
  _map(e, t, n) {
    let i = 0;
    for (let s = this.from; s < this.to; s++) {
      let a = this.maps[s], o = a.mapResult(e, t);
      if (o.recover != null) {
        let A = this.getMirror(s);
        if (A != null && A > s && A < this.to) {
          s = A, e = this.maps[A].recover(o.recover);
          continue;
        }
      }
      i |= o.delInfo, e = o.pos;
    }
    return n ? e : new J1(e, i, null);
  }
}
const jm = /* @__PURE__ */ Object.create(null);
class Ii {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return ls.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, t) {
    if (!t || !t.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let n = jm[t.stepType];
    if (!n)
      throw new RangeError(`No step type ${t.stepType} defined`);
    return n.fromJSON(e, t);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, t) {
    if (e in jm)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return jm[e] = t, t.prototype.jsonID = e, t;
  }
}
class Un {
  /**
  @internal
  */
  constructor(e, t) {
    this.doc = e, this.failed = t;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new Un(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new Un(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, t, n, i) {
    try {
      return Un.ok(e.replace(t, n, i));
    } catch (s) {
      if (s instanceof wp)
        return Un.fail(s.message);
      throw s;
    }
  }
}
function z2(r, e, t) {
  let n = [];
  for (let i = 0; i < r.childCount; i++) {
    let s = r.child(i);
    s.content.size && (s = s.copy(z2(s.content, e, s))), s.isInline && (s = e(s, t, i)), n.push(s);
  }
  return Ye.fromArray(n);
}
class Ko extends Ii {
  /**
  Create a mark step.
  */
  constructor(e, t, n) {
    super(), this.from = e, this.to = t, this.mark = n;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), n = e.resolve(this.from), i = n.node(n.sharedDepth(this.to)), s = new lt(z2(t.content, (a, o) => !a.isAtom || !o.type.allowsMarkType(this.mark.type) ? a : a.mark(this.mark.addToSet(a.marks)), i), t.openStart, t.openEnd);
    return Un.fromReplace(e, this.from, this.to, s);
  }
  invert() {
    return new Ca(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1);
    return t.deleted && n.deleted || t.pos >= n.pos ? null : new Ko(t.pos, n.pos, this.mark);
  }
  merge(e) {
    return e instanceof Ko && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Ko(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new Ko(t.from, t.to, e.markFromJSON(t.mark));
  }
}
Ii.jsonID("addMark", Ko);
class Ca extends Ii {
  /**
  Create a mark-removing step.
  */
  constructor(e, t, n) {
    super(), this.from = e, this.to = t, this.mark = n;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), n = new lt(z2(t.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e), t.openStart, t.openEnd);
    return Un.fromReplace(e, this.from, this.to, n);
  }
  invert() {
    return new Ko(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1);
    return t.deleted && n.deleted || t.pos >= n.pos ? null : new Ca(t.pos, n.pos, this.mark);
  }
  merge(e) {
    return e instanceof Ca && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Ca(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new Ca(t.from, t.to, e.markFromJSON(t.mark));
  }
}
Ii.jsonID("removeMark", Ca);
class $o extends Ii {
  /**
  Create a node mark step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return Un.fail("No node at mark step's position");
    let n = t.type.create(t.attrs, null, this.mark.addToSet(t.marks));
    return Un.fromReplace(e, this.pos, this.pos + 1, new lt(Ye.from(n), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    if (t) {
      let n = this.mark.addToSet(t.marks);
      if (n.length == t.marks.length) {
        for (let i = 0; i < t.marks.length; i++)
          if (!t.marks[i].isInSet(n))
            return new $o(this.pos, t.marks[i]);
        return new $o(this.pos, this.mark);
      }
    }
    return new Fu(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new $o(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new $o(t.pos, e.markFromJSON(t.mark));
  }
}
Ii.jsonID("addNodeMark", $o);
class Fu extends Ii {
  /**
  Create a mark-removing step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return Un.fail("No node at mark step's position");
    let n = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks));
    return Un.fromReplace(e, this.pos, this.pos + 1, new lt(Ye.from(n), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    return !t || !this.mark.isInSet(t.marks) ? this : new $o(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new Fu(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new Fu(t.pos, e.markFromJSON(t.mark));
  }
}
Ii.jsonID("removeNodeMark", Fu);
class Vn extends Ii {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, t, n, i = !1) {
    super(), this.from = e, this.to = t, this.slice = n, this.structure = i;
  }
  apply(e) {
    return this.structure && Y1(e, this.from, this.to) ? Un.fail("Structure replace would overwrite content") : Un.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new ls([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new Vn(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1);
    return t.deletedAcross && n.deletedAcross ? null : new Vn(t.pos, Math.max(t.pos, n.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof Vn) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let t = this.slice.size + e.slice.size == 0 ? lt.empty : new lt(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new Vn(this.from, this.to + (e.to - e.from), t, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let t = this.slice.size + e.slice.size == 0 ? lt.empty : new lt(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new Vn(e.from, this.to, t, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new Vn(t.from, t.to, lt.fromJSON(e, t.slice), !!t.structure);
  }
}
Ii.jsonID("replace", Vn);
class qn extends Ii {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, t, n, i, s, a, o = !1) {
    super(), this.from = e, this.to = t, this.gapFrom = n, this.gapTo = i, this.slice = s, this.insert = a, this.structure = o;
  }
  apply(e) {
    if (this.structure && (Y1(e, this.from, this.gapFrom) || Y1(e, this.gapTo, this.to)))
      return Un.fail("Structure gap-replace would overwrite content");
    let t = e.slice(this.gapFrom, this.gapTo);
    if (t.openStart || t.openEnd)
      return Un.fail("Gap is not a flat range");
    let n = this.slice.insertAt(this.insert, t.content);
    return n ? Un.fromReplace(e, this.from, this.to, n) : Un.fail("Content does not fit in gap");
  }
  getMap() {
    return new ls([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let t = this.gapTo - this.gapFrom;
    return new qn(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1), i = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1), s = this.to == this.gapTo ? n.pos : e.map(this.gapTo, 1);
    return t.deletedAcross && n.deletedAcross || i < t.pos || s > n.pos ? null : new qn(t.pos, n.pos, i, s, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new qn(t.from, t.to, t.gapFrom, t.gapTo, lt.fromJSON(e, t.slice), t.insert, !!t.structure);
  }
}
Ii.jsonID("replaceAround", qn);
function Y1(r, e, t) {
  let n = r.resolve(e), i = t - e, s = n.depth;
  for (; i > 0 && s > 0 && n.indexAfter(s) == n.node(s).childCount; )
    s--, i--;
  if (i > 0) {
    let a = n.node(s).maybeChild(n.indexAfter(s));
    for (; i > 0; ) {
      if (!a || a.isLeaf)
        return !0;
      a = a.firstChild, i--;
    }
  }
  return !1;
}
function A6(r, e, t, n) {
  let i = [], s = [], a, o;
  r.doc.nodesBetween(e, t, (A, l, u) => {
    if (!A.isInline)
      return;
    let c = A.marks;
    if (!n.isInSet(c) && u.type.allowsMarkType(n.type)) {
      let h = Math.max(l, e), f = Math.min(l + A.nodeSize, t), d = n.addToSet(c);
      for (let p = 0; p < c.length; p++)
        c[p].isInSet(d) || (a && a.to == h && a.mark.eq(c[p]) ? a.to = f : i.push(a = new Ca(h, f, c[p])));
      o && o.to == h ? o.to = f : s.push(o = new Ko(h, f, n));
    }
  }), i.forEach((A) => r.step(A)), s.forEach((A) => r.step(A));
}
function l6(r, e, t, n) {
  let i = [], s = 0;
  r.doc.nodesBetween(e, t, (a, o) => {
    if (!a.isInline)
      return;
    s++;
    let A = null;
    if (n instanceof ig) {
      let l = a.marks, u;
      for (; u = n.isInSet(l); )
        (A || (A = [])).push(u), l = u.removeFromSet(l);
    } else n ? n.isInSet(a.marks) && (A = [n]) : A = a.marks;
    if (A && A.length) {
      let l = Math.min(o + a.nodeSize, t);
      for (let u = 0; u < A.length; u++) {
        let c = A[u], h;
        for (let f = 0; f < i.length; f++) {
          let d = i[f];
          d.step == s - 1 && c.eq(i[f].style) && (h = d);
        }
        h ? (h.to = l, h.step = s) : i.push({ style: c, from: Math.max(o, e), to: l, step: s });
      }
    }
  }), i.forEach((a) => r.step(new Ca(a.from, a.to, a.style)));
}
function G2(r, e, t, n = t.contentMatch, i = !0) {
  let s = r.doc.nodeAt(e), a = [], o = e + 1;
  for (let A = 0; A < s.childCount; A++) {
    let l = s.child(A), u = o + l.nodeSize, c = n.matchType(l.type);
    if (!c)
      a.push(new Vn(o, u, lt.empty));
    else {
      n = c;
      for (let h = 0; h < l.marks.length; h++)
        t.allowsMarkType(l.marks[h].type) || r.step(new Ca(o, u, l.marks[h]));
      if (i && l.isText && t.whitespace != "pre") {
        let h, f = /\r?\n|\r/g, d;
        for (; h = f.exec(l.text); )
          d || (d = new lt(Ye.from(t.schema.text(" ", t.allowedMarks(l.marks))), 0, 0)), a.push(new Vn(o + h.index, o + h.index + h[0].length, d));
      }
    }
    o = u;
  }
  if (!n.validEnd) {
    let A = n.fillBefore(Ye.empty, !0);
    r.replace(o, o, new lt(A, 0, 0));
  }
  for (let A = a.length - 1; A >= 0; A--)
    r.step(a[A]);
}
function u6(r, e, t) {
  return (e == 0 || r.canReplace(e, r.childCount)) && (t == r.childCount || r.canReplace(0, t));
}
function Mu(r) {
  let t = r.parent.content.cutByIndex(r.startIndex, r.endIndex);
  for (let n = r.depth; ; --n) {
    let i = r.$from.node(n), s = r.$from.index(n), a = r.$to.indexAfter(n);
    if (n < r.depth && i.canReplace(s, a, t))
      return n;
    if (n == 0 || i.type.spec.isolating || !u6(i, s, a))
      break;
  }
  return null;
}
function c6(r, e, t) {
  let { $from: n, $to: i, depth: s } = e, a = n.before(s + 1), o = i.after(s + 1), A = a, l = o, u = Ye.empty, c = 0;
  for (let d = s, p = !1; d > t; d--)
    p || n.index(d) > 0 ? (p = !0, u = Ye.from(n.node(d).copy(u)), c++) : A--;
  let h = Ye.empty, f = 0;
  for (let d = s, p = !1; d > t; d--)
    p || i.after(d + 1) < i.end(d) ? (p = !0, h = Ye.from(i.node(d).copy(h)), f++) : l++;
  r.step(new qn(A, l, a, o, new lt(u.append(h), c, f), u.size - c, !0));
}
function q2(r, e, t = null, n = r) {
  let i = f6(r, e), s = i && h6(n, e);
  return s ? i.map(Ow).concat({ type: e, attrs: t }).concat(s.map(Ow)) : null;
}
function Ow(r) {
  return { type: r, attrs: null };
}
function f6(r, e) {
  let { parent: t, startIndex: n, endIndex: i } = r, s = t.contentMatchAt(n).findWrapping(e);
  if (!s)
    return null;
  let a = s.length ? s[0] : e;
  return t.canReplaceWith(n, i, a) ? s : null;
}
function h6(r, e) {
  let { parent: t, startIndex: n, endIndex: i } = r, s = t.child(n), a = e.contentMatch.findWrapping(s.type);
  if (!a)
    return null;
  let A = (a.length ? a[a.length - 1] : e).contentMatch;
  for (let l = n; A && l < i; l++)
    A = A.matchType(t.child(l).type);
  return !A || !A.validEnd ? null : a;
}
function d6(r, e, t) {
  let n = Ye.empty;
  for (let a = t.length - 1; a >= 0; a--) {
    if (n.size) {
      let o = t[a].type.contentMatch.matchFragment(n);
      if (!o || !o.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    n = Ye.from(t[a].type.create(t[a].attrs, n));
  }
  let i = e.start, s = e.end;
  r.step(new qn(i, s, i, s, new lt(n, 0, 0), t.length, !0));
}
function p6(r, e, t, n, i) {
  if (!n.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let s = r.steps.length;
  r.doc.nodesBetween(e, t, (a, o) => {
    let A = typeof i == "function" ? i(a) : i;
    if (a.isTextblock && !a.hasMarkup(n, A) && g6(r.doc, r.mapping.slice(s).map(o), n)) {
      let l = null;
      if (n.schema.linebreakReplacement) {
        let f = n.whitespace == "pre", d = !!n.contentMatch.matchType(n.schema.linebreakReplacement);
        f && !d ? l = !1 : !f && d && (l = !0);
      }
      l === !1 && dS(r, a, o, s), G2(r, r.mapping.slice(s).map(o, 1), n, void 0, l === null);
      let u = r.mapping.slice(s), c = u.map(o, 1), h = u.map(o + a.nodeSize, 1);
      return r.step(new qn(c, h, c + 1, h - 1, new lt(Ye.from(n.create(A, null, a.marks)), 0, 0), 1, !0)), l === !0 && hS(r, a, o, s), !1;
    }
  });
}
function hS(r, e, t, n) {
  e.forEach((i, s) => {
    if (i.isText) {
      let a, o = /\r?\n|\r/g;
      for (; a = o.exec(i.text); ) {
        let A = r.mapping.slice(n).map(t + 1 + s + a.index);
        r.replaceWith(A, A + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function dS(r, e, t, n) {
  e.forEach((i, s) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      let a = r.mapping.slice(n).map(t + 1 + s);
      r.replaceWith(a, a + 1, e.type.schema.text(`
`));
    }
  });
}
function g6(r, e, t) {
  let n = r.resolve(e), i = n.index();
  return n.parent.canReplaceWith(i, i + 1, t);
}
function m6(r, e, t, n, i) {
  let s = r.doc.nodeAt(e);
  if (!s)
    throw new RangeError("No node at given position");
  t || (t = s.type);
  let a = t.create(n, null, i || s.marks);
  if (s.isLeaf)
    return r.replaceWith(e, e + s.nodeSize, a);
  if (!t.validContent(s.content))
    throw new RangeError("Invalid content for node type " + t.name);
  r.step(new qn(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new lt(Ye.from(a), 0, 0), 1, !0));
}
function wu(r, e, t = 1, n) {
  let i = r.resolve(e), s = i.depth - t, a = n && n[n.length - 1] || i.parent;
  if (s < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !a.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
    return !1;
  for (let l = i.depth - 1, u = t - 2; l > s; l--, u--) {
    let c = i.node(l), h = i.index(l);
    if (c.type.spec.isolating)
      return !1;
    let f = c.content.cutByIndex(h, c.childCount), d = n && n[u + 1];
    d && (f = f.replaceChild(0, d.type.create(d.attrs)));
    let p = n && n[u] || c;
    if (!c.canReplace(h + 1, c.childCount) || !p.type.validContent(f))
      return !1;
  }
  let o = i.indexAfter(s), A = n && n[0];
  return i.node(s).canReplaceWith(o, o, A ? A.type : i.node(s + 1).type);
}
function v6(r, e, t = 1, n) {
  let i = r.doc.resolve(e), s = Ye.empty, a = Ye.empty;
  for (let o = i.depth, A = i.depth - t, l = t - 1; o > A; o--, l--) {
    s = Ye.from(i.node(o).copy(s));
    let u = n && n[l];
    a = Ye.from(u ? u.type.create(u.attrs, a) : i.node(o).copy(a));
  }
  r.step(new Vn(e, e, new lt(s.append(a), t, t), !0));
}
function uA(r, e) {
  let t = r.resolve(e), n = t.index();
  return pS(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(n, n + 1);
}
function b6(r, e) {
  e.content.size || r.type.compatibleContent(e.type);
  let t = r.contentMatchAt(r.childCount), { linebreakReplacement: n } = r.type.schema;
  for (let i = 0; i < e.childCount; i++) {
    let s = e.child(i), a = s.type == n ? r.type.schema.nodes.text : s.type;
    if (t = t.matchType(a), !t || !r.type.allowsMarks(s.marks))
      return !1;
  }
  return t.validEnd;
}
function pS(r, e) {
  return !!(r && e && !r.isLeaf && b6(r, e));
}
function sg(r, e, t = -1) {
  let n = r.resolve(e);
  for (let i = n.depth; ; i--) {
    let s, a, o = n.index(i);
    if (i == n.depth ? (s = n.nodeBefore, a = n.nodeAfter) : t > 0 ? (s = n.node(i + 1), o++, a = n.node(i).maybeChild(o)) : (s = n.node(i).maybeChild(o - 1), a = n.node(i + 1)), s && !s.isTextblock && pS(s, a) && n.node(i).canReplace(o, o + 1))
      return e;
    if (i == 0)
      break;
    e = t < 0 ? n.before(i) : n.after(i);
  }
}
function y6(r, e, t) {
  let n = null, { linebreakReplacement: i } = r.doc.type.schema, s = r.doc.resolve(e - t), a = s.node().type;
  if (i && a.inlineContent) {
    let u = a.whitespace == "pre", c = !!a.contentMatch.matchType(i);
    u && !c ? n = !1 : !u && c && (n = !0);
  }
  let o = r.steps.length;
  if (n === !1) {
    let u = r.doc.resolve(e + t);
    dS(r, u.node(), u.before(), o);
  }
  a.inlineContent && G2(r, e + t - 1, a, s.node().contentMatchAt(s.index()), n == null);
  let A = r.mapping.slice(o), l = A.map(e - t);
  if (r.step(new Vn(l, A.map(e + t, -1), lt.empty, !0)), n === !0) {
    let u = r.doc.resolve(l);
    hS(r, u.node(), u.before(), r.steps.length);
  }
  return r;
}
function w6(r, e, t) {
  let n = r.resolve(e);
  if (n.parent.canReplaceWith(n.index(), n.index(), t))
    return e;
  if (n.parentOffset == 0)
    for (let i = n.depth - 1; i >= 0; i--) {
      let s = n.index(i);
      if (n.node(i).canReplaceWith(s, s, t))
        return n.before(i + 1);
      if (s > 0)
        return null;
    }
  if (n.parentOffset == n.parent.content.size)
    for (let i = n.depth - 1; i >= 0; i--) {
      let s = n.indexAfter(i);
      if (n.node(i).canReplaceWith(s, s, t))
        return n.after(i + 1);
      if (s < n.node(i).childCount)
        return null;
    }
  return null;
}
function gS(r, e, t) {
  let n = r.resolve(e);
  if (!t.content.size)
    return e;
  let i = t.content;
  for (let s = 0; s < t.openStart; s++)
    i = i.firstChild.content;
  for (let s = 1; s <= (t.openStart == 0 && t.size ? 2 : 1); s++)
    for (let a = n.depth; a >= 0; a--) {
      let o = a == n.depth ? 0 : n.pos <= (n.start(a + 1) + n.end(a + 1)) / 2 ? -1 : 1, A = n.index(a) + (o > 0 ? 1 : 0), l = n.node(a), u = !1;
      if (s == 1)
        u = l.canReplace(A, A, i);
      else {
        let c = l.contentMatchAt(A).findWrapping(i.firstChild.type);
        u = c && l.canReplaceWith(A, A, c[0]);
      }
      if (u)
        return o == 0 ? n.pos : o < 0 ? n.before(a + 1) : n.after(a + 1);
    }
  return null;
}
function ag(r, e, t = e, n = lt.empty) {
  if (e == t && !n.size)
    return null;
  let i = r.resolve(e), s = r.resolve(t);
  return mS(i, s, n) ? new Vn(e, t, n) : new B6(i, s, n).fit();
}
function mS(r, e, t) {
  return !t.openStart && !t.openEnd && r.start() == e.start() && r.parent.canReplace(r.index(), e.index(), t.content);
}
class B6 {
  constructor(e, t, n) {
    this.$from = e, this.$to = t, this.unplaced = n, this.frontier = [], this.placed = Ye.empty;
    for (let i = 0; i <= e.depth; i++) {
      let s = e.node(i);
      this.frontier.push({
        type: s.type,
        match: s.contentMatchAt(e.indexAfter(i))
      });
    }
    for (let i = e.depth; i > 0; i--)
      this.placed = Ye.from(e.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let l = this.findFittable();
      l ? this.placeNodes(l) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, n = this.$from, i = this.close(e < 0 ? this.$to : n.doc.resolve(e));
    if (!i)
      return null;
    let s = this.placed, a = n.depth, o = i.depth;
    for (; a && o && s.childCount == 1; )
      s = s.firstChild.content, a--, o--;
    let A = new lt(s, a, o);
    return e > -1 ? new qn(n.pos, e, this.$to.pos, this.$to.end(), A, t) : A.size || n.pos != this.$to.pos ? new Vn(n.pos, i.pos, A) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let t = this.unplaced.content, n = 0, i = this.unplaced.openEnd; n < e; n++) {
      let s = t.firstChild;
      if (t.childCount > 1 && (i = 0), s.type.spec.isolating && i <= n) {
        e = n;
        break;
      }
      t = s.content;
    }
    for (let t = 1; t <= 2; t++)
      for (let n = t == 1 ? e : this.unplaced.openStart; n >= 0; n--) {
        let i, s = null;
        n ? (s = Km(this.unplaced.content, n - 1).firstChild, i = s.content) : i = this.unplaced.content;
        let a = i.firstChild;
        for (let o = this.depth; o >= 0; o--) {
          let { type: A, match: l } = this.frontier[o], u, c = null;
          if (t == 1 && (a ? l.matchType(a.type) || (c = l.fillBefore(Ye.from(a), !1)) : s && A.compatibleContent(s.type)))
            return { sliceDepth: n, frontierDepth: o, parent: s, inject: c };
          if (t == 2 && a && (u = l.findWrapping(a.type)))
            return { sliceDepth: n, frontierDepth: o, parent: s, wrap: u };
          if (s && l.matchType(s.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: t, openEnd: n } = this.unplaced, i = Km(e, t);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new lt(e, t + 1, Math.max(n, i.size + t >= e.size - n ? t + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: t, openEnd: n } = this.unplaced, i = Km(e, t);
    if (i.childCount <= 1 && t > 0) {
      let s = e.size - t <= t + i.size;
      this.unplaced = new lt(Oc(e, t - 1, 1), t - 1, s ? t - 1 : n);
    } else
      this.unplaced = new lt(Oc(e, t, 1), t, n);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: t, parent: n, inject: i, wrap: s }) {
    for (; this.depth > t; )
      this.closeFrontierNode();
    if (s)
      for (let p = 0; p < s.length; p++)
        this.openFrontierNode(s[p]);
    let a = this.unplaced, o = n ? n.content : a.content, A = a.openStart - e, l = 0, u = [], { match: c, type: h } = this.frontier[t];
    if (i) {
      for (let p = 0; p < i.childCount; p++)
        u.push(i.child(p));
      c = c.matchFragment(i);
    }
    let f = o.size + e - (a.content.size - a.openEnd);
    for (; l < o.childCount; ) {
      let p = o.child(l), v = c.matchType(p.type);
      if (!v)
        break;
      l++, (l > 1 || A == 0 || p.content.size) && (c = v, u.push(vS(p.mark(h.allowedMarks(p.marks)), l == 1 ? A : 0, l == o.childCount ? f : -1)));
    }
    let d = l == o.childCount;
    d || (f = -1), this.placed = Qc(this.placed, t, Ye.from(u)), this.frontier[t].match = c, d && f < 0 && n && n.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let p = 0, v = o; p < f; p++) {
      let m = v.lastChild;
      this.frontier.push({ type: m.type, match: m.contentMatchAt(m.childCount) }), v = m.content;
    }
    this.unplaced = d ? e == 0 ? lt.empty : new lt(Oc(a.content, e - 1, 1), e - 1, f < 0 ? a.openEnd : e - 1) : new lt(Oc(a.content, e, l), a.openStart, a.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], t;
    if (!e.type.isTextblock || !$m(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth)
      return -1;
    let { depth: n } = this.$to, i = this.$to.after(n);
    for (; n > 1 && i == this.$to.end(--n); )
      ++i;
    return i;
  }
  findCloseLevel(e) {
    e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
      let { match: n, type: i } = this.frontier[t], s = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), a = $m(e, t, i, n, s);
      if (a) {
        for (let o = t - 1; o >= 0; o--) {
          let { match: A, type: l } = this.frontier[o], u = $m(e, o, l, A, !0);
          if (!u || u.childCount)
            continue e;
        }
        return { depth: t, fit: a, move: s ? e.doc.resolve(e.after(t + 1)) : e };
      }
    }
  }
  close(e) {
    let t = this.findCloseLevel(e);
    if (!t)
      return null;
    for (; this.depth > t.depth; )
      this.closeFrontierNode();
    t.fit.childCount && (this.placed = Qc(this.placed, t.depth, t.fit)), e = t.move;
    for (let n = t.depth + 1; n <= e.depth; n++) {
      let i = e.node(n), s = i.type.contentMatch.fillBefore(i.content, !0, e.index(n));
      this.openFrontierNode(i.type, i.attrs, s);
    }
    return e;
  }
  openFrontierNode(e, t = null, n) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(e), this.placed = Qc(this.placed, this.depth, Ye.from(e.create(t, n))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let t = this.frontier.pop().match.fillBefore(Ye.empty, !0);
    t.childCount && (this.placed = Qc(this.placed, this.frontier.length, t));
  }
}
function Oc(r, e, t) {
  return e == 0 ? r.cutByIndex(t, r.childCount) : r.replaceChild(0, r.firstChild.copy(Oc(r.firstChild.content, e - 1, t)));
}
function Qc(r, e, t) {
  return e == 0 ? r.append(t) : r.replaceChild(r.childCount - 1, r.lastChild.copy(Qc(r.lastChild.content, e - 1, t)));
}
function Km(r, e) {
  for (let t = 0; t < e; t++)
    r = r.firstChild.content;
  return r;
}
function vS(r, e, t) {
  if (e <= 0)
    return r;
  let n = r.content;
  return e > 1 && (n = n.replaceChild(0, vS(n.firstChild, e - 1, n.childCount == 1 ? t - 1 : 0))), e > 0 && (n = r.type.contentMatch.fillBefore(n).append(n), t <= 0 && (n = n.append(r.type.contentMatch.matchFragment(n).fillBefore(Ye.empty, !0)))), r.copy(n);
}
function $m(r, e, t, n, i) {
  let s = r.node(e), a = i ? r.indexAfter(e) : r.index(e);
  if (a == s.childCount && !t.compatibleContent(s.type))
    return null;
  let o = n.fillBefore(s.content, !0, a);
  return o && !C6(t, s.content, a) ? o : null;
}
function C6(r, e, t) {
  for (let n = t; n < e.childCount; n++)
    if (!r.allowsMarks(e.child(n).marks))
      return !0;
  return !1;
}
function _6(r) {
  return r.spec.defining || r.spec.definingForContent;
}
function E6(r, e, t, n) {
  if (!n.size)
    return r.deleteRange(e, t);
  let i = r.doc.resolve(e), s = r.doc.resolve(t);
  if (mS(i, s, n))
    return r.step(new Vn(e, t, n));
  let a = yS(i, r.doc.resolve(t));
  a[a.length - 1] == 0 && a.pop();
  let o = -(i.depth + 1);
  a.unshift(o);
  for (let h = i.depth, f = i.pos - 1; h > 0; h--, f--) {
    let d = i.node(h).type.spec;
    if (d.defining || d.definingAsContext || d.isolating)
      break;
    a.indexOf(h) > -1 ? o = h : i.before(h) == f && a.splice(1, 0, -h);
  }
  let A = a.indexOf(o), l = [], u = n.openStart;
  for (let h = n.content, f = 0; ; f++) {
    let d = h.firstChild;
    if (l.push(d), f == n.openStart)
      break;
    h = d.content;
  }
  for (let h = u - 1; h >= 0; h--) {
    let f = l[h], d = _6(f.type);
    if (d && !f.sameMarkup(i.node(Math.abs(o) - 1)))
      u = h;
    else if (d || !f.type.isTextblock)
      break;
  }
  for (let h = n.openStart; h >= 0; h--) {
    let f = (h + u + 1) % (n.openStart + 1), d = l[f];
    if (d)
      for (let p = 0; p < a.length; p++) {
        let v = a[(p + A) % a.length], m = !0;
        v < 0 && (m = !1, v = -v);
        let b = i.node(v - 1), w = i.index(v - 1);
        if (b.canReplaceWith(w, w, d.type, d.marks))
          return r.replace(i.before(v), m ? s.after(v) : t, new lt(bS(n.content, 0, n.openStart, f), f, n.openEnd));
      }
  }
  let c = r.steps.length;
  for (let h = a.length - 1; h >= 0 && (r.replace(e, t, n), !(r.steps.length > c)); h--) {
    let f = a[h];
    f < 0 || (e = i.before(f), t = s.after(f));
  }
}
function bS(r, e, t, n, i) {
  if (e < t) {
    let s = r.firstChild;
    r = r.replaceChild(0, s.copy(bS(s.content, e + 1, t, n, s)));
  }
  if (e > n) {
    let s = i.contentMatchAt(0), a = s.fillBefore(r).append(r);
    r = a.append(s.matchFragment(a).fillBefore(Ye.empty, !0));
  }
  return r;
}
function S6(r, e, t, n) {
  if (!n.isInline && e == t && r.doc.resolve(e).parent.content.size) {
    let i = w6(r.doc, e, n.type);
    i != null && (e = t = i);
  }
  r.replaceRange(e, t, new lt(Ye.from(n), 0, 0));
}
function I6(r, e, t) {
  let n = r.doc.resolve(e), i = r.doc.resolve(t), s = yS(n, i);
  for (let a = 0; a < s.length; a++) {
    let o = s[a], A = a == s.length - 1;
    if (A && o == 0 || n.node(o).type.contentMatch.validEnd)
      return r.delete(n.start(o), i.end(o));
    if (o > 0 && (A || n.node(o - 1).canReplace(n.index(o - 1), i.indexAfter(o - 1))))
      return r.delete(n.before(o), i.after(o));
  }
  for (let a = 1; a <= n.depth && a <= i.depth; a++)
    if (e - n.start(a) == n.depth - a && t > n.end(a) && i.end(a) - t != i.depth - a && n.start(a - 1) == i.start(a - 1) && n.node(a - 1).canReplace(n.index(a - 1), i.index(a - 1)))
      return r.delete(n.before(a), t);
  r.delete(e, t);
}
function yS(r, e) {
  let t = [], n = Math.min(r.depth, e.depth);
  for (let i = n; i >= 0; i--) {
    let s = r.start(i);
    if (s < r.pos - (r.depth - i) || e.end(i) > e.pos + (e.depth - i) || r.node(i).type.spec.isolating || e.node(i).type.spec.isolating)
      break;
    (s == e.start(i) || i == r.depth && i == e.depth && r.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == s - 1) && t.push(i);
  }
  return t;
}
class Bu extends Ii {
  /**
  Construct an attribute step.
  */
  constructor(e, t, n) {
    super(), this.pos = e, this.attr = t, this.value = n;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return Un.fail("No node at attribute step's position");
    let n = /* @__PURE__ */ Object.create(null);
    for (let s in t.attrs)
      n[s] = t.attrs[s];
    n[this.attr] = this.value;
    let i = t.type.create(n, null, t.marks);
    return Un.fromReplace(e, this.pos, this.pos + 1, new lt(Ye.from(i), 0, t.isLeaf ? 0 : 1));
  }
  getMap() {
    return ls.empty;
  }
  invert(e) {
    return new Bu(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new Bu(t.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.pos != "number" || typeof t.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new Bu(t.pos, t.attr, t.value);
  }
}
Ii.jsonID("attr", Bu);
class vf extends Ii {
  /**
  Construct an attribute step.
  */
  constructor(e, t) {
    super(), this.attr = e, this.value = t;
  }
  apply(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let i in e.attrs)
      t[i] = e.attrs[i];
    t[this.attr] = this.value;
    let n = e.type.create(t, e.content, e.marks);
    return Un.ok(n);
  }
  getMap() {
    return ls.empty;
  }
  invert(e) {
    return new vf(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new vf(t.attr, t.value);
  }
}
Ii.jsonID("docAttr", vf);
let Tu = class extends Error {
};
Tu = function r(e) {
  let t = Error.call(this, e);
  return t.__proto__ = r.prototype, t;
};
Tu.prototype = Object.create(Error.prototype);
Tu.prototype.constructor = Tu;
Tu.prototype.name = "TransformError";
let F6 = class {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new yu();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let t = this.maybeStep(e);
    if (t.failed)
      throw new Tu(t.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let t = e.apply(this.doc);
    return t.failed || this.addStep(e, t.doc), t;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, t = e, n = lt.empty) {
    let i = ag(this.doc, e, t, n);
    return i && this.step(i), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, t, n) {
    return this.replace(e, t, new lt(Ye.from(n), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, t) {
    return this.replace(e, t, lt.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, t) {
    return this.replaceWith(e, e, t);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, t, n) {
    return E6(this, e, t, n), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, t, n) {
    return S6(this, e, t, n), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, t) {
    return I6(this, e, t), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, t) {
    return c6(this, e, t), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, t = 1) {
    return y6(this, e, t), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, t) {
    return d6(this, e, t), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, t = e, n, i = null) {
    return p6(this, e, t, n, i), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, t, n = null, i) {
    return m6(this, e, t, n, i), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, t, n) {
    return this.step(new Bu(e, t, n)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, t) {
    return this.step(new vf(e, t)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, t) {
    return this.step(new $o(e, t)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, t) {
    if (!(t instanceof Ur)) {
      let n = this.doc.nodeAt(e);
      if (!n)
        throw new RangeError("No node at position " + e);
      if (t = t.isInSet(n.marks), !t)
        return this;
    }
    return this.step(new Fu(e, t)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(e, t = 1, n) {
    return v6(this, e, t, n), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, t, n) {
    return A6(this, e, t, n), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, t, n) {
    return l6(this, e, t, n), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, t, n) {
    return G2(this, e, t, n), this;
  }
};
const Vm = /* @__PURE__ */ Object.create(null);
class Yt {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, t, n) {
    this.$anchor = e, this.$head = t, this.ranges = n || [new T6(e.min(t), e.max(t))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let t = 0; t < e.length; t++)
      if (e[t].$from.pos != e[t].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, t = lt.empty) {
    let n = t.content.lastChild, i = null;
    for (let o = 0; o < t.openEnd; o++)
      i = n, n = n.lastChild;
    let s = e.steps.length, a = this.ranges;
    for (let o = 0; o < a.length; o++) {
      let { $from: A, $to: l } = a[o], u = e.mapping.slice(s);
      e.replaceRange(u.map(A.pos), u.map(l.pos), o ? lt.empty : t), o == 0 && Mw(e, s, (n ? n.isInline : i && i.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, t) {
    let n = e.steps.length, i = this.ranges;
    for (let s = 0; s < i.length; s++) {
      let { $from: a, $to: o } = i[s], A = e.mapping.slice(n), l = A.map(a.pos), u = A.map(o.pos);
      s ? e.deleteRange(l, u) : (e.replaceRangeWith(l, u, t), Mw(e, n, t.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, t, n = !1) {
    let i = e.parent.inlineContent ? new zt(e) : iu(e.node(0), e.parent, e.pos, e.index(), t, n);
    if (i)
      return i;
    for (let s = e.depth - 1; s >= 0; s--) {
      let a = t < 0 ? iu(e.node(0), e.node(s), e.before(s + 1), e.index(s), t, n) : iu(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, t, n);
      if (a)
        return a;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, t = 1) {
    return this.findFrom(e, t) || this.findFrom(e, -t) || new Us(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return iu(e, e, 0, 0, 1) || new Us(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return iu(e, e, e.content.size, e.childCount, -1) || new Us(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, t) {
    if (!t || !t.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let n = Vm[t.type];
    if (!n)
      throw new RangeError(`No selection type ${t.type} defined`);
    return n.fromJSON(e, t);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, t) {
    if (e in Vm)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return Vm[e] = t, t.prototype.jsonID = e, t;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return zt.between(this.$anchor, this.$head).getBookmark();
  }
}
Yt.prototype.visible = !0;
class T6 {
  /**
  Create a range.
  */
  constructor(e, t) {
    this.$from = e, this.$to = t;
  }
}
let Qw = !1;
function Dw(r) {
  !Qw && !r.parent.inlineContent && (Qw = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + r.parent.type.name + ")"));
}
class zt extends Yt {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, t = e) {
    Dw(e), Dw(t), super(e, t);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, t) {
    let n = e.resolve(t.map(this.head));
    if (!n.parent.inlineContent)
      return Yt.near(n);
    let i = e.resolve(t.map(this.anchor));
    return new zt(i.parent.inlineContent ? i : n, n);
  }
  replace(e, t = lt.empty) {
    if (super.replace(e, t), t == lt.empty) {
      let n = this.$from.marksAcross(this.$to);
      n && e.ensureMarks(n);
    }
  }
  eq(e) {
    return e instanceof zt && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new og(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new zt(e.resolve(t.anchor), e.resolve(t.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, t, n = t) {
    let i = e.resolve(t);
    return new this(i, n == t ? i : e.resolve(n));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, t, n) {
    let i = e.pos - t.pos;
    if ((!n || i) && (n = i >= 0 ? 1 : -1), !t.parent.inlineContent) {
      let s = Yt.findFrom(t, n, !0) || Yt.findFrom(t, -n, !0);
      if (s)
        t = s.$head;
      else
        return Yt.near(t, n);
    }
    return e.parent.inlineContent || (i == 0 ? e = t : (e = (Yt.findFrom(e, -n, !0) || Yt.findFrom(e, n, !0)).$anchor, e.pos < t.pos != i < 0 && (e = t))), new zt(e, t);
  }
}
Yt.jsonID("text", zt);
class og {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new og(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return zt.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class Tt extends Yt {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let t = e.nodeAfter, n = e.node(0).resolve(e.pos + t.nodeSize);
    super(e, n), this.node = t;
  }
  map(e, t) {
    let { deleted: n, pos: i } = t.mapResult(this.anchor), s = e.resolve(i);
    return n ? Yt.near(s) : new Tt(s);
  }
  content() {
    return new lt(Ye.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof Tt && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new W2(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new Tt(e.resolve(t.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, t) {
    return new Tt(e.resolve(t));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
Tt.prototype.visible = !1;
Yt.jsonID("node", Tt);
class W2 {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: t, pos: n } = e.mapResult(this.anchor);
    return t ? new og(n, n) : new W2(n);
  }
  resolve(e) {
    let t = e.resolve(this.anchor), n = t.nodeAfter;
    return n && Tt.isSelectable(n) ? new Tt(t) : Yt.near(t);
  }
}
class Us extends Yt {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, t = lt.empty) {
    if (t == lt.empty) {
      e.delete(0, e.doc.content.size);
      let n = Yt.atStart(e.doc);
      n.eq(e.selection) || e.setSelection(n);
    } else
      super.replace(e, t);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new Us(e);
  }
  map(e) {
    return new Us(e);
  }
  eq(e) {
    return e instanceof Us;
  }
  getBookmark() {
    return x6;
  }
}
Yt.jsonID("all", Us);
const x6 = {
  map() {
    return this;
  },
  resolve(r) {
    return new Us(r);
  }
};
function iu(r, e, t, n, i, s = !1) {
  if (e.inlineContent)
    return zt.create(r, t);
  for (let a = n - (i > 0 ? 0 : 1); i > 0 ? a < e.childCount : a >= 0; a += i) {
    let o = e.child(a);
    if (o.isAtom) {
      if (!s && Tt.isSelectable(o))
        return Tt.create(r, t - (i < 0 ? o.nodeSize : 0));
    } else {
      let A = iu(r, o, t + i, i < 0 ? o.childCount : 0, i, s);
      if (A)
        return A;
    }
    t += o.nodeSize * i;
  }
  return null;
}
function Mw(r, e, t) {
  let n = r.steps.length - 1;
  if (n < e)
    return;
  let i = r.steps[n];
  if (!(i instanceof Vn || i instanceof qn))
    return;
  let s = r.mapping.maps[n], a;
  s.forEach((o, A, l, u) => {
    a == null && (a = u);
  }), r.setSelection(Yt.near(r.doc.resolve(a), t));
}
const Rw = 1, Jh = 2, Pw = 4;
class k6 extends F6 {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | Rw) & ~Jh, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & Rw) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= Jh, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return Ur.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & Jh) > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    super.addStep(e, t), this.updated = this.updated & ~Jh, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, t = !0) {
    let n = this.selection;
    return t && (e = e.mark(this.storedMarks || (n.empty ? n.$from.marks() : n.$from.marksAcross(n.$to) || Ur.none))), n.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, t, n) {
    let i = this.doc.type.schema;
    if (t == null)
      return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection();
    {
      if (n == null && (n = t), n = n ?? t, !e)
        return this.deleteRange(t, n);
      let s = this.storedMarks;
      if (!s) {
        let a = this.doc.resolve(t);
        s = n == t ? a.marks() : a.marksAcross(this.doc.resolve(n));
      }
      return this.replaceRangeWith(t, n, i.text(e, s)), this.selection.empty || this.setSelection(Yt.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, t) {
    return this.meta[typeof e == "string" ? e : e.key] = t, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= Pw, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & Pw) > 0;
  }
}
function Hw(r, e) {
  return !e || !r ? r : r.bind(e);
}
class Dc {
  constructor(e, t, n) {
    this.name = e, this.init = Hw(t.init, n), this.apply = Hw(t.apply, n);
  }
}
const L6 = [
  new Dc("doc", {
    init(r) {
      return r.doc || r.schema.topNodeType.createAndFill();
    },
    apply(r) {
      return r.doc;
    }
  }),
  new Dc("selection", {
    init(r, e) {
      return r.selection || Yt.atStart(e.doc);
    },
    apply(r) {
      return r.selection;
    }
  }),
  new Dc("storedMarks", {
    init(r) {
      return r.storedMarks || null;
    },
    apply(r, e, t, n) {
      return n.selection.$cursor ? r.storedMarks : null;
    }
  }),
  new Dc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(r, e) {
      return r.scrolledIntoView ? e + 1 : e;
    }
  })
];
class zm {
  constructor(e, t) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = L6.slice(), t && t.forEach((n) => {
      if (this.pluginsByKey[n.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + n.key + ")");
      this.plugins.push(n), this.pluginsByKey[n.key] = n, n.spec.state && this.fields.push(new Dc(n.key, n.spec.state, n));
    });
  }
}
class fu {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, t = -1) {
    for (let n = 0; n < this.config.plugins.length; n++)
      if (n != t) {
        let i = this.config.plugins[n];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let t = [e], n = this.applyInner(e), i = null;
    for (; ; ) {
      let s = !1;
      for (let a = 0; a < this.config.plugins.length; a++) {
        let o = this.config.plugins[a];
        if (o.spec.appendTransaction) {
          let A = i ? i[a].n : 0, l = i ? i[a].state : this, u = A < t.length && o.spec.appendTransaction.call(o, A ? t.slice(A) : t, l, n);
          if (u && n.filterTransaction(u, a)) {
            if (u.setMeta("appendedTransaction", e), !i) {
              i = [];
              for (let c = 0; c < this.config.plugins.length; c++)
                i.push(c < a ? { state: n, n: t.length } : { state: this, n: 0 });
            }
            t.push(u), n = n.applyInner(u), s = !0;
          }
          i && (i[a] = { state: n, n: t.length });
        }
      }
      if (!s)
        return { state: n, transactions: t };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let t = new fu(this.config), n = this.config.fields;
    for (let i = 0; i < n.length; i++) {
      let s = n[i];
      t[s.name] = s.apply(e, this[s.name], this, t);
    }
    return t;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new k6(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let t = new zm(e.doc ? e.doc.type.schema : e.schema, e.plugins), n = new fu(t);
    for (let i = 0; i < t.fields.length; i++)
      n[t.fields[i].name] = t.fields[i].init(e, n);
    return n;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let t = new zm(this.schema, e.plugins), n = t.fields, i = new fu(t);
    for (let s = 0; s < n.length; s++) {
      let a = n[s].name;
      i[a] = this.hasOwnProperty(a) ? this[a] : n[s].init(e, i);
    }
    return i;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (t.storedMarks = this.storedMarks.map((n) => n.toJSON())), e && typeof e == "object")
      for (let n in e) {
        if (n == "doc" || n == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = e[n], s = i.spec.state;
        s && s.toJSON && (t[n] = s.toJSON.call(i, this[i.key]));
      }
    return t;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, t, n) {
    if (!t)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let i = new zm(e.schema, e.plugins), s = new fu(i);
    return i.fields.forEach((a) => {
      if (a.name == "doc")
        s.doc = Jo.fromJSON(e.schema, t.doc);
      else if (a.name == "selection")
        s.selection = Yt.fromJSON(s.doc, t.selection);
      else if (a.name == "storedMarks")
        t.storedMarks && (s.storedMarks = t.storedMarks.map(e.schema.markFromJSON));
      else {
        if (n)
          for (let o in n) {
            let A = n[o], l = A.spec.state;
            if (A.key == a.name && l && l.fromJSON && Object.prototype.hasOwnProperty.call(t, o)) {
              s[a.name] = l.fromJSON.call(A, e, t[o], s);
              return;
            }
          }
        s[a.name] = a.init(e, s);
      }
    }), s;
  }
}
function wS(r, e, t) {
  for (let n in r) {
    let i = r[n];
    i instanceof Function ? i = i.bind(e) : n == "handleDOMEvents" && (i = wS(i, e, {})), t[n] = i;
  }
  return t;
}
let es = class {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && wS(e.props, this, this.props), this.key = e.key ? e.key.key : BS("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
};
const Gm = /* @__PURE__ */ Object.create(null);
function BS(r) {
  return r in Gm ? r + "$" + ++Gm[r] : (Gm[r] = 0, r + "$");
}
class Na {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = BS(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const ai = function(r) {
  for (var e = 0; ; e++)
    if (r = r.previousSibling, !r)
      return e;
}, bf = function(r) {
  let e = r.assignedSlot || r.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let Z1 = null;
const to = function(r, e, t) {
  let n = Z1 || (Z1 = document.createRange());
  return n.setEnd(r, t ?? r.nodeValue.length), n.setStart(r, e || 0), n;
}, U6 = function() {
  Z1 = null;
}, ol = function(r, e, t, n) {
  return t && (jw(r, e, t, n, -1) || jw(r, e, t, n, 1));
}, N6 = /^(img|br|input|textarea|hr)$/i;
function jw(r, e, t, n, i) {
  for (; ; ) {
    if (r == t && e == n)
      return !0;
    if (e == (i < 0 ? 0 : Ts(r))) {
      let s = r.parentNode;
      if (!s || s.nodeType != 1 || Qf(r) || N6.test(r.nodeName) || r.contentEditable == "false")
        return !1;
      e = ai(r) + (i < 0 ? 0 : 1), r = s;
    } else if (r.nodeType == 1) {
      if (r = r.childNodes[e + (i < 0 ? -1 : 0)], r.contentEditable == "false")
        return !1;
      e = i < 0 ? Ts(r) : 0;
    } else
      return !1;
  }
}
function Ts(r) {
  return r.nodeType == 3 ? r.nodeValue.length : r.childNodes.length;
}
function O6(r, e) {
  for (; ; ) {
    if (r.nodeType == 3 && e)
      return r;
    if (r.nodeType == 1 && e > 0) {
      if (r.contentEditable == "false")
        return null;
      r = r.childNodes[e - 1], e = Ts(r);
    } else if (r.parentNode && !Qf(r))
      e = ai(r), r = r.parentNode;
    else
      return null;
  }
}
function Q6(r, e) {
  for (; ; ) {
    if (r.nodeType == 3 && e < r.nodeValue.length)
      return r;
    if (r.nodeType == 1 && e < r.childNodes.length) {
      if (r.contentEditable == "false")
        return null;
      r = r.childNodes[e], e = 0;
    } else if (r.parentNode && !Qf(r))
      e = ai(r) + 1, r = r.parentNode;
    else
      return null;
  }
}
function D6(r, e, t) {
  for (let n = e == 0, i = e == Ts(r); n || i; ) {
    if (r == t)
      return !0;
    let s = ai(r);
    if (r = r.parentNode, !r)
      return !1;
    n = n && s == 0, i = i && s == Ts(r);
  }
}
function Qf(r) {
  let e;
  for (let t = r; t && !(e = t.pmViewDesc); t = t.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == r || e.contentDOM == r);
}
const Ag = function(r) {
  return r.focusNode && ol(r.focusNode, r.focusOffset, r.anchorNode, r.anchorOffset);
};
function OA(r, e) {
  let t = document.createEvent("Event");
  return t.initEvent("keydown", !0, !0), t.keyCode = r, t.key = t.code = e, t;
}
function M6(r) {
  let e = r.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function R6(r, e, t) {
  if (r.caretPositionFromPoint)
    try {
      let n = r.caretPositionFromPoint(e, t);
      if (n)
        return { node: n.offsetNode, offset: Math.min(Ts(n.offsetNode), n.offset) };
    } catch {
    }
  if (r.caretRangeFromPoint) {
    let n = r.caretRangeFromPoint(e, t);
    if (n)
      return { node: n.startContainer, offset: Math.min(Ts(n.startContainer), n.startOffset) };
  }
}
const Fa = typeof navigator < "u" ? navigator : null, Kw = typeof document < "u" ? document : null, cA = Fa && Fa.userAgent || "", ev = /Edge\/(\d+)/.exec(cA), CS = /MSIE \d/.exec(cA), tv = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(cA), Ji = !!(CS || tv || ev), Yo = CS ? document.documentMode : tv ? +tv[1] : ev ? +ev[1] : 0, aa = !Ji && /gecko\/(\d+)/i.test(cA);
aa && +(/Firefox\/(\d+)/.exec(cA) || [0, 0])[1];
const rv = !Ji && /Chrome\/(\d+)/.exec(cA), Si = !!rv, _S = rv ? +rv[1] : 0, Oi = !Ji && !!Fa && /Apple Computer/.test(Fa.vendor), xu = Oi && (/Mobile\/\w+/.test(cA) || !!Fa && Fa.maxTouchPoints > 2), Ss = xu || (Fa ? /Mac/.test(Fa.platform) : !1), P6 = Fa ? /Win/.test(Fa.platform) : !1, no = /Android \d/.test(cA), Df = !!Kw && "webkitFontSmoothing" in Kw.documentElement.style, H6 = Df ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function j6(r) {
  let e = r.defaultView && r.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: r.documentElement.clientWidth,
    top: 0,
    bottom: r.documentElement.clientHeight
  };
}
function Wa(r, e) {
  return typeof r == "number" ? r : r[e];
}
function K6(r) {
  let e = r.getBoundingClientRect(), t = e.width / r.offsetWidth || 1, n = e.height / r.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + r.clientWidth * t,
    top: e.top,
    bottom: e.top + r.clientHeight * n
  };
}
function $w(r, e, t) {
  let n = r.someProp("scrollThreshold") || 0, i = r.someProp("scrollMargin") || 5, s = r.dom.ownerDocument;
  for (let a = t || r.dom; a; a = bf(a)) {
    if (a.nodeType != 1)
      continue;
    let o = a, A = o == s.body, l = A ? j6(s) : K6(o), u = 0, c = 0;
    if (e.top < l.top + Wa(n, "top") ? c = -(l.top - e.top + Wa(i, "top")) : e.bottom > l.bottom - Wa(n, "bottom") && (c = e.bottom - e.top > l.bottom - l.top ? e.top + Wa(i, "top") - l.top : e.bottom - l.bottom + Wa(i, "bottom")), e.left < l.left + Wa(n, "left") ? u = -(l.left - e.left + Wa(i, "left")) : e.right > l.right - Wa(n, "right") && (u = e.right - l.right + Wa(i, "right")), u || c)
      if (A)
        s.defaultView.scrollBy(u, c);
      else {
        let h = o.scrollLeft, f = o.scrollTop;
        c && (o.scrollTop += c), u && (o.scrollLeft += u);
        let d = o.scrollLeft - h, p = o.scrollTop - f;
        e = { left: e.left - d, top: e.top - p, right: e.right - d, bottom: e.bottom - p };
      }
    if (A || /^(fixed|sticky)$/.test(getComputedStyle(a).position))
      break;
  }
}
function $6(r) {
  let e = r.dom.getBoundingClientRect(), t = Math.max(0, e.top), n, i;
  for (let s = (e.left + e.right) / 2, a = t + 1; a < Math.min(innerHeight, e.bottom); a += 5) {
    let o = r.root.elementFromPoint(s, a);
    if (!o || o == r.dom || !r.dom.contains(o))
      continue;
    let A = o.getBoundingClientRect();
    if (A.top >= t - 20) {
      n = o, i = A.top;
      break;
    }
  }
  return { refDOM: n, refTop: i, stack: ES(r.dom) };
}
function ES(r) {
  let e = [], t = r.ownerDocument;
  for (let n = r; n && (e.push({ dom: n, top: n.scrollTop, left: n.scrollLeft }), r != t); n = bf(n))
    ;
  return e;
}
function V6({ refDOM: r, refTop: e, stack: t }) {
  let n = r ? r.getBoundingClientRect().top : 0;
  SS(t, n == 0 ? 0 : n - e);
}
function SS(r, e) {
  for (let t = 0; t < r.length; t++) {
    let { dom: n, top: i, left: s } = r[t];
    n.scrollTop != i + e && (n.scrollTop = i + e), n.scrollLeft != s && (n.scrollLeft = s);
  }
}
let Kl = null;
function z6(r) {
  if (r.setActive)
    return r.setActive();
  if (Kl)
    return r.focus(Kl);
  let e = ES(r);
  r.focus(Kl == null ? {
    get preventScroll() {
      return Kl = { preventScroll: !0 }, !0;
    }
  } : void 0), Kl || (Kl = !1, SS(e, 0));
}
function IS(r, e) {
  let t, n = 2e8, i, s = 0, a = e.top, o = e.top, A, l;
  for (let u = r.firstChild, c = 0; u; u = u.nextSibling, c++) {
    let h;
    if (u.nodeType == 1)
      h = u.getClientRects();
    else if (u.nodeType == 3)
      h = to(u).getClientRects();
    else
      continue;
    for (let f = 0; f < h.length; f++) {
      let d = h[f];
      if (d.top <= a && d.bottom >= o) {
        a = Math.max(d.bottom, a), o = Math.min(d.top, o);
        let p = d.left > e.left ? d.left - e.left : d.right < e.left ? e.left - d.right : 0;
        if (p < n) {
          t = u, n = p, i = p && t.nodeType == 3 ? {
            left: d.right < e.left ? d.right : d.left,
            top: e.top
          } : e, u.nodeType == 1 && p && (s = c + (e.left >= (d.left + d.right) / 2 ? 1 : 0));
          continue;
        }
      } else d.top > e.top && !A && d.left <= e.left && d.right >= e.left && (A = u, l = { left: Math.max(d.left, Math.min(d.right, e.left)), top: d.top });
      !t && (e.left >= d.right && e.top >= d.top || e.left >= d.left && e.top >= d.bottom) && (s = c + 1);
    }
  }
  return !t && A && (t = A, i = l, n = 0), t && t.nodeType == 3 ? G6(t, i) : !t || n && t.nodeType == 1 ? { node: r, offset: s } : IS(t, i);
}
function G6(r, e) {
  let t = r.nodeValue.length, n = document.createRange();
  for (let i = 0; i < t; i++) {
    n.setEnd(r, i + 1), n.setStart(r, i);
    let s = Lo(n, 1);
    if (s.top != s.bottom && X2(e, s))
      return { node: r, offset: i + (e.left >= (s.left + s.right) / 2 ? 1 : 0) };
  }
  return { node: r, offset: 0 };
}
function X2(r, e) {
  return r.left >= e.left - 1 && r.left <= e.right + 1 && r.top >= e.top - 1 && r.top <= e.bottom + 1;
}
function q6(r, e) {
  let t = r.parentNode;
  return t && /^li$/i.test(t.nodeName) && e.left < r.getBoundingClientRect().left ? t : r;
}
function W6(r, e, t) {
  let { node: n, offset: i } = IS(e, t), s = -1;
  if (n.nodeType == 1 && !n.firstChild) {
    let a = n.getBoundingClientRect();
    s = a.left != a.right && t.left > (a.left + a.right) / 2 ? 1 : -1;
  }
  return r.docView.posFromDOM(n, i, s);
}
function X6(r, e, t, n) {
  let i = -1;
  for (let s = e, a = !1; s != r.dom; ) {
    let o = r.docView.nearestDesc(s, !0), A;
    if (!o)
      return null;
    if (o.dom.nodeType == 1 && (o.node.isBlock && o.parent || !o.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((A = o.dom.getBoundingClientRect()).width || A.height) && (o.node.isBlock && o.parent && (!a && A.left > n.left || A.top > n.top ? i = o.posBefore : (!a && A.right < n.left || A.bottom < n.top) && (i = o.posAfter), a = !0), !o.contentDOM && i < 0 && !o.node.isText))
      return (o.node.isBlock ? n.top < (A.top + A.bottom) / 2 : n.left < (A.left + A.right) / 2) ? o.posBefore : o.posAfter;
    s = o.dom.parentNode;
  }
  return i > -1 ? i : r.docView.posFromDOM(e, t, -1);
}
function FS(r, e, t) {
  let n = r.childNodes.length;
  if (n && t.top < t.bottom)
    for (let i = Math.max(0, Math.min(n - 1, Math.floor(n * (e.top - t.top) / (t.bottom - t.top)) - 2)), s = i; ; ) {
      let a = r.childNodes[s];
      if (a.nodeType == 1) {
        let o = a.getClientRects();
        for (let A = 0; A < o.length; A++) {
          let l = o[A];
          if (X2(e, l))
            return FS(a, e, l);
        }
      }
      if ((s = (s + 1) % n) == i)
        break;
    }
  return r;
}
function J6(r, e) {
  let t = r.dom.ownerDocument, n, i = 0, s = R6(t, e.left, e.top);
  s && ({ node: n, offset: i } = s);
  let a = (r.root.elementFromPoint ? r.root : t).elementFromPoint(e.left, e.top), o;
  if (!a || !r.dom.contains(a.nodeType != 1 ? a.parentNode : a)) {
    let l = r.dom.getBoundingClientRect();
    if (!X2(e, l) || (a = FS(r.dom, e, l), !a))
      return null;
  }
  if (Oi)
    for (let l = a; n && l; l = bf(l))
      l.draggable && (n = void 0);
  if (a = q6(a, e), n) {
    if (aa && n.nodeType == 1 && (i = Math.min(i, n.childNodes.length), i < n.childNodes.length)) {
      let u = n.childNodes[i], c;
      u.nodeName == "IMG" && (c = u.getBoundingClientRect()).right <= e.left && c.bottom > e.top && i++;
    }
    let l;
    Df && i && n.nodeType == 1 && (l = n.childNodes[i - 1]).nodeType == 1 && l.contentEditable == "false" && l.getBoundingClientRect().top >= e.top && i--, n == r.dom && i == n.childNodes.length - 1 && n.lastChild.nodeType == 1 && e.top > n.lastChild.getBoundingClientRect().bottom ? o = r.state.doc.content.size : (i == 0 || n.nodeType != 1 || n.childNodes[i - 1].nodeName != "BR") && (o = X6(r, n, i, e));
  }
  o == null && (o = W6(r, a, e));
  let A = r.docView.nearestDesc(a, !0);
  return { pos: o, inside: A ? A.posAtStart - A.border : -1 };
}
function Vw(r) {
  return r.top < r.bottom || r.left < r.right;
}
function Lo(r, e) {
  let t = r.getClientRects();
  if (t.length) {
    let n = t[e < 0 ? 0 : t.length - 1];
    if (Vw(n))
      return n;
  }
  return Array.prototype.find.call(t, Vw) || r.getBoundingClientRect();
}
const Y6 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function TS(r, e, t) {
  let { node: n, offset: i, atom: s } = r.docView.domFromPos(e, t < 0 ? -1 : 1), a = Df || aa;
  if (n.nodeType == 3)
    if (a && (Y6.test(n.nodeValue) || (t < 0 ? !i : i == n.nodeValue.length))) {
      let A = Lo(to(n, i, i), t);
      if (aa && i && /\s/.test(n.nodeValue[i - 1]) && i < n.nodeValue.length) {
        let l = Lo(to(n, i - 1, i - 1), -1);
        if (l.top == A.top) {
          let u = Lo(to(n, i, i + 1), -1);
          if (u.top != A.top)
            return wc(u, u.left < l.left);
        }
      }
      return A;
    } else {
      let A = i, l = i, u = t < 0 ? 1 : -1;
      return t < 0 && !i ? (l++, u = -1) : t >= 0 && i == n.nodeValue.length ? (A--, u = 1) : t < 0 ? A-- : l++, wc(Lo(to(n, A, l), u), u < 0);
    }
  if (!r.state.doc.resolve(e - (s || 0)).parent.inlineContent) {
    if (s == null && i && (t < 0 || i == Ts(n))) {
      let A = n.childNodes[i - 1];
      if (A.nodeType == 1)
        return qm(A.getBoundingClientRect(), !1);
    }
    if (s == null && i < Ts(n)) {
      let A = n.childNodes[i];
      if (A.nodeType == 1)
        return qm(A.getBoundingClientRect(), !0);
    }
    return qm(n.getBoundingClientRect(), t >= 0);
  }
  if (s == null && i && (t < 0 || i == Ts(n))) {
    let A = n.childNodes[i - 1], l = A.nodeType == 3 ? to(A, Ts(A) - (a ? 0 : 1)) : A.nodeType == 1 && (A.nodeName != "BR" || !A.nextSibling) ? A : null;
    if (l)
      return wc(Lo(l, 1), !1);
  }
  if (s == null && i < Ts(n)) {
    let A = n.childNodes[i];
    for (; A.pmViewDesc && A.pmViewDesc.ignoreForCoords; )
      A = A.nextSibling;
    let l = A ? A.nodeType == 3 ? to(A, 0, a ? 0 : 1) : A.nodeType == 1 ? A : null : null;
    if (l)
      return wc(Lo(l, -1), !0);
  }
  return wc(Lo(n.nodeType == 3 ? to(n) : n, -t), t >= 0);
}
function wc(r, e) {
  if (r.width == 0)
    return r;
  let t = e ? r.left : r.right;
  return { top: r.top, bottom: r.bottom, left: t, right: t };
}
function qm(r, e) {
  if (r.height == 0)
    return r;
  let t = e ? r.top : r.bottom;
  return { top: t, bottom: t, left: r.left, right: r.right };
}
function xS(r, e, t) {
  let n = r.state, i = r.root.activeElement;
  n != e && r.updateState(e), i != r.dom && r.focus();
  try {
    return t();
  } finally {
    n != e && r.updateState(n), i != r.dom && i && i.focus();
  }
}
function Z6(r, e, t) {
  let n = e.selection, i = t == "up" ? n.$from : n.$to;
  return xS(r, e, () => {
    let { node: s } = r.docView.domFromPos(i.pos, t == "up" ? -1 : 1);
    for (; ; ) {
      let o = r.docView.nearestDesc(s, !0);
      if (!o)
        break;
      if (o.node.isBlock) {
        s = o.contentDOM || o.dom;
        break;
      }
      s = o.dom.parentNode;
    }
    let a = TS(r, i.pos, 1);
    for (let o = s.firstChild; o; o = o.nextSibling) {
      let A;
      if (o.nodeType == 1)
        A = o.getClientRects();
      else if (o.nodeType == 3)
        A = to(o, 0, o.nodeValue.length).getClientRects();
      else
        continue;
      for (let l = 0; l < A.length; l++) {
        let u = A[l];
        if (u.bottom > u.top + 1 && (t == "up" ? a.top - u.top > (u.bottom - a.top) * 2 : u.bottom - a.bottom > (a.bottom - u.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const eQ = /[\u0590-\u08ac]/;
function tQ(r, e, t) {
  let { $head: n } = e.selection;
  if (!n.parent.isTextblock)
    return !1;
  let i = n.parentOffset, s = !i, a = i == n.parent.content.size, o = r.domSelection();
  return o ? !eQ.test(n.parent.textContent) || !o.modify ? t == "left" || t == "backward" ? s : a : xS(r, e, () => {
    let { focusNode: A, focusOffset: l, anchorNode: u, anchorOffset: c } = r.domSelectionRange(), h = o.caretBidiLevel;
    o.modify("move", t, "character");
    let f = n.depth ? r.docView.domAfterPos(n.before()) : r.dom, { focusNode: d, focusOffset: p } = r.domSelectionRange(), v = d && !f.contains(d.nodeType == 1 ? d : d.parentNode) || A == d && l == p;
    try {
      o.collapse(u, c), A && (A != u || l != c) && o.extend && o.extend(A, l);
    } catch {
    }
    return h != null && (o.caretBidiLevel = h), v;
  }) : n.pos == n.start() || n.pos == n.end();
}
let zw = null, Gw = null, qw = !1;
function rQ(r, e, t) {
  return zw == e && Gw == t ? qw : (zw = e, Gw = t, qw = t == "up" || t == "down" ? Z6(r, e, t) : tQ(r, e, t));
}
const Ns = 0, Ww = 1, HA = 2, Ta = 3;
class Mf {
  constructor(e, t, n, i) {
    this.parent = e, this.children = t, this.dom = n, this.contentDOM = i, this.dirty = Ns, n.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, t, n) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let t = 0; t < this.children.length; t++)
      e += this.children[t].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let t = 0, n = this.posAtStart; ; t++) {
      let i = this.children[t];
      if (i == e)
        return n;
      n += i.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, t, n) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (n < 0) {
        let s, a;
        if (e == this.contentDOM)
          s = e.childNodes[t - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.previousSibling;
        }
        for (; s && !((a = s.pmViewDesc) && a.parent == this); )
          s = s.previousSibling;
        return s ? this.posBeforeChild(a) + a.size : this.posAtStart;
      } else {
        let s, a;
        if (e == this.contentDOM)
          s = e.childNodes[t];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.nextSibling;
        }
        for (; s && !((a = s.pmViewDesc) && a.parent == this); )
          s = s.nextSibling;
        return s ? this.posBeforeChild(a) : this.posAtEnd;
      }
    let i;
    if (e == this.dom && this.contentDOM)
      i = t > ai(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (t == 0)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !1;
            break;
          }
          if (s.previousSibling)
            break;
        }
      if (i == null && t == e.childNodes.length)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !0;
            break;
          }
          if (s.nextSibling)
            break;
        }
    }
    return i ?? n > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, t = !1) {
    for (let n = !0, i = e; i; i = i.parentNode) {
      let s = this.getDesc(i), a;
      if (s && (!t || s.node))
        if (n && (a = s.nodeDOM) && !(a.nodeType == 1 ? a.contains(e.nodeType == 1 ? e : e.parentNode) : a == e))
          n = !1;
        else
          return s;
    }
  }
  getDesc(e) {
    let t = e.pmViewDesc;
    for (let n = t; n; n = n.parent)
      if (n == this)
        return t;
  }
  posFromDOM(e, t, n) {
    for (let i = e; i; i = i.parentNode) {
      let s = this.getDesc(i);
      if (s)
        return s.localPosFromDOM(e, t, n);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let t = 0, n = 0; t < this.children.length; t++) {
      let i = this.children[t], s = n + i.size;
      if (n == e && s != n) {
        for (; !i.border && i.children.length; )
          for (let a = 0; a < i.children.length; a++) {
            let o = i.children[a];
            if (o.size) {
              i = o;
              break;
            }
          }
        return i;
      }
      if (e < s)
        return i.descAt(e - n - i.border);
      n = s;
    }
  }
  domFromPos(e, t) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let n = 0, i = 0;
    for (let s = 0; n < this.children.length; n++) {
      let a = this.children[n], o = s + a.size;
      if (o > e || a instanceof LS) {
        i = e - s;
        break;
      }
      s = o;
    }
    if (i)
      return this.children[n].domFromPos(i - this.children[n].border, t);
    for (let s; n && !(s = this.children[n - 1]).size && s instanceof kS && s.side >= 0; n--)
      ;
    if (t <= 0) {
      let s, a = !0;
      for (; s = n ? this.children[n - 1] : null, !(!s || s.dom.parentNode == this.contentDOM); n--, a = !1)
        ;
      return s && t && a && !s.border && !s.domAtom ? s.domFromPos(s.size, t) : { node: this.contentDOM, offset: s ? ai(s.dom) + 1 : 0 };
    } else {
      let s, a = !0;
      for (; s = n < this.children.length ? this.children[n] : null, !(!s || s.dom.parentNode == this.contentDOM); n++, a = !1)
        ;
      return s && a && !s.border && !s.domAtom ? s.domFromPos(0, t) : { node: this.contentDOM, offset: s ? ai(s.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, t, n = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: t, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let i = -1, s = -1;
    for (let a = n, o = 0; ; o++) {
      let A = this.children[o], l = a + A.size;
      if (i == -1 && e <= l) {
        let u = a + A.border;
        if (e >= u && t <= l - A.border && A.node && A.contentDOM && this.contentDOM.contains(A.contentDOM))
          return A.parseRange(e, t, u);
        e = a;
        for (let c = o; c > 0; c--) {
          let h = this.children[c - 1];
          if (h.size && h.dom.parentNode == this.contentDOM && !h.emptyChildAt(1)) {
            i = ai(h.dom) + 1;
            break;
          }
          e -= h.size;
        }
        i == -1 && (i = 0);
      }
      if (i > -1 && (l > t || o == this.children.length - 1)) {
        t = l;
        for (let u = o + 1; u < this.children.length; u++) {
          let c = this.children[u];
          if (c.size && c.dom.parentNode == this.contentDOM && !c.emptyChildAt(-1)) {
            s = ai(c.dom);
            break;
          }
          t += c.size;
        }
        s == -1 && (s = this.contentDOM.childNodes.length);
        break;
      }
      a = l;
    }
    return { node: this.contentDOM, from: e, to: t, fromOffset: i, toOffset: s };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let t = this.children[e < 0 ? 0 : this.children.length - 1];
    return t.size == 0 || t.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: t, offset: n } = this.domFromPos(e, 0);
    if (t.nodeType != 1 || n == t.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return t.childNodes[n];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, t, n, i = !1) {
    let s = Math.min(e, t), a = Math.max(e, t);
    for (let f = 0, d = 0; f < this.children.length; f++) {
      let p = this.children[f], v = d + p.size;
      if (s > d && a < v)
        return p.setSelection(e - d - p.border, t - d - p.border, n, i);
      d = v;
    }
    let o = this.domFromPos(e, e ? -1 : 1), A = t == e ? o : this.domFromPos(t, t ? -1 : 1), l = n.root.getSelection(), u = n.domSelectionRange(), c = !1;
    if ((aa || Oi) && e == t) {
      let { node: f, offset: d } = o;
      if (f.nodeType == 3) {
        if (c = !!(d && f.nodeValue[d - 1] == `
`), c && d == f.nodeValue.length)
          for (let p = f, v; p; p = p.parentNode) {
            if (v = p.nextSibling) {
              v.nodeName == "BR" && (o = A = { node: v.parentNode, offset: ai(v) + 1 });
              break;
            }
            let m = p.pmViewDesc;
            if (m && m.node && m.node.isBlock)
              break;
          }
      } else {
        let p = f.childNodes[d - 1];
        c = p && (p.nodeName == "BR" || p.contentEditable == "false");
      }
    }
    if (aa && u.focusNode && u.focusNode != A.node && u.focusNode.nodeType == 1) {
      let f = u.focusNode.childNodes[u.focusOffset];
      f && f.contentEditable == "false" && (i = !0);
    }
    if (!(i || c && Oi) && ol(o.node, o.offset, u.anchorNode, u.anchorOffset) && ol(A.node, A.offset, u.focusNode, u.focusOffset))
      return;
    let h = !1;
    if ((l.extend || e == t) && !c) {
      l.collapse(o.node, o.offset);
      try {
        e != t && l.extend(A.node, A.offset), h = !0;
      } catch {
      }
    }
    if (!h) {
      if (e > t) {
        let d = o;
        o = A, A = d;
      }
      let f = document.createRange();
      f.setEnd(A.node, A.offset), f.setStart(o.node, o.offset), l.removeAllRanges(), l.addRange(f);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, t) {
    for (let n = 0, i = 0; i < this.children.length; i++) {
      let s = this.children[i], a = n + s.size;
      if (n == a ? e <= a && t >= n : e < a && t > n) {
        let o = n + s.border, A = a - s.border;
        if (e >= o && t <= A) {
          this.dirty = e == n || t == a ? HA : Ww, e == o && t == A && (s.contentLost || s.dom.parentNode != this.contentDOM) ? s.dirty = Ta : s.markDirty(e - o, t - o);
          return;
        } else
          s.dirty = s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length ? HA : Ta;
      }
      n = a;
    }
    this.dirty = HA;
  }
  markParentsDirty() {
    let e = 1;
    for (let t = this.parent; t; t = t.parent, e++) {
      let n = e == 1 ? HA : Ww;
      t.dirty < n && (t.dirty = n);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class kS extends Mf {
  constructor(e, t, n, i) {
    let s, a = t.type.toDOM;
    if (typeof a == "function" && (a = a(n, () => {
      if (!s)
        return i;
      if (s.parent)
        return s.parent.posBeforeChild(s);
    })), !t.type.spec.raw) {
      if (a.nodeType != 1) {
        let o = document.createElement("span");
        o.appendChild(a), a = o;
      }
      a.contentEditable = "false", a.classList.add("ProseMirror-widget");
    }
    super(e, [], a, null), this.widget = t, this.widget = t, s = this;
  }
  matchesWidget(e) {
    return this.dirty == Ns && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let t = this.widget.spec.stopEvent;
    return t ? t(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get side() {
    return this.widget.type.side;
  }
}
class nQ extends Mf {
  constructor(e, t, n, i) {
    super(e, [], t, null), this.textDOM = n, this.text = i;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, t) {
    return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class Al extends Mf {
  constructor(e, t, n, i, s) {
    super(e, [], n, i), this.mark = t, this.spec = s;
  }
  static create(e, t, n, i) {
    let s = i.nodeViews[t.type.name], a = s && s(t, i, n);
    return (!a || !a.dom) && (a = ul.renderSpec(document, t.type.spec.toDOM(t, n), null, t.attrs)), new Al(e, t, a.dom, a.contentDOM || a.dom, a);
  }
  parseRule() {
    return this.dirty & Ta || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != Ta && this.mark.eq(e);
  }
  markDirty(e, t) {
    if (super.markDirty(e, t), this.dirty != Ns) {
      let n = this.parent;
      for (; !n.node; )
        n = n.parent;
      n.dirty < this.dirty && (n.dirty = this.dirty), this.dirty = Ns;
    }
  }
  slice(e, t, n) {
    let i = Al.create(this.parent, this.mark, !0, n), s = this.children, a = this.size;
    t < a && (s = iv(s, t, a, n)), e > 0 && (s = iv(s, 0, e, n));
    for (let o = 0; o < s.length; o++)
      s[o].parent = i;
    return i.children = s, i;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class Zo extends Mf {
  constructor(e, t, n, i, s, a, o, A, l) {
    super(e, [], s, a), this.node = t, this.outerDeco = n, this.innerDeco = i, this.nodeDOM = o;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, t, n, i, s, a) {
    let o = s.nodeViews[t.type.name], A, l = o && o(t, s, () => {
      if (!A)
        return a;
      if (A.parent)
        return A.parent.posBeforeChild(A);
    }, n, i), u = l && l.dom, c = l && l.contentDOM;
    if (t.isText) {
      if (!u)
        u = document.createTextNode(t.text);
      else if (u.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else u || ({ dom: u, contentDOM: c } = ul.renderSpec(document, t.type.spec.toDOM(t), null, t.attrs));
    !c && !t.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), t.type.spec.draggable && (u.draggable = !0));
    let h = u;
    return u = OS(u, n, t), l ? A = new iQ(e, t, n, i, u, c || null, h, l, s, a + 1) : t.isText ? new lg(e, t, n, i, u, h, s) : new Zo(e, t, n, i, u, c || null, h, s, a + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let t = this.children.length - 1; t >= 0; t--) {
        let n = this.children[t];
        if (this.dom.contains(n.dom.parentNode)) {
          e.contentElement = n.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => Ye.empty);
    }
    return e;
  }
  matchesNode(e, t, n) {
    return this.dirty == Ns && e.eq(this.node) && _p(t, this.outerDeco) && n.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, t) {
    let n = this.node.inlineContent, i = t, s = e.composing ? this.localCompositionInfo(e, t) : null, a = s && s.pos > -1 ? s : null, o = s && s.pos < 0, A = new aQ(this, a && a.node, e);
    lQ(this.node, this.innerDeco, (l, u, c) => {
      l.spec.marks ? A.syncToMarks(l.spec.marks, n, e) : l.type.side >= 0 && !c && A.syncToMarks(u == this.node.childCount ? Ur.none : this.node.child(u).marks, n, e), A.placeWidget(l, e, i);
    }, (l, u, c, h) => {
      A.syncToMarks(l.marks, n, e);
      let f;
      A.findNodeMatch(l, u, c, h) || o && e.state.selection.from > i && e.state.selection.to < i + l.nodeSize && (f = A.findIndexWithChild(s.node)) > -1 && A.updateNodeAt(l, u, c, f, e) || A.updateNextNode(l, u, c, e, h, i) || A.addNode(l, u, c, e, i), i += l.nodeSize;
    }), A.syncToMarks([], n, e), this.node.isTextblock && A.addTextblockHacks(), A.destroyRest(), (A.changed || this.dirty == HA) && (a && this.protectLocalComposition(e, a), US(this.contentDOM, this.children, e), xu && uQ(this.dom));
  }
  localCompositionInfo(e, t) {
    let { from: n, to: i } = e.state.selection;
    if (!(e.state.selection instanceof zt) || n < t || i > t + this.node.content.size)
      return null;
    let s = e.input.compositionNode;
    if (!s || !this.dom.contains(s.parentNode))
      return null;
    if (this.node.inlineContent) {
      let a = s.nodeValue, o = cQ(this.node.content, a, n - t, i - t);
      return o < 0 ? null : { node: s, pos: o, text: a };
    } else
      return { node: s, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: t, pos: n, text: i }) {
    if (this.getDesc(t))
      return;
    let s = t;
    for (; s.parentNode != this.contentDOM; s = s.parentNode) {
      for (; s.previousSibling; )
        s.parentNode.removeChild(s.previousSibling);
      for (; s.nextSibling; )
        s.parentNode.removeChild(s.nextSibling);
      s.pmViewDesc && (s.pmViewDesc = void 0);
    }
    let a = new nQ(this, s, t, i);
    e.input.compositionNodes.push(a), this.children = iv(this.children, n, n + i.length, e, a);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, t, n, i) {
    return this.dirty == Ta || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, t, n, i), !0);
  }
  updateInner(e, t, n, i) {
    this.updateOuterDeco(t), this.node = e, this.innerDeco = n, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = Ns;
  }
  updateOuterDeco(e) {
    if (_p(e, this.outerDeco))
      return;
    let t = this.nodeDOM.nodeType != 1, n = this.dom;
    this.dom = NS(this.dom, this.nodeDOM, nv(this.outerDeco, this.node, t), nv(e, this.node, t)), this.dom != n && (n.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function Xw(r, e, t, n, i) {
  OS(n, e, r);
  let s = new Zo(void 0, r, e, t, n, n, n, i, 0);
  return s.contentDOM && s.updateChildren(i, 0), s;
}
class lg extends Zo {
  constructor(e, t, n, i, s, a, o) {
    super(e, t, n, i, s, null, a, o, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, t, n, i) {
    return this.dirty == Ta || this.dirty != Ns && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(t), (this.dirty != Ns || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = Ns, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let t = this.nodeDOM; t; t = t.parentNode)
      if (t == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, t, n) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, n);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, t, n) {
    let i = this.node.cut(e, t), s = document.createTextNode(i.text);
    return new lg(this.parent, i, this.outerDeco, this.innerDeco, s, s, n);
  }
  markDirty(e, t) {
    super.markDirty(e, t), this.dom != this.nodeDOM && (e == 0 || t == this.nodeDOM.nodeValue.length) && (this.dirty = Ta);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class LS extends Mf {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == Ns && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class iQ extends Zo {
  constructor(e, t, n, i, s, a, o, A, l, u) {
    super(e, t, n, i, s, a, o, l, u), this.spec = A;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, t, n, i) {
    if (this.dirty == Ta)
      return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let s = this.spec.update(e, t, n);
      return s && this.updateInner(e, t, n, i), s;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, t, n, i);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, t, n, i) {
    this.spec.setSelection ? this.spec.setSelection(e, t, n.root) : super.setSelection(e, t, n, i);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function US(r, e, t) {
  let n = r.firstChild, i = !1;
  for (let s = 0; s < e.length; s++) {
    let a = e[s], o = a.dom;
    if (o.parentNode == r) {
      for (; o != n; )
        n = Jw(n), i = !0;
      n = n.nextSibling;
    } else
      i = !0, r.insertBefore(o, n);
    if (a instanceof Al) {
      let A = n ? n.previousSibling : r.lastChild;
      US(a.contentDOM, a.children, t), n = A ? A.nextSibling : r.firstChild;
    }
  }
  for (; n; )
    n = Jw(n), i = !0;
  i && t.trackWrites == r && (t.trackWrites = null);
}
const Zc = function(r) {
  r && (this.nodeName = r);
};
Zc.prototype = /* @__PURE__ */ Object.create(null);
const jA = [new Zc()];
function nv(r, e, t) {
  if (r.length == 0)
    return jA;
  let n = t ? jA[0] : new Zc(), i = [n];
  for (let s = 0; s < r.length; s++) {
    let a = r[s].type.attrs;
    if (a) {
      a.nodeName && i.push(n = new Zc(a.nodeName));
      for (let o in a) {
        let A = a[o];
        A != null && (t && i.length == 1 && i.push(n = new Zc(e.isInline ? "span" : "div")), o == "class" ? n.class = (n.class ? n.class + " " : "") + A : o == "style" ? n.style = (n.style ? n.style + ";" : "") + A : o != "nodeName" && (n[o] = A));
      }
    }
  }
  return i;
}
function NS(r, e, t, n) {
  if (t == jA && n == jA)
    return e;
  let i = e;
  for (let s = 0; s < n.length; s++) {
    let a = n[s], o = t[s];
    if (s) {
      let A;
      o && o.nodeName == a.nodeName && i != r && (A = i.parentNode) && A.nodeName.toLowerCase() == a.nodeName || (A = document.createElement(a.nodeName), A.pmIsDeco = !0, A.appendChild(i), o = jA[0]), i = A;
    }
    sQ(i, o || jA[0], a);
  }
  return i;
}
function sQ(r, e, t) {
  for (let n in e)
    n != "class" && n != "style" && n != "nodeName" && !(n in t) && r.removeAttribute(n);
  for (let n in t)
    n != "class" && n != "style" && n != "nodeName" && t[n] != e[n] && r.setAttribute(n, t[n]);
  if (e.class != t.class) {
    let n = e.class ? e.class.split(" ").filter(Boolean) : [], i = t.class ? t.class.split(" ").filter(Boolean) : [];
    for (let s = 0; s < n.length; s++)
      i.indexOf(n[s]) == -1 && r.classList.remove(n[s]);
    for (let s = 0; s < i.length; s++)
      n.indexOf(i[s]) == -1 && r.classList.add(i[s]);
    r.classList.length == 0 && r.removeAttribute("class");
  }
  if (e.style != t.style) {
    if (e.style) {
      let n = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
      for (; i = n.exec(e.style); )
        r.style.removeProperty(i[1]);
    }
    t.style && (r.style.cssText += t.style);
  }
}
function OS(r, e, t) {
  return NS(r, r, jA, nv(e, t, r.nodeType != 1));
}
function _p(r, e) {
  if (r.length != e.length)
    return !1;
  for (let t = 0; t < r.length; t++)
    if (!r[t].type.eq(e[t].type))
      return !1;
  return !0;
}
function Jw(r) {
  let e = r.nextSibling;
  return r.parentNode.removeChild(r), e;
}
class aQ {
  constructor(e, t, n) {
    this.lock = t, this.view = n, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = oQ(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, t) {
    if (e != t) {
      for (let n = e; n < t; n++)
        this.top.children[n].destroy();
      this.top.children.splice(e, t - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, t, n) {
    let i = 0, s = this.stack.length >> 1, a = Math.min(s, e.length);
    for (; i < a && (i == s - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1; )
      i++;
    for (; i < s; )
      this.destroyRest(), this.top.dirty = Ns, this.index = this.stack.pop(), this.top = this.stack.pop(), s--;
    for (; s < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let o = -1;
      for (let A = this.index; A < Math.min(this.index + 3, this.top.children.length); A++) {
        let l = this.top.children[A];
        if (l.matchesMark(e[s]) && !this.isLocked(l.dom)) {
          o = A;
          break;
        }
      }
      if (o > -1)
        o > this.index && (this.changed = !0, this.destroyBetween(this.index, o)), this.top = this.top.children[this.index];
      else {
        let A = Al.create(this.top, e[s], t, n);
        this.top.children.splice(this.index, 0, A), this.top = A, this.changed = !0;
      }
      this.index = 0, s++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, t, n, i) {
    let s = -1, a;
    if (i >= this.preMatch.index && (a = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && a.matchesNode(e, t, n))
      s = this.top.children.indexOf(a, this.index);
    else
      for (let o = this.index, A = Math.min(this.top.children.length, o + 5); o < A; o++) {
        let l = this.top.children[o];
        if (l.matchesNode(e, t, n) && !this.preMatch.matched.has(l)) {
          s = o;
          break;
        }
      }
    return s < 0 ? !1 : (this.destroyBetween(this.index, s), this.index++, !0);
  }
  updateNodeAt(e, t, n, i, s) {
    let a = this.top.children[i];
    return a.dirty == Ta && a.dom == a.contentDOM && (a.dirty = HA), a.update(e, t, n, s) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let t = e.parentNode;
      if (!t)
        return -1;
      if (t == this.top.contentDOM) {
        let n = e.pmViewDesc;
        if (n) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == n)
              return i;
        }
        return -1;
      }
      e = t;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, t, n, i, s, a) {
    for (let o = this.index; o < this.top.children.length; o++) {
      let A = this.top.children[o];
      if (A instanceof Zo) {
        let l = this.preMatch.matched.get(A);
        if (l != null && l != s)
          return !1;
        let u = A.dom, c, h = this.isLocked(u) && !(e.isText && A.node && A.node.isText && A.nodeDOM.nodeValue == e.text && A.dirty != Ta && _p(t, A.outerDeco));
        if (!h && A.update(e, t, n, i))
          return this.destroyBetween(this.index, o), A.dom != u && (this.changed = !0), this.index++, !0;
        if (!h && (c = this.recreateWrapper(A, e, t, n, i, a)))
          return this.destroyBetween(this.index, o), this.top.children[this.index] = c, c.contentDOM && (c.dirty = HA, c.updateChildren(i, a + 1), c.dirty = Ns), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, t, n, i, s, a) {
    if (e.dirty || t.isAtom || !e.children.length || !e.node.content.eq(t.content) || !_p(n, e.outerDeco) || !i.eq(e.innerDeco))
      return null;
    let o = Zo.create(this.top, t, n, i, s, a);
    if (o.contentDOM) {
      o.children = e.children, e.children = [];
      for (let A of o.children)
        A.parent = o;
    }
    return e.destroy(), o;
  }
  // Insert the node as a newly created node desc.
  addNode(e, t, n, i, s) {
    let a = Zo.create(this.top, e, t, n, i, s);
    a.contentDOM && a.updateChildren(i, s + 1), this.top.children.splice(this.index++, 0, a), this.changed = !0;
  }
  placeWidget(e, t, n) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let s = new kS(this.top, e, t, n);
      this.top.children.splice(this.index++, 0, s), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], t = this.top;
    for (; e instanceof Al; )
      t = e, e = t.children[t.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof lg) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Oi || Si) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", t), this.addHackNode("BR", this.top));
  }
  addHackNode(e, t) {
    if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e))
      this.index++;
    else {
      let n = document.createElement(e);
      e == "IMG" && (n.className = "ProseMirror-separator", n.alt = ""), e == "BR" && (n.className = "ProseMirror-trailingBreak");
      let i = new LS(this.top, [], n, null);
      t != this.top ? t.children.push(i) : t.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function oQ(r, e) {
  let t = e, n = t.children.length, i = r.childCount, s = /* @__PURE__ */ new Map(), a = [];
  e: for (; i > 0; ) {
    let o;
    for (; ; )
      if (n) {
        let l = t.children[n - 1];
        if (l instanceof Al)
          t = l, n = l.children.length;
        else {
          o = l, n--;
          break;
        }
      } else {
        if (t == e)
          break e;
        n = t.parent.children.indexOf(t), t = t.parent;
      }
    let A = o.node;
    if (A) {
      if (A != r.child(i - 1))
        break;
      --i, s.set(o, i), a.push(o);
    }
  }
  return { index: i, matched: s, matches: a.reverse() };
}
function AQ(r, e) {
  return r.type.side - e.type.side;
}
function lQ(r, e, t, n) {
  let i = e.locals(r), s = 0;
  if (i.length == 0) {
    for (let l = 0; l < r.childCount; l++) {
      let u = r.child(l);
      n(u, i, e.forChild(s, u), l), s += u.nodeSize;
    }
    return;
  }
  let a = 0, o = [], A = null;
  for (let l = 0; ; ) {
    let u, c;
    for (; a < i.length && i[a].to == s; ) {
      let v = i[a++];
      v.widget && (u ? (c || (c = [u])).push(v) : u = v);
    }
    if (u)
      if (c) {
        c.sort(AQ);
        for (let v = 0; v < c.length; v++)
          t(c[v], l, !!A);
      } else
        t(u, l, !!A);
    let h, f;
    if (A)
      f = -1, h = A, A = null;
    else if (l < r.childCount)
      f = l, h = r.child(l++);
    else
      break;
    for (let v = 0; v < o.length; v++)
      o[v].to <= s && o.splice(v--, 1);
    for (; a < i.length && i[a].from <= s && i[a].to > s; )
      o.push(i[a++]);
    let d = s + h.nodeSize;
    if (h.isText) {
      let v = d;
      a < i.length && i[a].from < v && (v = i[a].from);
      for (let m = 0; m < o.length; m++)
        o[m].to < v && (v = o[m].to);
      v < d && (A = h.cut(v - s), h = h.cut(0, v - s), d = v, f = -1);
    } else
      for (; a < i.length && i[a].to < d; )
        a++;
    let p = h.isInline && !h.isLeaf ? o.filter((v) => !v.inline) : o.slice();
    n(h, p, e.forChild(s, h), f), s = d;
  }
}
function uQ(r) {
  if (r.nodeName == "UL" || r.nodeName == "OL") {
    let e = r.style.cssText;
    r.style.cssText = e + "; list-style: square !important", window.getComputedStyle(r).listStyle, r.style.cssText = e;
  }
}
function cQ(r, e, t, n) {
  for (let i = 0, s = 0; i < r.childCount && s <= n; ) {
    let a = r.child(i++), o = s;
    if (s += a.nodeSize, !a.isText)
      continue;
    let A = a.text;
    for (; i < r.childCount; ) {
      let l = r.child(i++);
      if (s += l.nodeSize, !l.isText)
        break;
      A += l.text;
    }
    if (s >= t) {
      if (s >= n && A.slice(n - e.length - o, n - o) == e)
        return n - e.length;
      let l = o < n ? A.lastIndexOf(e, n - o - 1) : -1;
      if (l >= 0 && l + e.length + o >= t)
        return o + l;
      if (t == n && A.length >= n + e.length - o && A.slice(n - o, n - o + e.length) == e)
        return n;
    }
  }
  return -1;
}
function iv(r, e, t, n, i) {
  let s = [];
  for (let a = 0, o = 0; a < r.length; a++) {
    let A = r[a], l = o, u = o += A.size;
    l >= t || u <= e ? s.push(A) : (l < e && s.push(A.slice(0, e - l, n)), i && (s.push(i), i = void 0), u > t && s.push(A.slice(t - l, A.size, n)));
  }
  return s;
}
function J2(r, e = null) {
  let t = r.domSelectionRange(), n = r.state.doc;
  if (!t.focusNode)
    return null;
  let i = r.docView.nearestDesc(t.focusNode), s = i && i.size == 0, a = r.docView.posFromDOM(t.focusNode, t.focusOffset, 1);
  if (a < 0)
    return null;
  let o = n.resolve(a), A, l;
  if (Ag(t)) {
    for (A = a; i && !i.node; )
      i = i.parent;
    let c = i.node;
    if (i && c.isAtom && Tt.isSelectable(c) && i.parent && !(c.isInline && D6(t.focusNode, t.focusOffset, i.dom))) {
      let h = i.posBefore;
      l = new Tt(a == h ? o : n.resolve(h));
    }
  } else {
    if (t instanceof r.dom.ownerDocument.defaultView.Selection && t.rangeCount > 1) {
      let c = a, h = a;
      for (let f = 0; f < t.rangeCount; f++) {
        let d = t.getRangeAt(f);
        c = Math.min(c, r.docView.posFromDOM(d.startContainer, d.startOffset, 1)), h = Math.max(h, r.docView.posFromDOM(d.endContainer, d.endOffset, -1));
      }
      if (c < 0)
        return null;
      [A, a] = h == r.state.selection.anchor ? [h, c] : [c, h], o = n.resolve(a);
    } else
      A = r.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1);
    if (A < 0)
      return null;
  }
  let u = n.resolve(A);
  if (!l) {
    let c = e == "pointer" || r.state.selection.head < o.pos && !s ? 1 : -1;
    l = Y2(r, u, o, c);
  }
  return l;
}
function QS(r) {
  return r.editable ? r.hasFocus() : MS(r) && document.activeElement && document.activeElement.contains(r.dom);
}
function so(r, e = !1) {
  let t = r.state.selection;
  if (DS(r, t), !!QS(r)) {
    if (!e && r.input.mouseDown && r.input.mouseDown.allowDefault && Si) {
      let n = r.domSelectionRange(), i = r.domObserver.currentSelection;
      if (n.anchorNode && i.anchorNode && ol(n.anchorNode, n.anchorOffset, i.anchorNode, i.anchorOffset)) {
        r.input.mouseDown.delayedSelectionSync = !0, r.domObserver.setCurSelection();
        return;
      }
    }
    if (r.domObserver.disconnectSelection(), r.cursorWrapper)
      hQ(r);
    else {
      let { anchor: n, head: i } = t, s, a;
      Yw && !(t instanceof zt) && (t.$from.parent.inlineContent || (s = Zw(r, t.from)), !t.empty && !t.$from.parent.inlineContent && (a = Zw(r, t.to))), r.docView.setSelection(n, i, r, e), Yw && (s && eB(s), a && eB(a)), t.visible ? r.dom.classList.remove("ProseMirror-hideselection") : (r.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && fQ(r));
    }
    r.domObserver.setCurSelection(), r.domObserver.connectSelection();
  }
}
const Yw = Oi || Si && _S < 63;
function Zw(r, e) {
  let { node: t, offset: n } = r.docView.domFromPos(e, 0), i = n < t.childNodes.length ? t.childNodes[n] : null, s = n ? t.childNodes[n - 1] : null;
  if (Oi && i && i.contentEditable == "false")
    return Wm(i);
  if ((!i || i.contentEditable == "false") && (!s || s.contentEditable == "false")) {
    if (i)
      return Wm(i);
    if (s)
      return Wm(s);
  }
}
function Wm(r) {
  return r.contentEditable = "true", Oi && r.draggable && (r.draggable = !1, r.wasDraggable = !0), r;
}
function eB(r) {
  r.contentEditable = "false", r.wasDraggable && (r.draggable = !0, r.wasDraggable = null);
}
function fQ(r) {
  let e = r.dom.ownerDocument;
  e.removeEventListener("selectionchange", r.input.hideSelectionGuard);
  let t = r.domSelectionRange(), n = t.anchorNode, i = t.anchorOffset;
  e.addEventListener("selectionchange", r.input.hideSelectionGuard = () => {
    (t.anchorNode != n || t.anchorOffset != i) && (e.removeEventListener("selectionchange", r.input.hideSelectionGuard), setTimeout(() => {
      (!QS(r) || r.state.selection.visible) && r.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function hQ(r) {
  let e = r.domSelection(), t = document.createRange();
  if (!e)
    return;
  let n = r.cursorWrapper.dom, i = n.nodeName == "IMG";
  i ? t.setStart(n.parentNode, ai(n) + 1) : t.setStart(n, 0), t.collapse(!0), e.removeAllRanges(), e.addRange(t), !i && !r.state.selection.visible && Ji && Yo <= 11 && (n.disabled = !0, n.disabled = !1);
}
function DS(r, e) {
  if (e instanceof Tt) {
    let t = r.docView.descAt(e.from);
    t != r.lastSelectedViewDesc && (tB(r), t && t.selectNode(), r.lastSelectedViewDesc = t);
  } else
    tB(r);
}
function tB(r) {
  r.lastSelectedViewDesc && (r.lastSelectedViewDesc.parent && r.lastSelectedViewDesc.deselectNode(), r.lastSelectedViewDesc = void 0);
}
function Y2(r, e, t, n) {
  return r.someProp("createSelectionBetween", (i) => i(r, e, t)) || zt.between(e, t, n);
}
function rB(r) {
  return r.editable && !r.hasFocus() ? !1 : MS(r);
}
function MS(r) {
  let e = r.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return r.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (r.editable || r.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function dQ(r) {
  let e = r.docView.domFromPos(r.state.selection.anchor, 0), t = r.domSelectionRange();
  return ol(e.node, e.offset, t.anchorNode, t.anchorOffset);
}
function sv(r, e) {
  let { $anchor: t, $head: n } = r.selection, i = e > 0 ? t.max(n) : t.min(n), s = i.parent.inlineContent ? i.depth ? r.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
  return s && Yt.findFrom(s, e);
}
function Oo(r, e) {
  return r.dispatch(r.state.tr.setSelection(e).scrollIntoView()), !0;
}
function nB(r, e, t) {
  let n = r.state.selection;
  if (n instanceof zt)
    if (t.indexOf("s") > -1) {
      let { $head: i } = n, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter;
      if (!s || s.isText || !s.isLeaf)
        return !1;
      let a = r.state.doc.resolve(i.pos + s.nodeSize * (e < 0 ? -1 : 1));
      return Oo(r, new zt(n.$anchor, a));
    } else if (n.empty) {
      if (r.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let i = sv(r.state, e);
        return i && i instanceof Tt ? Oo(r, i) : !1;
      } else if (!(Ss && t.indexOf("m") > -1)) {
        let i = n.$head, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, a;
        if (!s || s.isText)
          return !1;
        let o = e < 0 ? i.pos - s.nodeSize : i.pos;
        return s.isAtom || (a = r.docView.descAt(o)) && !a.contentDOM ? Tt.isSelectable(s) ? Oo(r, new Tt(e < 0 ? r.state.doc.resolve(i.pos - s.nodeSize) : i)) : Df ? Oo(r, new zt(r.state.doc.resolve(e < 0 ? o : o + s.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (n instanceof Tt && n.node.isInline)
      return Oo(r, new zt(e > 0 ? n.$to : n.$from));
    {
      let i = sv(r.state, e);
      return i ? Oo(r, i) : !1;
    }
  }
}
function Ep(r) {
  return r.nodeType == 3 ? r.nodeValue.length : r.childNodes.length;
}
function ef(r, e) {
  let t = r.pmViewDesc;
  return t && t.size == 0 && (e < 0 || r.nextSibling || r.nodeName != "BR");
}
function $l(r, e) {
  return e < 0 ? pQ(r) : gQ(r);
}
function pQ(r) {
  let e = r.domSelectionRange(), t = e.focusNode, n = e.focusOffset;
  if (!t)
    return;
  let i, s, a = !1;
  for (aa && t.nodeType == 1 && n < Ep(t) && ef(t.childNodes[n], -1) && (a = !0); ; )
    if (n > 0) {
      if (t.nodeType != 1)
        break;
      {
        let o = t.childNodes[n - 1];
        if (ef(o, -1))
          i = t, s = --n;
        else if (o.nodeType == 3)
          t = o, n = t.nodeValue.length;
        else
          break;
      }
    } else {
      if (RS(t))
        break;
      {
        let o = t.previousSibling;
        for (; o && ef(o, -1); )
          i = t.parentNode, s = ai(o), o = o.previousSibling;
        if (o)
          t = o, n = Ep(t);
        else {
          if (t = t.parentNode, t == r.dom)
            break;
          n = 0;
        }
      }
    }
  a ? av(r, t, n) : i && av(r, i, s);
}
function gQ(r) {
  let e = r.domSelectionRange(), t = e.focusNode, n = e.focusOffset;
  if (!t)
    return;
  let i = Ep(t), s, a;
  for (; ; )
    if (n < i) {
      if (t.nodeType != 1)
        break;
      let o = t.childNodes[n];
      if (ef(o, 1))
        s = t, a = ++n;
      else
        break;
    } else {
      if (RS(t))
        break;
      {
        let o = t.nextSibling;
        for (; o && ef(o, 1); )
          s = o.parentNode, a = ai(o) + 1, o = o.nextSibling;
        if (o)
          t = o, n = 0, i = Ep(t);
        else {
          if (t = t.parentNode, t == r.dom)
            break;
          n = i = 0;
        }
      }
    }
  s && av(r, s, a);
}
function RS(r) {
  let e = r.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function mQ(r, e) {
  for (; r && e == r.childNodes.length && !Qf(r); )
    e = ai(r) + 1, r = r.parentNode;
  for (; r && e < r.childNodes.length; ) {
    let t = r.childNodes[e];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    r = t, e = 0;
  }
}
function vQ(r, e) {
  for (; r && !e && !Qf(r); )
    e = ai(r), r = r.parentNode;
  for (; r && e; ) {
    let t = r.childNodes[e - 1];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    r = t, e = r.childNodes.length;
  }
}
function av(r, e, t) {
  if (e.nodeType != 3) {
    let s, a;
    (a = mQ(e, t)) ? (e = a, t = 0) : (s = vQ(e, t)) && (e = s, t = s.nodeValue.length);
  }
  let n = r.domSelection();
  if (!n)
    return;
  if (Ag(n)) {
    let s = document.createRange();
    s.setEnd(e, t), s.setStart(e, t), n.removeAllRanges(), n.addRange(s);
  } else n.extend && n.extend(e, t);
  r.domObserver.setCurSelection();
  let { state: i } = r;
  setTimeout(() => {
    r.state == i && so(r);
  }, 50);
}
function iB(r, e) {
  let t = r.state.doc.resolve(e);
  if (!(Si || P6) && t.parent.inlineContent) {
    let i = r.coordsAtPos(e);
    if (e > t.start()) {
      let s = r.coordsAtPos(e - 1), a = (s.top + s.bottom) / 2;
      if (a > i.top && a < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left < i.left ? "ltr" : "rtl";
    }
    if (e < t.end()) {
      let s = r.coordsAtPos(e + 1), a = (s.top + s.bottom) / 2;
      if (a > i.top && a < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left > i.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(r.dom).direction == "rtl" ? "rtl" : "ltr";
}
function sB(r, e, t) {
  let n = r.state.selection;
  if (n instanceof zt && !n.empty || t.indexOf("s") > -1 || Ss && t.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: s } = n;
  if (!i.parent.inlineContent || r.endOfTextblock(e < 0 ? "up" : "down")) {
    let a = sv(r.state, e);
    if (a && a instanceof Tt)
      return Oo(r, a);
  }
  if (!i.parent.inlineContent) {
    let a = e < 0 ? i : s, o = n instanceof Us ? Yt.near(a, e) : Yt.findFrom(a, e);
    return o ? Oo(r, o) : !1;
  }
  return !1;
}
function aB(r, e) {
  if (!(r.state.selection instanceof zt))
    return !0;
  let { $head: t, $anchor: n, empty: i } = r.state.selection;
  if (!t.sameParent(n))
    return !0;
  if (!i)
    return !1;
  if (r.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let s = !t.textOffset && (e < 0 ? t.nodeBefore : t.nodeAfter);
  if (s && !s.isText) {
    let a = r.state.tr;
    return e < 0 ? a.delete(t.pos - s.nodeSize, t.pos) : a.delete(t.pos, t.pos + s.nodeSize), r.dispatch(a), !0;
  }
  return !1;
}
function oB(r, e, t) {
  r.domObserver.stop(), e.contentEditable = t, r.domObserver.start();
}
function bQ(r) {
  if (!Oi || r.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: t } = r.domSelectionRange();
  if (e && e.nodeType == 1 && t == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let n = e.firstChild;
    oB(r, n, "true"), setTimeout(() => oB(r, n, "false"), 20);
  }
  return !1;
}
function yQ(r) {
  let e = "";
  return r.ctrlKey && (e += "c"), r.metaKey && (e += "m"), r.altKey && (e += "a"), r.shiftKey && (e += "s"), e;
}
function wQ(r, e) {
  let t = e.keyCode, n = yQ(e);
  if (t == 8 || Ss && t == 72 && n == "c")
    return aB(r, -1) || $l(r, -1);
  if (t == 46 && !e.shiftKey || Ss && t == 68 && n == "c")
    return aB(r, 1) || $l(r, 1);
  if (t == 13 || t == 27)
    return !0;
  if (t == 37 || Ss && t == 66 && n == "c") {
    let i = t == 37 ? iB(r, r.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return nB(r, i, n) || $l(r, i);
  } else if (t == 39 || Ss && t == 70 && n == "c") {
    let i = t == 39 ? iB(r, r.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return nB(r, i, n) || $l(r, i);
  } else {
    if (t == 38 || Ss && t == 80 && n == "c")
      return sB(r, -1, n) || $l(r, -1);
    if (t == 40 || Ss && t == 78 && n == "c")
      return bQ(r) || sB(r, 1, n) || $l(r, 1);
    if (n == (Ss ? "m" : "c") && (t == 66 || t == 73 || t == 89 || t == 90))
      return !0;
  }
  return !1;
}
function Z2(r, e) {
  r.someProp("transformCopied", (f) => {
    e = f(e, r);
  });
  let t = [], { content: n, openStart: i, openEnd: s } = e;
  for (; i > 1 && s > 1 && n.childCount == 1 && n.firstChild.childCount == 1; ) {
    i--, s--;
    let f = n.firstChild;
    t.push(f.type.name, f.attrs != f.type.defaultAttrs ? f.attrs : null), n = f.content;
  }
  let a = r.someProp("clipboardSerializer") || ul.fromSchema(r.state.schema), o = VS(), A = o.createElement("div");
  A.appendChild(a.serializeFragment(n, { document: o }));
  let l = A.firstChild, u, c = 0;
  for (; l && l.nodeType == 1 && (u = $S[l.nodeName.toLowerCase()]); ) {
    for (let f = u.length - 1; f >= 0; f--) {
      let d = o.createElement(u[f]);
      for (; A.firstChild; )
        d.appendChild(A.firstChild);
      A.appendChild(d), c++;
    }
    l = A.firstChild;
  }
  l && l.nodeType == 1 && l.setAttribute("data-pm-slice", `${i} ${s}${c ? ` -${c}` : ""} ${JSON.stringify(t)}`);
  let h = r.someProp("clipboardTextSerializer", (f) => f(e, r)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: A, text: h, slice: e };
}
function PS(r, e, t, n, i) {
  let s = i.parent.type.spec.code, a, o;
  if (!t && !e)
    return null;
  let A = e && (n || s || !t);
  if (A) {
    if (r.someProp("transformPastedText", (h) => {
      e = h(e, s || n, r);
    }), s)
      return e ? new lt(Ye.from(r.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : lt.empty;
    let c = r.someProp("clipboardTextParser", (h) => h(e, i, n, r));
    if (c)
      o = c;
    else {
      let h = i.marks(), { schema: f } = r.state, d = ul.fromSchema(f);
      a = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((p) => {
        let v = a.appendChild(document.createElement("p"));
        p && v.appendChild(d.serializeNode(f.text(p, h)));
      });
    }
  } else
    r.someProp("transformPastedHTML", (c) => {
      t = c(t, r);
    }), a = EQ(t), Df && SQ(a);
  let l = a && a.querySelector("[data-pm-slice]"), u = l && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(l.getAttribute("data-pm-slice") || "");
  if (u && u[3])
    for (let c = +u[3]; c > 0; c--) {
      let h = a.firstChild;
      for (; h && h.nodeType != 1; )
        h = h.nextSibling;
      if (!h)
        break;
      a = h;
    }
  if (o || (o = (r.someProp("clipboardParser") || r.someProp("domParser") || Jc.fromSchema(r.state.schema)).parseSlice(a, {
    preserveWhitespace: !!(A || u),
    context: i,
    ruleFromNode(h) {
      return h.nodeName == "BR" && !h.nextSibling && h.parentNode && !BQ.test(h.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), u)
    o = IQ(AB(o, +u[1], +u[2]), u[4]);
  else if (o = lt.maxOpen(CQ(o.content, i), !0), o.openStart || o.openEnd) {
    let c = 0, h = 0;
    for (let f = o.content.firstChild; c < o.openStart && !f.type.spec.isolating; c++, f = f.firstChild)
      ;
    for (let f = o.content.lastChild; h < o.openEnd && !f.type.spec.isolating; h++, f = f.lastChild)
      ;
    o = AB(o, c, h);
  }
  return r.someProp("transformPasted", (c) => {
    o = c(o, r);
  }), o;
}
const BQ = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function CQ(r, e) {
  if (r.childCount < 2)
    return r;
  for (let t = e.depth; t >= 0; t--) {
    let i = e.node(t).contentMatchAt(e.index(t)), s, a = [];
    if (r.forEach((o) => {
      if (!a)
        return;
      let A = i.findWrapping(o.type), l;
      if (!A)
        return a = null;
      if (l = a.length && s.length && jS(A, s, o, a[a.length - 1], 0))
        a[a.length - 1] = l;
      else {
        a.length && (a[a.length - 1] = KS(a[a.length - 1], s.length));
        let u = HS(o, A);
        a.push(u), i = i.matchType(u.type), s = A;
      }
    }), a)
      return Ye.from(a);
  }
  return r;
}
function HS(r, e, t = 0) {
  for (let n = e.length - 1; n >= t; n--)
    r = e[n].create(null, Ye.from(r));
  return r;
}
function jS(r, e, t, n, i) {
  if (i < r.length && i < e.length && r[i] == e[i]) {
    let s = jS(r, e, t, n.lastChild, i + 1);
    if (s)
      return n.copy(n.content.replaceChild(n.childCount - 1, s));
    if (n.contentMatchAt(n.childCount).matchType(i == r.length - 1 ? t.type : r[i + 1]))
      return n.copy(n.content.append(Ye.from(HS(t, r, i + 1))));
  }
}
function KS(r, e) {
  if (e == 0)
    return r;
  let t = r.content.replaceChild(r.childCount - 1, KS(r.lastChild, e - 1)), n = r.contentMatchAt(r.childCount).fillBefore(Ye.empty, !0);
  return r.copy(t.append(n));
}
function ov(r, e, t, n, i, s) {
  let a = e < 0 ? r.firstChild : r.lastChild, o = a.content;
  return r.childCount > 1 && (s = 0), i < n - 1 && (o = ov(o, e, t, n, i + 1, s)), i >= t && (o = e < 0 ? a.contentMatchAt(0).fillBefore(o, s <= i).append(o) : o.append(a.contentMatchAt(a.childCount).fillBefore(Ye.empty, !0))), r.replaceChild(e < 0 ? 0 : r.childCount - 1, a.copy(o));
}
function AB(r, e, t) {
  return e < r.openStart && (r = new lt(ov(r.content, -1, e, r.openStart, 0, r.openEnd), e, r.openEnd)), t < r.openEnd && (r = new lt(ov(r.content, 1, t, r.openEnd, 0, 0), r.openStart, t)), r;
}
const $S = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let lB = null;
function VS() {
  return lB || (lB = document.implementation.createHTMLDocument("title"));
}
let Xm = null;
function _Q(r) {
  let e = window.trustedTypes;
  return e ? (Xm || (Xm = e.createPolicy("ProseMirrorClipboard", { createHTML: (t) => t })), Xm.createHTML(r)) : r;
}
function EQ(r) {
  let e = /^(\s*<meta [^>]*>)*/.exec(r);
  e && (r = r.slice(e[0].length));
  let t = VS().createElement("div"), n = /<([a-z][^>\s]+)/i.exec(r), i;
  if ((i = n && $S[n[1].toLowerCase()]) && (r = i.map((s) => "<" + s + ">").join("") + r + i.map((s) => "</" + s + ">").reverse().join("")), t.innerHTML = _Q(r), i)
    for (let s = 0; s < i.length; s++)
      t = t.querySelector(i[s]) || t;
  return t;
}
function SQ(r) {
  let e = r.querySelectorAll(Si ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let t = 0; t < e.length; t++) {
    let n = e[t];
    n.childNodes.length == 1 && n.textContent == " " && n.parentNode && n.parentNode.replaceChild(r.ownerDocument.createTextNode(" "), n);
  }
}
function IQ(r, e) {
  if (!r.size)
    return r;
  let t = r.content.firstChild.type.schema, n;
  try {
    n = JSON.parse(e);
  } catch {
    return r;
  }
  let { content: i, openStart: s, openEnd: a } = r;
  for (let o = n.length - 2; o >= 0; o -= 2) {
    let A = t.nodes[n[o]];
    if (!A || A.hasRequiredAttrs())
      break;
    i = Ye.from(A.create(n[o + 1], i)), s++, a++;
  }
  return new lt(i, s, a);
}
const Qi = {}, Di = {}, FQ = { touchstart: !0, touchmove: !0 };
class TQ {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function xQ(r) {
  for (let e in Qi) {
    let t = Qi[e];
    r.dom.addEventListener(e, r.input.eventHandlers[e] = (n) => {
      LQ(r, n) && !eb(r, n) && (r.editable || !(n.type in Di)) && t(r, n);
    }, FQ[e] ? { passive: !0 } : void 0);
  }
  Oi && r.dom.addEventListener("input", () => null), Av(r);
}
function Vo(r, e) {
  r.input.lastSelectionOrigin = e, r.input.lastSelectionTime = Date.now();
}
function kQ(r) {
  r.domObserver.stop();
  for (let e in r.input.eventHandlers)
    r.dom.removeEventListener(e, r.input.eventHandlers[e]);
  clearTimeout(r.input.composingTimeout), clearTimeout(r.input.lastIOSEnterFallbackTimeout);
}
function Av(r) {
  r.someProp("handleDOMEvents", (e) => {
    for (let t in e)
      r.input.eventHandlers[t] || r.dom.addEventListener(t, r.input.eventHandlers[t] = (n) => eb(r, n));
  });
}
function eb(r, e) {
  return r.someProp("handleDOMEvents", (t) => {
    let n = t[e.type];
    return n ? n(r, e) || e.defaultPrevented : !1;
  });
}
function LQ(r, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target; t != r.dom; t = t.parentNode)
    if (!t || t.nodeType == 11 || t.pmViewDesc && t.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function UQ(r, e) {
  !eb(r, e) && Qi[e.type] && (r.editable || !(e.type in Di)) && Qi[e.type](r, e);
}
Di.keydown = (r, e) => {
  let t = e;
  if (r.input.shiftKey = t.keyCode == 16 || t.shiftKey, !GS(r, t) && (r.input.lastKeyCode = t.keyCode, r.input.lastKeyCodeTime = Date.now(), !(no && Si && t.keyCode == 13)))
    if (t.keyCode != 229 && r.domObserver.forceFlush(), xu && t.keyCode == 13 && !t.ctrlKey && !t.altKey && !t.metaKey) {
      let n = Date.now();
      r.input.lastIOSEnter = n, r.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        r.input.lastIOSEnter == n && (r.someProp("handleKeyDown", (i) => i(r, OA(13, "Enter"))), r.input.lastIOSEnter = 0);
      }, 200);
    } else r.someProp("handleKeyDown", (n) => n(r, t)) || wQ(r, t) ? t.preventDefault() : Vo(r, "key");
};
Di.keyup = (r, e) => {
  e.keyCode == 16 && (r.input.shiftKey = !1);
};
Di.keypress = (r, e) => {
  let t = e;
  if (GS(r, t) || !t.charCode || t.ctrlKey && !t.altKey || Ss && t.metaKey)
    return;
  if (r.someProp("handleKeyPress", (i) => i(r, t))) {
    t.preventDefault();
    return;
  }
  let n = r.state.selection;
  if (!(n instanceof zt) || !n.$from.sameParent(n.$to)) {
    let i = String.fromCharCode(t.charCode);
    !/[\r\n]/.test(i) && !r.someProp("handleTextInput", (s) => s(r, n.$from.pos, n.$to.pos, i)) && r.dispatch(r.state.tr.insertText(i).scrollIntoView()), t.preventDefault();
  }
};
function ug(r) {
  return { left: r.clientX, top: r.clientY };
}
function NQ(r, e) {
  let t = e.x - r.clientX, n = e.y - r.clientY;
  return t * t + n * n < 100;
}
function tb(r, e, t, n, i) {
  if (n == -1)
    return !1;
  let s = r.state.doc.resolve(n);
  for (let a = s.depth + 1; a > 0; a--)
    if (r.someProp(e, (o) => a > s.depth ? o(r, t, s.nodeAfter, s.before(a), i, !0) : o(r, t, s.node(a), s.before(a), i, !1)))
      return !0;
  return !1;
}
function Cu(r, e, t) {
  if (r.focused || r.focus(), r.state.selection.eq(e))
    return;
  let n = r.state.tr.setSelection(e);
  n.setMeta("pointer", !0), r.dispatch(n);
}
function OQ(r, e) {
  if (e == -1)
    return !1;
  let t = r.state.doc.resolve(e), n = t.nodeAfter;
  return n && n.isAtom && Tt.isSelectable(n) ? (Cu(r, new Tt(t)), !0) : !1;
}
function QQ(r, e) {
  if (e == -1)
    return !1;
  let t = r.state.selection, n, i;
  t instanceof Tt && (n = t.node);
  let s = r.state.doc.resolve(e);
  for (let a = s.depth + 1; a > 0; a--) {
    let o = a > s.depth ? s.nodeAfter : s.node(a);
    if (Tt.isSelectable(o)) {
      n && t.$from.depth > 0 && a >= t.$from.depth && s.before(t.$from.depth + 1) == t.$from.pos ? i = s.before(t.$from.depth) : i = s.before(a);
      break;
    }
  }
  return i != null ? (Cu(r, Tt.create(r.state.doc, i)), !0) : !1;
}
function DQ(r, e, t, n, i) {
  return tb(r, "handleClickOn", e, t, n) || r.someProp("handleClick", (s) => s(r, e, n)) || (i ? QQ(r, t) : OQ(r, t));
}
function MQ(r, e, t, n) {
  return tb(r, "handleDoubleClickOn", e, t, n) || r.someProp("handleDoubleClick", (i) => i(r, e, n));
}
function RQ(r, e, t, n) {
  return tb(r, "handleTripleClickOn", e, t, n) || r.someProp("handleTripleClick", (i) => i(r, e, n)) || PQ(r, t, n);
}
function PQ(r, e, t) {
  if (t.button != 0)
    return !1;
  let n = r.state.doc;
  if (e == -1)
    return n.inlineContent ? (Cu(r, zt.create(n, 0, n.content.size)), !0) : !1;
  let i = n.resolve(e);
  for (let s = i.depth + 1; s > 0; s--) {
    let a = s > i.depth ? i.nodeAfter : i.node(s), o = i.before(s);
    if (a.inlineContent)
      Cu(r, zt.create(n, o + 1, o + 1 + a.content.size));
    else if (Tt.isSelectable(a))
      Cu(r, Tt.create(n, o));
    else
      continue;
    return !0;
  }
}
function rb(r) {
  return Sp(r);
}
const zS = Ss ? "metaKey" : "ctrlKey";
Qi.mousedown = (r, e) => {
  let t = e;
  r.input.shiftKey = t.shiftKey;
  let n = rb(r), i = Date.now(), s = "singleClick";
  i - r.input.lastClick.time < 500 && NQ(t, r.input.lastClick) && !t[zS] && (r.input.lastClick.type == "singleClick" ? s = "doubleClick" : r.input.lastClick.type == "doubleClick" && (s = "tripleClick")), r.input.lastClick = { time: i, x: t.clientX, y: t.clientY, type: s };
  let a = r.posAtCoords(ug(t));
  a && (s == "singleClick" ? (r.input.mouseDown && r.input.mouseDown.done(), r.input.mouseDown = new HQ(r, a, t, !!n)) : (s == "doubleClick" ? MQ : RQ)(r, a.pos, a.inside, t) ? t.preventDefault() : Vo(r, "pointer"));
};
class HQ {
  constructor(e, t, n, i) {
    this.view = e, this.pos = t, this.event = n, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!n[zS], this.allowDefault = n.shiftKey;
    let s, a;
    if (t.inside > -1)
      s = e.state.doc.nodeAt(t.inside), a = t.inside;
    else {
      let u = e.state.doc.resolve(t.pos);
      s = u.parent, a = u.depth ? u.before() : 0;
    }
    const o = i ? null : n.target, A = o ? e.docView.nearestDesc(o, !0) : null;
    this.target = A && A.dom.nodeType == 1 ? A.dom : null;
    let { selection: l } = e.state;
    (n.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1 || l instanceof Tt && l.from <= a && l.to > a) && (this.mightDrag = {
      node: s,
      pos: a,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && aa && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), Vo(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => so(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let t = this.pos;
    this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(ug(e))), this.updateAllowDefault(e), this.allowDefault || !t ? Vo(this.view, "pointer") : DQ(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    Oi && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    Si && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (Cu(this.view, Yt.near(this.view.state.doc.resolve(t.pos))), e.preventDefault()) : Vo(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), Vo(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
Qi.touchstart = (r) => {
  r.input.lastTouch = Date.now(), rb(r), Vo(r, "pointer");
};
Qi.touchmove = (r) => {
  r.input.lastTouch = Date.now(), Vo(r, "pointer");
};
Qi.contextmenu = (r) => rb(r);
function GS(r, e) {
  return r.composing ? !0 : Oi && Math.abs(e.timeStamp - r.input.compositionEndedAt) < 500 ? (r.input.compositionEndedAt = -2e8, !0) : !1;
}
const jQ = no ? 5e3 : -1;
Di.compositionstart = Di.compositionupdate = (r) => {
  if (!r.composing) {
    r.domObserver.flush();
    let { state: e } = r, t = e.selection.$to;
    if (e.selection instanceof zt && (e.storedMarks || !t.textOffset && t.parentOffset && t.nodeBefore.marks.some((n) => n.type.spec.inclusive === !1)))
      r.markCursor = r.state.storedMarks || t.marks(), Sp(r, !0), r.markCursor = null;
    else if (Sp(r, !e.selection.empty), aa && e.selection.empty && t.parentOffset && !t.textOffset && t.nodeBefore.marks.length) {
      let n = r.domSelectionRange();
      for (let i = n.focusNode, s = n.focusOffset; i && i.nodeType == 1 && s != 0; ) {
        let a = s < 0 ? i.lastChild : i.childNodes[s - 1];
        if (!a)
          break;
        if (a.nodeType == 3) {
          let o = r.domSelection();
          o && o.collapse(a, a.nodeValue.length);
          break;
        } else
          i = a, s = -1;
      }
    }
    r.input.composing = !0;
  }
  qS(r, jQ);
};
Di.compositionend = (r, e) => {
  r.composing && (r.input.composing = !1, r.input.compositionEndedAt = e.timeStamp, r.input.compositionPendingChanges = r.domObserver.pendingRecords().length ? r.input.compositionID : 0, r.input.compositionNode = null, r.input.compositionPendingChanges && Promise.resolve().then(() => r.domObserver.flush()), r.input.compositionID++, qS(r, 20));
};
function qS(r, e) {
  clearTimeout(r.input.composingTimeout), e > -1 && (r.input.composingTimeout = setTimeout(() => Sp(r), e));
}
function WS(r) {
  for (r.composing && (r.input.composing = !1, r.input.compositionEndedAt = $Q()); r.input.compositionNodes.length > 0; )
    r.input.compositionNodes.pop().markParentsDirty();
}
function KQ(r) {
  let e = r.domSelectionRange();
  if (!e.focusNode)
    return null;
  let t = O6(e.focusNode, e.focusOffset), n = Q6(e.focusNode, e.focusOffset);
  if (t && n && t != n) {
    let i = n.pmViewDesc, s = r.domObserver.lastChangedTextNode;
    if (t == s || n == s)
      return s;
    if (!i || !i.isText(n.nodeValue))
      return n;
    if (r.input.compositionNode == n) {
      let a = t.pmViewDesc;
      if (!(!a || !a.isText(t.nodeValue)))
        return n;
    }
  }
  return t || n;
}
function $Q() {
  let r = document.createEvent("Event");
  return r.initEvent("event", !0, !0), r.timeStamp;
}
function Sp(r, e = !1) {
  if (!(no && r.domObserver.flushingSoon >= 0)) {
    if (r.domObserver.forceFlush(), WS(r), e || r.docView && r.docView.dirty) {
      let t = J2(r);
      return t && !t.eq(r.state.selection) ? r.dispatch(r.state.tr.setSelection(t)) : (r.markCursor || e) && !r.state.selection.empty ? r.dispatch(r.state.tr.deleteSelection()) : r.updateState(r.state), !0;
    }
    return !1;
  }
}
function VQ(r, e) {
  if (!r.dom.parentNode)
    return;
  let t = r.dom.parentNode.appendChild(document.createElement("div"));
  t.appendChild(e), t.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let n = getSelection(), i = document.createRange();
  i.selectNodeContents(e), r.dom.blur(), n.removeAllRanges(), n.addRange(i), setTimeout(() => {
    t.parentNode && t.parentNode.removeChild(t), r.focus();
  }, 50);
}
const yf = Ji && Yo < 15 || xu && H6 < 604;
Qi.copy = Di.cut = (r, e) => {
  let t = e, n = r.state.selection, i = t.type == "cut";
  if (n.empty)
    return;
  let s = yf ? null : t.clipboardData, a = n.content(), { dom: o, text: A } = Z2(r, a);
  s ? (t.preventDefault(), s.clearData(), s.setData("text/html", o.innerHTML), s.setData("text/plain", A)) : VQ(r, o), i && r.dispatch(r.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function zQ(r) {
  return r.openStart == 0 && r.openEnd == 0 && r.content.childCount == 1 ? r.content.firstChild : null;
}
function GQ(r, e) {
  if (!r.dom.parentNode)
    return;
  let t = r.input.shiftKey || r.state.selection.$from.parent.type.spec.code, n = r.dom.parentNode.appendChild(document.createElement(t ? "textarea" : "div"));
  t || (n.contentEditable = "true"), n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus();
  let i = r.input.shiftKey && r.input.lastKeyCode != 45;
  setTimeout(() => {
    r.focus(), n.parentNode && n.parentNode.removeChild(n), t ? wf(r, n.value, null, i, e) : wf(r, n.textContent, n.innerHTML, i, e);
  }, 50);
}
function wf(r, e, t, n, i) {
  let s = PS(r, e, t, n, r.state.selection.$from);
  if (r.someProp("handlePaste", (A) => A(r, i, s || lt.empty)))
    return !0;
  if (!s)
    return !1;
  let a = zQ(s), o = a ? r.state.tr.replaceSelectionWith(a, n) : r.state.tr.replaceSelection(s);
  return r.dispatch(o.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function XS(r) {
  let e = r.getData("text/plain") || r.getData("Text");
  if (e)
    return e;
  let t = r.getData("text/uri-list");
  return t ? t.replace(/\r?\n/g, " ") : "";
}
Di.paste = (r, e) => {
  let t = e;
  if (r.composing && !no)
    return;
  let n = yf ? null : t.clipboardData, i = r.input.shiftKey && r.input.lastKeyCode != 45;
  n && wf(r, XS(n), n.getData("text/html"), i, t) ? t.preventDefault() : GQ(r, t);
};
class JS {
  constructor(e, t, n) {
    this.slice = e, this.move = t, this.node = n;
  }
}
const YS = Ss ? "altKey" : "ctrlKey";
Qi.dragstart = (r, e) => {
  let t = e, n = r.input.mouseDown;
  if (n && n.done(), !t.dataTransfer)
    return;
  let i = r.state.selection, s = i.empty ? null : r.posAtCoords(ug(t)), a;
  if (!(s && s.pos >= i.from && s.pos <= (i instanceof Tt ? i.to - 1 : i.to))) {
    if (n && n.mightDrag)
      a = Tt.create(r.state.doc, n.mightDrag.pos);
    else if (t.target && t.target.nodeType == 1) {
      let c = r.docView.nearestDesc(t.target, !0);
      c && c.node.type.spec.draggable && c != r.docView && (a = Tt.create(r.state.doc, c.posBefore));
    }
  }
  let o = (a || r.state.selection).content(), { dom: A, text: l, slice: u } = Z2(r, o);
  (!t.dataTransfer.files.length || !Si || _S > 120) && t.dataTransfer.clearData(), t.dataTransfer.setData(yf ? "Text" : "text/html", A.innerHTML), t.dataTransfer.effectAllowed = "copyMove", yf || t.dataTransfer.setData("text/plain", l), r.dragging = new JS(u, !t[YS], a);
};
Qi.dragend = (r) => {
  let e = r.dragging;
  window.setTimeout(() => {
    r.dragging == e && (r.dragging = null);
  }, 50);
};
Di.dragover = Di.dragenter = (r, e) => e.preventDefault();
Di.drop = (r, e) => {
  let t = e, n = r.dragging;
  if (r.dragging = null, !t.dataTransfer)
    return;
  let i = r.posAtCoords(ug(t));
  if (!i)
    return;
  let s = r.state.doc.resolve(i.pos), a = n && n.slice;
  a ? r.someProp("transformPasted", (d) => {
    a = d(a, r);
  }) : a = PS(r, XS(t.dataTransfer), yf ? null : t.dataTransfer.getData("text/html"), !1, s);
  let o = !!(n && !t[YS]);
  if (r.someProp("handleDrop", (d) => d(r, t, a || lt.empty, o))) {
    t.preventDefault();
    return;
  }
  if (!a)
    return;
  t.preventDefault();
  let A = a ? gS(r.state.doc, s.pos, a) : s.pos;
  A == null && (A = s.pos);
  let l = r.state.tr;
  if (o) {
    let { node: d } = n;
    d ? d.replace(l) : l.deleteSelection();
  }
  let u = l.mapping.map(A), c = a.openStart == 0 && a.openEnd == 0 && a.content.childCount == 1, h = l.doc;
  if (c ? l.replaceRangeWith(u, u, a.content.firstChild) : l.replaceRange(u, u, a), l.doc.eq(h))
    return;
  let f = l.doc.resolve(u);
  if (c && Tt.isSelectable(a.content.firstChild) && f.nodeAfter && f.nodeAfter.sameMarkup(a.content.firstChild))
    l.setSelection(new Tt(f));
  else {
    let d = l.mapping.map(A);
    l.mapping.maps[l.mapping.maps.length - 1].forEach((p, v, m, b) => d = b), l.setSelection(Y2(r, f, l.doc.resolve(d)));
  }
  r.focus(), r.dispatch(l.setMeta("uiEvent", "drop"));
};
Qi.focus = (r) => {
  r.input.lastFocus = Date.now(), r.focused || (r.domObserver.stop(), r.dom.classList.add("ProseMirror-focused"), r.domObserver.start(), r.focused = !0, setTimeout(() => {
    r.docView && r.hasFocus() && !r.domObserver.currentSelection.eq(r.domSelectionRange()) && so(r);
  }, 20));
};
Qi.blur = (r, e) => {
  let t = e;
  r.focused && (r.domObserver.stop(), r.dom.classList.remove("ProseMirror-focused"), r.domObserver.start(), t.relatedTarget && r.dom.contains(t.relatedTarget) && r.domObserver.currentSelection.clear(), r.focused = !1);
};
Qi.beforeinput = (r, e) => {
  if (Si && no && e.inputType == "deleteContentBackward") {
    r.domObserver.flushSoon();
    let { domChangeCount: n } = r.input;
    setTimeout(() => {
      if (r.input.domChangeCount != n || (r.dom.blur(), r.focus(), r.someProp("handleKeyDown", (s) => s(r, OA(8, "Backspace")))))
        return;
      let { $cursor: i } = r.state.selection;
      i && i.pos > 0 && r.dispatch(r.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let r in Di)
  Qi[r] = Di[r];
function Bf(r, e) {
  if (r == e)
    return !0;
  for (let t in r)
    if (r[t] !== e[t])
      return !1;
  for (let t in e)
    if (!(t in r))
      return !1;
  return !0;
}
class Ip {
  constructor(e, t) {
    this.toDOM = e, this.spec = t || XA, this.side = this.spec.side || 0;
  }
  map(e, t, n, i) {
    let { pos: s, deleted: a } = e.mapResult(t.from + i, this.side < 0 ? -1 : 1);
    return a ? null : new xs(s - n, s - n, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof Ip && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Bf(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class eA {
  constructor(e, t) {
    this.attrs = e, this.spec = t || XA;
  }
  map(e, t, n, i) {
    let s = e.map(t.from + i, this.spec.inclusiveStart ? -1 : 1) - n, a = e.map(t.to + i, this.spec.inclusiveEnd ? 1 : -1) - n;
    return s >= a ? null : new xs(s, a, this);
  }
  valid(e, t) {
    return t.from < t.to;
  }
  eq(e) {
    return this == e || e instanceof eA && Bf(this.attrs, e.attrs) && Bf(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof eA;
  }
  destroy() {
  }
}
class nb {
  constructor(e, t) {
    this.attrs = e, this.spec = t || XA;
  }
  map(e, t, n, i) {
    let s = e.mapResult(t.from + i, 1);
    if (s.deleted)
      return null;
    let a = e.mapResult(t.to + i, -1);
    return a.deleted || a.pos <= s.pos ? null : new xs(s.pos - n, a.pos - n, this);
  }
  valid(e, t) {
    let { index: n, offset: i } = e.content.findIndex(t.from), s;
    return i == t.from && !(s = e.child(n)).isText && i + s.nodeSize == t.to;
  }
  eq(e) {
    return this == e || e instanceof nb && Bf(this.attrs, e.attrs) && Bf(this.spec, e.spec);
  }
  destroy() {
  }
}
class xs {
  /**
  @internal
  */
  constructor(e, t, n) {
    this.from = e, this.to = t, this.type = n;
  }
  /**
  @internal
  */
  copy(e, t) {
    return new xs(e, t, this.type);
  }
  /**
  @internal
  */
  eq(e, t = 0) {
    return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to;
  }
  /**
  @internal
  */
  map(e, t, n) {
    return this.type.map(e, this, t, n);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, t, n) {
    return new xs(e, e, new Ip(t, n));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, t, n, i) {
    return new xs(e, t, new eA(n, i));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, t, n, i) {
    return new xs(e, t, new nb(n, i));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof eA;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof Ip;
  }
}
const su = [], XA = {};
class Mn {
  /**
  @internal
  */
  constructor(e, t) {
    this.local = e.length ? e : su, this.children = t.length ? t : su;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, t) {
    return t.length ? Fp(t, e, 0, XA) : Bi;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, t, n) {
    let i = [];
    return this.findInner(e ?? 0, t ?? 1e9, i, 0, n), i;
  }
  findInner(e, t, n, i, s) {
    for (let a = 0; a < this.local.length; a++) {
      let o = this.local[a];
      o.from <= t && o.to >= e && (!s || s(o.spec)) && n.push(o.copy(o.from + i, o.to + i));
    }
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] < t && this.children[a + 1] > e) {
        let o = this.children[a] + 1;
        this.children[a + 2].findInner(e - o, t - o, n, i + o, s);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, t, n) {
    return this == Bi || e.maps.length == 0 ? this : this.mapInner(e, t, 0, 0, n || XA);
  }
  /**
  @internal
  */
  mapInner(e, t, n, i, s) {
    let a;
    for (let o = 0; o < this.local.length; o++) {
      let A = this.local[o].map(e, n, i);
      A && A.type.valid(t, A) ? (a || (a = [])).push(A) : s.onRemove && s.onRemove(this.local[o].spec);
    }
    return this.children.length ? qQ(this.children, a || [], e, t, n, i, s) : a ? new Mn(a.sort(JA), su) : Bi;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, t) {
    return t.length ? this == Bi ? Mn.create(e, t) : this.addInner(e, t, 0) : this;
  }
  addInner(e, t, n) {
    let i, s = 0;
    e.forEach((o, A) => {
      let l = A + n, u;
      if (u = e3(t, o, l)) {
        for (i || (i = this.children.slice()); s < i.length && i[s] < A; )
          s += 3;
        i[s] == A ? i[s + 2] = i[s + 2].addInner(o, u, l + 1) : i.splice(s, 0, A, A + o.nodeSize, Fp(u, o, l + 1, XA)), s += 3;
      }
    });
    let a = ZS(s ? t3(t) : t, -n);
    for (let o = 0; o < a.length; o++)
      a[o].type.valid(e, a[o]) || a.splice(o--, 1);
    return new Mn(a.length ? this.local.concat(a).sort(JA) : this.local, i || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == Bi ? this : this.removeInner(e, 0);
  }
  removeInner(e, t) {
    let n = this.children, i = this.local;
    for (let s = 0; s < n.length; s += 3) {
      let a, o = n[s] + t, A = n[s + 1] + t;
      for (let u = 0, c; u < e.length; u++)
        (c = e[u]) && c.from > o && c.to < A && (e[u] = null, (a || (a = [])).push(c));
      if (!a)
        continue;
      n == this.children && (n = this.children.slice());
      let l = n[s + 2].removeInner(a, o + 1);
      l != Bi ? n[s + 2] = l : (n.splice(s, 3), s -= 3);
    }
    if (i.length) {
      for (let s = 0, a; s < e.length; s++)
        if (a = e[s])
          for (let o = 0; o < i.length; o++)
            i[o].eq(a, t) && (i == this.local && (i = this.local.slice()), i.splice(o--, 1));
    }
    return n == this.children && i == this.local ? this : i.length || n.length ? new Mn(i, n) : Bi;
  }
  forChild(e, t) {
    if (this == Bi)
      return this;
    if (t.isLeaf)
      return Mn.empty;
    let n, i;
    for (let o = 0; o < this.children.length; o += 3)
      if (this.children[o] >= e) {
        this.children[o] == e && (n = this.children[o + 2]);
        break;
      }
    let s = e + 1, a = s + t.content.size;
    for (let o = 0; o < this.local.length; o++) {
      let A = this.local[o];
      if (A.from < a && A.to > s && A.type instanceof eA) {
        let l = Math.max(s, A.from) - s, u = Math.min(a, A.to) - s;
        l < u && (i || (i = [])).push(A.copy(l, u));
      }
    }
    if (i) {
      let o = new Mn(i.sort(JA), su);
      return n ? new Ro([o, n]) : o;
    }
    return n || Bi;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof Mn) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let t = 0; t < this.local.length; t++)
      if (!this.local[t].eq(e.local[t]))
        return !1;
    for (let t = 0; t < this.children.length; t += 3)
      if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return ib(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == Bi)
      return su;
    if (e.inlineContent || !this.local.some(eA.is))
      return this.local;
    let t = [];
    for (let n = 0; n < this.local.length; n++)
      this.local[n].type instanceof eA || t.push(this.local[n]);
    return t;
  }
  forEachSet(e) {
    e(this);
  }
}
Mn.empty = new Mn([], []);
Mn.removeOverlap = ib;
const Bi = Mn.empty;
class Ro {
  constructor(e) {
    this.members = e;
  }
  map(e, t) {
    const n = this.members.map((i) => i.map(e, t, XA));
    return Ro.from(n);
  }
  forChild(e, t) {
    if (t.isLeaf)
      return Mn.empty;
    let n = [];
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].forChild(e, t);
      s != Bi && (s instanceof Ro ? n = n.concat(s.members) : n.push(s));
    }
    return Ro.from(n);
  }
  eq(e) {
    if (!(e instanceof Ro) || e.members.length != this.members.length)
      return !1;
    for (let t = 0; t < this.members.length; t++)
      if (!this.members[t].eq(e.members[t]))
        return !1;
    return !0;
  }
  locals(e) {
    let t, n = !0;
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].localsInner(e);
      if (s.length)
        if (!t)
          t = s;
        else {
          n && (t = t.slice(), n = !1);
          for (let a = 0; a < s.length; a++)
            t.push(s[a]);
        }
    }
    return t ? ib(n ? t : t.sort(JA)) : su;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return Bi;
      case 1:
        return e[0];
      default:
        return new Ro(e.every((t) => t instanceof Mn) ? e : e.reduce((t, n) => t.concat(n instanceof Mn ? n : n.members), []));
    }
  }
  forEachSet(e) {
    for (let t = 0; t < this.members.length; t++)
      this.members[t].forEachSet(e);
  }
}
function qQ(r, e, t, n, i, s, a) {
  let o = r.slice();
  for (let l = 0, u = s; l < t.maps.length; l++) {
    let c = 0;
    t.maps[l].forEach((h, f, d, p) => {
      let v = p - d - (f - h);
      for (let m = 0; m < o.length; m += 3) {
        let b = o[m + 1];
        if (b < 0 || h > b + u - c)
          continue;
        let w = o[m] + u - c;
        f >= w ? o[m + 1] = h <= w ? -2 : -1 : h >= u && v && (o[m] += v, o[m + 1] += v);
      }
      c += v;
    }), u = t.maps[l].map(u, -1);
  }
  let A = !1;
  for (let l = 0; l < o.length; l += 3)
    if (o[l + 1] < 0) {
      if (o[l + 1] == -2) {
        A = !0, o[l + 1] = -1;
        continue;
      }
      let u = t.map(r[l] + s), c = u - i;
      if (c < 0 || c >= n.content.size) {
        A = !0;
        continue;
      }
      let h = t.map(r[l + 1] + s, -1), f = h - i, { index: d, offset: p } = n.content.findIndex(c), v = n.maybeChild(d);
      if (v && p == c && p + v.nodeSize == f) {
        let m = o[l + 2].mapInner(t, v, u + 1, r[l] + s + 1, a);
        m != Bi ? (o[l] = c, o[l + 1] = f, o[l + 2] = m) : (o[l + 1] = -2, A = !0);
      } else
        A = !0;
    }
  if (A) {
    let l = WQ(o, r, e, t, i, s, a), u = Fp(l, n, 0, a);
    e = u.local;
    for (let c = 0; c < o.length; c += 3)
      o[c + 1] < 0 && (o.splice(c, 3), c -= 3);
    for (let c = 0, h = 0; c < u.children.length; c += 3) {
      let f = u.children[c];
      for (; h < o.length && o[h] < f; )
        h += 3;
      o.splice(h, 0, u.children[c], u.children[c + 1], u.children[c + 2]);
    }
  }
  return new Mn(e.sort(JA), o);
}
function ZS(r, e) {
  if (!e || !r.length)
    return r;
  let t = [];
  for (let n = 0; n < r.length; n++) {
    let i = r[n];
    t.push(new xs(i.from + e, i.to + e, i.type));
  }
  return t;
}
function WQ(r, e, t, n, i, s, a) {
  function o(A, l) {
    for (let u = 0; u < A.local.length; u++) {
      let c = A.local[u].map(n, i, l);
      c ? t.push(c) : a.onRemove && a.onRemove(A.local[u].spec);
    }
    for (let u = 0; u < A.children.length; u += 3)
      o(A.children[u + 2], A.children[u] + l + 1);
  }
  for (let A = 0; A < r.length; A += 3)
    r[A + 1] == -1 && o(r[A + 2], e[A] + s + 1);
  return t;
}
function e3(r, e, t) {
  if (e.isLeaf)
    return null;
  let n = t + e.nodeSize, i = null;
  for (let s = 0, a; s < r.length; s++)
    (a = r[s]) && a.from > t && a.to < n && ((i || (i = [])).push(a), r[s] = null);
  return i;
}
function t3(r) {
  let e = [];
  for (let t = 0; t < r.length; t++)
    r[t] != null && e.push(r[t]);
  return e;
}
function Fp(r, e, t, n) {
  let i = [], s = !1;
  e.forEach((o, A) => {
    let l = e3(r, o, A + t);
    if (l) {
      s = !0;
      let u = Fp(l, o, t + A + 1, n);
      u != Bi && i.push(A, A + o.nodeSize, u);
    }
  });
  let a = ZS(s ? t3(r) : r, -t).sort(JA);
  for (let o = 0; o < a.length; o++)
    a[o].type.valid(e, a[o]) || (n.onRemove && n.onRemove(a[o].spec), a.splice(o--, 1));
  return a.length || i.length ? new Mn(a, i) : Bi;
}
function JA(r, e) {
  return r.from - e.from || r.to - e.to;
}
function ib(r) {
  let e = r;
  for (let t = 0; t < e.length - 1; t++) {
    let n = e[t];
    if (n.from != n.to)
      for (let i = t + 1; i < e.length; i++) {
        let s = e[i];
        if (s.from == n.from) {
          s.to != n.to && (e == r && (e = r.slice()), e[i] = s.copy(s.from, n.to), uB(e, i + 1, s.copy(n.to, s.to)));
          continue;
        } else {
          s.from < n.to && (e == r && (e = r.slice()), e[t] = n.copy(n.from, s.from), uB(e, i, n.copy(s.from, n.to)));
          break;
        }
      }
  }
  return e;
}
function uB(r, e, t) {
  for (; e < r.length && JA(t, r[e]) > 0; )
    e++;
  r.splice(e, 0, t);
}
function Jm(r) {
  let e = [];
  return r.someProp("decorations", (t) => {
    let n = t(r.state);
    n && n != Bi && e.push(n);
  }), r.cursorWrapper && e.push(Mn.create(r.state.doc, [r.cursorWrapper.deco])), Ro.from(e);
}
const XQ = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, JQ = Ji && Yo <= 11;
class YQ {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class ZQ {
  constructor(e, t) {
    this.view = e, this.handleDOMChange = t, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new YQ(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((n) => {
      for (let i = 0; i < n.length; i++)
        this.queue.push(n[i]);
      Ji && Yo <= 11 && n.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), JQ && (this.onCharData = (n) => {
      this.queue.push({ target: n.target, type: "characterData", oldValue: n.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, XQ)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let t = 0; t < e.length; t++)
          this.queue.push(e[t]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (rB(this.view)) {
      if (this.suppressingSelectionUpdates)
        return so(this.view);
      if (Ji && Yo <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && ol(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let t = /* @__PURE__ */ new Set(), n;
    for (let s = e.focusNode; s; s = bf(s))
      t.add(s);
    for (let s = e.anchorNode; s; s = bf(s))
      if (t.has(s)) {
        n = s;
        break;
      }
    let i = n && this.view.docView.nearestDesc(n);
    if (i && i.ignoreMutation({
      type: "selection",
      target: n.nodeType == 3 ? n.parentNode : n
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let n = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(n) && rB(e) && !this.ignoreSelectionChange(n), s = -1, a = -1, o = !1, A = [];
    if (e.editable)
      for (let u = 0; u < t.length; u++) {
        let c = this.registerMutation(t[u], A);
        c && (s = s < 0 ? c.from : Math.min(c.from, s), a = a < 0 ? c.to : Math.max(c.to, a), c.typeOver && (o = !0));
      }
    if (aa && A.length) {
      let u = A.filter((c) => c.nodeName == "BR");
      if (u.length == 2) {
        let [c, h] = u;
        c.parentNode && c.parentNode.parentNode == h.parentNode ? h.remove() : c.remove();
      } else {
        let { focusNode: c } = this.currentSelection;
        for (let h of u) {
          let f = h.parentNode;
          f && f.nodeName == "LI" && (!c || rD(e, c) != f) && h.remove();
        }
      }
    }
    let l = null;
    s < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && Ag(n) && (l = J2(e)) && l.eq(Yt.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, so(e), this.currentSelection.set(n)) : (s > -1 || i) && (s > -1 && (e.docView.markDirty(s, a), eD(e)), this.handleDOMChange(s, a, o, A), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(n) || so(e), this.currentSelection.set(n));
  }
  registerMutation(e, t) {
    if (t.indexOf(e.target) > -1)
      return null;
    let n = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (n == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !n || n.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let u = 0; u < e.addedNodes.length; u++) {
        let c = e.addedNodes[u];
        t.push(c), c.nodeType == 3 && (this.lastChangedTextNode = c);
      }
      if (n.contentDOM && n.contentDOM != n.dom && !n.contentDOM.contains(e.target))
        return { from: n.posBefore, to: n.posAfter };
      let i = e.previousSibling, s = e.nextSibling;
      if (Ji && Yo <= 11 && e.addedNodes.length)
        for (let u = 0; u < e.addedNodes.length; u++) {
          let { previousSibling: c, nextSibling: h } = e.addedNodes[u];
          (!c || Array.prototype.indexOf.call(e.addedNodes, c) < 0) && (i = c), (!h || Array.prototype.indexOf.call(e.addedNodes, h) < 0) && (s = h);
        }
      let a = i && i.parentNode == e.target ? ai(i) + 1 : 0, o = n.localPosFromDOM(e.target, a, -1), A = s && s.parentNode == e.target ? ai(s) : e.target.childNodes.length, l = n.localPosFromDOM(e.target, A, 1);
      return { from: o, to: l };
    } else return e.type == "attributes" ? { from: n.posAtStart - n.border, to: n.posAtEnd + n.border } : (this.lastChangedTextNode = e.target, {
      from: n.posAtStart,
      to: n.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    });
  }
}
let cB = /* @__PURE__ */ new WeakMap(), fB = !1;
function eD(r) {
  if (!cB.has(r) && (cB.set(r, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(r.dom).whiteSpace) !== -1)) {
    if (r.requiresGeckoHackNode = aa, fB)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), fB = !0;
  }
}
function hB(r, e) {
  let t = e.startContainer, n = e.startOffset, i = e.endContainer, s = e.endOffset, a = r.domAtPos(r.state.selection.anchor);
  return ol(a.node, a.offset, i, s) && ([t, n, i, s] = [i, s, t, n]), { anchorNode: t, anchorOffset: n, focusNode: i, focusOffset: s };
}
function tD(r, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(r.root)[0];
    if (i)
      return hB(r, i);
  }
  let t;
  function n(i) {
    i.preventDefault(), i.stopImmediatePropagation(), t = i.getTargetRanges()[0];
  }
  return r.dom.addEventListener("beforeinput", n, !0), document.execCommand("indent"), r.dom.removeEventListener("beforeinput", n, !0), t ? hB(r, t) : null;
}
function rD(r, e) {
  for (let t = e.parentNode; t && t != r.dom; t = t.parentNode) {
    let n = r.docView.nearestDesc(t, !0);
    if (n && n.node.isBlock)
      return t;
  }
  return null;
}
function nD(r, e, t) {
  let { node: n, fromOffset: i, toOffset: s, from: a, to: o } = r.docView.parseRange(e, t), A = r.domSelectionRange(), l, u = A.anchorNode;
  if (u && r.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (l = [{ node: u, offset: A.anchorOffset }], Ag(A) || l.push({ node: A.focusNode, offset: A.focusOffset })), Si && r.input.lastKeyCode === 8)
    for (let v = s; v > i; v--) {
      let m = n.childNodes[v - 1], b = m.pmViewDesc;
      if (m.nodeName == "BR" && !b) {
        s = v;
        break;
      }
      if (!b || b.size)
        break;
    }
  let c = r.state.doc, h = r.someProp("domParser") || Jc.fromSchema(r.state.schema), f = c.resolve(a), d = null, p = h.parse(n, {
    topNode: f.parent,
    topMatch: f.parent.contentMatchAt(f.index()),
    topOpen: !0,
    from: i,
    to: s,
    preserveWhitespace: f.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: l,
    ruleFromNode: iD,
    context: f
  });
  if (l && l[0].pos != null) {
    let v = l[0].pos, m = l[1] && l[1].pos;
    m == null && (m = v), d = { anchor: v + a, head: m + a };
  }
  return { doc: p, sel: d, from: a, to: o };
}
function iD(r) {
  let e = r.pmViewDesc;
  if (e)
    return e.parseRule();
  if (r.nodeName == "BR" && r.parentNode) {
    if (Oi && /^(ul|ol)$/i.test(r.parentNode.nodeName)) {
      let t = document.createElement("div");
      return t.appendChild(document.createElement("li")), { skip: t };
    } else if (r.parentNode.lastChild == r || Oi && /^(tr|table)$/i.test(r.parentNode.nodeName))
      return { ignore: !0 };
  } else if (r.nodeName == "IMG" && r.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const sD = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function aD(r, e, t, n, i) {
  let s = r.input.compositionPendingChanges || (r.composing ? r.input.compositionID : 0);
  if (r.input.compositionPendingChanges = 0, e < 0) {
    let N = r.input.lastSelectionTime > Date.now() - 50 ? r.input.lastSelectionOrigin : null, D = J2(r, N);
    if (D && !r.state.selection.eq(D)) {
      if (Si && no && r.input.lastKeyCode === 13 && Date.now() - 100 < r.input.lastKeyCodeTime && r.someProp("handleKeyDown", (E) => E(r, OA(13, "Enter"))))
        return;
      let T = r.state.tr.setSelection(D);
      N == "pointer" ? T.setMeta("pointer", !0) : N == "key" && T.scrollIntoView(), s && T.setMeta("composition", s), r.dispatch(T);
    }
    return;
  }
  let a = r.state.doc.resolve(e), o = a.sharedDepth(t);
  e = a.before(o + 1), t = r.state.doc.resolve(t).after(o + 1);
  let A = r.state.selection, l = nD(r, e, t), u = r.state.doc, c = u.slice(l.from, l.to), h, f;
  r.input.lastKeyCode === 8 && Date.now() - 100 < r.input.lastKeyCodeTime ? (h = r.state.selection.to, f = "end") : (h = r.state.selection.from, f = "start"), r.input.lastKeyCode = null;
  let d = lD(c.content, l.doc.content, l.from, h, f);
  if (d && r.input.domChangeCount++, (xu && r.input.lastIOSEnter > Date.now() - 225 || no) && i.some((N) => N.nodeType == 1 && !sD.test(N.nodeName)) && (!d || d.endA >= d.endB) && r.someProp("handleKeyDown", (N) => N(r, OA(13, "Enter")))) {
    r.input.lastIOSEnter = 0;
    return;
  }
  if (!d)
    if (n && A instanceof zt && !A.empty && A.$head.sameParent(A.$anchor) && !r.composing && !(l.sel && l.sel.anchor != l.sel.head))
      d = { start: A.from, endA: A.to, endB: A.to };
    else {
      if (l.sel) {
        let N = dB(r, r.state.doc, l.sel);
        if (N && !N.eq(r.state.selection)) {
          let D = r.state.tr.setSelection(N);
          s && D.setMeta("composition", s), r.dispatch(D);
        }
      }
      return;
    }
  r.state.selection.from < r.state.selection.to && d.start == d.endB && r.state.selection instanceof zt && (d.start > r.state.selection.from && d.start <= r.state.selection.from + 2 && r.state.selection.from >= l.from ? d.start = r.state.selection.from : d.endA < r.state.selection.to && d.endA >= r.state.selection.to - 2 && r.state.selection.to <= l.to && (d.endB += r.state.selection.to - d.endA, d.endA = r.state.selection.to)), Ji && Yo <= 11 && d.endB == d.start + 1 && d.endA == d.start && d.start > l.from && l.doc.textBetween(d.start - l.from - 1, d.start - l.from + 1) == "  " && (d.start--, d.endA--, d.endB--);
  let p = l.doc.resolveNoCache(d.start - l.from), v = l.doc.resolveNoCache(d.endB - l.from), m = u.resolve(d.start), b = p.sameParent(v) && p.parent.inlineContent && m.end() >= d.endA, w;
  if ((xu && r.input.lastIOSEnter > Date.now() - 225 && (!b || i.some((N) => N.nodeName == "DIV" || N.nodeName == "P")) || !b && p.pos < l.doc.content.size && !p.sameParent(v) && (w = Yt.findFrom(l.doc.resolve(p.pos + 1), 1, !0)) && w.head == v.pos) && r.someProp("handleKeyDown", (N) => N(r, OA(13, "Enter")))) {
    r.input.lastIOSEnter = 0;
    return;
  }
  if (r.state.selection.anchor > d.start && AD(u, d.start, d.endA, p, v) && r.someProp("handleKeyDown", (N) => N(r, OA(8, "Backspace")))) {
    no && Si && r.domObserver.suppressSelectionUpdates();
    return;
  }
  Si && d.endB == d.start && (r.input.lastChromeDelete = Date.now()), no && !b && p.start() != v.start() && v.parentOffset == 0 && p.depth == v.depth && l.sel && l.sel.anchor == l.sel.head && l.sel.head == d.endA && (d.endB -= 2, v = l.doc.resolveNoCache(d.endB - l.from), setTimeout(() => {
    r.someProp("handleKeyDown", function(N) {
      return N(r, OA(13, "Enter"));
    });
  }, 20));
  let B = d.start, _ = d.endA, x, C, F;
  if (b) {
    if (p.pos == v.pos)
      Ji && Yo <= 11 && p.parentOffset == 0 && (r.domObserver.suppressSelectionUpdates(), setTimeout(() => so(r), 20)), x = r.state.tr.delete(B, _), C = u.resolve(d.start).marksAcross(u.resolve(d.endA));
    else if (
      // Adding or removing a mark
      d.endA == d.endB && (F = oD(p.parent.content.cut(p.parentOffset, v.parentOffset), m.parent.content.cut(m.parentOffset, d.endA - m.start())))
    )
      x = r.state.tr, F.type == "add" ? x.addMark(B, _, F.mark) : x.removeMark(B, _, F.mark);
    else if (p.parent.child(p.index()).isText && p.index() == v.index() - (v.textOffset ? 0 : 1)) {
      let N = p.parent.textBetween(p.parentOffset, v.parentOffset);
      if (r.someProp("handleTextInput", (D) => D(r, B, _, N)))
        return;
      x = r.state.tr.insertText(N, B, _);
    }
  }
  if (x || (x = r.state.tr.replace(B, _, l.doc.slice(d.start - l.from, d.endB - l.from))), l.sel) {
    let N = dB(r, x.doc, l.sel);
    N && !(Si && r.composing && N.empty && (d.start != d.endB || r.input.lastChromeDelete < Date.now() - 100) && (N.head == B || N.head == x.mapping.map(_) - 1) || Ji && N.empty && N.head == B) && x.setSelection(N);
  }
  C && x.ensureMarks(C), s && x.setMeta("composition", s), r.dispatch(x.scrollIntoView());
}
function dB(r, e, t) {
  return Math.max(t.anchor, t.head) > e.content.size ? null : Y2(r, e.resolve(t.anchor), e.resolve(t.head));
}
function oD(r, e) {
  let t = r.firstChild.marks, n = e.firstChild.marks, i = t, s = n, a, o, A;
  for (let u = 0; u < n.length; u++)
    i = n[u].removeFromSet(i);
  for (let u = 0; u < t.length; u++)
    s = t[u].removeFromSet(s);
  if (i.length == 1 && s.length == 0)
    o = i[0], a = "add", A = (u) => u.mark(o.addToSet(u.marks));
  else if (i.length == 0 && s.length == 1)
    o = s[0], a = "remove", A = (u) => u.mark(o.removeFromSet(u.marks));
  else
    return null;
  let l = [];
  for (let u = 0; u < e.childCount; u++)
    l.push(A(e.child(u)));
  if (Ye.from(l).eq(r))
    return { mark: o, type: a };
}
function AD(r, e, t, n, i) {
  if (
    // The content must have shrunk
    t - e <= i.pos - n.pos || // newEnd must point directly at or after the end of the block that newStart points into
    Ym(n, !0, !1) < i.pos
  )
    return !1;
  let s = r.resolve(e);
  if (!n.parent.isTextblock) {
    let o = s.nodeAfter;
    return o != null && t == e + o.nodeSize;
  }
  if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock)
    return !1;
  let a = r.resolve(Ym(s, !0, !0));
  return !a.parent.isTextblock || a.pos > t || Ym(a, !0, !1) < t ? !1 : n.parent.content.cut(n.parentOffset).eq(a.parent.content);
}
function Ym(r, e, t) {
  let n = r.depth, i = e ? r.end() : r.pos;
  for (; n > 0 && (e || r.indexAfter(n) == r.node(n).childCount); )
    n--, i++, e = !1;
  if (t) {
    let s = r.node(n).maybeChild(r.indexAfter(n));
    for (; s && !s.isLeaf; )
      s = s.firstChild, i++;
  }
  return i;
}
function lD(r, e, t, n, i) {
  let s = r.findDiffStart(e, t);
  if (s == null)
    return null;
  let { a, b: o } = r.findDiffEnd(e, t + r.size, t + e.size);
  if (i == "end") {
    let A = Math.max(0, s - Math.min(a, o));
    n -= a + A - s;
  }
  if (a < s && r.size < e.size) {
    let A = n <= s && n >= a ? s - n : 0;
    s -= A, s && s < e.size && pB(e.textBetween(s - 1, s + 1)) && (s += A ? 1 : -1), o = s + (o - a), a = s;
  } else if (o < s) {
    let A = n <= s && n >= o ? s - n : 0;
    s -= A, s && s < r.size && pB(r.textBetween(s - 1, s + 1)) && (s += A ? 1 : -1), a = s + (a - o), o = s;
  }
  return { start: s, endA: a, endB: o };
}
function pB(r) {
  if (r.length != 2)
    return !1;
  let e = r.charCodeAt(0), t = r.charCodeAt(1);
  return e >= 56320 && e <= 57343 && t >= 55296 && t <= 56319;
}
class uD {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, t) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new TQ(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = t, this.state = t.state, this.directPlugins = t.plugins || [], this.directPlugins.forEach(yB), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = vB(this), mB(this), this.nodeViews = bB(this), this.docView = Xw(this.state.doc, gB(this), Jm(this), this.dom, this), this.domObserver = new ZQ(this, (n, i, s, a) => aD(this, n, i, s, a)), this.domObserver.start(), xQ(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let t in e)
        this._props[t] = e[t];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && Av(this);
    let t = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(yB), this.directPlugins = e.plugins), this.updateStateInner(e.state, t);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let t = {};
    for (let n in this._props)
      t[n] = this._props[n];
    t.state = this.state;
    for (let n in e)
      t[n] = e[n];
    this.update(t);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, t) {
    var n;
    let i = this.state, s = !1, a = !1;
    e.storedMarks && this.composing && (WS(this), a = !0), this.state = e;
    let o = i.plugins != e.plugins || this._props.plugins != t.plugins;
    if (o || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) {
      let f = bB(this);
      fD(f, this.nodeViews) && (this.nodeViews = f, s = !0);
    }
    (o || t.handleDOMEvents != this._props.handleDOMEvents) && Av(this), this.editable = vB(this), mB(this);
    let A = Jm(this), l = gB(this), u = i.plugins != e.plugins && !i.doc.eq(e.doc) ? "reset" : e.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", c = s || !this.docView.matchesNode(e.doc, l, A);
    (c || !e.selection.eq(i.selection)) && (a = !0);
    let h = u == "preserve" && a && this.dom.style.overflowAnchor == null && $6(this);
    if (a) {
      this.domObserver.stop();
      let f = c && (Ji || Si) && !this.composing && !i.selection.empty && !e.selection.empty && cD(i.selection, e.selection);
      if (c) {
        let d = Si ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = KQ(this)), (s || !this.docView.update(e.doc, l, A, this)) && (this.docView.updateOuterDeco(l), this.docView.destroy(), this.docView = Xw(e.doc, l, A, this.dom, this)), d && !this.trackWrites && (f = !0);
      }
      f || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && dQ(this)) ? so(this, f) : (DS(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(i), !((n = this.dragging) === null || n === void 0) && n.node && !i.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, i), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : h && V6(h);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (t) => t(this))) if (this.state.selection instanceof Tt) {
        let t = this.docView.domAfterPos(this.state.selection.from);
        t.nodeType == 1 && $w(this, t.getBoundingClientRect(), e);
      } else
        $w(this, this.coordsAtPos(this.state.selection.head, 1), e);
    }
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let t = 0; t < this.directPlugins.length; t++) {
        let n = this.directPlugins[t];
        n.spec.view && this.pluginViews.push(n.spec.view(this));
      }
      for (let t = 0; t < this.state.plugins.length; t++) {
        let n = this.state.plugins[t];
        n.spec.view && this.pluginViews.push(n.spec.view(this));
      }
    } else
      for (let t = 0; t < this.pluginViews.length; t++) {
        let n = this.pluginViews[t];
        n.update && n.update(this, e);
      }
  }
  updateDraggedNode(e, t) {
    let n = e.node, i = -1;
    if (this.state.doc.nodeAt(n.from) == n.node)
      i = n.from;
    else {
      let s = n.from + (this.state.doc.content.size - t.doc.content.size);
      (s > 0 && this.state.doc.nodeAt(s)) == n.node && (i = s);
    }
    this.dragging = new JS(e.slice, e.move, i < 0 ? void 0 : Tt.create(this.state.doc, i));
  }
  someProp(e, t) {
    let n = this._props && this._props[e], i;
    if (n != null && (i = t ? t(n) : n))
      return i;
    for (let a = 0; a < this.directPlugins.length; a++) {
      let o = this.directPlugins[a].props[e];
      if (o != null && (i = t ? t(o) : o))
        return i;
    }
    let s = this.state.plugins;
    if (s)
      for (let a = 0; a < s.length; a++) {
        let o = s[a].props[e];
        if (o != null && (i = t ? t(o) : o))
          return i;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (Ji) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && z6(this.dom), so(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let t = this.dom.parentNode; t; t = t.parentNode)
        if (t.nodeType == 9 || t.nodeType == 11 && t.host)
          return t.getSelection || (Object.getPrototypeOf(t).getSelection = () => t.ownerDocument.getSelection()), this._root = t;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return J6(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, t = 1) {
    return TS(this, e, t);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, t = 0) {
    return this.docView.domFromPos(e, t);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let t = this.docView.descAt(e);
    return t ? t.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, t, n = -1) {
    let i = this.docView.posFromDOM(e, t, n);
    if (i == null)
      throw new RangeError("DOM position not inside the editor");
    return i;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, t) {
    return rQ(this, t || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, t) {
    return wf(this, "", e, !1, t || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, t) {
    return wf(this, e, null, !0, t || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(e) {
    return Z2(this, e);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (kQ(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Jm(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, U6());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return UQ(this, e);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(e) {
    let t = this._props.dispatchTransaction;
    t ? t.call(this, e) : this.updateState(this.state.apply(e));
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? Oi && this.root.nodeType === 11 && M6(this.dom.ownerDocument) == this.dom && tD(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
function gB(r) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(r.editable), r.someProp("attributes", (t) => {
    if (typeof t == "function" && (t = t(r.state)), t)
      for (let n in t)
        n == "class" ? e.class += " " + t[n] : n == "style" ? e.style = (e.style ? e.style + ";" : "") + t[n] : !e[n] && n != "contenteditable" && n != "nodeName" && (e[n] = String(t[n]));
  }), e.translate || (e.translate = "no"), [xs.node(0, r.state.doc.content.size, e)];
}
function mB(r) {
  if (r.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), r.cursorWrapper = { dom: e, deco: xs.widget(r.state.selection.from, e, { raw: !0, marks: r.markCursor }) };
  } else
    r.cursorWrapper = null;
}
function vB(r) {
  return !r.someProp("editable", (e) => e(r.state) === !1);
}
function cD(r, e) {
  let t = Math.min(r.$anchor.sharedDepth(r.head), e.$anchor.sharedDepth(e.head));
  return r.$anchor.start(t) != e.$anchor.start(t);
}
function bB(r) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(n) {
    for (let i in n)
      Object.prototype.hasOwnProperty.call(e, i) || (e[i] = n[i]);
  }
  return r.someProp("nodeViews", t), r.someProp("markViews", t), e;
}
function fD(r, e) {
  let t = 0, n = 0;
  for (let i in r) {
    if (r[i] != e[i])
      return !0;
    t++;
  }
  for (let i in e)
    n++;
  return t != n;
}
function yB(r) {
  if (r.spec.state || r.spec.filterTransaction || r.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var iA = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Tp = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, hD = typeof navigator < "u" && /Mac/.test(navigator.platform), dD = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var oi = 0; oi < 10; oi++) iA[48 + oi] = iA[96 + oi] = String(oi);
for (var oi = 1; oi <= 24; oi++) iA[oi + 111] = "F" + oi;
for (var oi = 65; oi <= 90; oi++)
  iA[oi] = String.fromCharCode(oi + 32), Tp[oi] = String.fromCharCode(oi);
for (var Zm in iA) Tp.hasOwnProperty(Zm) || (Tp[Zm] = iA[Zm]);
function pD(r) {
  var e = hD && r.metaKey && r.shiftKey && !r.ctrlKey && !r.altKey || dD && r.shiftKey && r.key && r.key.length == 1 || r.key == "Unidentified", t = !e && r.key || (r.shiftKey ? Tp : iA)[r.keyCode] || r.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
const gD = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function mD(r) {
  let e = r.split(/-(?!$)/), t = e[e.length - 1];
  t == "Space" && (t = " ");
  let n, i, s, a;
  for (let o = 0; o < e.length - 1; o++) {
    let A = e[o];
    if (/^(cmd|meta|m)$/i.test(A))
      a = !0;
    else if (/^a(lt)?$/i.test(A))
      n = !0;
    else if (/^(c|ctrl|control)$/i.test(A))
      i = !0;
    else if (/^s(hift)?$/i.test(A))
      s = !0;
    else if (/^mod$/i.test(A))
      gD ? a = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + A);
  }
  return n && (t = "Alt-" + t), i && (t = "Ctrl-" + t), a && (t = "Meta-" + t), s && (t = "Shift-" + t), t;
}
function vD(r) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in r)
    e[mD(t)] = r[t];
  return e;
}
function e0(r, e, t = !0) {
  return e.altKey && (r = "Alt-" + r), e.ctrlKey && (r = "Ctrl-" + r), e.metaKey && (r = "Meta-" + r), t && e.shiftKey && (r = "Shift-" + r), r;
}
function bD(r) {
  return new es({ props: { handleKeyDown: r3(r) } });
}
function r3(r) {
  let e = vD(r);
  return function(t, n) {
    let i = pD(n), s, a = e[e0(i, n)];
    if (a && a(t.state, t.dispatch, t))
      return !0;
    if (i.length == 1 && i != " ") {
      if (n.shiftKey) {
        let o = e[e0(i, n, !1)];
        if (o && o(t.state, t.dispatch, t))
          return !0;
      }
      if ((n.shiftKey || n.altKey || n.metaKey || i.charCodeAt(0) > 127) && (s = iA[n.keyCode]) && s != i) {
        let o = e[e0(s, n)];
        if (o && o(t.state, t.dispatch, t))
          return !0;
      }
    }
    return !1;
  };
}
const yD = (r, e) => r.selection.empty ? !1 : (e && e(r.tr.deleteSelection().scrollIntoView()), !0);
function n3(r, e) {
  let { $cursor: t } = r.selection;
  return !t || (e ? !e.endOfTextblock("backward", r) : t.parentOffset > 0) ? null : t;
}
const wD = (r, e, t) => {
  let n = n3(r, t);
  if (!n)
    return !1;
  let i = sb(n);
  if (!i) {
    let a = n.blockRange(), o = a && Mu(a);
    return o == null ? !1 : (e && e(r.tr.lift(a, o).scrollIntoView()), !0);
  }
  let s = i.nodeBefore;
  if (o3(r, i, e, -1))
    return !0;
  if (n.parent.content.size == 0 && (ku(s, "end") || Tt.isSelectable(s)))
    for (let a = n.depth; ; a--) {
      let o = ag(r.doc, n.before(a), n.after(a), lt.empty);
      if (o && o.slice.size < o.to - o.from) {
        if (e) {
          let A = r.tr.step(o);
          A.setSelection(ku(s, "end") ? Yt.findFrom(A.doc.resolve(A.mapping.map(i.pos, -1)), -1) : Tt.create(A.doc, i.pos - s.nodeSize)), e(A.scrollIntoView());
        }
        return !0;
      }
      if (a == 1 || n.node(a - 1).childCount > 1)
        break;
    }
  return s.isAtom && i.depth == n.depth - 1 ? (e && e(r.tr.delete(i.pos - s.nodeSize, i.pos).scrollIntoView()), !0) : !1;
}, BD = (r, e, t) => {
  let n = n3(r, t);
  if (!n)
    return !1;
  let i = sb(n);
  return i ? i3(r, i, e) : !1;
}, CD = (r, e, t) => {
  let n = s3(r, t);
  if (!n)
    return !1;
  let i = ab(n);
  return i ? i3(r, i, e) : !1;
};
function i3(r, e, t) {
  let n = e.nodeBefore, i = n, s = e.pos - 1;
  for (; !i.isTextblock; s--) {
    if (i.type.spec.isolating)
      return !1;
    let u = i.lastChild;
    if (!u)
      return !1;
    i = u;
  }
  let a = e.nodeAfter, o = a, A = e.pos + 1;
  for (; !o.isTextblock; A++) {
    if (o.type.spec.isolating)
      return !1;
    let u = o.firstChild;
    if (!u)
      return !1;
    o = u;
  }
  let l = ag(r.doc, s, A, lt.empty);
  if (!l || l.from != s || l instanceof Vn && l.slice.size >= A - s)
    return !1;
  if (t) {
    let u = r.tr.step(l);
    u.setSelection(zt.create(u.doc, s)), t(u.scrollIntoView());
  }
  return !0;
}
function ku(r, e, t = !1) {
  for (let n = r; n; n = e == "start" ? n.firstChild : n.lastChild) {
    if (n.isTextblock)
      return !0;
    if (t && n.childCount != 1)
      return !1;
  }
  return !1;
}
const _D = (r, e, t) => {
  let { $head: n, empty: i } = r.selection, s = n;
  if (!i)
    return !1;
  if (n.parent.isTextblock) {
    if (t ? !t.endOfTextblock("backward", r) : n.parentOffset > 0)
      return !1;
    s = sb(n);
  }
  let a = s && s.nodeBefore;
  return !a || !Tt.isSelectable(a) ? !1 : (e && e(r.tr.setSelection(Tt.create(r.doc, s.pos - a.nodeSize)).scrollIntoView()), !0);
};
function sb(r) {
  if (!r.parent.type.spec.isolating)
    for (let e = r.depth - 1; e >= 0; e--) {
      if (r.index(e) > 0)
        return r.doc.resolve(r.before(e + 1));
      if (r.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function s3(r, e) {
  let { $cursor: t } = r.selection;
  return !t || (e ? !e.endOfTextblock("forward", r) : t.parentOffset < t.parent.content.size) ? null : t;
}
const ED = (r, e, t) => {
  let n = s3(r, t);
  if (!n)
    return !1;
  let i = ab(n);
  if (!i)
    return !1;
  let s = i.nodeAfter;
  if (o3(r, i, e, 1))
    return !0;
  if (n.parent.content.size == 0 && (ku(s, "start") || Tt.isSelectable(s))) {
    let a = ag(r.doc, n.before(), n.after(), lt.empty);
    if (a && a.slice.size < a.to - a.from) {
      if (e) {
        let o = r.tr.step(a);
        o.setSelection(ku(s, "start") ? Yt.findFrom(o.doc.resolve(o.mapping.map(i.pos)), 1) : Tt.create(o.doc, o.mapping.map(i.pos))), e(o.scrollIntoView());
      }
      return !0;
    }
  }
  return s.isAtom && i.depth == n.depth - 1 ? (e && e(r.tr.delete(i.pos, i.pos + s.nodeSize).scrollIntoView()), !0) : !1;
}, SD = (r, e, t) => {
  let { $head: n, empty: i } = r.selection, s = n;
  if (!i)
    return !1;
  if (n.parent.isTextblock) {
    if (t ? !t.endOfTextblock("forward", r) : n.parentOffset < n.parent.content.size)
      return !1;
    s = ab(n);
  }
  let a = s && s.nodeAfter;
  return !a || !Tt.isSelectable(a) ? !1 : (e && e(r.tr.setSelection(Tt.create(r.doc, s.pos)).scrollIntoView()), !0);
};
function ab(r) {
  if (!r.parent.type.spec.isolating)
    for (let e = r.depth - 1; e >= 0; e--) {
      let t = r.node(e);
      if (r.index(e) + 1 < t.childCount)
        return r.doc.resolve(r.after(e + 1));
      if (t.type.spec.isolating)
        break;
    }
  return null;
}
const ID = (r, e) => {
  let t = r.selection, n = t instanceof Tt, i;
  if (n) {
    if (t.node.isTextblock || !uA(r.doc, t.from))
      return !1;
    i = t.from;
  } else if (i = sg(r.doc, t.from, -1), i == null)
    return !1;
  if (e) {
    let s = r.tr.join(i);
    n && s.setSelection(Tt.create(s.doc, i - r.doc.resolve(i).nodeBefore.nodeSize)), e(s.scrollIntoView());
  }
  return !0;
}, FD = (r, e) => {
  let t = r.selection, n;
  if (t instanceof Tt) {
    if (t.node.isTextblock || !uA(r.doc, t.to))
      return !1;
    n = t.to;
  } else if (n = sg(r.doc, t.to, 1), n == null)
    return !1;
  return e && e(r.tr.join(n).scrollIntoView()), !0;
}, TD = (r, e) => {
  let { $from: t, $to: n } = r.selection, i = t.blockRange(n), s = i && Mu(i);
  return s == null ? !1 : (e && e(r.tr.lift(i, s).scrollIntoView()), !0);
}, xD = (r, e) => {
  let { $head: t, $anchor: n } = r.selection;
  return !t.parent.type.spec.code || !t.sameParent(n) ? !1 : (e && e(r.tr.insertText(`
`).scrollIntoView()), !0);
};
function a3(r) {
  for (let e = 0; e < r.edgeCount; e++) {
    let { type: t } = r.edge(e);
    if (t.isTextblock && !t.hasRequiredAttrs())
      return t;
  }
  return null;
}
const kD = (r, e) => {
  let { $head: t, $anchor: n } = r.selection;
  if (!t.parent.type.spec.code || !t.sameParent(n))
    return !1;
  let i = t.node(-1), s = t.indexAfter(-1), a = a3(i.contentMatchAt(s));
  if (!a || !i.canReplaceWith(s, s, a))
    return !1;
  if (e) {
    let o = t.after(), A = r.tr.replaceWith(o, o, a.createAndFill());
    A.setSelection(Yt.near(A.doc.resolve(o), 1)), e(A.scrollIntoView());
  }
  return !0;
}, LD = (r, e) => {
  let t = r.selection, { $from: n, $to: i } = t;
  if (t instanceof Us || n.parent.inlineContent || i.parent.inlineContent)
    return !1;
  let s = a3(i.parent.contentMatchAt(i.indexAfter()));
  if (!s || !s.isTextblock)
    return !1;
  if (e) {
    let a = (!n.parentOffset && i.index() < i.parent.childCount ? n : i).pos, o = r.tr.insert(a, s.createAndFill());
    o.setSelection(zt.create(o.doc, a + 1)), e(o.scrollIntoView());
  }
  return !0;
}, UD = (r, e) => {
  let { $cursor: t } = r.selection;
  if (!t || t.parent.content.size)
    return !1;
  if (t.depth > 1 && t.after() != t.end(-1)) {
    let s = t.before();
    if (wu(r.doc, s))
      return e && e(r.tr.split(s).scrollIntoView()), !0;
  }
  let n = t.blockRange(), i = n && Mu(n);
  return i == null ? !1 : (e && e(r.tr.lift(n, i).scrollIntoView()), !0);
}, ND = (r, e) => {
  let { $from: t, to: n } = r.selection, i, s = t.sharedDepth(n);
  return s == 0 ? !1 : (i = t.before(s), e && e(r.tr.setSelection(Tt.create(r.doc, i))), !0);
};
function OD(r, e, t) {
  let n = e.nodeBefore, i = e.nodeAfter, s = e.index();
  return !n || !i || !n.type.compatibleContent(i.type) ? !1 : !n.content.size && e.parent.canReplace(s - 1, s) ? (t && t(r.tr.delete(e.pos - n.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(s, s + 1) || !(i.isTextblock || uA(r.doc, e.pos)) ? !1 : (t && t(r.tr.join(e.pos).scrollIntoView()), !0);
}
function o3(r, e, t, n) {
  let i = e.nodeBefore, s = e.nodeAfter, a, o, A = i.type.spec.isolating || s.type.spec.isolating;
  if (!A && OD(r, e, t))
    return !0;
  let l = !A && e.parent.canReplace(e.index(), e.index() + 1);
  if (l && (a = (o = i.contentMatchAt(i.childCount)).findWrapping(s.type)) && o.matchType(a[0] || s.type).validEnd) {
    if (t) {
      let f = e.pos + s.nodeSize, d = Ye.empty;
      for (let m = a.length - 1; m >= 0; m--)
        d = Ye.from(a[m].create(null, d));
      d = Ye.from(i.copy(d));
      let p = r.tr.step(new qn(e.pos - 1, f, e.pos, f, new lt(d, 1, 0), a.length, !0)), v = p.doc.resolve(f + 2 * a.length);
      v.nodeAfter && v.nodeAfter.type == i.type && uA(p.doc, v.pos) && p.join(v.pos), t(p.scrollIntoView());
    }
    return !0;
  }
  let u = s.type.spec.isolating || n > 0 && A ? null : Yt.findFrom(e, 1), c = u && u.$from.blockRange(u.$to), h = c && Mu(c);
  if (h != null && h >= e.depth)
    return t && t(r.tr.lift(c, h).scrollIntoView()), !0;
  if (l && ku(s, "start", !0) && ku(i, "end")) {
    let f = i, d = [];
    for (; d.push(f), !f.isTextblock; )
      f = f.lastChild;
    let p = s, v = 1;
    for (; !p.isTextblock; p = p.firstChild)
      v++;
    if (f.canReplace(f.childCount, f.childCount, p.content)) {
      if (t) {
        let m = Ye.empty;
        for (let w = d.length - 1; w >= 0; w--)
          m = Ye.from(d[w].copy(m));
        let b = r.tr.step(new qn(e.pos - d.length, e.pos + s.nodeSize, e.pos + v, e.pos + s.nodeSize - v, new lt(m, d.length, 0), 0, !0));
        t(b.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function A3(r) {
  return function(e, t) {
    let n = e.selection, i = r < 0 ? n.$from : n.$to, s = i.depth;
    for (; i.node(s).isInline; ) {
      if (!s)
        return !1;
      s--;
    }
    return i.node(s).isTextblock ? (t && t(e.tr.setSelection(zt.create(e.doc, r < 0 ? i.start(s) : i.end(s)))), !0) : !1;
  };
}
const QD = A3(-1), DD = A3(1);
function MD(r, e = null) {
  return function(t, n) {
    let { $from: i, $to: s } = t.selection, a = i.blockRange(s), o = a && q2(a, r, e);
    return o ? (n && n(t.tr.wrap(a, o).scrollIntoView()), !0) : !1;
  };
}
function wB(r, e = null) {
  return function(t, n) {
    let i = !1;
    for (let s = 0; s < t.selection.ranges.length && !i; s++) {
      let { $from: { pos: a }, $to: { pos: o } } = t.selection.ranges[s];
      t.doc.nodesBetween(a, o, (A, l) => {
        if (i)
          return !1;
        if (!(!A.isTextblock || A.hasMarkup(r, e)))
          if (A.type == r)
            i = !0;
          else {
            let u = t.doc.resolve(l), c = u.index();
            i = u.parent.canReplaceWith(c, c + 1, r);
          }
      });
    }
    if (!i)
      return !1;
    if (n) {
      let s = t.tr;
      for (let a = 0; a < t.selection.ranges.length; a++) {
        let { $from: { pos: o }, $to: { pos: A } } = t.selection.ranges[a];
        s.setBlockType(o, A, r, e);
      }
      n(s.scrollIntoView());
    }
    return !0;
  };
}
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function RD(r, e = null) {
  return function(t, n) {
    let { $from: i, $to: s } = t.selection, a = i.blockRange(s);
    if (!a)
      return !1;
    let o = n ? t.tr : null;
    return PD(o, a, r, e) ? (n && n(o.scrollIntoView()), !0) : !1;
  };
}
function PD(r, e, t, n = null) {
  let i = !1, s = e, a = e.$from.doc;
  if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(t) && e.startIndex == 0) {
    if (e.$from.index(e.depth - 1) == 0)
      return !1;
    let A = a.resolve(e.start - 2);
    s = new Cp(A, A, e.depth), e.endIndex < e.parent.childCount && (e = new Cp(e.$from, a.resolve(e.$to.end(e.depth)), e.depth)), i = !0;
  }
  let o = q2(s, t, n, e);
  return o ? (r && HD(r, e, o, i, t), !0) : !1;
}
function HD(r, e, t, n, i) {
  let s = Ye.empty;
  for (let u = t.length - 1; u >= 0; u--)
    s = Ye.from(t[u].type.create(t[u].attrs, s));
  r.step(new qn(e.start - (n ? 2 : 0), e.end, e.start, e.end, new lt(s, 0, 0), t.length, !0));
  let a = 0;
  for (let u = 0; u < t.length; u++)
    t[u].type == i && (a = u + 1);
  let o = t.length - a, A = e.start + t.length - (n ? 2 : 0), l = e.parent;
  for (let u = e.startIndex, c = e.endIndex, h = !0; u < c; u++, h = !1)
    !h && wu(r.doc, A, o) && (r.split(A, o), A += 2 * o), A += l.child(u).nodeSize;
  return r;
}
function jD(r) {
  return function(e, t) {
    let { $from: n, $to: i } = e.selection, s = n.blockRange(i, (a) => a.childCount > 0 && a.firstChild.type == r);
    return s ? t ? n.node(s.depth - 1).type == r ? KD(e, t, r, s) : $D(e, t, s) : !0 : !1;
  };
}
function KD(r, e, t, n) {
  let i = r.tr, s = n.end, a = n.$to.end(n.depth);
  s < a && (i.step(new qn(s - 1, a, s, a, new lt(Ye.from(t.create(null, n.parent.copy())), 1, 0), 1, !0)), n = new Cp(i.doc.resolve(n.$from.pos), i.doc.resolve(a), n.depth));
  const o = Mu(n);
  if (o == null)
    return !1;
  i.lift(n, o);
  let A = i.mapping.map(s, -1) - 1;
  return uA(i.doc, A) && i.join(A), e(i.scrollIntoView()), !0;
}
function $D(r, e, t) {
  let n = r.tr, i = t.parent;
  for (let f = t.end, d = t.endIndex - 1, p = t.startIndex; d > p; d--)
    f -= i.child(d).nodeSize, n.delete(f - 1, f + 1);
  let s = n.doc.resolve(t.start), a = s.nodeAfter;
  if (n.mapping.map(t.end) != t.start + s.nodeAfter.nodeSize)
    return !1;
  let o = t.startIndex == 0, A = t.endIndex == i.childCount, l = s.node(-1), u = s.index(-1);
  if (!l.canReplace(u + (o ? 0 : 1), u + 1, a.content.append(A ? Ye.empty : Ye.from(i))))
    return !1;
  let c = s.pos, h = c + a.nodeSize;
  return n.step(new qn(c - (o ? 1 : 0), h + (A ? 1 : 0), c + 1, h - 1, new lt((o ? Ye.empty : Ye.from(i.copy(Ye.empty))).append(A ? Ye.empty : Ye.from(i.copy(Ye.empty))), o ? 0 : 1, A ? 0 : 1), o ? 0 : 1)), e(n.scrollIntoView()), !0;
}
function VD(r) {
  return function(e, t) {
    let { $from: n, $to: i } = e.selection, s = n.blockRange(i, (l) => l.childCount > 0 && l.firstChild.type == r);
    if (!s)
      return !1;
    let a = s.startIndex;
    if (a == 0)
      return !1;
    let o = s.parent, A = o.child(a - 1);
    if (A.type != r)
      return !1;
    if (t) {
      let l = A.lastChild && A.lastChild.type == o.type, u = Ye.from(l ? r.create() : null), c = new lt(Ye.from(r.create(null, Ye.from(o.type.create(null, u)))), l ? 3 : 1, 0), h = s.start, f = s.end;
      t(e.tr.step(new qn(h - (l ? 3 : 1), f, h, f, c, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function cg(r) {
  const { state: e, transaction: t } = r;
  let { selection: n } = t, { doc: i } = t, { storedMarks: s } = t;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return s;
    },
    get selection() {
      return n;
    },
    get doc() {
      return i;
    },
    get tr() {
      return n = t.selection, i = t.doc, s = t.storedMarks, t;
    }
  };
}
class fg {
  constructor(e) {
    this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: t, state: n } = this, { view: i } = t, { tr: s } = n, a = this.buildProps(s);
    return Object.fromEntries(Object.entries(e).map(([o, A]) => [o, (...u) => {
      const c = A(...u)(a);
      return !s.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(s), c;
    }]));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, t = !0) {
    const { rawCommands: n, editor: i, state: s } = this, { view: a } = i, o = [], A = !!e, l = e || s.tr, u = () => (!A && t && !l.getMeta("preventDispatch") && !this.hasCustomState && a.dispatch(l), o.every((h) => h === !0)), c = {
      ...Object.fromEntries(Object.entries(n).map(([h, f]) => [h, (...p) => {
        const v = this.buildProps(l, t), m = f(...p)(v);
        return o.push(m), c;
      }])),
      run: u
    };
    return c;
  }
  createCan(e) {
    const { rawCommands: t, state: n } = this, i = !1, s = e || n.tr, a = this.buildProps(s, i);
    return {
      ...Object.fromEntries(Object.entries(t).map(([A, l]) => [A, (...u) => l(...u)({ ...a, dispatch: void 0 })])),
      chain: () => this.createChain(s, i)
    };
  }
  buildProps(e, t = !0) {
    const { rawCommands: n, editor: i, state: s } = this, { view: a } = i, o = {
      tr: e,
      editor: i,
      view: a,
      state: cg({
        state: s,
        transaction: e
      }),
      dispatch: t ? () => {
      } : void 0,
      chain: () => this.createChain(e, t),
      can: () => this.createCan(e),
      get commands() {
        return Object.fromEntries(Object.entries(n).map(([A, l]) => [A, (...u) => l(...u)(o)]));
      }
    };
    return o;
  }
}
class zD {
  constructor() {
    this.callbacks = {};
  }
  on(e, t) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(t), this;
  }
  emit(e, ...t) {
    const n = this.callbacks[e];
    return n && n.forEach((i) => i.apply(this, t)), this;
  }
  off(e, t) {
    const n = this.callbacks[e];
    return n && (t ? this.callbacks[e] = n.filter((i) => i !== t) : delete this.callbacks[e]), this;
  }
  once(e, t) {
    const n = (...i) => {
      this.off(e, n), t.apply(this, i);
    };
    return this.on(e, n);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
function vt(r, e, t) {
  return r.config[e] === void 0 && r.parent ? vt(r.parent, e, t) : typeof r.config[e] == "function" ? r.config[e].bind({
    ...t,
    parent: r.parent ? vt(r.parent, e, t) : null
  }) : r.config[e];
}
function hg(r) {
  const e = r.filter((i) => i.type === "extension"), t = r.filter((i) => i.type === "node"), n = r.filter((i) => i.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: t,
    markExtensions: n
  };
}
function l3(r) {
  const e = [], { nodeExtensions: t, markExtensions: n } = hg(r), i = [...t, ...n], s = {
    default: null,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return r.forEach((a) => {
    const o = {
      name: a.name,
      options: a.options,
      storage: a.storage,
      extensions: i
    }, A = vt(a, "addGlobalAttributes", o);
    if (!A)
      return;
    A().forEach((u) => {
      u.types.forEach((c) => {
        Object.entries(u.attributes).forEach(([h, f]) => {
          e.push({
            type: c,
            name: h,
            attribute: {
              ...s,
              ...f
            }
          });
        });
      });
    });
  }), i.forEach((a) => {
    const o = {
      name: a.name,
      options: a.options,
      storage: a.storage
    }, A = vt(a, "addAttributes", o);
    if (!A)
      return;
    const l = A();
    Object.entries(l).forEach(([u, c]) => {
      const h = {
        ...s,
        ...c
      };
      typeof (h == null ? void 0 : h.default) == "function" && (h.default = h.default()), h != null && h.isRequired && (h == null ? void 0 : h.default) === void 0 && delete h.default, e.push({
        type: a.name,
        name: u,
        attribute: h
      });
    });
  }), e;
}
function Xn(r, e) {
  if (typeof r == "string") {
    if (!e.nodes[r])
      throw Error(`There is no node type named '${r}'. Maybe you forgot to add the extension?`);
    return e.nodes[r];
  }
  return r;
}
function li(...r) {
  return r.filter((e) => !!e).reduce((e, t) => {
    const n = { ...e };
    return Object.entries(t).forEach(([i, s]) => {
      if (!n[i]) {
        n[i] = s;
        return;
      }
      if (i === "class") {
        const o = s ? String(s).split(" ") : [], A = n[i] ? n[i].split(" ") : [], l = o.filter((u) => !A.includes(u));
        n[i] = [...A, ...l].join(" ");
      } else if (i === "style") {
        const o = s ? s.split(";").map((u) => u.trim()).filter(Boolean) : [], A = n[i] ? n[i].split(";").map((u) => u.trim()).filter(Boolean) : [], l = /* @__PURE__ */ new Map();
        A.forEach((u) => {
          const [c, h] = u.split(":").map((f) => f.trim());
          l.set(c, h);
        }), o.forEach((u) => {
          const [c, h] = u.split(":").map((f) => f.trim());
          l.set(c, h);
        }), n[i] = Array.from(l.entries()).map(([u, c]) => `${u}: ${c}`).join("; ");
      } else
        n[i] = s;
    }), n;
  }, {});
}
function lv(r, e) {
  return e.filter((t) => t.type === r.type.name).filter((t) => t.attribute.rendered).map((t) => t.attribute.renderHTML ? t.attribute.renderHTML(r.attrs) || {} : {
    [t.name]: r.attrs[t.name]
  }).reduce((t, n) => li(t, n), {});
}
function u3(r) {
  return typeof r == "function";
}
function nr(r, e = void 0, ...t) {
  return u3(r) ? e ? r.bind(e)(...t) : r(...t) : r;
}
function GD(r = {}) {
  return Object.keys(r).length === 0 && r.constructor === Object;
}
function qD(r) {
  return typeof r != "string" ? r : r.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(r) : r === "true" ? !0 : r === "false" ? !1 : r;
}
function BB(r, e) {
  return "style" in r ? r : {
    ...r,
    getAttrs: (t) => {
      const n = r.getAttrs ? r.getAttrs(t) : r.attrs;
      if (n === !1)
        return !1;
      const i = e.reduce((s, a) => {
        const o = a.attribute.parseHTML ? a.attribute.parseHTML(t) : qD(t.getAttribute(a.name));
        return o == null ? s : {
          ...s,
          [a.name]: o
        };
      }, {});
      return { ...n, ...i };
    }
  };
}
function CB(r) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(r).filter(([e, t]) => e === "attrs" && GD(t) ? !1 : t != null)
  );
}
function WD(r, e) {
  var t;
  const n = l3(r), { nodeExtensions: i, markExtensions: s } = hg(r), a = (t = i.find((l) => vt(l, "topNode"))) === null || t === void 0 ? void 0 : t.name, o = Object.fromEntries(i.map((l) => {
    const u = n.filter((m) => m.type === l.name), c = {
      name: l.name,
      options: l.options,
      storage: l.storage,
      editor: e
    }, h = r.reduce((m, b) => {
      const w = vt(b, "extendNodeSchema", c);
      return {
        ...m,
        ...w ? w(l) : {}
      };
    }, {}), f = CB({
      ...h,
      content: nr(vt(l, "content", c)),
      marks: nr(vt(l, "marks", c)),
      group: nr(vt(l, "group", c)),
      inline: nr(vt(l, "inline", c)),
      atom: nr(vt(l, "atom", c)),
      selectable: nr(vt(l, "selectable", c)),
      draggable: nr(vt(l, "draggable", c)),
      code: nr(vt(l, "code", c)),
      whitespace: nr(vt(l, "whitespace", c)),
      linebreakReplacement: nr(vt(l, "linebreakReplacement", c)),
      defining: nr(vt(l, "defining", c)),
      isolating: nr(vt(l, "isolating", c)),
      attrs: Object.fromEntries(u.map((m) => {
        var b;
        return [m.name, { default: (b = m == null ? void 0 : m.attribute) === null || b === void 0 ? void 0 : b.default }];
      }))
    }), d = nr(vt(l, "parseHTML", c));
    d && (f.parseDOM = d.map((m) => BB(m, u)));
    const p = vt(l, "renderHTML", c);
    p && (f.toDOM = (m) => p({
      node: m,
      HTMLAttributes: lv(m, u)
    }));
    const v = vt(l, "renderText", c);
    return v && (f.toText = v), [l.name, f];
  })), A = Object.fromEntries(s.map((l) => {
    const u = n.filter((v) => v.type === l.name), c = {
      name: l.name,
      options: l.options,
      storage: l.storage,
      editor: e
    }, h = r.reduce((v, m) => {
      const b = vt(m, "extendMarkSchema", c);
      return {
        ...v,
        ...b ? b(l) : {}
      };
    }, {}), f = CB({
      ...h,
      inclusive: nr(vt(l, "inclusive", c)),
      excludes: nr(vt(l, "excludes", c)),
      group: nr(vt(l, "group", c)),
      spanning: nr(vt(l, "spanning", c)),
      code: nr(vt(l, "code", c)),
      attrs: Object.fromEntries(u.map((v) => {
        var m;
        return [v.name, { default: (m = v == null ? void 0 : v.attribute) === null || m === void 0 ? void 0 : m.default }];
      }))
    }), d = nr(vt(l, "parseHTML", c));
    d && (f.parseDOM = d.map((v) => BB(v, u)));
    const p = vt(l, "renderHTML", c);
    return p && (f.toDOM = (v) => p({
      mark: v,
      HTMLAttributes: lv(v, u)
    })), [l.name, f];
  }));
  return new sS({
    topNode: a,
    nodes: o,
    marks: A
  });
}
function t0(r, e) {
  return e.nodes[r] || e.marks[r] || null;
}
function _B(r, e) {
  return Array.isArray(e) ? e.some((t) => (typeof t == "string" ? t : t.name) === r.name) : e;
}
function ob(r, e) {
  const t = ul.fromSchema(e).serializeFragment(r), i = document.implementation.createHTMLDocument().createElement("div");
  return i.appendChild(t), i.innerHTML;
}
const XD = (r, e = 500) => {
  let t = "";
  const n = r.parentOffset;
  return r.parent.nodesBetween(Math.max(0, n - e), n, (i, s, a, o) => {
    var A, l;
    const u = ((l = (A = i.type.spec).toText) === null || l === void 0 ? void 0 : l.call(A, {
      node: i,
      pos: s,
      parent: a,
      index: o
    })) || i.textContent || "%leaf%";
    t += i.isAtom && !i.isText ? u : u.slice(0, Math.max(0, n - s));
  }), t;
};
function Ab(r) {
  return Object.prototype.toString.call(r) === "[object RegExp]";
}
class dg {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const JD = (r, e) => {
  if (Ab(e))
    return e.exec(r);
  const t = e(r);
  if (!t)
    return null;
  const n = [t.text];
  return n.index = t.index, n.input = r, n.data = t.data, t.replaceWith && (t.text.includes(t.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), n.push(t.replaceWith)), n;
};
function Yh(r) {
  var e;
  const { editor: t, from: n, to: i, text: s, rules: a, plugin: o } = r, { view: A } = t;
  if (A.composing)
    return !1;
  const l = A.state.doc.resolve(n);
  if (
    // check for code node
    l.parent.type.spec.code || !((e = l.nodeBefore || l.nodeAfter) === null || e === void 0) && e.marks.find((h) => h.type.spec.code)
  )
    return !1;
  let u = !1;
  const c = XD(l) + s;
  return a.forEach((h) => {
    if (u)
      return;
    const f = JD(c, h.find);
    if (!f)
      return;
    const d = A.state.tr, p = cg({
      state: A.state,
      transaction: d
    }), v = {
      from: n - (f[0].length - s.length),
      to: i
    }, { commands: m, chain: b, can: w } = new fg({
      editor: t,
      state: p
    });
    h.handler({
      state: p,
      range: v,
      match: f,
      commands: m,
      chain: b,
      can: w
    }) === null || !d.steps.length || (d.setMeta(o, {
      transform: d,
      from: n,
      to: i,
      text: s
    }), A.dispatch(d), u = !0);
  }), u;
}
function YD(r) {
  const { editor: e, rules: t } = r, n = new es({
    state: {
      init() {
        return null;
      },
      apply(i, s, a) {
        const o = i.getMeta(n);
        if (o)
          return o;
        const A = i.getMeta("applyInputRules");
        return !!A && setTimeout(() => {
          let { text: u } = A;
          typeof u == "string" ? u = u : u = ob(Ye.from(u), a.schema);
          const { from: c } = A, h = c + u.length;
          Yh({
            editor: e,
            from: c,
            to: h,
            text: u,
            rules: t,
            plugin: n
          });
        }), i.selectionSet || i.docChanged ? null : s;
      }
    },
    props: {
      handleTextInput(i, s, a, o) {
        return Yh({
          editor: e,
          from: s,
          to: a,
          text: o,
          rules: t,
          plugin: n
        });
      },
      handleDOMEvents: {
        compositionend: (i) => (setTimeout(() => {
          const { $cursor: s } = i.state.selection;
          s && Yh({
            editor: e,
            from: s.pos,
            to: s.pos,
            text: "",
            rules: t,
            plugin: n
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(i, s) {
        if (s.key !== "Enter")
          return !1;
        const { $cursor: a } = i.state.selection;
        return a ? Yh({
          editor: e,
          from: a.pos,
          to: a.pos,
          text: `
`,
          rules: t,
          plugin: n
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return n;
}
function ZD(r) {
  return Object.prototype.toString.call(r).slice(8, -1);
}
function Zh(r) {
  return ZD(r) !== "Object" ? !1 : r.constructor === Object && Object.getPrototypeOf(r) === Object.prototype;
}
function pg(r, e) {
  const t = { ...r };
  return Zh(r) && Zh(e) && Object.keys(e).forEach((n) => {
    Zh(e[n]) && Zh(r[n]) ? t[n] = pg(r[n], e[n]) : t[n] = e[n];
  }), t;
}
class xa {
  constructor(e = {}) {
    this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = nr(vt(this, "addOptions", {
      name: this.name
    }))), this.storage = nr(vt(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new xa(e);
  }
  configure(e = {}) {
    const t = this.extend({
      ...this.config,
      addOptions: () => pg(this.options, e)
    });
    return t.name = this.name, t.parent = this.parent, t;
  }
  extend(e = {}) {
    const t = new xa(e);
    return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = nr(vt(t, "addOptions", {
      name: t.name
    })), t.storage = nr(vt(t, "addStorage", {
      name: t.name,
      options: t.options
    })), t;
  }
  static handleExit({ editor: e, mark: t }) {
    const { tr: n } = e.state, i = e.state.selection.$from;
    if (i.pos === i.end()) {
      const a = i.marks();
      if (!!!a.find((l) => (l == null ? void 0 : l.type.name) === t.name))
        return !1;
      const A = a.find((l) => (l == null ? void 0 : l.type.name) === t.name);
      return A && n.removeStoredMark(A), n.insertText(" ", i.pos), e.view.dispatch(n), !0;
    }
    return !1;
  }
}
function e8(r) {
  return typeof r == "number";
}
class t8 {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const r8 = (r, e, t) => {
  if (Ab(e))
    return [...r.matchAll(e)];
  const n = e(r, t);
  return n ? n.map((i) => {
    const s = [i.text];
    return s.index = i.index, s.input = r, s.data = i.data, i.replaceWith && (i.text.includes(i.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), s.push(i.replaceWith)), s;
  }) : [];
};
function n8(r) {
  const { editor: e, state: t, from: n, to: i, rule: s, pasteEvent: a, dropEvent: o } = r, { commands: A, chain: l, can: u } = new fg({
    editor: e,
    state: t
  }), c = [];
  return t.doc.nodesBetween(n, i, (f, d) => {
    if (!f.isTextblock || f.type.spec.code)
      return;
    const p = Math.max(n, d), v = Math.min(i, d + f.content.size), m = f.textBetween(p - d, v - d, void 0, "￼");
    r8(m, s.find, a).forEach((w) => {
      if (w.index === void 0)
        return;
      const B = p + w.index + 1, _ = B + w[0].length, x = {
        from: t.tr.mapping.map(B),
        to: t.tr.mapping.map(_)
      }, C = s.handler({
        state: t,
        range: x,
        match: w,
        commands: A,
        chain: l,
        can: u,
        pasteEvent: a,
        dropEvent: o
      });
      c.push(C);
    });
  }), c.every((f) => f !== null);
}
let ed = null;
const i8 = (r) => {
  var e;
  const t = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (e = t.clipboardData) === null || e === void 0 || e.setData("text/html", r), t;
};
function s8(r) {
  const { editor: e, rules: t } = r;
  let n = null, i = !1, s = !1, a = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, o;
  try {
    o = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    o = null;
  }
  const A = ({ state: u, from: c, to: h, rule: f, pasteEvt: d }) => {
    const p = u.tr, v = cg({
      state: u,
      transaction: p
    });
    if (!(!n8({
      editor: e,
      state: v,
      from: Math.max(c - 1, 0),
      to: h.b - 1,
      rule: f,
      pasteEvent: d,
      dropEvent: o
    }) || !p.steps.length)) {
      try {
        o = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        o = null;
      }
      return a = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, p;
    }
  };
  return t.map((u) => new es({
    // we register a global drag handler to track the current drag source element
    view(c) {
      const h = (d) => {
        var p;
        n = !((p = c.dom.parentElement) === null || p === void 0) && p.contains(d.target) ? c.dom.parentElement : null, n && (ed = e);
      }, f = () => {
        ed && (ed = null);
      };
      return window.addEventListener("dragstart", h), window.addEventListener("dragend", f), {
        destroy() {
          window.removeEventListener("dragstart", h), window.removeEventListener("dragend", f);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (c, h) => {
          if (s = n === c.dom.parentElement, o = h, !s) {
            const f = ed;
            f && setTimeout(() => {
              const d = f.state.selection;
              d && f.commands.deleteRange({ from: d.from, to: d.to });
            }, 10);
          }
          return !1;
        },
        paste: (c, h) => {
          var f;
          const d = (f = h.clipboardData) === null || f === void 0 ? void 0 : f.getData("text/html");
          return a = h, i = !!(d != null && d.includes("data-pm-slice")), !1;
        }
      }
    },
    appendTransaction: (c, h, f) => {
      const d = c[0], p = d.getMeta("uiEvent") === "paste" && !i, v = d.getMeta("uiEvent") === "drop" && !s, m = d.getMeta("applyPasteRules"), b = !!m;
      if (!p && !v && !b)
        return;
      if (b) {
        let { text: _ } = m;
        typeof _ == "string" ? _ = _ : _ = ob(Ye.from(_), f.schema);
        const { from: x } = m, C = x + _.length, F = i8(_);
        return A({
          rule: u,
          state: f,
          from: x,
          to: { b: C },
          pasteEvt: F
        });
      }
      const w = h.doc.content.findDiffStart(f.doc.content), B = h.doc.content.findDiffEnd(f.doc.content);
      if (!(!e8(w) || !B || w === B.b))
        return A({
          rule: u,
          state: f,
          from: w,
          to: B,
          pasteEvt: a
        });
    }
  }));
}
function a8(r) {
  const e = r.filter((t, n) => r.indexOf(t) !== n);
  return Array.from(new Set(e));
}
class hu {
  constructor(e, t) {
    this.splittableMarks = [], this.editor = t, this.extensions = hu.resolve(e), this.schema = WD(this.extensions, t), this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(e) {
    const t = hu.sort(hu.flatten(e)), n = a8(t.map((i) => i.name));
    return n.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${n.map((i) => `'${i}'`).join(", ")}]. This can lead to issues.`), t;
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(e) {
    return e.map((t) => {
      const n = {
        name: t.name,
        options: t.options,
        storage: t.storage
      }, i = vt(t, "addExtensions", n);
      return i ? [t, ...this.flatten(i())] : t;
    }).flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(e) {
    return e.sort((n, i) => {
      const s = vt(n, "priority") || 100, a = vt(i, "priority") || 100;
      return s > a ? -1 : s < a ? 1 : 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((e, t) => {
      const n = {
        name: t.name,
        options: t.options,
        storage: t.storage,
        editor: this.editor,
        type: t0(t.name, this.schema)
      }, i = vt(t, "addCommands", n);
      return i ? {
        ...e,
        ...i()
      } : e;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: e } = this, t = hu.sort([...this.extensions].reverse()), n = [], i = [], s = t.map((a) => {
      const o = {
        name: a.name,
        options: a.options,
        storage: a.storage,
        editor: e,
        type: t0(a.name, this.schema)
      }, A = [], l = vt(a, "addKeyboardShortcuts", o);
      let u = {};
      if (a.type === "mark" && vt(a, "exitable", o) && (u.ArrowRight = () => xa.handleExit({ editor: e, mark: a })), l) {
        const p = Object.fromEntries(Object.entries(l()).map(([v, m]) => [v, () => m({ editor: e })]));
        u = { ...u, ...p };
      }
      const c = bD(u);
      A.push(c);
      const h = vt(a, "addInputRules", o);
      _B(a, e.options.enableInputRules) && h && n.push(...h());
      const f = vt(a, "addPasteRules", o);
      _B(a, e.options.enablePasteRules) && f && i.push(...f());
      const d = vt(a, "addProseMirrorPlugins", o);
      if (d) {
        const p = d();
        A.push(...p);
      }
      return A;
    }).flat();
    return [
      YD({
        editor: e,
        rules: n
      }),
      ...s8({
        editor: e,
        rules: i
      }),
      ...s
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return l3(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: e } = this, { nodeExtensions: t } = hg(this.extensions);
    return Object.fromEntries(t.filter((n) => !!vt(n, "addNodeView")).map((n) => {
      const i = this.attributes.filter((A) => A.type === n.name), s = {
        name: n.name,
        options: n.options,
        storage: n.storage,
        editor: e,
        type: Xn(n.name, this.schema)
      }, a = vt(n, "addNodeView", s);
      if (!a)
        return [];
      const o = (A, l, u, c, h) => {
        const f = lv(A, i);
        return a()({
          // pass-through
          node: A,
          view: l,
          getPos: u,
          decorations: c,
          innerDecorations: h,
          // tiptap-specific
          editor: e,
          extension: n,
          HTMLAttributes: f
        });
      };
      return [n.name, o];
    }));
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((e) => {
      var t;
      this.editor.extensionStorage[e.name] = e.storage;
      const n = {
        name: e.name,
        options: e.options,
        storage: e.storage,
        editor: this.editor,
        type: t0(e.name, this.schema)
      };
      e.type === "mark" && (!((t = nr(vt(e, "keepOnSplit", n))) !== null && t !== void 0) || t) && this.splittableMarks.push(e.name);
      const i = vt(e, "onBeforeCreate", n), s = vt(e, "onCreate", n), a = vt(e, "onUpdate", n), o = vt(e, "onSelectionUpdate", n), A = vt(e, "onTransaction", n), l = vt(e, "onFocus", n), u = vt(e, "onBlur", n), c = vt(e, "onDestroy", n);
      i && this.editor.on("beforeCreate", i), s && this.editor.on("create", s), a && this.editor.on("update", a), o && this.editor.on("selectionUpdate", o), A && this.editor.on("transaction", A), l && this.editor.on("focus", l), u && this.editor.on("blur", u), c && this.editor.on("destroy", c);
    });
  }
}
class Mi {
  constructor(e = {}) {
    this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = nr(vt(this, "addOptions", {
      name: this.name
    }))), this.storage = nr(vt(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new Mi(e);
  }
  configure(e = {}) {
    const t = this.extend({
      ...this.config,
      addOptions: () => pg(this.options, e)
    });
    return t.name = this.name, t.parent = this.parent, t;
  }
  extend(e = {}) {
    const t = new Mi({ ...this.config, ...e });
    return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = nr(vt(t, "addOptions", {
      name: t.name
    })), t.storage = nr(vt(t, "addStorage", {
      name: t.name,
      options: t.options
    })), t;
  }
}
function c3(r, e, t) {
  const { from: n, to: i } = e, { blockSeparator: s = `

`, textSerializers: a = {} } = t || {};
  let o = "";
  return r.nodesBetween(n, i, (A, l, u, c) => {
    var h;
    A.isBlock && l > n && (o += s);
    const f = a == null ? void 0 : a[A.type.name];
    if (f)
      return u && (o += f({
        node: A,
        pos: l,
        parent: u,
        index: c,
        range: e
      })), !1;
    A.isText && (o += (h = A == null ? void 0 : A.text) === null || h === void 0 ? void 0 : h.slice(Math.max(n, l) - l, i - l));
  }), o;
}
function f3(r) {
  return Object.fromEntries(Object.entries(r.nodes).filter(([, e]) => e.spec.toText).map(([e, t]) => [e, t.spec.toText]));
}
const o8 = Mi.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new es({
        key: new Na("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: r } = this, { state: e, schema: t } = r, { doc: n, selection: i } = e, { ranges: s } = i, a = Math.min(...s.map((u) => u.$from.pos)), o = Math.max(...s.map((u) => u.$to.pos)), A = f3(t);
            return c3(n, { from: a, to: o }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: A
            });
          }
        }
      })
    ];
  }
}), A8 = () => ({ editor: r, view: e }) => (requestAnimationFrame(() => {
  var t;
  r.isDestroyed || (e.dom.blur(), (t = window == null ? void 0 : window.getSelection()) === null || t === void 0 || t.removeAllRanges());
}), !0), l8 = (r = !1) => ({ commands: e }) => e.setContent("", r), u8 = () => ({ state: r, tr: e, dispatch: t }) => {
  const { selection: n } = e, { ranges: i } = n;
  return t && i.forEach(({ $from: s, $to: a }) => {
    r.doc.nodesBetween(s.pos, a.pos, (o, A) => {
      if (o.type.isText)
        return;
      const { doc: l, mapping: u } = e, c = l.resolve(u.map(A)), h = l.resolve(u.map(A + o.nodeSize)), f = c.blockRange(h);
      if (!f)
        return;
      const d = Mu(f);
      if (o.type.isTextblock) {
        const { defaultType: p } = c.parent.contentMatchAt(c.index());
        e.setNodeMarkup(f.start, p);
      }
      (d || d === 0) && e.lift(f, d);
    });
  }), !0;
}, c8 = (r) => (e) => r(e), f8 = () => ({ state: r, dispatch: e }) => LD(r, e), h8 = (r, e) => ({ editor: t, tr: n }) => {
  const { state: i } = t, s = i.doc.slice(r.from, r.to);
  n.deleteRange(r.from, r.to);
  const a = n.mapping.map(e);
  return n.insert(a, s.content), n.setSelection(new zt(n.doc.resolve(a - 1))), !0;
}, d8 = () => ({ tr: r, dispatch: e }) => {
  const { selection: t } = r, n = t.$anchor.node();
  if (n.content.size > 0)
    return !1;
  const i = r.selection.$anchor;
  for (let s = i.depth; s > 0; s -= 1)
    if (i.node(s).type === n.type) {
      if (e) {
        const o = i.before(s), A = i.after(s);
        r.delete(o, A).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, p8 = (r) => ({ tr: e, state: t, dispatch: n }) => {
  const i = Xn(r, t.schema), s = e.selection.$anchor;
  for (let a = s.depth; a > 0; a -= 1)
    if (s.node(a).type === i) {
      if (n) {
        const A = s.before(a), l = s.after(a);
        e.delete(A, l).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, g8 = (r) => ({ tr: e, dispatch: t }) => {
  const { from: n, to: i } = r;
  return t && e.delete(n, i), !0;
}, m8 = () => ({ state: r, dispatch: e }) => yD(r, e), v8 = () => ({ commands: r }) => r.keyboardShortcut("Enter"), b8 = () => ({ state: r, dispatch: e }) => kD(r, e);
function xp(r, e, t = { strict: !0 }) {
  const n = Object.keys(e);
  return n.length ? n.every((i) => t.strict ? e[i] === r[i] : Ab(e[i]) ? e[i].test(r[i]) : e[i] === r[i]) : !0;
}
function h3(r, e, t = {}) {
  return r.find((n) => n.type === e && xp(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(t).map((i) => [i, n.attrs[i]])),
    t
  ));
}
function EB(r, e, t = {}) {
  return !!h3(r, e, t);
}
function lb(r, e, t) {
  var n;
  if (!r || !e)
    return;
  let i = r.parent.childAfter(r.parentOffset);
  if ((!i.node || !i.node.marks.some((u) => u.type === e)) && (i = r.parent.childBefore(r.parentOffset)), !i.node || !i.node.marks.some((u) => u.type === e) || (t = t || ((n = i.node.marks[0]) === null || n === void 0 ? void 0 : n.attrs), !h3([...i.node.marks], e, t)))
    return;
  let a = i.index, o = r.start() + i.offset, A = a + 1, l = o + i.node.nodeSize;
  for (; a > 0 && EB([...r.parent.child(a - 1).marks], e, t); )
    a -= 1, o -= r.parent.child(a).nodeSize;
  for (; A < r.parent.childCount && EB([...r.parent.child(A).marks], e, t); )
    l += r.parent.child(A).nodeSize, A += 1;
  return {
    from: o,
    to: l
  };
}
function fA(r, e) {
  if (typeof r == "string") {
    if (!e.marks[r])
      throw Error(`There is no mark type named '${r}'. Maybe you forgot to add the extension?`);
    return e.marks[r];
  }
  return r;
}
const y8 = (r, e = {}) => ({ tr: t, state: n, dispatch: i }) => {
  const s = fA(r, n.schema), { doc: a, selection: o } = t, { $from: A, from: l, to: u } = o;
  if (i) {
    const c = lb(A, s, e);
    if (c && c.from <= l && c.to >= u) {
      const h = zt.create(a, c.from, c.to);
      t.setSelection(h);
    }
  }
  return !0;
}, w8 = (r) => (e) => {
  const t = typeof r == "function" ? r(e) : r;
  for (let n = 0; n < t.length; n += 1)
    if (t[n](e))
      return !0;
  return !1;
};
function d3(r) {
  return r instanceof zt;
}
function KA(r = 0, e = 0, t = 0) {
  return Math.min(Math.max(r, e), t);
}
function p3(r, e = null) {
  if (!e)
    return null;
  const t = Yt.atStart(r), n = Yt.atEnd(r);
  if (e === "start" || e === !0)
    return t;
  if (e === "end")
    return n;
  const i = t.from, s = n.to;
  return e === "all" ? zt.create(r, KA(0, i, s), KA(r.content.size, i, s)) : zt.create(r, KA(e, i, s), KA(e, i, s));
}
function B8() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function ub() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
const C8 = (r = null, e = {}) => ({ editor: t, view: n, tr: i, dispatch: s }) => {
  e = {
    scrollIntoView: !0,
    ...e
  };
  const a = () => {
    (ub() || B8()) && n.dom.focus(), requestAnimationFrame(() => {
      t.isDestroyed || (n.focus(), e != null && e.scrollIntoView && t.commands.scrollIntoView());
    });
  };
  if (n.hasFocus() && r === null || r === !1)
    return !0;
  if (s && r === null && !d3(t.state.selection))
    return a(), !0;
  const o = p3(i.doc, r) || t.state.selection, A = t.state.selection.eq(o);
  return s && (A || i.setSelection(o), A && i.storedMarks && i.setStoredMarks(i.storedMarks), a()), !0;
}, _8 = (r, e) => (t) => r.every((n, i) => e(n, { ...t, index: i })), E8 = (r, e) => ({ tr: t, commands: n }) => n.insertContentAt({ from: t.selection.from, to: t.selection.to }, r, e), g3 = (r) => {
  const e = r.childNodes;
  for (let t = e.length - 1; t >= 0; t -= 1) {
    const n = e[t];
    n.nodeType === 3 && n.nodeValue && /^(\n\s\s|\n)$/.test(n.nodeValue) ? r.removeChild(n) : n.nodeType === 1 && g3(n);
  }
  return r;
};
function td(r) {
  const e = `<body>${r}</body>`, t = new window.DOMParser().parseFromString(e, "text/html").body;
  return g3(t);
}
function kp(r, e, t) {
  if (r instanceof Jo || r instanceof Ye)
    return r;
  t = {
    slice: !0,
    parseOptions: {},
    ...t
  };
  const n = typeof r == "object" && r !== null, i = typeof r == "string";
  if (n)
    try {
      if (Array.isArray(r) && r.length > 0)
        return Ye.fromArray(r.map((o) => e.nodeFromJSON(o)));
      const a = e.nodeFromJSON(r);
      return t.errorOnInvalidContent && a.check(), a;
    } catch (s) {
      if (t.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: s });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", r, "Error:", s), kp("", e, t);
    }
  if (i) {
    if (t.errorOnInvalidContent) {
      let a = !1, o = "";
      const A = new sS({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (l) => (a = !0, o = typeof l == "string" ? l : l.outerHTML, null)
              }
            ]
          }
        })
      });
      if (t.slice ? Jc.fromSchema(A).parseSlice(td(r), t.parseOptions) : Jc.fromSchema(A).parse(td(r), t.parseOptions), t.errorOnInvalidContent && a)
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${o}`) });
    }
    const s = Jc.fromSchema(e);
    return t.slice ? s.parseSlice(td(r), t.parseOptions).content : s.parse(td(r), t.parseOptions);
  }
  return kp("", e, t);
}
function S8(r, e, t) {
  const n = r.steps.length - 1;
  if (n < e)
    return;
  const i = r.steps[n];
  if (!(i instanceof Vn || i instanceof qn))
    return;
  const s = r.mapping.maps[n];
  let a = 0;
  s.forEach((o, A, l, u) => {
    a === 0 && (a = u);
  }), r.setSelection(Yt.near(r.doc.resolve(a), t));
}
const I8 = (r) => !("type" in r), F8 = (r, e, t) => ({ tr: n, dispatch: i, editor: s }) => {
  var a;
  if (i) {
    t = {
      parseOptions: s.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...t
    };
    let o;
    try {
      o = kp(e, s.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...t.parseOptions
        },
        errorOnInvalidContent: (a = t.errorOnInvalidContent) !== null && a !== void 0 ? a : s.options.enableContentCheck
      });
    } catch (d) {
      return s.emit("contentError", {
        editor: s,
        error: d,
        disableCollaboration: () => {
          s.storage.collaboration && (s.storage.collaboration.isDisabled = !0);
        }
      }), !1;
    }
    let { from: A, to: l } = typeof r == "number" ? { from: r, to: r } : { from: r.from, to: r.to }, u = !0, c = !0;
    if ((I8(o) ? o : [o]).forEach((d) => {
      d.check(), u = u ? d.isText && d.marks.length === 0 : !1, c = c ? d.isBlock : !1;
    }), A === l && c) {
      const { parent: d } = n.doc.resolve(A);
      d.isTextblock && !d.type.spec.code && !d.childCount && (A -= 1, l += 1);
    }
    let f;
    if (u) {
      if (Array.isArray(e))
        f = e.map((d) => d.text || "").join("");
      else if (e instanceof Ye) {
        let d = "";
        e.forEach((p) => {
          p.text && (d += p.text);
        }), f = d;
      } else typeof e == "object" && e && e.text ? f = e.text : f = e;
      n.insertText(f, A, l);
    } else
      f = o, n.replaceWith(A, l, f);
    t.updateSelection && S8(n, n.steps.length - 1, -1), t.applyInputRules && n.setMeta("applyInputRules", { from: A, text: f }), t.applyPasteRules && n.setMeta("applyPasteRules", { from: A, text: f });
  }
  return !0;
}, T8 = () => ({ state: r, dispatch: e }) => ID(r, e), x8 = () => ({ state: r, dispatch: e }) => FD(r, e), k8 = () => ({ state: r, dispatch: e }) => wD(r, e), L8 = () => ({ state: r, dispatch: e }) => ED(r, e), U8 = () => ({ state: r, dispatch: e, tr: t }) => {
  try {
    const n = sg(r.doc, r.selection.$from.pos, -1);
    return n == null ? !1 : (t.join(n, 2), e && e(t), !0);
  } catch {
    return !1;
  }
}, N8 = () => ({ state: r, dispatch: e, tr: t }) => {
  try {
    const n = sg(r.doc, r.selection.$from.pos, 1);
    return n == null ? !1 : (t.join(n, 2), e && e(t), !0);
  } catch {
    return !1;
  }
}, O8 = () => ({ state: r, dispatch: e }) => BD(r, e), Q8 = () => ({ state: r, dispatch: e }) => CD(r, e);
function m3() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function D8(r) {
  const e = r.split(/-(?!$)/);
  let t = e[e.length - 1];
  t === "Space" && (t = " ");
  let n, i, s, a;
  for (let o = 0; o < e.length - 1; o += 1) {
    const A = e[o];
    if (/^(cmd|meta|m)$/i.test(A))
      a = !0;
    else if (/^a(lt)?$/i.test(A))
      n = !0;
    else if (/^(c|ctrl|control)$/i.test(A))
      i = !0;
    else if (/^s(hift)?$/i.test(A))
      s = !0;
    else if (/^mod$/i.test(A))
      ub() || m3() ? a = !0 : i = !0;
    else
      throw new Error(`Unrecognized modifier name: ${A}`);
  }
  return n && (t = `Alt-${t}`), i && (t = `Ctrl-${t}`), a && (t = `Meta-${t}`), s && (t = `Shift-${t}`), t;
}
const M8 = (r) => ({ editor: e, view: t, tr: n, dispatch: i }) => {
  const s = D8(r).split(/-(?!$)/), a = s.find((l) => !["Alt", "Ctrl", "Meta", "Shift"].includes(l)), o = new KeyboardEvent("keydown", {
    key: a === "Space" ? " " : a,
    altKey: s.includes("Alt"),
    ctrlKey: s.includes("Ctrl"),
    metaKey: s.includes("Meta"),
    shiftKey: s.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), A = e.captureTransaction(() => {
    t.someProp("handleKeyDown", (l) => l(t, o));
  });
  return A == null || A.steps.forEach((l) => {
    const u = l.map(n.mapping);
    u && i && n.maybeStep(u);
  }), !0;
};
function Cf(r, e, t = {}) {
  const { from: n, to: i, empty: s } = r.selection, a = e ? Xn(e, r.schema) : null, o = [];
  r.doc.nodesBetween(n, i, (c, h) => {
    if (c.isText)
      return;
    const f = Math.max(n, h), d = Math.min(i, h + c.nodeSize);
    o.push({
      node: c,
      from: f,
      to: d
    });
  });
  const A = i - n, l = o.filter((c) => a ? a.name === c.node.type.name : !0).filter((c) => xp(c.node.attrs, t, { strict: !1 }));
  return s ? !!l.length : l.reduce((c, h) => c + h.to - h.from, 0) >= A;
}
const R8 = (r, e = {}) => ({ state: t, dispatch: n }) => {
  const i = Xn(r, t.schema);
  return Cf(t, i, e) ? TD(t, n) : !1;
}, P8 = () => ({ state: r, dispatch: e }) => UD(r, e), H8 = (r) => ({ state: e, dispatch: t }) => {
  const n = Xn(r, e.schema);
  return jD(n)(e, t);
}, j8 = () => ({ state: r, dispatch: e }) => xD(r, e);
function gg(r, e) {
  return e.nodes[r] ? "node" : e.marks[r] ? "mark" : null;
}
function SB(r, e) {
  const t = typeof e == "string" ? [e] : e;
  return Object.keys(r).reduce((n, i) => (t.includes(i) || (n[i] = r[i]), n), {});
}
const K8 = (r, e) => ({ tr: t, state: n, dispatch: i }) => {
  let s = null, a = null;
  const o = gg(typeof r == "string" ? r : r.name, n.schema);
  return o ? (o === "node" && (s = Xn(r, n.schema)), o === "mark" && (a = fA(r, n.schema)), i && t.selection.ranges.forEach((A) => {
    n.doc.nodesBetween(A.$from.pos, A.$to.pos, (l, u) => {
      s && s === l.type && t.setNodeMarkup(u, void 0, SB(l.attrs, e)), a && l.marks.length && l.marks.forEach((c) => {
        a === c.type && t.addMark(u, u + l.nodeSize, a.create(SB(c.attrs, e)));
      });
    });
  }), !0) : !1;
}, $8 = () => ({ tr: r, dispatch: e }) => (e && r.scrollIntoView(), !0), V8 = () => ({ tr: r, dispatch: e }) => {
  if (e) {
    const t = new Us(r.doc);
    r.setSelection(t);
  }
  return !0;
}, z8 = () => ({ state: r, dispatch: e }) => _D(r, e), G8 = () => ({ state: r, dispatch: e }) => SD(r, e), q8 = () => ({ state: r, dispatch: e }) => ND(r, e), W8 = () => ({ state: r, dispatch: e }) => DD(r, e), X8 = () => ({ state: r, dispatch: e }) => QD(r, e);
function uv(r, e, t = {}, n = {}) {
  return kp(r, e, {
    slice: !1,
    parseOptions: t,
    errorOnInvalidContent: n.errorOnInvalidContent
  });
}
const J8 = (r, e = !1, t = {}, n = {}) => ({ editor: i, tr: s, dispatch: a, commands: o }) => {
  var A, l;
  const { doc: u } = s;
  if (t.preserveWhitespace !== "full") {
    const c = uv(r, i.schema, t, {
      errorOnInvalidContent: (A = n.errorOnInvalidContent) !== null && A !== void 0 ? A : i.options.enableContentCheck
    });
    return a && s.replaceWith(0, u.content.size, c).setMeta("preventUpdate", !e), !0;
  }
  return a && s.setMeta("preventUpdate", !e), o.insertContentAt({ from: 0, to: u.content.size }, r, {
    parseOptions: t,
    errorOnInvalidContent: (l = n.errorOnInvalidContent) !== null && l !== void 0 ? l : i.options.enableContentCheck
  });
};
function v3(r, e) {
  const t = fA(e, r.schema), { from: n, to: i, empty: s } = r.selection, a = [];
  s ? (r.storedMarks && a.push(...r.storedMarks), a.push(...r.selection.$head.marks())) : r.doc.nodesBetween(n, i, (A) => {
    a.push(...A.marks);
  });
  const o = a.find((A) => A.type.name === t.name);
  return o ? { ...o.attrs } : {};
}
function Y8(r) {
  for (let e = 0; e < r.edgeCount; e += 1) {
    const { type: t } = r.edge(e);
    if (t.isTextblock && !t.hasRequiredAttrs())
      return t;
  }
  return null;
}
function Z8(r, e) {
  for (let t = r.depth; t > 0; t -= 1) {
    const n = r.node(t);
    if (e(n))
      return {
        pos: t > 0 ? r.before(t) : 0,
        start: r.start(t),
        depth: t,
        node: n
      };
  }
}
function cb(r) {
  return (e) => Z8(e.$from, r);
}
function eM(r, e) {
  const t = {
    from: 0,
    to: r.content.size
  };
  return c3(r, t, e);
}
function tM(r, e) {
  const t = Xn(e, r.schema), { from: n, to: i } = r.selection, s = [];
  r.doc.nodesBetween(n, i, (o) => {
    s.push(o);
  });
  const a = s.reverse().find((o) => o.type.name === t.name);
  return a ? { ...a.attrs } : {};
}
function rM(r, e) {
  const t = gg(typeof e == "string" ? e : e.name, r.schema);
  return t === "node" ? tM(r, e) : t === "mark" ? v3(r, e) : {};
}
function b3(r, e, t) {
  const n = [];
  return r === e ? t.resolve(r).marks().forEach((i) => {
    const s = t.resolve(r), a = lb(s, i.type);
    a && n.push({
      mark: i,
      ...a
    });
  }) : t.nodesBetween(r, e, (i, s) => {
    !i || (i == null ? void 0 : i.nodeSize) === void 0 || n.push(...i.marks.map((a) => ({
      from: s,
      to: s + i.nodeSize,
      mark: a
    })));
  }), n;
}
function np(r, e, t) {
  return Object.fromEntries(Object.entries(t).filter(([n]) => {
    const i = r.find((s) => s.type === e && s.name === n);
    return i ? i.attribute.keepOnSplit : !1;
  }));
}
function cv(r, e, t = {}) {
  const { empty: n, ranges: i } = r.selection, s = e ? fA(e, r.schema) : null;
  if (n)
    return !!(r.storedMarks || r.selection.$from.marks()).filter((c) => s ? s.name === c.type.name : !0).find((c) => xp(c.attrs, t, { strict: !1 }));
  let a = 0;
  const o = [];
  if (i.forEach(({ $from: c, $to: h }) => {
    const f = c.pos, d = h.pos;
    r.doc.nodesBetween(f, d, (p, v) => {
      if (!p.isText && !p.marks.length)
        return;
      const m = Math.max(f, v), b = Math.min(d, v + p.nodeSize), w = b - m;
      a += w, o.push(...p.marks.map((B) => ({
        mark: B,
        from: m,
        to: b
      })));
    });
  }), a === 0)
    return !1;
  const A = o.filter((c) => s ? s.name === c.mark.type.name : !0).filter((c) => xp(c.mark.attrs, t, { strict: !1 })).reduce((c, h) => c + h.to - h.from, 0), l = o.filter((c) => s ? c.mark.type !== s && c.mark.type.excludes(s) : !0).reduce((c, h) => c + h.to - h.from, 0);
  return (A > 0 ? A + l : A) >= a;
}
function nM(r, e, t = {}) {
  if (!e)
    return Cf(r, null, t) || cv(r, null, t);
  const n = gg(e, r.schema);
  return n === "node" ? Cf(r, e, t) : n === "mark" ? cv(r, e, t) : !1;
}
function IB(r, e) {
  const { nodeExtensions: t } = hg(e), n = t.find((a) => a.name === r);
  if (!n)
    return !1;
  const i = {
    name: n.name,
    options: n.options,
    storage: n.storage
  }, s = nr(vt(n, "group", i));
  return typeof s != "string" ? !1 : s.split(" ").includes("list");
}
function fb(r, { checkChildren: e = !0, ignoreWhitespace: t = !1 } = {}) {
  var n;
  if (t) {
    if (r.type.name === "hardBreak")
      return !0;
    if (r.isText)
      return /^\s*$/m.test((n = r.text) !== null && n !== void 0 ? n : "");
  }
  if (r.isText)
    return !r.text;
  if (r.isAtom || r.isLeaf)
    return !1;
  if (r.content.childCount === 0)
    return !0;
  if (e) {
    let i = !0;
    return r.content.forEach((s) => {
      i !== !1 && (fb(s, { ignoreWhitespace: t, checkChildren: e }) || (i = !1));
    }), i;
  }
  return !1;
}
function iM(r) {
  return r instanceof Tt;
}
function sM(r, e, t) {
  var n;
  const { selection: i } = e;
  let s = null;
  if (d3(i) && (s = i.$cursor), s) {
    const o = (n = r.storedMarks) !== null && n !== void 0 ? n : s.marks();
    return !!t.isInSet(o) || !o.some((A) => A.type.excludes(t));
  }
  const { ranges: a } = i;
  return a.some(({ $from: o, $to: A }) => {
    let l = o.depth === 0 ? r.doc.inlineContent && r.doc.type.allowsMarkType(t) : !1;
    return r.doc.nodesBetween(o.pos, A.pos, (u, c, h) => {
      if (l)
        return !1;
      if (u.isInline) {
        const f = !h || h.type.allowsMarkType(t), d = !!t.isInSet(u.marks) || !u.marks.some((p) => p.type.excludes(t));
        l = f && d;
      }
      return !l;
    }), l;
  });
}
const aM = (r, e = {}) => ({ tr: t, state: n, dispatch: i }) => {
  const { selection: s } = t, { empty: a, ranges: o } = s, A = fA(r, n.schema);
  if (i)
    if (a) {
      const l = v3(n, A);
      t.addStoredMark(A.create({
        ...l,
        ...e
      }));
    } else
      o.forEach((l) => {
        const u = l.$from.pos, c = l.$to.pos;
        n.doc.nodesBetween(u, c, (h, f) => {
          const d = Math.max(f, u), p = Math.min(f + h.nodeSize, c);
          h.marks.find((m) => m.type === A) ? h.marks.forEach((m) => {
            A === m.type && t.addMark(d, p, A.create({
              ...m.attrs,
              ...e
            }));
          }) : t.addMark(d, p, A.create(e));
        });
      });
  return sM(n, t, A);
}, oM = (r, e) => ({ tr: t }) => (t.setMeta(r, e), !0), AM = (r, e = {}) => ({ state: t, dispatch: n, chain: i }) => {
  const s = Xn(r, t.schema);
  let a;
  return t.selection.$anchor.sameParent(t.selection.$head) && (a = t.selection.$anchor.parent.attrs), s.isTextblock ? i().command(({ commands: o }) => wB(s, { ...a, ...e })(t) ? !0 : o.clearNodes()).command(({ state: o }) => wB(s, { ...a, ...e })(o, n)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, lM = (r) => ({ tr: e, dispatch: t }) => {
  if (t) {
    const { doc: n } = e, i = KA(r, 0, n.content.size), s = Tt.create(n, i);
    e.setSelection(s);
  }
  return !0;
}, uM = (r) => ({ tr: e, dispatch: t }) => {
  if (t) {
    const { doc: n } = e, { from: i, to: s } = typeof r == "number" ? { from: r, to: r } : r, a = zt.atStart(n).from, o = zt.atEnd(n).to, A = KA(i, a, o), l = KA(s, a, o), u = zt.create(n, A, l);
    e.setSelection(u);
  }
  return !0;
}, cM = (r) => ({ state: e, dispatch: t }) => {
  const n = Xn(r, e.schema);
  return VD(n)(e, t);
};
function FB(r, e) {
  const t = r.storedMarks || r.selection.$to.parentOffset && r.selection.$from.marks();
  if (t) {
    const n = t.filter((i) => e == null ? void 0 : e.includes(i.type.name));
    r.tr.ensureMarks(n);
  }
}
const fM = ({ keepMarks: r = !0 } = {}) => ({ tr: e, state: t, dispatch: n, editor: i }) => {
  const { selection: s, doc: a } = e, { $from: o, $to: A } = s, l = i.extensionManager.attributes, u = np(l, o.node().type.name, o.node().attrs);
  if (s instanceof Tt && s.node.isBlock)
    return !o.parentOffset || !wu(a, o.pos) ? !1 : (n && (r && FB(t, i.extensionManager.splittableMarks), e.split(o.pos).scrollIntoView()), !0);
  if (!o.parent.isBlock)
    return !1;
  const c = A.parentOffset === A.parent.content.size, h = o.depth === 0 ? void 0 : Y8(o.node(-1).contentMatchAt(o.indexAfter(-1)));
  let f = c && h ? [
    {
      type: h,
      attrs: u
    }
  ] : void 0, d = wu(e.doc, e.mapping.map(o.pos), 1, f);
  if (!f && !d && wu(e.doc, e.mapping.map(o.pos), 1, h ? [{ type: h }] : void 0) && (d = !0, f = h ? [
    {
      type: h,
      attrs: u
    }
  ] : void 0), n) {
    if (d && (s instanceof zt && e.deleteSelection(), e.split(e.mapping.map(o.pos), 1, f), h && !c && !o.parentOffset && o.parent.type !== h)) {
      const p = e.mapping.map(o.before()), v = e.doc.resolve(p);
      o.node(-1).canReplaceWith(v.index(), v.index() + 1, h) && e.setNodeMarkup(e.mapping.map(o.before()), h);
    }
    r && FB(t, i.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return d;
}, hM = (r, e = {}) => ({ tr: t, state: n, dispatch: i, editor: s }) => {
  var a;
  const o = Xn(r, n.schema), { $from: A, $to: l } = n.selection, u = n.selection.node;
  if (u && u.isBlock || A.depth < 2 || !A.sameParent(l))
    return !1;
  const c = A.node(-1);
  if (c.type !== o)
    return !1;
  const h = s.extensionManager.attributes;
  if (A.parent.content.size === 0 && A.node(-1).childCount === A.indexAfter(-1)) {
    if (A.depth === 2 || A.node(-3).type !== o || A.index(-2) !== A.node(-2).childCount - 1)
      return !1;
    if (i) {
      let m = Ye.empty;
      const b = A.index(-1) ? 1 : A.index(-2) ? 2 : 3;
      for (let F = A.depth - b; F >= A.depth - 3; F -= 1)
        m = Ye.from(A.node(F).copy(m));
      const w = A.indexAfter(-1) < A.node(-2).childCount ? 1 : A.indexAfter(-2) < A.node(-3).childCount ? 2 : 3, B = {
        ...np(h, A.node().type.name, A.node().attrs),
        ...e
      }, _ = ((a = o.contentMatch.defaultType) === null || a === void 0 ? void 0 : a.createAndFill(B)) || void 0;
      m = m.append(Ye.from(o.createAndFill(null, _) || void 0));
      const x = A.before(A.depth - (b - 1));
      t.replace(x, A.after(-w), new lt(m, 4 - b, 0));
      let C = -1;
      t.doc.nodesBetween(x, t.doc.content.size, (F, N) => {
        if (C > -1)
          return !1;
        F.isTextblock && F.content.size === 0 && (C = N + 1);
      }), C > -1 && t.setSelection(zt.near(t.doc.resolve(C))), t.scrollIntoView();
    }
    return !0;
  }
  const f = l.pos === A.end() ? c.contentMatchAt(0).defaultType : null, d = {
    ...np(h, c.type.name, c.attrs),
    ...e
  }, p = {
    ...np(h, A.node().type.name, A.node().attrs),
    ...e
  };
  t.delete(A.pos, l.pos);
  const v = f ? [
    { type: o, attrs: d },
    { type: f, attrs: p }
  ] : [{ type: o, attrs: d }];
  if (!wu(t.doc, A.pos, 2))
    return !1;
  if (i) {
    const { selection: m, storedMarks: b } = n, { splittableMarks: w } = s.extensionManager, B = b || m.$to.parentOffset && m.$from.marks();
    if (t.split(A.pos, 2, v).scrollIntoView(), !B || !i)
      return !0;
    const _ = B.filter((x) => w.includes(x.type.name));
    t.ensureMarks(_);
  }
  return !0;
}, r0 = (r, e) => {
  const t = cb((a) => a.type === e)(r.selection);
  if (!t)
    return !0;
  const n = r.doc.resolve(Math.max(0, t.pos - 1)).before(t.depth);
  if (n === void 0)
    return !0;
  const i = r.doc.nodeAt(n);
  return t.node.type === (i == null ? void 0 : i.type) && uA(r.doc, t.pos) && r.join(t.pos), !0;
}, n0 = (r, e) => {
  const t = cb((a) => a.type === e)(r.selection);
  if (!t)
    return !0;
  const n = r.doc.resolve(t.start).after(t.depth);
  if (n === void 0)
    return !0;
  const i = r.doc.nodeAt(n);
  return t.node.type === (i == null ? void 0 : i.type) && uA(r.doc, n) && r.join(n), !0;
}, dM = (r, e, t, n = {}) => ({ editor: i, tr: s, state: a, dispatch: o, chain: A, commands: l, can: u }) => {
  const { extensions: c, splittableMarks: h } = i.extensionManager, f = Xn(r, a.schema), d = Xn(e, a.schema), { selection: p, storedMarks: v } = a, { $from: m, $to: b } = p, w = m.blockRange(b), B = v || p.$to.parentOffset && p.$from.marks();
  if (!w)
    return !1;
  const _ = cb((x) => IB(x.type.name, c))(p);
  if (w.depth >= 1 && _ && w.depth - _.depth <= 1) {
    if (_.node.type === f)
      return l.liftListItem(d);
    if (IB(_.node.type.name, c) && f.validContent(_.node.content) && o)
      return A().command(() => (s.setNodeMarkup(_.pos, f), !0)).command(() => r0(s, f)).command(() => n0(s, f)).run();
  }
  return !t || !B || !o ? A().command(() => u().wrapInList(f, n) ? !0 : l.clearNodes()).wrapInList(f, n).command(() => r0(s, f)).command(() => n0(s, f)).run() : A().command(() => {
    const x = u().wrapInList(f, n), C = B.filter((F) => h.includes(F.type.name));
    return s.ensureMarks(C), x ? !0 : l.clearNodes();
  }).wrapInList(f, n).command(() => r0(s, f)).command(() => n0(s, f)).run();
}, pM = (r, e = {}, t = {}) => ({ state: n, commands: i }) => {
  const { extendEmptyMarkRange: s = !1 } = t, a = fA(r, n.schema);
  return cv(n, a, e) ? i.unsetMark(a, { extendEmptyMarkRange: s }) : i.setMark(a, e);
}, gM = (r, e, t = {}) => ({ state: n, commands: i }) => {
  const s = Xn(r, n.schema), a = Xn(e, n.schema), o = Cf(n, s, t);
  let A;
  return n.selection.$anchor.sameParent(n.selection.$head) && (A = n.selection.$anchor.parent.attrs), o ? i.setNode(a, A) : i.setNode(s, { ...A, ...t });
}, mM = (r, e = {}) => ({ state: t, commands: n }) => {
  const i = Xn(r, t.schema);
  return Cf(t, i, e) ? n.lift(i) : n.wrapIn(i, e);
}, vM = () => ({ state: r, dispatch: e }) => {
  const t = r.plugins;
  for (let n = 0; n < t.length; n += 1) {
    const i = t[n];
    let s;
    if (i.spec.isInputRules && (s = i.getState(r))) {
      if (e) {
        const a = r.tr, o = s.transform;
        for (let A = o.steps.length - 1; A >= 0; A -= 1)
          a.step(o.steps[A].invert(o.docs[A]));
        if (s.text) {
          const A = a.doc.resolve(s.from).marks();
          a.replaceWith(s.from, s.to, r.schema.text(s.text, A));
        } else
          a.delete(s.from, s.to);
      }
      return !0;
    }
  }
  return !1;
}, bM = () => ({ tr: r, dispatch: e }) => {
  const { selection: t } = r, { empty: n, ranges: i } = t;
  return n || e && i.forEach((s) => {
    r.removeMark(s.$from.pos, s.$to.pos);
  }), !0;
}, yM = (r, e = {}) => ({ tr: t, state: n, dispatch: i }) => {
  var s;
  const { extendEmptyMarkRange: a = !1 } = e, { selection: o } = t, A = fA(r, n.schema), { $from: l, empty: u, ranges: c } = o;
  if (!i)
    return !0;
  if (u && a) {
    let { from: h, to: f } = o;
    const d = (s = l.marks().find((v) => v.type === A)) === null || s === void 0 ? void 0 : s.attrs, p = lb(l, A, d);
    p && (h = p.from, f = p.to), t.removeMark(h, f, A);
  } else
    c.forEach((h) => {
      t.removeMark(h.$from.pos, h.$to.pos, A);
    });
  return t.removeStoredMark(A), !0;
}, wM = (r, e = {}) => ({ tr: t, state: n, dispatch: i }) => {
  let s = null, a = null;
  const o = gg(typeof r == "string" ? r : r.name, n.schema);
  return o ? (o === "node" && (s = Xn(r, n.schema)), o === "mark" && (a = fA(r, n.schema)), i && t.selection.ranges.forEach((A) => {
    const l = A.$from.pos, u = A.$to.pos;
    let c, h, f, d;
    t.selection.empty ? n.doc.nodesBetween(l, u, (p, v) => {
      s && s === p.type && (f = Math.max(v, l), d = Math.min(v + p.nodeSize, u), c = v, h = p);
    }) : n.doc.nodesBetween(l, u, (p, v) => {
      v < l && s && s === p.type && (f = Math.max(v, l), d = Math.min(v + p.nodeSize, u), c = v, h = p), v >= l && v <= u && (s && s === p.type && t.setNodeMarkup(v, void 0, {
        ...p.attrs,
        ...e
      }), a && p.marks.length && p.marks.forEach((m) => {
        if (a === m.type) {
          const b = Math.max(v, l), w = Math.min(v + p.nodeSize, u);
          t.addMark(b, w, a.create({
            ...m.attrs,
            ...e
          }));
        }
      }));
    }), h && (c !== void 0 && t.setNodeMarkup(c, void 0, {
      ...h.attrs,
      ...e
    }), a && h.marks.length && h.marks.forEach((p) => {
      a === p.type && t.addMark(f, d, a.create({
        ...p.attrs,
        ...e
      }));
    }));
  }), !0) : !1;
}, BM = (r, e = {}) => ({ state: t, dispatch: n }) => {
  const i = Xn(r, t.schema);
  return MD(i, e)(t, n);
}, CM = (r, e = {}) => ({ state: t, dispatch: n }) => {
  const i = Xn(r, t.schema);
  return RD(i, e)(t, n);
};
var _M = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur: A8,
  clearContent: l8,
  clearNodes: u8,
  command: c8,
  createParagraphNear: f8,
  cut: h8,
  deleteCurrentNode: d8,
  deleteNode: p8,
  deleteRange: g8,
  deleteSelection: m8,
  enter: v8,
  exitCode: b8,
  extendMarkRange: y8,
  first: w8,
  focus: C8,
  forEach: _8,
  insertContent: E8,
  insertContentAt: F8,
  joinBackward: k8,
  joinDown: x8,
  joinForward: L8,
  joinItemBackward: U8,
  joinItemForward: N8,
  joinTextblockBackward: O8,
  joinTextblockForward: Q8,
  joinUp: T8,
  keyboardShortcut: M8,
  lift: R8,
  liftEmptyBlock: P8,
  liftListItem: H8,
  newlineInCode: j8,
  resetAttributes: K8,
  scrollIntoView: $8,
  selectAll: V8,
  selectNodeBackward: z8,
  selectNodeForward: G8,
  selectParentNode: q8,
  selectTextblockEnd: W8,
  selectTextblockStart: X8,
  setContent: J8,
  setMark: aM,
  setMeta: oM,
  setNode: AM,
  setNodeSelection: lM,
  setTextSelection: uM,
  sinkListItem: cM,
  splitBlock: fM,
  splitListItem: hM,
  toggleList: dM,
  toggleMark: pM,
  toggleNode: gM,
  toggleWrap: mM,
  undoInputRule: vM,
  unsetAllMarks: bM,
  unsetMark: yM,
  updateAttributes: wM,
  wrapIn: BM,
  wrapInList: CM
});
const EM = Mi.create({
  name: "commands",
  addCommands() {
    return {
      ..._M
    };
  }
}), SM = Mi.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new es({
        key: new Na("tiptapDrop"),
        props: {
          handleDrop: (r, e, t, n) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: t,
              moved: n
            });
          }
        }
      })
    ];
  }
}), IM = Mi.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new es({
        key: new Na("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), FM = Mi.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: r } = this;
    return [
      new es({
        key: new Na("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (e, t) => {
              r.isFocused = !0;
              const n = r.state.tr.setMeta("focus", { event: t }).setMeta("addToHistory", !1);
              return e.dispatch(n), !1;
            },
            blur: (e, t) => {
              r.isFocused = !1;
              const n = r.state.tr.setMeta("blur", { event: t }).setMeta("addToHistory", !1);
              return e.dispatch(n), !1;
            }
          }
        }
      })
    ];
  }
}), TM = Mi.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const r = () => this.editor.commands.first(({ commands: a }) => [
      () => a.undoInputRule(),
      // maybe convert first text block node to default node
      () => a.command(({ tr: o }) => {
        const { selection: A, doc: l } = o, { empty: u, $anchor: c } = A, { pos: h, parent: f } = c, d = c.parent.isTextblock && h > 0 ? o.doc.resolve(h - 1) : c, p = d.parent.type.spec.isolating, v = c.pos - c.parentOffset, m = p && d.parent.childCount === 1 ? v === c.pos : Yt.atStart(l).from === h;
        return !u || !f.type.isTextblock || f.textContent.length || !m || m && c.parent.type.name === "paragraph" ? !1 : a.clearNodes();
      }),
      () => a.deleteSelection(),
      () => a.joinBackward(),
      () => a.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: a }) => [
      () => a.deleteSelection(),
      () => a.deleteCurrentNode(),
      () => a.joinForward(),
      () => a.selectNodeForward()
    ]), n = {
      Enter: () => this.editor.commands.first(({ commands: a }) => [
        () => a.newlineInCode(),
        () => a.createParagraphNear(),
        () => a.liftEmptyBlock(),
        () => a.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: r,
      "Mod-Backspace": r,
      "Shift-Backspace": r,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, i = {
      ...n
    }, s = {
      ...n,
      "Ctrl-h": r,
      "Alt-Backspace": r,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return ub() || m3() ? s : i;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new es({
        key: new Na("clearDocument"),
        appendTransaction: (r, e, t) => {
          if (r.some((p) => p.getMeta("composition")))
            return;
          const n = r.some((p) => p.docChanged) && !e.doc.eq(t.doc), i = r.some((p) => p.getMeta("preventClearDocument"));
          if (!n || i)
            return;
          const { empty: s, from: a, to: o } = e.selection, A = Yt.atStart(e.doc).from, l = Yt.atEnd(e.doc).to;
          if (s || !(a === A && o === l) || !fb(t.doc))
            return;
          const h = t.tr, f = cg({
            state: t,
            transaction: h
          }), { commands: d } = new fg({
            editor: this.editor,
            state: f
          });
          if (d.clearNodes(), !!h.steps.length)
            return h;
        }
      })
    ];
  }
}), xM = Mi.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new es({
        key: new Na("tiptapPaste"),
        props: {
          handlePaste: (r, e, t) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: t
            });
          }
        }
      })
    ];
  }
}), kM = Mi.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new es({
        key: new Na("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
class QA {
  get name() {
    return this.node.type.name;
  }
  constructor(e, t, n = !1, i = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = n, this.resolvedPos = e, this.editor = t, this.currentNode = i;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var e;
    return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(e) {
    let t = this.from, n = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      t = this.from + 1, n = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: t, to: n }, e);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1), t = this.resolvedPos.doc.resolve(e);
    return new QA(t, this.editor);
  }
  get before() {
    let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new QA(e, this.editor);
  }
  get after() {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new QA(e, this.editor);
  }
  get children() {
    const e = [];
    return this.node.content.forEach((t, n) => {
      const i = t.isBlock && !t.isTextblock, s = t.isAtom && !t.isText, a = this.pos + n + (s ? 0 : 1), o = this.resolvedPos.doc.resolve(a);
      if (!i && o.depth <= this.depth)
        return;
      const A = new QA(o, this.editor, i, i ? t : null);
      i && (A.actualDepth = this.depth + 1), e.push(new QA(o, this.editor, i, i ? t : null));
    }), e;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const e = this.children;
    return e[e.length - 1] || null;
  }
  closest(e, t = {}) {
    let n = null, i = this.parent;
    for (; i && !n; ) {
      if (i.node.type.name === e)
        if (Object.keys(t).length > 0) {
          const s = i.node.attrs, a = Object.keys(t);
          for (let o = 0; o < a.length; o += 1) {
            const A = a[o];
            if (s[A] !== t[A])
              break;
          }
        } else
          n = i;
      i = i.parent;
    }
    return n;
  }
  querySelector(e, t = {}) {
    return this.querySelectorAll(e, t, !0)[0] || null;
  }
  querySelectorAll(e, t = {}, n = !1) {
    let i = [];
    if (!this.children || this.children.length === 0)
      return i;
    const s = Object.keys(t);
    return this.children.forEach((a) => {
      n && i.length > 0 || (a.node.type.name === e && s.every((A) => t[A] === a.node.attrs[A]) && i.push(a), !(n && i.length > 0) && (i = i.concat(a.querySelectorAll(e, t, n))));
    }), i;
  }
  setAttribute(e) {
    const { tr: t } = this.editor.state;
    t.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...e
    }), this.editor.view.dispatch(t);
  }
}
const LM = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function UM(r, e, t) {
  const n = document.querySelector("style[data-tiptap-style]");
  if (n !== null)
    return n;
  const i = document.createElement("style");
  return e && i.setAttribute("nonce", e), i.setAttribute("data-tiptap-style", ""), i.innerHTML = r, document.getElementsByTagName("head")[0].appendChild(i), i;
}
class NM extends zD {
  constructor(e = {}) {
    super(), this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: t }) => {
        throw t;
      },
      onPaste: () => null,
      onDrop: () => null
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: t, slice: n, moved: i }) => this.options.onDrop(t, n, i)), this.on("paste", ({ event: t, slice: n }) => this.options.onPaste(t, n)), window.setTimeout(() => {
      this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0);
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && document && (this.css = UM(LM, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, t = !0) {
    this.setOptions({ editable: e }), t && this.emit("update", { editor: this, transaction: this.state.tr });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(e, t) {
    const n = u3(t) ? t(e, [...this.state.plugins]) : [...this.state.plugins, e], i = this.state.reconfigure({ plugins: n });
    return this.view.updateState(i), i;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const t = this.state.plugins;
    let n = t;
    if ([].concat(e).forEach((s) => {
      const a = typeof s == "string" ? `${s}$` : s.key;
      n = t.filter((o) => !o.key.startsWith(a));
    }), t.length === n.length)
      return;
    const i = this.state.reconfigure({
      plugins: n
    });
    return this.view.updateState(i), i;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var e, t;
    const i = [...this.options.enableCoreExtensions ? [
      IM,
      o8.configure({
        blockSeparator: (t = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || t === void 0 ? void 0 : t.blockSeparator
      }),
      EM,
      FM,
      TM,
      kM,
      SM,
      xM
    ].filter((s) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[s.name] !== !1 : !0) : [], ...this.options.extensions].filter((s) => ["extension", "node", "mark"].includes(s == null ? void 0 : s.type));
    this.extensionManager = new hu(i, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new fg({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    var e;
    let t;
    try {
      t = uv(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
    } catch (a) {
      if (!(a instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(a.message))
        throw a;
      this.emit("contentError", {
        editor: this,
        error: a,
        disableCollaboration: () => {
          this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter((o) => o.name !== "collaboration"), this.createExtensionManager();
        }
      }), t = uv(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: !1 });
    }
    const n = p3(t, this.options.autofocus);
    this.view = new uD(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(e = this.options.editorProps) === null || e === void 0 ? void 0 : e.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: fu.create({
        doc: t,
        selection: n || void 0
      })
    });
    const i = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(i), this.createNodeViews(), this.prependClass();
    const s = this.view.dom;
    s.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(e) {
    this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1;
    const t = this.capturedTransaction;
    return this.capturedTransaction = null, t;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((a) => {
        var o;
        return (o = this.capturedTransaction) === null || o === void 0 ? void 0 : o.step(a);
      });
      return;
    }
    const t = this.state.apply(e), n = !this.state.selection.eq(t.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction: e,
      nextState: t
    }), this.view.updateState(t), this.emit("transaction", {
      editor: this,
      transaction: e
    }), n && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const i = e.getMeta("focus"), s = e.getMeta("blur");
    i && this.emit("focus", {
      editor: this,
      event: i.event,
      transaction: e
    }), s && this.emit("blur", {
      editor: this,
      event: s.event,
      transaction: e
    }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
      editor: this,
      transaction: e
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return rM(this.state, e);
  }
  isActive(e, t) {
    const n = typeof e == "string" ? e : null, i = typeof e == "string" ? t : e;
    return nM(this.state, n, i);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return ob(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const { blockSeparator: t = `

`, textSerializers: n = {} } = e || {};
    return eM(this.state.doc, {
      blockSeparator: t,
      textSerializers: {
        ...f3(this.schema),
        ...n
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return fb(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    if (this.emit("destroy"), this.view) {
      const e = this.view.dom;
      e && e.editor && delete e.editor, this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e;
    return !(!((e = this.view) === null || e === void 0) && e.docView);
  }
  $node(e, t) {
    var n;
    return ((n = this.$doc) === null || n === void 0 ? void 0 : n.querySelector(e, t)) || null;
  }
  $nodes(e, t) {
    var n;
    return ((n = this.$doc) === null || n === void 0 ? void 0 : n.querySelectorAll(e, t)) || null;
  }
  $pos(e) {
    const t = this.state.doc.resolve(e);
    return new QA(t, this);
  }
  get $doc() {
    return this.$pos(0);
  }
}
function Lu(r) {
  return new dg({
    find: r.find,
    handler: ({ state: e, range: t, match: n }) => {
      const i = nr(r.getAttributes, void 0, n);
      if (i === !1 || i === null)
        return null;
      const { tr: s } = e, a = n[n.length - 1], o = n[0];
      if (a) {
        const A = o.search(/\S/), l = t.from + o.indexOf(a), u = l + a.length;
        if (b3(t.from, t.to, e.doc).filter((f) => f.mark.type.excluded.find((p) => p === r.type && p !== f.mark.type)).filter((f) => f.to > l).length)
          return null;
        u < t.to && s.delete(u, t.to), l > t.from && s.delete(t.from + A, l);
        const h = t.from + A + a.length;
        s.addMark(t.from + A, h, r.type.create(i || {})), s.removeStoredMark(r.type);
      }
    }
  });
}
function OM(r) {
  return new dg({
    find: r.find,
    handler: ({ state: e, range: t, match: n }) => {
      const i = nr(r.getAttributes, void 0, n) || {}, { tr: s } = e, a = t.from;
      let o = t.to;
      const A = r.type.create(i);
      if (n[1]) {
        const l = n[0].lastIndexOf(n[1]);
        let u = a + l;
        u > o ? u = o : o = u + n[1].length;
        const c = n[0][n[0].length - 1];
        s.insertText(c, a + n[0].length - 1), s.replaceWith(u, o, A);
      } else if (n[0]) {
        const l = r.type.isInline ? a : a - 1;
        s.insert(l, r.type.create(i)).delete(s.mapping.map(a), s.mapping.map(o));
      }
      s.scrollIntoView();
    }
  });
}
function fv(r) {
  return new dg({
    find: r.find,
    handler: ({ state: e, range: t, match: n }) => {
      const i = e.doc.resolve(t.from), s = nr(r.getAttributes, void 0, n) || {};
      if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), r.type))
        return null;
      e.tr.delete(t.from, t.to).setBlockType(t.from, t.from, r.type, s);
    }
  });
}
function _f(r) {
  return new dg({
    find: r.find,
    handler: ({ state: e, range: t, match: n, chain: i }) => {
      const s = nr(r.getAttributes, void 0, n) || {}, a = e.tr.delete(t.from, t.to), A = a.doc.resolve(t.from).blockRange(), l = A && q2(A, r.type, s);
      if (!l)
        return null;
      if (a.wrap(A, l), r.keepMarks && r.editor) {
        const { selection: c, storedMarks: h } = e, { splittableMarks: f } = r.editor.extensionManager, d = h || c.$to.parentOffset && c.$from.marks();
        if (d) {
          const p = d.filter((v) => f.includes(v.type.name));
          a.ensureMarks(p);
        }
      }
      if (r.keepAttributes) {
        const c = r.type.name === "bulletList" || r.type.name === "orderedList" ? "listItem" : "taskList";
        i().updateAttributes(c, s).run();
      }
      const u = a.doc.resolve(t.from - 1).nodeBefore;
      u && u.type === r.type && uA(a.doc, t.from - 1) && (!r.joinPredicate || r.joinPredicate(n, u)) && a.join(t.from - 1);
    }
  });
}
let oa = class hv {
  constructor(e = {}) {
    this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = nr(vt(this, "addOptions", {
      name: this.name
    }))), this.storage = nr(vt(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new hv(e);
  }
  configure(e = {}) {
    const t = this.extend({
      ...this.config,
      addOptions: () => pg(this.options, e)
    });
    return t.name = this.name, t.parent = this.parent, t;
  }
  extend(e = {}) {
    const t = new hv(e);
    return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = nr(vt(t, "addOptions", {
      name: t.name
    })), t.storage = nr(vt(t, "addStorage", {
      name: t.name,
      options: t.options
    })), t;
  }
};
function Uu(r) {
  return new t8({
    find: r.find,
    handler: ({ state: e, range: t, match: n, pasteEvent: i }) => {
      const s = nr(r.getAttributes, void 0, n, i);
      if (s === !1 || s === null)
        return null;
      const { tr: a } = e, o = n[n.length - 1], A = n[0];
      let l = t.to;
      if (o) {
        const u = A.search(/\S/), c = t.from + A.indexOf(o), h = c + o.length;
        if (b3(t.from, t.to, e.doc).filter((d) => d.mark.type.excluded.find((v) => v === r.type && v !== d.mark.type)).filter((d) => d.to > c).length)
          return null;
        h < t.to && a.delete(h, t.to), c > t.from && a.delete(t.from + u, c), l = t.from + u + o.length, a.addMark(t.from + u, l, r.type.create(s || {})), a.removeStoredMark(r.type);
      }
    }
  });
}
const QM = /^\s*>\s$/, DM = oa.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes: r }) {
    return ["blockquote", li(this.options.HTMLAttributes, r), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: r }) => r.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: r }) => r.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: r }) => r.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      _f({
        find: QM,
        type: this.type
      })
    ];
  }
}), MM = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, RM = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, PM = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, HM = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, jM = xa.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (r) => r.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (r) => r.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (r) => /^(bold(er)?|[5-9]\d{2,})$/.test(r) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: r }) {
    return ["strong", li(this.options.HTMLAttributes, r), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: r }) => r.setMark(this.name),
      toggleBold: () => ({ commands: r }) => r.toggleMark(this.name),
      unsetBold: () => ({ commands: r }) => r.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      Lu({
        find: MM,
        type: this.type
      }),
      Lu({
        find: PM,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Uu({
        find: RM,
        type: this.type
      }),
      Uu({
        find: HM,
        type: this.type
      })
    ];
  }
}), KM = "listItem", TB = "textStyle", xB = /^\s*([-+*])\s$/, $M = oa.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes: r }) {
    return ["ul", li(this.options.HTMLAttributes, r), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: r, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(KM, this.editor.getAttributes(TB)).run() : r.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let r = _f({
      find: xB,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (r = _f({
      find: xB,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(TB),
      editor: this.editor
    })), [
      r
    ];
  }
}), VM = /(^|[^`])`([^`]+)`(?!`)/, zM = /(^|[^`])`([^`]+)`(?!`)/g, GM = xa.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes: r }) {
    return ["code", li(this.options.HTMLAttributes, r), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: r }) => r.setMark(this.name),
      toggleCode: () => ({ commands: r }) => r.toggleMark(this.name),
      unsetCode: () => ({ commands: r }) => r.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      Lu({
        find: VM,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Uu({
        find: zM,
        type: this.type
      })
    ];
  }
}), qM = /^```([a-z]+)?[\s\n]$/, WM = /^~~~([a-z]+)?[\s\n]$/, XM = oa.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: !0,
  defining: !0,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (r) => {
          var e;
          const { languageClassPrefix: t } = this.options, s = [...((e = r.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter((a) => a.startsWith(t)).map((a) => a.replace(t, ""))[0];
          return s || null;
        },
        rendered: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: r, HTMLAttributes: e }) {
    return [
      "pre",
      li(this.options.HTMLAttributes, e),
      [
        "code",
        {
          class: r.attrs.language ? this.options.languageClassPrefix + r.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (r) => ({ commands: e }) => e.setNode(this.name, r),
      toggleCodeBlock: (r) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", r)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: r, $anchor: e } = this.editor.state.selection, t = e.pos === 1;
        return !r || e.parent.type.name !== this.name ? !1 : t || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1;
      },
      // exit node on triple enter
      Enter: ({ editor: r }) => {
        if (!this.options.exitOnTripleEnter)
          return !1;
        const { state: e } = r, { selection: t } = e, { $from: n, empty: i } = t;
        if (!i || n.parent.type !== this.type)
          return !1;
        const s = n.parentOffset === n.parent.nodeSize - 2, a = n.parent.textContent.endsWith(`

`);
        return !s || !a ? !1 : r.chain().command(({ tr: o }) => (o.delete(n.pos - 2, n.pos), !0)).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor: r }) => {
        if (!this.options.exitOnArrowDown)
          return !1;
        const { state: e } = r, { selection: t, doc: n } = e, { $from: i, empty: s } = t;
        if (!s || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2))
          return !1;
        const o = i.after();
        return o === void 0 ? !1 : n.nodeAt(o) ? r.commands.command(({ tr: l }) => (l.setSelection(Yt.near(n.resolve(o))), !0)) : r.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      fv({
        find: qM,
        type: this.type,
        getAttributes: (r) => ({
          language: r[1]
        })
      }),
      fv({
        find: WM,
        type: this.type,
        getAttributes: (r) => ({
          language: r[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new es({
        key: new Na("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (r, e) => {
            if (!e.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const t = e.clipboardData.getData("text/plain"), n = e.clipboardData.getData("vscode-editor-data"), i = n ? JSON.parse(n) : void 0, s = i == null ? void 0 : i.mode;
            if (!t || !s)
              return !1;
            const { tr: a, schema: o } = r.state, A = o.text(t.replace(/\r\n?/g, `
`));
            return a.replaceSelectionWith(this.type.create({ language: s }, A)), a.selection.$from.parent.type !== this.type && a.setSelection(zt.near(a.doc.resolve(Math.max(0, a.selection.from - 2)))), a.setMeta("paste", !0), r.dispatch(a), !0;
          }
        }
      })
    ];
  }
}), JM = oa.create({
  name: "doc",
  topNode: !0,
  content: "block+"
});
function YM(r = {}) {
  return new es({
    view(e) {
      return new ZM(e, r);
    }
  });
}
class ZM {
  constructor(e, t) {
    var n;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (n = t.width) !== null && n !== void 0 ? n : 1, this.color = t.color === !1 ? void 0 : t.color || "black", this.class = t.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((i) => {
      let s = (a) => {
        this[i](a);
      };
      return e.dom.addEventListener(i, s), { name: i, handler: s };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: t }) => this.editorView.dom.removeEventListener(e, t));
  }
  update(e, t) {
    this.cursorPos != null && t.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), t = !e.parent.inlineContent, n;
    if (t) {
      let o = e.nodeBefore, A = e.nodeAfter;
      if (o || A) {
        let l = this.editorView.nodeDOM(this.cursorPos - (o ? o.nodeSize : 0));
        if (l) {
          let u = l.getBoundingClientRect(), c = o ? u.bottom : u.top;
          o && A && (c = (c + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), n = { left: u.left, right: u.right, top: c - this.width / 2, bottom: c + this.width / 2 };
        }
      }
    }
    if (!n) {
      let o = this.editorView.coordsAtPos(this.cursorPos);
      n = { left: o.left - this.width / 2, right: o.left + this.width / 2, top: o.top, bottom: o.bottom };
    }
    let i = this.editorView.dom.offsetParent;
    this.element || (this.element = i.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", t), this.element.classList.toggle("prosemirror-dropcursor-inline", !t);
    let s, a;
    if (!i || i == document.body && getComputedStyle(i).position == "static")
      s = -pageXOffset, a = -pageYOffset;
    else {
      let o = i.getBoundingClientRect();
      s = o.left - i.scrollLeft, a = o.top - i.scrollTop;
    }
    this.element.style.left = n.left - s + "px", this.element.style.top = n.top - a + "px", this.element.style.width = n.right - n.left + "px", this.element.style.height = n.bottom - n.top + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let t = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), n = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside), i = n && n.type.spec.disableDropCursor, s = typeof i == "function" ? i(this.editorView, t, e) : i;
    if (t && !s) {
      let a = t.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let o = gS(this.editorView.state.doc, a, this.editorView.dragging.slice);
        o != null && (a = o);
      }
      this.setCursor(a), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null);
  }
}
const eR = Mi.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      YM(this.options)
    ];
  }
});
class nn extends Yt {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, t) {
    let n = e.resolve(t.map(this.head));
    return nn.valid(n) ? new nn(n) : Yt.near(n);
  }
  content() {
    return lt.empty;
  }
  eq(e) {
    return e instanceof nn && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new nn(e.resolve(t.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new hb(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let t = e.parent;
    if (t.isTextblock || !tR(e) || !rR(e))
      return !1;
    let n = t.type.spec.allowGapCursor;
    if (n != null)
      return n;
    let i = t.contentMatchAt(e.index()).defaultType;
    return i && i.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, t, n = !1) {
    e: for (; ; ) {
      if (!n && nn.valid(e))
        return e;
      let i = e.pos, s = null;
      for (let a = e.depth; ; a--) {
        let o = e.node(a);
        if (t > 0 ? e.indexAfter(a) < o.childCount : e.index(a) > 0) {
          s = o.child(t > 0 ? e.indexAfter(a) : e.index(a) - 1);
          break;
        } else if (a == 0)
          return null;
        i += t;
        let A = e.doc.resolve(i);
        if (nn.valid(A))
          return A;
      }
      for (; ; ) {
        let a = t > 0 ? s.firstChild : s.lastChild;
        if (!a) {
          if (s.isAtom && !s.isText && !Tt.isSelectable(s)) {
            e = e.doc.resolve(i + s.nodeSize * t), n = !1;
            continue e;
          }
          break;
        }
        s = a, i += t;
        let o = e.doc.resolve(i);
        if (nn.valid(o))
          return o;
      }
      return null;
    }
  }
}
nn.prototype.visible = !1;
nn.findFrom = nn.findGapCursorFrom;
Yt.jsonID("gapcursor", nn);
class hb {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new hb(e.map(this.pos));
  }
  resolve(e) {
    let t = e.resolve(this.pos);
    return nn.valid(t) ? new nn(t) : Yt.near(t);
  }
}
function tR(r) {
  for (let e = r.depth; e >= 0; e--) {
    let t = r.index(e), n = r.node(e);
    if (t == 0) {
      if (n.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = n.child(t - 1); ; i = i.lastChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function rR(r) {
  for (let e = r.depth; e >= 0; e--) {
    let t = r.indexAfter(e), n = r.node(e);
    if (t == n.childCount) {
      if (n.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = n.child(t); ; i = i.firstChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function nR() {
  return new es({
    props: {
      decorations: oR,
      createSelectionBetween(r, e, t) {
        return e.pos == t.pos && nn.valid(t) ? new nn(t) : null;
      },
      handleClick: sR,
      handleKeyDown: iR,
      handleDOMEvents: { beforeinput: aR }
    }
  });
}
const iR = r3({
  ArrowLeft: rd("horiz", -1),
  ArrowRight: rd("horiz", 1),
  ArrowUp: rd("vert", -1),
  ArrowDown: rd("vert", 1)
});
function rd(r, e) {
  const t = r == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(n, i, s) {
    let a = n.selection, o = e > 0 ? a.$to : a.$from, A = a.empty;
    if (a instanceof zt) {
      if (!s.endOfTextblock(t) || o.depth == 0)
        return !1;
      A = !1, o = n.doc.resolve(e > 0 ? o.after() : o.before());
    }
    let l = nn.findGapCursorFrom(o, e, A);
    return l ? (i && i(n.tr.setSelection(new nn(l))), !0) : !1;
  };
}
function sR(r, e, t) {
  if (!r || !r.editable)
    return !1;
  let n = r.state.doc.resolve(e);
  if (!nn.valid(n))
    return !1;
  let i = r.posAtCoords({ left: t.clientX, top: t.clientY });
  return i && i.inside > -1 && Tt.isSelectable(r.state.doc.nodeAt(i.inside)) ? !1 : (r.dispatch(r.state.tr.setSelection(new nn(n))), !0);
}
function aR(r, e) {
  if (e.inputType != "insertCompositionText" || !(r.state.selection instanceof nn))
    return !1;
  let { $from: t } = r.state.selection, n = t.parent.contentMatchAt(t.index()).findWrapping(r.state.schema.nodes.text);
  if (!n)
    return !1;
  let i = Ye.empty;
  for (let a = n.length - 1; a >= 0; a--)
    i = Ye.from(n[a].createAndFill(null, i));
  let s = r.state.tr.replace(t.pos, t.pos, new lt(i, 0, 0));
  return s.setSelection(zt.near(s.doc.resolve(t.pos + 1))), r.dispatch(s), !1;
}
function oR(r) {
  if (!(r.selection instanceof nn))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", Mn.create(r.doc, [xs.widget(r.selection.head, e, { key: "gapcursor" })]);
}
const AR = Mi.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      nR()
    ];
  },
  extendNodeSchema(r) {
    var e;
    const t = {
      name: r.name,
      options: r.options,
      storage: r.storage
    };
    return {
      allowGapCursor: (e = nr(vt(r, "allowGapCursor", t))) !== null && e !== void 0 ? e : null
    };
  }
}), lR = oa.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  linebreakReplacement: !0,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes: r }) {
    return ["br", li(this.options.HTMLAttributes, r)];
  },
  renderText() {
    return `
`;
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: r, chain: e, state: t, editor: n }) => r.first([
        () => r.exitCode(),
        () => r.command(() => {
          const { selection: i, storedMarks: s } = t;
          if (i.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: a } = this.options, { splittableMarks: o } = n.extensionManager, A = s || i.$to.parentOffset && i.$from.marks();
          return e().insertContent({ type: this.name }).command(({ tr: l, dispatch: u }) => {
            if (u && A && a) {
              const c = A.filter((h) => o.includes(h.type.name));
              l.ensureMarks(c);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), uR = oa.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((r) => ({
      tag: `h${r}`,
      attrs: { level: r }
    }));
  },
  renderHTML({ node: r, HTMLAttributes: e }) {
    return [`h${this.options.levels.includes(r.attrs.level) ? r.attrs.level : this.options.levels[0]}`, li(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setHeading: (r) => ({ commands: e }) => this.options.levels.includes(r.level) ? e.setNode(this.name, r) : !1,
      toggleHeading: (r) => ({ commands: e }) => this.options.levels.includes(r.level) ? e.toggleNode(this.name, "paragraph", r) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((r, e) => ({
      ...r,
      [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((r) => fv({
      find: new RegExp(`^(#{${Math.min(...this.options.levels)},${r}})\\s$`),
      type: this.type,
      getAttributes: {
        level: r
      }
    }));
  }
});
var Lp = 200, Wn = function() {
};
Wn.prototype.append = function(e) {
  return e.length ? (e = Wn.from(e), !this.length && e || e.length < Lp && this.leafAppend(e) || this.length < Lp && e.leafPrepend(this) || this.appendInner(e)) : this;
};
Wn.prototype.prepend = function(e) {
  return e.length ? Wn.from(e).append(this) : this;
};
Wn.prototype.appendInner = function(e) {
  return new cR(this, e);
};
Wn.prototype.slice = function(e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = this.length), e >= t ? Wn.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t));
};
Wn.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
Wn.prototype.forEach = function(e, t, n) {
  t === void 0 && (t = 0), n === void 0 && (n = this.length), t <= n ? this.forEachInner(e, t, n, 0) : this.forEachInvertedInner(e, t, n, 0);
};
Wn.prototype.map = function(e, t, n) {
  t === void 0 && (t = 0), n === void 0 && (n = this.length);
  var i = [];
  return this.forEach(function(s, a) {
    return i.push(e(s, a));
  }, t, n), i;
};
Wn.from = function(e) {
  return e instanceof Wn ? e : e && e.length ? new y3(e) : Wn.empty;
};
var y3 = /* @__PURE__ */ function(r) {
  function e(n) {
    r.call(this), this.values = n;
  }
  r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e;
  var t = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(i, s) {
    return i == 0 && s == this.length ? this : new e(this.values.slice(i, s));
  }, e.prototype.getInner = function(i) {
    return this.values[i];
  }, e.prototype.forEachInner = function(i, s, a, o) {
    for (var A = s; A < a; A++)
      if (i(this.values[A], o + A) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(i, s, a, o) {
    for (var A = s - 1; A >= a; A--)
      if (i(this.values[A], o + A) === !1)
        return !1;
  }, e.prototype.leafAppend = function(i) {
    if (this.length + i.length <= Lp)
      return new e(this.values.concat(i.flatten()));
  }, e.prototype.leafPrepend = function(i) {
    if (this.length + i.length <= Lp)
      return new e(i.flatten().concat(this.values));
  }, t.length.get = function() {
    return this.values.length;
  }, t.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, t), e;
}(Wn);
Wn.empty = new y3([]);
var cR = /* @__PURE__ */ function(r) {
  function e(t, n) {
    r.call(this), this.left = t, this.right = n, this.length = t.length + n.length, this.depth = Math.max(t.depth, n.depth) + 1;
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(n) {
    return n < this.left.length ? this.left.get(n) : this.right.get(n - this.left.length);
  }, e.prototype.forEachInner = function(n, i, s, a) {
    var o = this.left.length;
    if (i < o && this.left.forEachInner(n, i, Math.min(s, o), a) === !1 || s > o && this.right.forEachInner(n, Math.max(i - o, 0), Math.min(this.length, s) - o, a + o) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(n, i, s, a) {
    var o = this.left.length;
    if (i > o && this.right.forEachInvertedInner(n, i - o, Math.max(s, o) - o, a + o) === !1 || s < o && this.left.forEachInvertedInner(n, Math.min(i, o), s, a) === !1)
      return !1;
  }, e.prototype.sliceInner = function(n, i) {
    if (n == 0 && i == this.length)
      return this;
    var s = this.left.length;
    return i <= s ? this.left.slice(n, i) : n >= s ? this.right.slice(n - s, i - s) : this.left.slice(n, s).append(this.right.slice(0, i - s));
  }, e.prototype.leafAppend = function(n) {
    var i = this.right.leafAppend(n);
    if (i)
      return new e(this.left, i);
  }, e.prototype.leafPrepend = function(n) {
    var i = this.left.leafPrepend(n);
    if (i)
      return new e(i, this.right);
  }, e.prototype.appendInner = function(n) {
    return this.left.depth >= Math.max(this.right.depth, n.depth) + 1 ? new e(this.left, new e(this.right, n)) : new e(this, n);
  }, e;
}(Wn);
const fR = 500;
class na {
  constructor(e, t) {
    this.items = e, this.eventCount = t;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, t) {
    if (this.eventCount == 0)
      return null;
    let n = this.items.length;
    for (; ; n--)
      if (this.items.get(n - 1).selection) {
        --n;
        break;
      }
    let i, s;
    t && (i = this.remapping(n, this.items.length), s = i.maps.length);
    let a = e.tr, o, A, l = [], u = [];
    return this.items.forEach((c, h) => {
      if (!c.step) {
        i || (i = this.remapping(n, h + 1), s = i.maps.length), s--, u.push(c);
        return;
      }
      if (i) {
        u.push(new Ba(c.map));
        let f = c.step.map(i.slice(s)), d;
        f && a.maybeStep(f).doc && (d = a.mapping.maps[a.mapping.maps.length - 1], l.push(new Ba(d, void 0, void 0, l.length + u.length))), s--, d && i.appendMap(d, s);
      } else
        a.maybeStep(c.step);
      if (c.selection)
        return o = i ? c.selection.map(i.slice(s)) : c.selection, A = new na(this.items.slice(0, n).append(u.reverse().concat(l)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: A, transform: a, selection: o };
  }
  // Create a new branch with the given transform added.
  addTransform(e, t, n, i) {
    let s = [], a = this.eventCount, o = this.items, A = !i && o.length ? o.get(o.length - 1) : null;
    for (let u = 0; u < e.steps.length; u++) {
      let c = e.steps[u].invert(e.docs[u]), h = new Ba(e.mapping.maps[u], c, t), f;
      (f = A && A.merge(h)) && (h = f, u ? s.pop() : o = o.slice(0, o.length - 1)), s.push(h), t && (a++, t = void 0), i || (A = h);
    }
    let l = a - n.depth;
    return l > dR && (o = hR(o, l), a -= l), new na(o.append(s), a);
  }
  remapping(e, t) {
    let n = new yu();
    return this.items.forEach((i, s) => {
      let a = i.mirrorOffset != null && s - i.mirrorOffset >= e ? n.maps.length - i.mirrorOffset : void 0;
      n.appendMap(i.map, a);
    }, e, t), n;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new na(this.items.append(e.map((t) => new Ba(t))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, t) {
    if (!this.eventCount)
      return this;
    let n = [], i = Math.max(0, this.items.length - t), s = e.mapping, a = e.steps.length, o = this.eventCount;
    this.items.forEach((h) => {
      h.selection && o--;
    }, i);
    let A = t;
    this.items.forEach((h) => {
      let f = s.getMirror(--A);
      if (f == null)
        return;
      a = Math.min(a, f);
      let d = s.maps[f];
      if (h.step) {
        let p = e.steps[f].invert(e.docs[f]), v = h.selection && h.selection.map(s.slice(A + 1, f));
        v && o++, n.push(new Ba(d, p, v));
      } else
        n.push(new Ba(d));
    }, i);
    let l = [];
    for (let h = t; h < a; h++)
      l.push(new Ba(s.maps[h]));
    let u = this.items.slice(0, i).append(l).append(n), c = new na(u, o);
    return c.emptyItemCount() > fR && (c = c.compress(this.items.length - n.length)), c;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((t) => {
      t.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let t = this.remapping(0, e), n = t.maps.length, i = [], s = 0;
    return this.items.forEach((a, o) => {
      if (o >= e)
        i.push(a), a.selection && s++;
      else if (a.step) {
        let A = a.step.map(t.slice(n)), l = A && A.getMap();
        if (n--, l && t.appendMap(l, n), A) {
          let u = a.selection && a.selection.map(t.slice(n));
          u && s++;
          let c = new Ba(l.invert(), A, u), h, f = i.length - 1;
          (h = i.length && i[f].merge(c)) ? i[f] = h : i.push(c);
        }
      } else a.map && n--;
    }, this.items.length, 0), new na(Wn.from(i.reverse()), s);
  }
}
na.empty = new na(Wn.empty, 0);
function hR(r, e) {
  let t;
  return r.forEach((n, i) => {
    if (n.selection && e-- == 0)
      return t = i, !1;
  }), r.slice(t);
}
class Ba {
  constructor(e, t, n, i) {
    this.map = e, this.step = t, this.selection = n, this.mirrorOffset = i;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let t = e.step.merge(this.step);
      if (t)
        return new Ba(t.getMap().invert(), t, this.selection);
    }
  }
}
class Qo {
  constructor(e, t, n, i, s) {
    this.done = e, this.undone = t, this.prevRanges = n, this.prevTime = i, this.prevComposition = s;
  }
}
const dR = 20;
function pR(r, e, t, n) {
  let i = t.getMeta(YA), s;
  if (i)
    return i.historyState;
  t.getMeta(vR) && (r = new Qo(r.done, r.undone, null, 0, -1));
  let a = t.getMeta("appendedTransaction");
  if (t.steps.length == 0)
    return r;
  if (a && a.getMeta(YA))
    return a.getMeta(YA).redo ? new Qo(r.done.addTransform(t, void 0, n, ip(e)), r.undone, kB(t.mapping.maps), r.prevTime, r.prevComposition) : new Qo(r.done, r.undone.addTransform(t, void 0, n, ip(e)), null, r.prevTime, r.prevComposition);
  if (t.getMeta("addToHistory") !== !1 && !(a && a.getMeta("addToHistory") === !1)) {
    let o = t.getMeta("composition"), A = r.prevTime == 0 || !a && r.prevComposition != o && (r.prevTime < (t.time || 0) - n.newGroupDelay || !gR(t, r.prevRanges)), l = a ? i0(r.prevRanges, t.mapping) : kB(t.mapping.maps);
    return new Qo(r.done.addTransform(t, A ? e.selection.getBookmark() : void 0, n, ip(e)), na.empty, l, t.time, o ?? r.prevComposition);
  } else return (s = t.getMeta("rebased")) ? new Qo(r.done.rebased(t, s), r.undone.rebased(t, s), i0(r.prevRanges, t.mapping), r.prevTime, r.prevComposition) : new Qo(r.done.addMaps(t.mapping.maps), r.undone.addMaps(t.mapping.maps), i0(r.prevRanges, t.mapping), r.prevTime, r.prevComposition);
}
function gR(r, e) {
  if (!e)
    return !1;
  if (!r.docChanged)
    return !0;
  let t = !1;
  return r.mapping.maps[0].forEach((n, i) => {
    for (let s = 0; s < e.length; s += 2)
      n <= e[s + 1] && i >= e[s] && (t = !0);
  }), t;
}
function kB(r) {
  let e = [];
  for (let t = r.length - 1; t >= 0 && e.length == 0; t--)
    r[t].forEach((n, i, s, a) => e.push(s, a));
  return e;
}
function i0(r, e) {
  if (!r)
    return null;
  let t = [];
  for (let n = 0; n < r.length; n += 2) {
    let i = e.map(r[n], 1), s = e.map(r[n + 1], -1);
    i <= s && t.push(i, s);
  }
  return t;
}
function mR(r, e, t) {
  let n = ip(e), i = YA.get(e).spec.config, s = (t ? r.undone : r.done).popEvent(e, n);
  if (!s)
    return null;
  let a = s.selection.resolve(s.transform.doc), o = (t ? r.done : r.undone).addTransform(s.transform, e.selection.getBookmark(), i, n), A = new Qo(t ? o : s.remaining, t ? s.remaining : o, null, 0, -1);
  return s.transform.setSelection(a).setMeta(YA, { redo: t, historyState: A });
}
let s0 = !1, LB = null;
function ip(r) {
  let e = r.plugins;
  if (LB != e) {
    s0 = !1, LB = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].spec.historyPreserveItems) {
        s0 = !0;
        break;
      }
  }
  return s0;
}
const YA = new Na("history"), vR = new Na("closeHistory");
function bR(r = {}) {
  return r = {
    depth: r.depth || 100,
    newGroupDelay: r.newGroupDelay || 500
  }, new es({
    key: YA,
    state: {
      init() {
        return new Qo(na.empty, na.empty, null, 0, -1);
      },
      apply(e, t, n) {
        return pR(t, n, e, r);
      }
    },
    config: r,
    props: {
      handleDOMEvents: {
        beforeinput(e, t) {
          let n = t.inputType, i = n == "historyUndo" ? B3 : n == "historyRedo" ? C3 : null;
          return i ? (t.preventDefault(), i(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
function w3(r, e) {
  return (t, n) => {
    let i = YA.getState(t);
    if (!i || (r ? i.undone : i.done).eventCount == 0)
      return !1;
    if (n) {
      let s = mR(i, t, r);
      s && n(e ? s.scrollIntoView() : s);
    }
    return !0;
  };
}
const B3 = w3(!1, !0), C3 = w3(!0, !0), yR = Mi.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: r, dispatch: e }) => B3(r, e),
      redo: () => ({ state: r, dispatch: e }) => C3(r, e)
    };
  },
  addProseMirrorPlugins() {
    return [
      bR(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-я": () => this.editor.commands.undo(),
      "Shift-Mod-я": () => this.editor.commands.redo()
    };
  }
}), wR = oa.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: r }) {
    return ["hr", li(this.options.HTMLAttributes, r)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: r, state: e }) => {
        const { selection: t } = e, { $from: n, $to: i } = t, s = r();
        return n.parentOffset === 0 ? s.insertContentAt({
          from: Math.max(n.pos - 1, 0),
          to: i.pos
        }, {
          type: this.name
        }) : iM(t) ? s.insertContentAt(i.pos, {
          type: this.name
        }) : s.insertContent({ type: this.name }), s.command(({ tr: a, dispatch: o }) => {
          var A;
          if (o) {
            const { $to: l } = a.selection, u = l.end();
            if (l.nodeAfter)
              l.nodeAfter.isTextblock ? a.setSelection(zt.create(a.doc, l.pos + 1)) : l.nodeAfter.isBlock ? a.setSelection(Tt.create(a.doc, l.pos)) : a.setSelection(zt.create(a.doc, l.pos));
            else {
              const c = (A = l.parent.type.contentMatch.defaultType) === null || A === void 0 ? void 0 : A.create();
              c && (a.insert(u, c), a.setSelection(zt.create(a.doc, u + 1)));
            }
            a.scrollIntoView();
          }
          return !0;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      OM({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), BR = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, CR = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, _R = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, ER = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, SR = xa.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (r) => r.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (r) => r.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: r }) {
    return ["em", li(this.options.HTMLAttributes, r), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: r }) => r.setMark(this.name),
      toggleItalic: () => ({ commands: r }) => r.toggleMark(this.name),
      unsetItalic: () => ({ commands: r }) => r.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      Lu({
        find: BR,
        type: this.type
      }),
      Lu({
        find: _R,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Uu({
        find: CR,
        type: this.type
      }),
      Uu({
        find: ER,
        type: this.type
      })
    ];
  }
}), _3 = oa.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: r }) {
    return ["li", li(this.options.HTMLAttributes, r), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), IR = "listItem", UB = "textStyle", NB = /^(\d+)\.\s$/, FR = oa.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (r) => r.hasAttribute("start") ? parseInt(r.getAttribute("start") || "", 10) : 1
      },
      type: {
        default: void 0,
        parseHTML: (r) => r.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: r }) {
    const { start: e, ...t } = r;
    return e === 1 ? ["ol", li(this.options.HTMLAttributes, t), 0] : ["ol", li(this.options.HTMLAttributes, r), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: r, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(IR, this.editor.getAttributes(UB)).run() : r.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let r = _f({
      find: NB,
      type: this.type,
      getAttributes: (e) => ({ start: +e[1] }),
      joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (r = _f({
      find: NB,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(UB) }),
      joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1],
      editor: this.editor
    })), [
      r
    ];
  }
}), TR = oa.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes: r }) {
    return ["p", li(this.options.HTMLAttributes, r), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: r }) => r.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), xR = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, kR = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, LR = xa.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (r) => r.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: r }) {
    return ["s", li(this.options.HTMLAttributes, r), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: r }) => r.setMark(this.name),
      toggleStrike: () => ({ commands: r }) => r.toggleMark(this.name),
      unsetStrike: () => ({ commands: r }) => r.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      Lu({
        find: xR,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Uu({
        find: kR,
        type: this.type
      })
    ];
  }
}), UR = oa.create({
  name: "text",
  group: "inline"
}), NR = Mi.create({
  name: "starterKit",
  addExtensions() {
    var r, e, t, n, i, s, a, o, A, l, u, c, h, f, d, p, v, m;
    const b = [];
    return this.options.bold !== !1 && b.push(jM.configure((r = this.options) === null || r === void 0 ? void 0 : r.bold)), this.options.blockquote !== !1 && b.push(DM.configure((e = this.options) === null || e === void 0 ? void 0 : e.blockquote)), this.options.bulletList !== !1 && b.push($M.configure((t = this.options) === null || t === void 0 ? void 0 : t.bulletList)), this.options.code !== !1 && b.push(GM.configure((n = this.options) === null || n === void 0 ? void 0 : n.code)), this.options.codeBlock !== !1 && b.push(XM.configure((i = this.options) === null || i === void 0 ? void 0 : i.codeBlock)), this.options.document !== !1 && b.push(JM.configure((s = this.options) === null || s === void 0 ? void 0 : s.document)), this.options.dropcursor !== !1 && b.push(eR.configure((a = this.options) === null || a === void 0 ? void 0 : a.dropcursor)), this.options.gapcursor !== !1 && b.push(AR.configure((o = this.options) === null || o === void 0 ? void 0 : o.gapcursor)), this.options.hardBreak !== !1 && b.push(lR.configure((A = this.options) === null || A === void 0 ? void 0 : A.hardBreak)), this.options.heading !== !1 && b.push(uR.configure((l = this.options) === null || l === void 0 ? void 0 : l.heading)), this.options.history !== !1 && b.push(yR.configure((u = this.options) === null || u === void 0 ? void 0 : u.history)), this.options.horizontalRule !== !1 && b.push(wR.configure((c = this.options) === null || c === void 0 ? void 0 : c.horizontalRule)), this.options.italic !== !1 && b.push(SR.configure((h = this.options) === null || h === void 0 ? void 0 : h.italic)), this.options.listItem !== !1 && b.push(_3.configure((f = this.options) === null || f === void 0 ? void 0 : f.listItem)), this.options.orderedList !== !1 && b.push(FR.configure((d = this.options) === null || d === void 0 ? void 0 : d.orderedList)), this.options.paragraph !== !1 && b.push(TR.configure((p = this.options) === null || p === void 0 ? void 0 : p.paragraph)), this.options.strike !== !1 && b.push(LR.configure((v = this.options) === null || v === void 0 ? void 0 : v.strike)), this.options.text !== !1 && b.push(UR.configure((m = this.options) === null || m === void 0 ? void 0 : m.text)), b;
  }
}), OR = (r) => {
  if (!r.children.length)
    return;
  const e = r.querySelectorAll("span");
  e && e.forEach((t) => {
    var n, i;
    const s = t.getAttribute("style"), a = (i = (n = t.parentElement) === null || n === void 0 ? void 0 : n.closest("span")) === null || i === void 0 ? void 0 : i.getAttribute("style");
    t.setAttribute("style", `${a};${s}`);
  });
}, QR = xa.create({
  name: "textStyle",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {},
      mergeNestedSpanStyles: !1
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (r) => r.hasAttribute("style") ? (this.options.mergeNestedSpanStyles && OR(r), {}) : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: r }) {
    return ["span", li(this.options.HTMLAttributes, r), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ tr: r }) => {
        const { selection: e } = r;
        return r.doc.nodesBetween(e.from, e.to, (t, n) => {
          if (t.isTextblock)
            return !0;
          t.marks.filter((i) => i.type === this.type).some((i) => Object.values(i.attrs).some((s) => !!s)) || r.removeMark(n, n + t.nodeSize, this.type);
        }), !0;
      }
    };
  }
}), DR = xa.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (r) => r.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: r }) {
    return ["u", li(this.options.HTMLAttributes, r), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: r }) => r.setMark(this.name),
      toggleUnderline: () => ({ commands: r }) => r.toggleMark(this.name),
      unsetUnderline: () => ({ commands: r }) => r.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});
async function MR(r) {
  return new Promise((e, t) => {
    const n = new FileReader();
    n.onload = () => {
      typeof n.result == "string" ? e(n.result) : t(new Error("Failed to convert image to Base64"));
    }, n.onerror = () => t(new Error("Error reading file")), n.readAsDataURL(r);
  });
}
function RR(r) {
  const e = new Image();
  return e.src = r, e;
}
const OB = {
  convertImageToBase64: MR,
  createImageFromBase64: RR
};
function E3(r, e) {
  let t;
  return function(...n) {
    clearTimeout(t), t = setTimeout(() => r.apply(this, n), e);
  };
}
function br(r) {
  "@babel/helpers - typeof";
  return br = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, br(r);
}
var _i = Uint8Array, cs = Uint16Array, db = Int32Array, mg = new _i([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), vg = new _i([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), dv = new _i([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), S3 = function(r, e) {
  for (var t = new cs(31), n = 0; n < 31; ++n)
    t[n] = e += 1 << r[n - 1];
  for (var i = new db(t[30]), n = 1; n < 30; ++n)
    for (var s = t[n]; s < t[n + 1]; ++s)
      i[s] = s - t[n] << 5 | n;
  return { b: t, r: i };
}, I3 = S3(mg, 2), F3 = I3.b, pv = I3.r;
F3[28] = 258, pv[258] = 28;
var T3 = S3(vg, 0), PR = T3.b, QB = T3.r, gv = new cs(32768);
for (var Vr = 0; Vr < 32768; ++Vr) {
  var xo = (Vr & 43690) >> 1 | (Vr & 21845) << 1;
  xo = (xo & 52428) >> 2 | (xo & 13107) << 2, xo = (xo & 61680) >> 4 | (xo & 3855) << 4, gv[Vr] = ((xo & 65280) >> 8 | (xo & 255) << 8) >> 1;
}
var Ea = function(r, e, t) {
  for (var n = r.length, i = 0, s = new cs(e); i < n; ++i)
    r[i] && ++s[r[i] - 1];
  var a = new cs(e);
  for (i = 1; i < e; ++i)
    a[i] = a[i - 1] + s[i - 1] << 1;
  var o;
  if (t) {
    o = new cs(1 << e);
    var A = 15 - e;
    for (i = 0; i < n; ++i)
      if (r[i])
        for (var l = i << 4 | r[i], u = e - r[i], c = a[r[i] - 1]++ << u, h = c | (1 << u) - 1; c <= h; ++c)
          o[gv[c] >> A] = l;
  } else
    for (o = new cs(n), i = 0; i < n; ++i)
      r[i] && (o[i] = gv[a[r[i] - 1]++] >> 15 - r[i]);
  return o;
}, sA = new _i(288);
for (var Vr = 0; Vr < 144; ++Vr)
  sA[Vr] = 8;
for (var Vr = 144; Vr < 256; ++Vr)
  sA[Vr] = 9;
for (var Vr = 256; Vr < 280; ++Vr)
  sA[Vr] = 7;
for (var Vr = 280; Vr < 288; ++Vr)
  sA[Vr] = 8;
var Ef = new _i(32);
for (var Vr = 0; Vr < 32; ++Vr)
  Ef[Vr] = 5;
var HR = /* @__PURE__ */ Ea(sA, 9, 0), jR = /* @__PURE__ */ Ea(sA, 9, 1), KR = /* @__PURE__ */ Ea(Ef, 5, 0), $R = /* @__PURE__ */ Ea(Ef, 5, 1), a0 = function(r) {
  for (var e = r[0], t = 1; t < r.length; ++t)
    r[t] > e && (e = r[t]);
  return e;
}, Gs = function(r, e, t) {
  var n = e / 8 | 0;
  return (r[n] | r[n + 1] << 8) >> (e & 7) & t;
}, o0 = function(r, e) {
  var t = e / 8 | 0;
  return (r[t] | r[t + 1] << 8 | r[t + 2] << 16) >> (e & 7);
}, pb = function(r) {
  return (r + 7) / 8 | 0;
}, x3 = function(r, e, t) {
  return (t == null || t > r.length) && (t = r.length), new _i(r.subarray(e, t));
}, VR = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], ea = function(r, e, t) {
  var n = new Error(e || VR[r]);
  if (n.code = r, Error.captureStackTrace && Error.captureStackTrace(n, ea), !t)
    throw n;
  return n;
}, zR = function(r, e, t, n) {
  var i = r.length, s = 0;
  if (!i || e.f && !e.l)
    return t || new _i(0);
  var a = !t, o = a || e.i != 2, A = e.i;
  a && (t = new _i(i * 3));
  var l = function(de) {
    var Ce = t.length;
    if (de > Ce) {
      var Qe = new _i(Math.max(Ce * 2, de));
      Qe.set(t), t = Qe;
    }
  }, u = e.f || 0, c = e.p || 0, h = e.b || 0, f = e.l, d = e.d, p = e.m, v = e.n, m = i * 8;
  do {
    if (!f) {
      u = Gs(r, c, 1);
      var b = Gs(r, c + 1, 3);
      if (c += 3, b)
        if (b == 1)
          f = jR, d = $R, p = 9, v = 5;
        else if (b == 2) {
          var x = Gs(r, c, 31) + 257, C = Gs(r, c + 10, 15) + 4, F = x + Gs(r, c + 5, 31) + 1;
          c += 14;
          for (var N = new _i(F), D = new _i(19), T = 0; T < C; ++T)
            D[dv[T]] = Gs(r, c + T * 3, 7);
          c += C * 3;
          for (var E = a0(D), L = (1 << E) - 1, S = Ea(D, E, 1), T = 0; T < F; ) {
            var X = S[Gs(r, c, L)];
            c += X & 15;
            var w = X >> 4;
            if (w < 16)
              N[T++] = w;
            else {
              var z = 0, R = 0;
              for (w == 16 ? (R = 3 + Gs(r, c, 3), c += 2, z = N[T - 1]) : w == 17 ? (R = 3 + Gs(r, c, 7), c += 3) : w == 18 && (R = 11 + Gs(r, c, 127), c += 7); R--; )
                N[T++] = z;
            }
          }
          var V = N.subarray(0, x), O = N.subarray(x);
          p = a0(V), v = a0(O), f = Ea(V, p, 1), d = Ea(O, v, 1);
        } else
          ea(1);
      else {
        var w = pb(c) + 4, B = r[w - 4] | r[w - 3] << 8, _ = w + B;
        if (_ > i) {
          A && ea(0);
          break;
        }
        o && l(h + B), t.set(r.subarray(w, _), h), e.b = h += B, e.p = c = _ * 8, e.f = u;
        continue;
      }
      if (c > m) {
        A && ea(0);
        break;
      }
    }
    o && l(h + 131072);
    for (var J = (1 << p) - 1, Z = (1 << v) - 1, U = c; ; U = c) {
      var z = f[o0(r, c) & J], P = z >> 4;
      if (c += z & 15, c > m) {
        A && ea(0);
        break;
      }
      if (z || ea(2), P < 256)
        t[h++] = P;
      else if (P == 256) {
        U = c, f = null;
        break;
      } else {
        var H = P - 254;
        if (P > 264) {
          var T = P - 257, $ = mg[T];
          H = Gs(r, c, (1 << $) - 1) + F3[T], c += $;
        }
        var ie = d[o0(r, c) & Z], ue = ie >> 4;
        ie || ea(3), c += ie & 15;
        var O = PR[ue];
        if (ue > 3) {
          var $ = vg[ue];
          O += o0(r, c) & (1 << $) - 1, c += $;
        }
        if (c > m) {
          A && ea(0);
          break;
        }
        o && l(h + 131072);
        var he = h + H;
        if (h < O) {
          var ve = s - O, Le = Math.min(O, he);
          for (ve + h < 0 && ea(3); h < Le; ++h)
            t[h] = n[ve + h];
        }
        for (; h < he; ++h)
          t[h] = t[h - O];
      }
    }
    e.l = f, e.p = U, e.b = h, e.f = u, f && (u = 1, e.m = p, e.d = d, e.n = v);
  } while (!u);
  return h != t.length && a ? x3(t, 0, h) : t.subarray(0, h);
}, Xa = function(r, e, t) {
  t <<= e & 7;
  var n = e / 8 | 0;
  r[n] |= t, r[n + 1] |= t >> 8;
}, Bc = function(r, e, t) {
  t <<= e & 7;
  var n = e / 8 | 0;
  r[n] |= t, r[n + 1] |= t >> 8, r[n + 2] |= t >> 16;
}, A0 = function(r, e) {
  for (var t = [], n = 0; n < r.length; ++n)
    r[n] && t.push({ s: n, f: r[n] });
  var i = t.length, s = t.slice();
  if (!i)
    return { t: L3, l: 0 };
  if (i == 1) {
    var a = new _i(t[0].s + 1);
    return a[t[0].s] = 1, { t: a, l: 1 };
  }
  t.sort(function(_, x) {
    return _.f - x.f;
  }), t.push({ s: -1, f: 25001 });
  var o = t[0], A = t[1], l = 0, u = 1, c = 2;
  for (t[0] = { s: -1, f: o.f + A.f, l: o, r: A }; u != i - 1; )
    o = t[t[l].f < t[c].f ? l++ : c++], A = t[l != u && t[l].f < t[c].f ? l++ : c++], t[u++] = { s: -1, f: o.f + A.f, l: o, r: A };
  for (var h = s[0].s, n = 1; n < i; ++n)
    s[n].s > h && (h = s[n].s);
  var f = new cs(h + 1), d = mv(t[u - 1], f, 0);
  if (d > e) {
    var n = 0, p = 0, v = d - e, m = 1 << v;
    for (s.sort(function(x, C) {
      return f[C.s] - f[x.s] || x.f - C.f;
    }); n < i; ++n) {
      var b = s[n].s;
      if (f[b] > e)
        p += m - (1 << d - f[b]), f[b] = e;
      else
        break;
    }
    for (p >>= v; p > 0; ) {
      var w = s[n].s;
      f[w] < e ? p -= 1 << e - f[w]++ - 1 : ++n;
    }
    for (; n >= 0 && p; --n) {
      var B = s[n].s;
      f[B] == e && (--f[B], ++p);
    }
    d = e;
  }
  return { t: new _i(f), l: d };
}, mv = function(r, e, t) {
  return r.s == -1 ? Math.max(mv(r.l, e, t + 1), mv(r.r, e, t + 1)) : e[r.s] = t;
}, DB = function(r) {
  for (var e = r.length; e && !r[--e]; )
    ;
  for (var t = new cs(++e), n = 0, i = r[0], s = 1, a = function(A) {
    t[n++] = A;
  }, o = 1; o <= e; ++o)
    if (r[o] == i && o != e)
      ++s;
    else {
      if (!i && s > 2) {
        for (; s > 138; s -= 138)
          a(32754);
        s > 2 && (a(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0);
      } else if (s > 3) {
        for (a(i), --s; s > 6; s -= 6)
          a(8304);
        s > 2 && (a(s - 3 << 5 | 8208), s = 0);
      }
      for (; s--; )
        a(i);
      s = 1, i = r[o];
    }
  return { c: t.subarray(0, n), n: e };
}, Cc = function(r, e) {
  for (var t = 0, n = 0; n < e.length; ++n)
    t += r[n] * e[n];
  return t;
}, k3 = function(r, e, t) {
  var n = t.length, i = pb(e + 2);
  r[i] = n & 255, r[i + 1] = n >> 8, r[i + 2] = r[i] ^ 255, r[i + 3] = r[i + 1] ^ 255;
  for (var s = 0; s < n; ++s)
    r[i + s + 4] = t[s];
  return (i + 4 + n) * 8;
}, MB = function(r, e, t, n, i, s, a, o, A, l, u) {
  Xa(e, u++, t), ++i[256];
  for (var c = A0(i, 15), h = c.t, f = c.l, d = A0(s, 15), p = d.t, v = d.l, m = DB(h), b = m.c, w = m.n, B = DB(p), _ = B.c, x = B.n, C = new cs(19), F = 0; F < b.length; ++F)
    ++C[b[F] & 31];
  for (var F = 0; F < _.length; ++F)
    ++C[_[F] & 31];
  for (var N = A0(C, 7), D = N.t, T = N.l, E = 19; E > 4 && !D[dv[E - 1]]; --E)
    ;
  var L = l + 5 << 3, S = Cc(i, sA) + Cc(s, Ef) + a, X = Cc(i, h) + Cc(s, p) + a + 14 + 3 * E + Cc(C, D) + 2 * C[16] + 3 * C[17] + 7 * C[18];
  if (A >= 0 && L <= S && L <= X)
    return k3(e, u, r.subarray(A, A + l));
  var z, R, V, O;
  if (Xa(e, u, 1 + (X < S)), u += 2, X < S) {
    z = Ea(h, f, 0), R = h, V = Ea(p, v, 0), O = p;
    var J = Ea(D, T, 0);
    Xa(e, u, w - 257), Xa(e, u + 5, x - 1), Xa(e, u + 10, E - 4), u += 14;
    for (var F = 0; F < E; ++F)
      Xa(e, u + 3 * F, D[dv[F]]);
    u += 3 * E;
    for (var Z = [b, _], U = 0; U < 2; ++U)
      for (var P = Z[U], F = 0; F < P.length; ++F) {
        var H = P[F] & 31;
        Xa(e, u, J[H]), u += D[H], H > 15 && (Xa(e, u, P[F] >> 5 & 127), u += P[F] >> 12);
      }
  } else
    z = HR, R = sA, V = KR, O = Ef;
  for (var F = 0; F < o; ++F) {
    var $ = n[F];
    if ($ > 255) {
      var H = $ >> 18 & 31;
      Bc(e, u, z[H + 257]), u += R[H + 257], H > 7 && (Xa(e, u, $ >> 23 & 31), u += mg[H]);
      var ie = $ & 31;
      Bc(e, u, V[ie]), u += O[ie], ie > 3 && (Bc(e, u, $ >> 5 & 8191), u += vg[ie]);
    } else
      Bc(e, u, z[$]), u += R[$];
  }
  return Bc(e, u, z[256]), u + R[256];
}, GR = /* @__PURE__ */ new db([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), L3 = /* @__PURE__ */ new _i(0), qR = function(r, e, t, n, i, s) {
  var a = s.z || r.length, o = new _i(n + a + 5 * (1 + Math.ceil(a / 7e3)) + i), A = o.subarray(n, o.length - i), l = s.l, u = (s.r || 0) & 7;
  if (e) {
    u && (A[0] = s.r >> 3);
    for (var c = GR[e - 1], h = c >> 13, f = c & 8191, d = (1 << t) - 1, p = s.p || new cs(32768), v = s.h || new cs(d + 1), m = Math.ceil(t / 3), b = 2 * m, w = function(M) {
      return (r[M] ^ r[M + 1] << m ^ r[M + 2] << b) & d;
    }, B = new db(25e3), _ = new cs(288), x = new cs(32), C = 0, F = 0, N = s.i || 0, D = 0, T = s.w || 0, E = 0; N + 2 < a; ++N) {
      var L = w(N), S = N & 32767, X = v[L];
      if (p[S] = X, v[L] = S, T <= N) {
        var z = a - N;
        if ((C > 7e3 || D > 24576) && (z > 423 || !l)) {
          u = MB(r, A, 0, B, _, x, F, D, E, N - E, u), D = C = F = 0, E = N;
          for (var R = 0; R < 286; ++R)
            _[R] = 0;
          for (var R = 0; R < 30; ++R)
            x[R] = 0;
        }
        var V = 2, O = 0, J = f, Z = S - X & 32767;
        if (z > 2 && L == w(N - Z))
          for (var U = Math.min(h, z) - 1, P = Math.min(32767, N), H = Math.min(258, z); Z <= P && --J && S != X; ) {
            if (r[N + V] == r[N + V - Z]) {
              for (var $ = 0; $ < H && r[N + $] == r[N + $ - Z]; ++$)
                ;
              if ($ > V) {
                if (V = $, O = Z, $ > U)
                  break;
                for (var ie = Math.min(Z, $ - 2), ue = 0, R = 0; R < ie; ++R) {
                  var he = N - Z + R & 32767, ve = p[he], Le = he - ve & 32767;
                  Le > ue && (ue = Le, X = he);
                }
              }
            }
            S = X, X = p[S], Z += S - X & 32767;
          }
        if (O) {
          B[D++] = 268435456 | pv[V] << 18 | QB[O];
          var de = pv[V] & 31, Ce = QB[O] & 31;
          F += mg[de] + vg[Ce], ++_[257 + de], ++x[Ce], T = N + V, ++C;
        } else
          B[D++] = r[N], ++_[r[N]];
      }
    }
    for (N = Math.max(N, T); N < a; ++N)
      B[D++] = r[N], ++_[r[N]];
    u = MB(r, A, l, B, _, x, F, D, E, N - E, u), l || (s.r = u & 7 | A[u / 8 | 0] << 3, u -= 7, s.h = v, s.p = p, s.i = N, s.w = T);
  } else {
    for (var N = s.w || 0; N < a + l; N += 65535) {
      var Qe = N + 65535;
      Qe >= a && (A[u / 8 | 0] = l, Qe = a), u = k3(A, u + 1, r.subarray(N, Qe));
    }
    s.i = a;
  }
  return x3(o, 0, n + pb(u) + i);
}, U3 = function() {
  var r = 1, e = 0;
  return {
    p: function(t) {
      for (var n = r, i = e, s = t.length | 0, a = 0; a != s; ) {
        for (var o = Math.min(a + 2655, s); a < o; ++a)
          i += n += t[a];
        n = (n & 65535) + 15 * (n >> 16), i = (i & 65535) + 15 * (i >> 16);
      }
      r = n, e = i;
    },
    d: function() {
      return r %= 65521, e %= 65521, (r & 255) << 24 | (r & 65280) << 8 | (e & 255) << 8 | e >> 8;
    }
  };
}, WR = function(r, e, t, n, i) {
  if (!i && (i = { l: 1 }, e.dictionary)) {
    var s = e.dictionary.subarray(-32768), a = new _i(s.length + r.length);
    a.set(s), a.set(r, s.length), r = a, i.w = s.length;
  }
  return qR(r, e.level == null ? 6 : e.level, e.mem == null ? i.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(r.length))) * 1.5) : 20 : 12 + e.mem, t, n, i);
}, N3 = function(r, e, t) {
  for (; t; ++e)
    r[e] = t, t >>>= 8;
}, XR = function(r, e) {
  var t = e.level, n = t == 0 ? 0 : t < 6 ? 1 : t == 9 ? 3 : 2;
  if (r[0] = 120, r[1] = n << 6 | (e.dictionary && 32), r[1] |= 31 - (r[0] << 8 | r[1]) % 31, e.dictionary) {
    var i = U3();
    i.p(e.dictionary), N3(r, 2, i.d());
  }
}, JR = function(r, e) {
  return ((r[0] & 15) != 8 || r[0] >> 4 > 7 || (r[0] << 8 | r[1]) % 31) && ea(6, "invalid zlib data"), (r[1] >> 5 & 1) == +!e && ea(6, "invalid zlib data: " + (r[1] & 32 ? "need" : "unexpected") + " dictionary"), (r[1] >> 3 & 4) + 2;
};
function vv(r, e) {
  e || (e = {});
  var t = U3();
  t.p(r);
  var n = WR(r, e, e.dictionary ? 6 : 2, 4);
  return XR(n, e), N3(n, n.length - 4, t.d()), n;
}
function YR(r, e) {
  return zR(r.subarray(JR(r, e), -4), { i: 2 }, e, e);
}
var ZR = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), eP = 0;
try {
  ZR.decode(L3, { stream: !0 }), eP = 1;
} catch {
}
/** @license
 *
 * jsPDF - PDF Document creation from JavaScript
 * Version 2.5.2 Built on 2024-09-17T13:29:57.859Z
 *                      CommitID 00000000
 *
 * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
 *               2015-2021 yWorks GmbH, http://www.yworks.com
 *               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
 *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
 *               2010 Aaron Spike, https://github.com/acspike
 *               2012 Willow Systems Corporation, https://github.com/willowsystems
 *               2012 Pablo Hess, https://github.com/pablohess
 *               2012 Florian Jenett, https://github.com/fjenett
 *               2013 Warren Weckesser, https://github.com/warrenweckesser
 *               2013 Youssef Beddad, https://github.com/lifof
 *               2013 Lee Driscoll, https://github.com/lsdriscoll
 *               2013 Stefan Slonevskiy, https://github.com/stefslon
 *               2013 Jeremy Morel, https://github.com/jmorel
 *               2013 Christoph Hartmann, https://github.com/chris-rock
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
 *               2014 James Makes, https://github.com/dollaruw
 *               2014 Diego Casorran, https://github.com/diegocr
 *               2014 Steven Spungin, https://github.com/Flamenco
 *               2014 Kenneth Glassey, https://github.com/Gavvers
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Contributor(s):
 *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
 *    kim3er, mfo, alnorth, Flamenco
 */
var Lt = /* @__PURE__ */ function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
}();
function l0() {
  Lt.console && typeof Lt.console.log == "function" && Lt.console.log.apply(Lt.console, arguments);
}
var Lr = { log: l0, warn: function(r) {
  Lt.console && (typeof Lt.console.warn == "function" ? Lt.console.warn.apply(Lt.console, arguments) : l0.call(null, arguments));
}, error: function(r) {
  Lt.console && (typeof Lt.console.error == "function" ? Lt.console.error.apply(Lt.console, arguments) : l0(r));
} };
function u0(r, e, t) {
  var n = new XMLHttpRequest();
  n.open("GET", r), n.responseType = "blob", n.onload = function() {
    NA(n.response, e, t);
  }, n.onerror = function() {
    Lr.error("could not download file");
  }, n.send();
}
function RB(r) {
  var e = new XMLHttpRequest();
  e.open("HEAD", r, !1);
  try {
    e.send();
  } catch {
  }
  return e.status >= 200 && e.status <= 299;
}
function nd(r) {
  try {
    r.dispatchEvent(new MouseEvent("click"));
  } catch {
    var e = document.createEvent("MouseEvents");
    e.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), r.dispatchEvent(e);
  }
}
var tf, bv, NA = Lt.saveAs || ((typeof window > "u" ? "undefined" : br(window)) !== "object" || window !== Lt ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(r, e, t) {
  var n = Lt.URL || Lt.webkitURL, i = document.createElement("a");
  e = e || r.name || "download", i.download = e, i.rel = "noopener", typeof r == "string" ? (i.href = r, i.origin !== location.origin ? RB(i.href) ? u0(r, e, t) : nd(i, i.target = "_blank") : nd(i)) : (i.href = n.createObjectURL(r), setTimeout(function() {
    n.revokeObjectURL(i.href);
  }, 4e4), setTimeout(function() {
    nd(i);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(r, e, t) {
  if (e = e || r.name || "download", typeof r == "string") if (RB(r)) u0(r, e, t);
  else {
    var n = document.createElement("a");
    n.href = r, n.target = "_blank", setTimeout(function() {
      nd(n);
    });
  }
  else navigator.msSaveOrOpenBlob(function(i, s) {
    return s === void 0 ? s = { autoBom: !1 } : br(s) !== "object" && (Lr.warn("Deprecated: Expected third argument to be a object"), s = { autoBom: !s }), s.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(i.type) ? new Blob(["\uFEFF", i], { type: i.type }) : i;
  }(r, t), e);
} : function(r, e, t, n) {
  if ((n = n || open("", "_blank")) && (n.document.title = n.document.body.innerText = "downloading..."), typeof r == "string") return u0(r, e, t);
  var i = r.type === "application/octet-stream", s = /constructor/i.test(Lt.HTMLElement) || Lt.safari, a = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((a || i && s) && (typeof FileReader > "u" ? "undefined" : br(FileReader)) === "object") {
    var o = new FileReader();
    o.onloadend = function() {
      var u = o.result;
      u = a ? u : u.replace(/^data:[^;]*;/, "data:attachment/file;"), n ? n.location.href = u : location = u, n = null;
    }, o.readAsDataURL(r);
  } else {
    var A = Lt.URL || Lt.webkitURL, l = A.createObjectURL(r);
    n ? n.location = l : location.href = l, n = null, setTimeout(function() {
      A.revokeObjectURL(l);
    }, 4e4);
  }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
function O3(r) {
  var e;
  r = r || "", this.ok = !1, r.charAt(0) == "#" && (r = r.substr(1, 6)), r = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[r = (r = r.replace(/ /g, "")).toLowerCase()] || r;
  for (var t = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(o) {
    return [parseInt(o[1]), parseInt(o[2]), parseInt(o[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(o) {
    return [parseInt(o[1], 16), parseInt(o[2], 16), parseInt(o[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(o) {
    return [parseInt(o[1] + o[1], 16), parseInt(o[2] + o[2], 16), parseInt(o[3] + o[3], 16)];
  } }], n = 0; n < t.length; n++) {
    var i = t[n].re, s = t[n].process, a = i.exec(r);
    a && (e = s(a), this.r = e[0], this.g = e[1], this.b = e[2], this.ok = !0);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var o = this.r.toString(16), A = this.g.toString(16), l = this.b.toString(16);
    return o.length == 1 && (o = "0" + o), A.length == 1 && (A = "0" + A), l.length == 1 && (l = "0" + l), "#" + o + A + l;
  };
}
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function c0(r, e) {
  var t = r[0], n = r[1], i = r[2], s = r[3];
  t = mi(t, n, i, s, e[0], 7, -680876936), s = mi(s, t, n, i, e[1], 12, -389564586), i = mi(i, s, t, n, e[2], 17, 606105819), n = mi(n, i, s, t, e[3], 22, -1044525330), t = mi(t, n, i, s, e[4], 7, -176418897), s = mi(s, t, n, i, e[5], 12, 1200080426), i = mi(i, s, t, n, e[6], 17, -1473231341), n = mi(n, i, s, t, e[7], 22, -45705983), t = mi(t, n, i, s, e[8], 7, 1770035416), s = mi(s, t, n, i, e[9], 12, -1958414417), i = mi(i, s, t, n, e[10], 17, -42063), n = mi(n, i, s, t, e[11], 22, -1990404162), t = mi(t, n, i, s, e[12], 7, 1804603682), s = mi(s, t, n, i, e[13], 12, -40341101), i = mi(i, s, t, n, e[14], 17, -1502002290), t = vi(t, n = mi(n, i, s, t, e[15], 22, 1236535329), i, s, e[1], 5, -165796510), s = vi(s, t, n, i, e[6], 9, -1069501632), i = vi(i, s, t, n, e[11], 14, 643717713), n = vi(n, i, s, t, e[0], 20, -373897302), t = vi(t, n, i, s, e[5], 5, -701558691), s = vi(s, t, n, i, e[10], 9, 38016083), i = vi(i, s, t, n, e[15], 14, -660478335), n = vi(n, i, s, t, e[4], 20, -405537848), t = vi(t, n, i, s, e[9], 5, 568446438), s = vi(s, t, n, i, e[14], 9, -1019803690), i = vi(i, s, t, n, e[3], 14, -187363961), n = vi(n, i, s, t, e[8], 20, 1163531501), t = vi(t, n, i, s, e[13], 5, -1444681467), s = vi(s, t, n, i, e[2], 9, -51403784), i = vi(i, s, t, n, e[7], 14, 1735328473), t = bi(t, n = vi(n, i, s, t, e[12], 20, -1926607734), i, s, e[5], 4, -378558), s = bi(s, t, n, i, e[8], 11, -2022574463), i = bi(i, s, t, n, e[11], 16, 1839030562), n = bi(n, i, s, t, e[14], 23, -35309556), t = bi(t, n, i, s, e[1], 4, -1530992060), s = bi(s, t, n, i, e[4], 11, 1272893353), i = bi(i, s, t, n, e[7], 16, -155497632), n = bi(n, i, s, t, e[10], 23, -1094730640), t = bi(t, n, i, s, e[13], 4, 681279174), s = bi(s, t, n, i, e[0], 11, -358537222), i = bi(i, s, t, n, e[3], 16, -722521979), n = bi(n, i, s, t, e[6], 23, 76029189), t = bi(t, n, i, s, e[9], 4, -640364487), s = bi(s, t, n, i, e[12], 11, -421815835), i = bi(i, s, t, n, e[15], 16, 530742520), t = yi(t, n = bi(n, i, s, t, e[2], 23, -995338651), i, s, e[0], 6, -198630844), s = yi(s, t, n, i, e[7], 10, 1126891415), i = yi(i, s, t, n, e[14], 15, -1416354905), n = yi(n, i, s, t, e[5], 21, -57434055), t = yi(t, n, i, s, e[12], 6, 1700485571), s = yi(s, t, n, i, e[3], 10, -1894986606), i = yi(i, s, t, n, e[10], 15, -1051523), n = yi(n, i, s, t, e[1], 21, -2054922799), t = yi(t, n, i, s, e[8], 6, 1873313359), s = yi(s, t, n, i, e[15], 10, -30611744), i = yi(i, s, t, n, e[6], 15, -1560198380), n = yi(n, i, s, t, e[13], 21, 1309151649), t = yi(t, n, i, s, e[4], 6, -145523070), s = yi(s, t, n, i, e[11], 10, -1120210379), i = yi(i, s, t, n, e[2], 15, 718787259), n = yi(n, i, s, t, e[9], 21, -343485551), r[0] = zo(t, r[0]), r[1] = zo(n, r[1]), r[2] = zo(i, r[2]), r[3] = zo(s, r[3]);
}
function bg(r, e, t, n, i, s) {
  return e = zo(zo(e, r), zo(n, s)), zo(e << i | e >>> 32 - i, t);
}
function mi(r, e, t, n, i, s, a) {
  return bg(e & t | ~e & n, r, e, i, s, a);
}
function vi(r, e, t, n, i, s, a) {
  return bg(e & n | t & ~n, r, e, i, s, a);
}
function bi(r, e, t, n, i, s, a) {
  return bg(e ^ t ^ n, r, e, i, s, a);
}
function yi(r, e, t, n, i, s, a) {
  return bg(t ^ (e | ~n), r, e, i, s, a);
}
function Q3(r) {
  var e, t = r.length, n = [1732584193, -271733879, -1732584194, 271733878];
  for (e = 64; e <= r.length; e += 64) c0(n, tP(r.substring(e - 64, e)));
  r = r.substring(e - 64);
  var i = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e = 0; e < r.length; e++) i[e >> 2] |= r.charCodeAt(e) << (e % 4 << 3);
  if (i[e >> 2] |= 128 << (e % 4 << 3), e > 55) for (c0(n, i), e = 0; e < 16; e++) i[e] = 0;
  return i[14] = 8 * t, c0(n, i), n;
}
function tP(r) {
  var e, t = [];
  for (e = 0; e < 64; e += 4) t[e >> 2] = r.charCodeAt(e) + (r.charCodeAt(e + 1) << 8) + (r.charCodeAt(e + 2) << 16) + (r.charCodeAt(e + 3) << 24);
  return t;
}
tf = Lt.atob.bind(Lt), bv = Lt.btoa.bind(Lt);
var PB = "0123456789abcdef".split("");
function rP(r) {
  for (var e = "", t = 0; t < 4; t++) e += PB[r >> 8 * t + 4 & 15] + PB[r >> 8 * t & 15];
  return e;
}
function nP(r) {
  return String.fromCharCode((255 & r) >> 0, (65280 & r) >> 8, (16711680 & r) >> 16, (4278190080 & r) >> 24);
}
function yv(r) {
  return Q3(r).map(nP).join("");
}
var iP = function(r) {
  for (var e = 0; e < r.length; e++) r[e] = rP(r[e]);
  return r.join("");
}(Q3("hello")) != "5d41402abc4b2a76b9719d911017c592";
function zo(r, e) {
  if (iP) {
    var t = (65535 & r) + (65535 & e);
    return (r >> 16) + (e >> 16) + (t >> 16) << 16 | 65535 & t;
  }
  return r + e & 4294967295;
}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
function wv(r, e) {
  var t, n, i, s;
  if (r !== t) {
    for (var a = (i = r, s = 1 + (256 / r.length >> 0), new Array(s + 1).join(i)), o = [], A = 0; A < 256; A++) o[A] = A;
    var l = 0;
    for (A = 0; A < 256; A++) {
      var u = o[A];
      l = (l + u + a.charCodeAt(A)) % 256, o[A] = o[l], o[l] = u;
    }
    t = r, n = o;
  } else o = n;
  var c = e.length, h = 0, f = 0, d = "";
  for (A = 0; A < c; A++) f = (f + (u = o[h = (h + 1) % 256])) % 256, o[h] = o[f], o[f] = u, a = o[(o[h] + o[f]) % 256], d += String.fromCharCode(e.charCodeAt(A) ^ a);
  return d;
}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
var HB = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function au(r, e, t, n) {
  this.v = 1, this.r = 2;
  var i = 192;
  r.forEach(function(o) {
    if (HB.perm !== void 0) throw new Error("Invalid permission: " + o);
    i += HB[o];
  }), this.padding = "(¿N^NuAd\0NVÿú\b..\0¶Ðh>/\f©þdSiz";
  var s = (e + this.padding).substr(0, 32), a = (t + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(s, a), this.P = -(1 + (255 ^ i)), this.encryptionKey = yv(s + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(n)).substr(0, 5), this.U = wv(this.encryptionKey, this.padding);
}
function ou(r) {
  if (/[^\u0000-\u00ff]/.test(r)) throw new Error("Invalid PDF Name Object: " + r + ", Only accept ASCII characters.");
  for (var e = "", t = r.length, n = 0; n < t; n++) {
    var i = r.charCodeAt(n);
    i < 33 || i === 35 || i === 37 || i === 40 || i === 41 || i === 47 || i === 60 || i === 62 || i === 91 || i === 93 || i === 123 || i === 125 || i > 126 ? e += "#" + ("0" + i.toString(16)).slice(-2) : e += r[n];
  }
  return e;
}
function jB(r) {
  if (br(r) !== "object") throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var e = {};
  this.subscribe = function(t, n, i) {
    if (i = i || !1, typeof t != "string" || typeof n != "function" || typeof i != "boolean") throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    e.hasOwnProperty(t) || (e[t] = {});
    var s = Math.random().toString(35);
    return e[t][s] = [n, !!i], s;
  }, this.unsubscribe = function(t) {
    for (var n in e) if (e[n][t]) return delete e[n][t], Object.keys(e[n]).length === 0 && delete e[n], !0;
    return !1;
  }, this.publish = function(t) {
    if (e.hasOwnProperty(t)) {
      var n = Array.prototype.slice.call(arguments, 1), i = [];
      for (var s in e[t]) {
        var a = e[t][s];
        try {
          a[0].apply(r, n);
        } catch (o) {
          Lt.console && Lr.error("jsPDF PubSub Error", o.message, o);
        }
        a[1] && i.push(s);
      }
      i.length && i.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return e;
  };
}
function Sf(r) {
  if (!(this instanceof Sf)) return new Sf(r);
  var e = "opacity,stroke-opacity".split(",");
  for (var t in r) r.hasOwnProperty(t) && e.indexOf(t) >= 0 && (this[t] = r[t]);
  this.id = "", this.objectNumber = -1;
}
function D3(r, e) {
  this.gState = r, this.matrix = e, this.id = "", this.objectNumber = -1;
}
function Po(r, e, t, n, i) {
  if (!(this instanceof Po)) return new Po(r, e, t, n, i);
  this.type = r === "axial" ? 2 : 3, this.coords = e, this.colors = t, D3.call(this, n, i);
}
function $A(r, e, t, n, i) {
  if (!(this instanceof $A)) return new $A(r, e, t, n, i);
  this.boundingBox = r, this.xStep = e, this.yStep = t, this.stream = "", this.cloneIndex = 0, D3.call(this, n, i);
}
function Ft(r) {
  var e, t = typeof arguments[0] == "string" ? arguments[0] : "p", n = arguments[1], i = arguments[2], s = arguments[3], a = [], o = 1, A = 16, l = "S", u = null;
  br(r = r || {}) === "object" && (t = r.orientation, n = r.unit || n, i = r.format || i, s = r.compress || r.compressPdf || s, (u = r.encryption || null) !== null && (u.userPassword = u.userPassword || "", u.ownerPassword = u.ownerPassword || "", u.userPermissions = u.userPermissions || []), o = typeof r.userUnit == "number" ? Math.abs(r.userUnit) : 1, r.precision !== void 0 && (e = r.precision), r.floatPrecision !== void 0 && (A = r.floatPrecision), l = r.defaultPathOperation || "S"), a = r.filters || (s === !0 ? ["FlateEncode"] : a), n = n || "mm", t = ("" + (t || "P")).toLowerCase();
  var c = r.putOnlyUsedFonts || !1, h = {}, f = { internal: {}, __private__: {} };
  f.__private__.PubSub = jB;
  var d = "1.3", p = f.__private__.getPdfVersion = function() {
    return d;
  };
  f.__private__.setPdfVersion = function(I) {
    d = I;
  };
  var v = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  f.__private__.getPageFormats = function() {
    return v;
  };
  var m = f.__private__.getPageFormat = function(I) {
    return v[I];
  };
  i = i || "a4";
  var b = { COMPAT: "compat", ADVANCED: "advanced" }, w = b.COMPAT;
  function B() {
    this.saveGraphicsState(), G(new Ct(et, 0, 0, -et, 0, vo() * et).toString() + " cm"), this.setFontSize(this.getFontSize() / et), l = "n", w = b.ADVANCED;
  }
  function _() {
    this.restoreGraphicsState(), l = "S", w = b.COMPAT;
  }
  var x = f.__private__.combineFontStyleAndFontWeight = function(I, K) {
    if (I == "bold" && K == "normal" || I == "bold" && K == 400 || I == "normal" && K == "italic" || I == "bold" && K == "italic") throw new Error("Invalid Combination of fontweight and fontstyle");
    return K && (I = K == 400 || K === "normal" ? I === "italic" ? "italic" : "normal" : K != 700 && K !== "bold" || I !== "normal" ? (K == 700 ? "bold" : K) + "" + I : "bold"), I;
  };
  f.advancedAPI = function(I) {
    var K = w === b.COMPAT;
    return K && B.call(this), typeof I != "function" || (I(this), K && _.call(this)), this;
  }, f.compatAPI = function(I) {
    var K = w === b.ADVANCED;
    return K && _.call(this), typeof I != "function" || (I(this), K && B.call(this)), this;
  }, f.isAdvancedAPI = function() {
    return w === b.ADVANCED;
  };
  var C, F = function(I) {
    if (w !== b.ADVANCED) throw new Error(I + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, N = f.roundToPrecision = f.__private__.roundToPrecision = function(I, K) {
    var oe = e || K;
    if (isNaN(I) || isNaN(oe)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return I.toFixed(oe).replace(/0+$/, "");
  };
  C = f.hpf = f.__private__.hpf = typeof A == "number" ? function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return N(I, A);
  } : A === "smart" ? function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return N(I, I > -1 && I < 1 ? 16 : 5);
  } : function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return N(I, 16);
  };
  var D = f.f2 = f.__private__.f2 = function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.f2");
    return N(I, 2);
  }, T = f.__private__.f3 = function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.f3");
    return N(I, 3);
  }, E = f.scale = f.__private__.scale = function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.scale");
    return w === b.COMPAT ? I * et : w === b.ADVANCED ? I : void 0;
  }, L = function(I) {
    return w === b.COMPAT ? vo() - I : w === b.ADVANCED ? I : void 0;
  }, S = function(I) {
    return E(L(I));
  };
  f.__private__.setPrecision = f.setPrecision = function(I) {
    typeof parseInt(I, 10) == "number" && (e = parseInt(I, 10));
  };
  var X, z = "00000000000000000000000000000000", R = f.__private__.getFileId = function() {
    return z;
  }, V = f.__private__.setFileId = function(I) {
    return z = I !== void 0 && /^[a-fA-F0-9]{32}$/.test(I) ? I.toUpperCase() : z.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), u !== null && (di = new au(u.userPermissions, u.userPassword, u.ownerPassword, z)), z;
  };
  f.setFileId = function(I) {
    return V(I), this;
  }, f.getFileId = function() {
    return R();
  };
  var O = f.__private__.convertDateToPDFDate = function(I) {
    var K = I.getTimezoneOffset(), oe = K < 0 ? "+" : "-", me = Math.floor(Math.abs(K / 60)), Se = Math.abs(K % 60), De = [oe, H(me), "'", H(Se), "'"].join("");
    return ["D:", I.getFullYear(), H(I.getMonth() + 1), H(I.getDate()), H(I.getHours()), H(I.getMinutes()), H(I.getSeconds()), De].join("");
  }, J = f.__private__.convertPDFDateToDate = function(I) {
    var K = parseInt(I.substr(2, 4), 10), oe = parseInt(I.substr(6, 2), 10) - 1, me = parseInt(I.substr(8, 2), 10), Se = parseInt(I.substr(10, 2), 10), De = parseInt(I.substr(12, 2), 10), Je = parseInt(I.substr(14, 2), 10);
    return new Date(K, oe, me, Se, De, Je, 0);
  }, Z = f.__private__.setCreationDate = function(I) {
    var K;
    if (I === void 0 && (I = /* @__PURE__ */ new Date()), I instanceof Date) K = O(I);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(I)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      K = I;
    }
    return X = K;
  }, U = f.__private__.getCreationDate = function(I) {
    var K = X;
    return I === "jsDate" && (K = J(X)), K;
  };
  f.setCreationDate = function(I) {
    return Z(I), this;
  }, f.getCreationDate = function(I) {
    return U(I);
  };
  var P, H = f.__private__.padd2 = function(I) {
    return ("0" + parseInt(I)).slice(-2);
  }, $ = f.__private__.padd2Hex = function(I) {
    return ("00" + (I = I.toString())).substr(I.length);
  }, ie = 0, ue = [], he = [], ve = 0, Le = [], de = [], Ce = !1, Qe = he, M = function() {
    ie = 0, ve = 0, he = [], ue = [], Le = [], Ki = ur(), Zn = ur();
  };
  f.__private__.setCustomOutputDestination = function(I) {
    Ce = !0, Qe = I;
  };
  var Ae = function(I) {
    Ce || (Qe = I);
  };
  f.__private__.resetCustomOutputDestination = function() {
    Ce = !1, Qe = he;
  };
  var G = f.__private__.out = function(I) {
    return I = I.toString(), ve += I.length + 1, Qe.push(I), Qe;
  }, ne = f.__private__.write = function(I) {
    return G(arguments.length === 1 ? I.toString() : Array.prototype.join.call(arguments, " "));
  }, ee = f.__private__.getArrayBuffer = function(I) {
    for (var K = I.length, oe = new ArrayBuffer(K), me = new Uint8Array(oe); K--; ) me[K] = I.charCodeAt(K);
    return oe;
  }, ae = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  f.__private__.getStandardFonts = function() {
    return ae;
  };
  var re = r.fontSize || 16;
  f.__private__.setFontSize = f.setFontSize = function(I) {
    return re = w === b.ADVANCED ? I / et : I, this;
  };
  var ce, le = f.__private__.getFontSize = f.getFontSize = function() {
    return w === b.COMPAT ? re : re * et;
  }, Te = r.R2L || !1;
  f.__private__.setR2L = f.setR2L = function(I) {
    return Te = I, this;
  }, f.__private__.getR2L = f.getR2L = function() {
    return Te;
  };
  var Oe, Ue = f.__private__.setZoomMode = function(I) {
    var K = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(I)) ce = I;
    else if (isNaN(I)) {
      if (K.indexOf(I) === -1) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + I + '" is not recognized.');
      ce = I;
    } else ce = parseInt(I, 10);
  };
  f.__private__.getZoomMode = function() {
    return ce;
  };
  var Ge, at = f.__private__.setPageMode = function(I) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(I) == -1) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + I + '" is not recognized.');
    Oe = I;
  };
  f.__private__.getPageMode = function() {
    return Oe;
  };
  var it = f.__private__.setLayoutMode = function(I) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(I) == -1) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + I + '" is not recognized.');
    Ge = I;
  };
  f.__private__.getLayoutMode = function() {
    return Ge;
  }, f.__private__.setDisplayMode = f.setDisplayMode = function(I, K, oe) {
    return Ue(I), it(K), at(oe), this;
  };
  var ut = { title: "", subject: "", author: "", keywords: "", creator: "" };
  f.__private__.getDocumentProperty = function(I) {
    if (Object.keys(ut).indexOf(I) === -1) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return ut[I];
  }, f.__private__.getDocumentProperties = function() {
    return ut;
  }, f.__private__.setDocumentProperties = f.setProperties = f.setDocumentProperties = function(I) {
    for (var K in ut) ut.hasOwnProperty(K) && I[K] && (ut[K] = I[K]);
    return this;
  }, f.__private__.setDocumentProperty = function(I, K) {
    if (Object.keys(ut).indexOf(I) === -1) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return ut[I] = K;
  };
  var St, et, gr, bt, Qr, Wt = {}, kt = {}, Dr = [], Xt = {}, Cn = {}, mr = {}, Ir = {}, hr = null, wr = 0, gt = [], rr = new jB(f), Rs = r.hotfixes || [], Yr = {}, fi = {}, Fi = [], Ct = function I(K, oe, me, Se, De, Je) {
    if (!(this instanceof I)) return new I(K, oe, me, Se, De, Je);
    isNaN(K) && (K = 1), isNaN(oe) && (oe = 0), isNaN(me) && (me = 0), isNaN(Se) && (Se = 1), isNaN(De) && (De = 0), isNaN(Je) && (Je = 0), this._matrix = [K, oe, me, Se, De, Je];
  };
  Object.defineProperty(Ct.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(I) {
    this._matrix[0] = I;
  } }), Object.defineProperty(Ct.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(I) {
    this._matrix[1] = I;
  } }), Object.defineProperty(Ct.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(I) {
    this._matrix[2] = I;
  } }), Object.defineProperty(Ct.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(I) {
    this._matrix[3] = I;
  } }), Object.defineProperty(Ct.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(I) {
    this._matrix[4] = I;
  } }), Object.defineProperty(Ct.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(I) {
    this._matrix[5] = I;
  } }), Object.defineProperty(Ct.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(I) {
    this._matrix[0] = I;
  } }), Object.defineProperty(Ct.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(I) {
    this._matrix[1] = I;
  } }), Object.defineProperty(Ct.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(I) {
    this._matrix[2] = I;
  } }), Object.defineProperty(Ct.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(I) {
    this._matrix[3] = I;
  } }), Object.defineProperty(Ct.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(I) {
    this._matrix[4] = I;
  } }), Object.defineProperty(Ct.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(I) {
    this._matrix[5] = I;
  } }), Object.defineProperty(Ct.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Ct.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Ct.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Ct.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
  } }), Ct.prototype.join = function(I) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(C).join(I);
  }, Ct.prototype.multiply = function(I) {
    var K = I.sx * this.sx + I.shy * this.shx, oe = I.sx * this.shy + I.shy * this.sy, me = I.shx * this.sx + I.sy * this.shx, Se = I.shx * this.shy + I.sy * this.sy, De = I.tx * this.sx + I.ty * this.shx + this.tx, Je = I.tx * this.shy + I.ty * this.sy + this.ty;
    return new Ct(K, oe, me, Se, De, Je);
  }, Ct.prototype.decompose = function() {
    var I = this.sx, K = this.shy, oe = this.shx, me = this.sy, Se = this.tx, De = this.ty, Je = Math.sqrt(I * I + K * K), At = (I /= Je) * oe + (K /= Je) * me;
    oe -= I * At, me -= K * At;
    var _t = Math.sqrt(oe * oe + me * me);
    return At /= _t, I * (me /= _t) < K * (oe /= _t) && (I = -I, K = -K, At = -At, Je = -Je), { scale: new Ct(Je, 0, 0, _t, 0, 0), translate: new Ct(1, 0, 0, 1, Se, De), rotate: new Ct(I, K, -K, I, 0, 0), skew: new Ct(1, 0, At, 1, 0, 0) };
  }, Ct.prototype.toString = function(I) {
    return this.join(" ");
  }, Ct.prototype.inversed = function() {
    var I = this.sx, K = this.shy, oe = this.shx, me = this.sy, Se = this.tx, De = this.ty, Je = 1 / (I * me - K * oe), At = me * Je, _t = -K * Je, Gt = -oe * Je, Kt = I * Je;
    return new Ct(At, _t, Gt, Kt, -At * Se - Gt * De, -_t * Se - Kt * De);
  }, Ct.prototype.applyToPoint = function(I) {
    var K = I.x * this.sx + I.y * this.shx + this.tx, oe = I.x * this.shy + I.y * this.sy + this.ty;
    return new El(K, oe);
  }, Ct.prototype.applyToRectangle = function(I) {
    var K = this.applyToPoint(I), oe = this.applyToPoint(new El(I.x + I.w, I.y + I.h));
    return new ec(K.x, K.y, oe.x - K.x, oe.y - K.y);
  }, Ct.prototype.clone = function() {
    var I = this.sx, K = this.shy, oe = this.shx, me = this.sy, Se = this.tx, De = this.ty;
    return new Ct(I, K, oe, me, Se, De);
  }, f.Matrix = Ct;
  var Ti = f.matrixMult = function(I, K) {
    return K.multiply(I);
  }, Yn = new Ct(1, 0, 0, 1, 0, 0);
  f.unitMatrix = f.identityMatrix = Yn;
  var _n = function(I, K) {
    if (!Cn[I]) {
      var oe = (K instanceof Po ? "Sh" : "P") + (Object.keys(Xt).length + 1).toString(10);
      K.id = oe, Cn[I] = oe, Xt[oe] = K, rr.publish("addPattern", K);
    }
  };
  f.ShadingPattern = Po, f.TilingPattern = $A, f.addShadingPattern = function(I, K) {
    return F("addShadingPattern()"), _n(I, K), this;
  }, f.beginTilingPattern = function(I) {
    F("beginTilingPattern()"), gh(I.boundingBox[0], I.boundingBox[1], I.boundingBox[2] - I.boundingBox[0], I.boundingBox[3] - I.boundingBox[1], I.matrix);
  }, f.endTilingPattern = function(I, K) {
    F("endTilingPattern()"), K.stream = de[P].join(`
`), _n(I, K), rr.publish("endTilingPattern", K), Fi.pop().restore();
  };
  var Gr = f.__private__.newObject = function() {
    var I = ur();
    return En(I, !0), I;
  }, ur = f.__private__.newObjectDeferred = function() {
    return ie++, ue[ie] = function() {
      return ve;
    }, ie;
  }, En = function(I, K) {
    return K = typeof K == "boolean" && K, ue[I] = ve, K && G(I + " 0 obj"), I;
  }, Ps = f.__private__.newAdditionalObject = function() {
    var I = { objId: ur(), content: "" };
    return Le.push(I), I;
  }, Ki = ur(), Zn = ur(), Nn = f.__private__.decodeColorString = function(I) {
    var K = I.split(" ");
    if (K.length !== 2 || K[1] !== "g" && K[1] !== "G")
      K.length === 5 && (K[4] === "k" || K[4] === "K") && (K = [(1 - K[0]) * (1 - K[3]), (1 - K[1]) * (1 - K[3]), (1 - K[2]) * (1 - K[3]), "r"]);
    else {
      var oe = parseFloat(K[0]);
      K = [oe, oe, oe, "r"];
    }
    for (var me = "#", Se = 0; Se < 3; Se++) me += ("0" + Math.floor(255 * parseFloat(K[Se])).toString(16)).slice(-2);
    return me;
  }, qr = f.__private__.encodeColorString = function(I) {
    var K;
    typeof I == "string" && (I = { ch1: I });
    var oe = I.ch1, me = I.ch2, Se = I.ch3, De = I.ch4, Je = I.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof oe == "string" && oe.charAt(0) !== "#") {
      var At = new O3(oe);
      if (At.ok) oe = At.toHex();
      else if (!/^\d*\.?\d*$/.test(oe)) throw new Error('Invalid color "' + oe + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof oe == "string" && /^#[0-9A-Fa-f]{3}$/.test(oe) && (oe = "#" + oe[1] + oe[1] + oe[2] + oe[2] + oe[3] + oe[3]), typeof oe == "string" && /^#[0-9A-Fa-f]{6}$/.test(oe)) {
      var _t = parseInt(oe.substr(1), 16);
      oe = _t >> 16 & 255, me = _t >> 8 & 255, Se = 255 & _t;
    }
    if (me === void 0 || De === void 0 && oe === me && me === Se) if (typeof oe == "string") K = oe + " " + Je[0];
    else switch (I.precision) {
      case 2:
        K = D(oe / 255) + " " + Je[0];
        break;
      case 3:
      default:
        K = T(oe / 255) + " " + Je[0];
    }
    else if (De === void 0 || br(De) === "object") {
      if (De && !isNaN(De.a) && De.a === 0) return K = ["1.", "1.", "1.", Je[1]].join(" ");
      if (typeof oe == "string") K = [oe, me, Se, Je[1]].join(" ");
      else switch (I.precision) {
        case 2:
          K = [D(oe / 255), D(me / 255), D(Se / 255), Je[1]].join(" ");
          break;
        default:
        case 3:
          K = [T(oe / 255), T(me / 255), T(Se / 255), Je[1]].join(" ");
      }
    } else if (typeof oe == "string") K = [oe, me, Se, De, Je[2]].join(" ");
    else switch (I.precision) {
      case 2:
        K = [D(oe), D(me), D(Se), D(De), Je[2]].join(" ");
        break;
      case 3:
      default:
        K = [T(oe), T(me), T(Se), T(De), Je[2]].join(" ");
    }
    return K;
  }, Ee = f.__private__.getFilters = function() {
    return a;
  }, or = f.__private__.putStream = function(I) {
    var K = (I = I || {}).data || "", oe = I.filters || Ee(), me = I.alreadyAppliedFilters || [], Se = I.addLength1 || !1, De = K.length, Je = I.objectId, At = function(pi) {
      return pi;
    };
    if (u !== null && Je === void 0) throw new Error("ObjectId must be passed to putStream for file encryption");
    u !== null && (At = di.encryptor(Je, 0));
    var _t = {};
    oe === !0 && (oe = ["FlateEncode"]);
    var Gt = I.additionalKeyValues || [], Kt = (_t = Ft.API.processDataByFilters !== void 0 ? Ft.API.processDataByFilters(K, oe) : { data: K, reverseChain: [] }).reverseChain + (Array.isArray(me) ? me.join(" ") : me.toString());
    if (_t.data.length !== 0 && (Gt.push({ key: "Length", value: _t.data.length }), Se === !0 && Gt.push({ key: "Length1", value: De })), Kt.length != 0) if (Kt.split("/").length - 1 == 1) Gt.push({ key: "Filter", value: Kt });
    else {
      Gt.push({ key: "Filter", value: "[" + Kt + "]" });
      for (var dr = 0; dr < Gt.length; dr += 1) if (Gt[dr].key === "DecodeParms") {
        for (var Xr = [], en = 0; en < _t.reverseChain.split("/").length - 1; en += 1) Xr.push("null");
        Xr.push(Gt[dr].value), Gt[dr].value = "[" + Xr.join(" ") + "]";
      }
    }
    G("<<");
    for (var Sn = 0; Sn < Gt.length; Sn++) G("/" + Gt[Sn].key + " " + Gt[Sn].value);
    G(">>"), _t.data.length !== 0 && (G("stream"), G(At(_t.data)), G("endstream"));
  }, hi = f.__private__.putPage = function(I) {
    var K = I.number, oe = I.data, me = I.objId, Se = I.contentsObjId;
    En(me, !0), G("<</Type /Page"), G("/Parent " + I.rootDictionaryObjId + " 0 R"), G("/Resources " + I.resourceDictionaryObjId + " 0 R"), G("/MediaBox [" + parseFloat(C(I.mediaBox.bottomLeftX)) + " " + parseFloat(C(I.mediaBox.bottomLeftY)) + " " + C(I.mediaBox.topRightX) + " " + C(I.mediaBox.topRightY) + "]"), I.cropBox !== null && G("/CropBox [" + C(I.cropBox.bottomLeftX) + " " + C(I.cropBox.bottomLeftY) + " " + C(I.cropBox.topRightX) + " " + C(I.cropBox.topRightY) + "]"), I.bleedBox !== null && G("/BleedBox [" + C(I.bleedBox.bottomLeftX) + " " + C(I.bleedBox.bottomLeftY) + " " + C(I.bleedBox.topRightX) + " " + C(I.bleedBox.topRightY) + "]"), I.trimBox !== null && G("/TrimBox [" + C(I.trimBox.bottomLeftX) + " " + C(I.trimBox.bottomLeftY) + " " + C(I.trimBox.topRightX) + " " + C(I.trimBox.topRightY) + "]"), I.artBox !== null && G("/ArtBox [" + C(I.artBox.bottomLeftX) + " " + C(I.artBox.bottomLeftY) + " " + C(I.artBox.topRightX) + " " + C(I.artBox.topRightY) + "]"), typeof I.userUnit == "number" && I.userUnit !== 1 && G("/UserUnit " + I.userUnit), rr.publish("putPage", { objId: me, pageContext: gt[K], pageNumber: K, page: oe }), G("/Contents " + Se + " 0 R"), G(">>"), G("endobj");
    var De = oe.join(`
`);
    return w === b.ADVANCED && (De += `
Q`), En(Se, !0), or({ data: De, filters: Ee(), objectId: Se }), G("endobj"), me;
  }, hs = f.__private__.putPages = function() {
    var I, K, oe = [];
    for (I = 1; I <= wr; I++) gt[I].objId = ur(), gt[I].contentsObjId = ur();
    for (I = 1; I <= wr; I++) oe.push(hi({ number: I, data: de[I], objId: gt[I].objId, contentsObjId: gt[I].contentsObjId, mediaBox: gt[I].mediaBox, cropBox: gt[I].cropBox, bleedBox: gt[I].bleedBox, trimBox: gt[I].trimBox, artBox: gt[I].artBox, userUnit: gt[I].userUnit, rootDictionaryObjId: Ki, resourceDictionaryObjId: Zn }));
    En(Ki, !0), G("<</Type /Pages");
    var me = "/Kids [";
    for (K = 0; K < wr; K++) me += oe[K] + " 0 R ";
    G(me + "]"), G("/Count " + wr), G(">>"), G("endobj"), rr.publish("postPutPages");
  }, ds = function(I) {
    rr.publish("putFont", { font: I, out: G, newObject: Gr, putStream: or }), I.isAlreadyPutted !== !0 && (I.objectNumber = Gr(), G("<<"), G("/Type /Font"), G("/BaseFont /" + ou(I.postScriptName)), G("/Subtype /Type1"), typeof I.encoding == "string" && G("/Encoding /" + I.encoding), G("/FirstChar 32"), G("/LastChar 255"), G(">>"), G("endobj"));
  }, dt = function() {
    for (var I in Wt) Wt.hasOwnProperty(I) && (c === !1 || c === !0 && h.hasOwnProperty(I)) && ds(Wt[I]);
  }, be = function(I) {
    I.objectNumber = Gr();
    var K = [];
    K.push({ key: "Type", value: "/XObject" }), K.push({ key: "Subtype", value: "/Form" }), K.push({ key: "BBox", value: "[" + [C(I.x), C(I.y), C(I.x + I.width), C(I.y + I.height)].join(" ") + "]" }), K.push({ key: "Matrix", value: "[" + I.matrix.toString() + "]" });
    var oe = I.pages[1].join(`
`);
    or({ data: oe, additionalKeyValues: K, objectId: I.objectNumber }), G("endobj");
  }, Ze = function() {
    for (var I in Yr) Yr.hasOwnProperty(I) && be(Yr[I]);
  }, rt = function(I, K) {
    var oe, me = [], Se = 1 / (K - 1);
    for (oe = 0; oe < 1; oe += Se) me.push(oe);
    if (me.push(1), I[0].offset != 0) {
      var De = { offset: 0, color: I[0].color };
      I.unshift(De);
    }
    if (I[I.length - 1].offset != 1) {
      var Je = { offset: 1, color: I[I.length - 1].color };
      I.push(Je);
    }
    for (var At = "", _t = 0, Gt = 0; Gt < me.length; Gt++) {
      for (oe = me[Gt]; oe > I[_t + 1].offset; ) _t++;
      var Kt = I[_t].offset, dr = (oe - Kt) / (I[_t + 1].offset - Kt), Xr = I[_t].color, en = I[_t + 1].color;
      At += $(Math.round((1 - dr) * Xr[0] + dr * en[0]).toString(16)) + $(Math.round((1 - dr) * Xr[1] + dr * en[1]).toString(16)) + $(Math.round((1 - dr) * Xr[2] + dr * en[2]).toString(16));
    }
    return At.trim();
  }, cr = function(I, K) {
    K || (K = 21);
    var oe = Gr(), me = rt(I.colors, K), Se = [];
    Se.push({ key: "FunctionType", value: "0" }), Se.push({ key: "Domain", value: "[0.0 1.0]" }), Se.push({ key: "Size", value: "[" + K + "]" }), Se.push({ key: "BitsPerSample", value: "8" }), Se.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Se.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), or({ data: me, additionalKeyValues: Se, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: oe }), G("endobj"), I.objectNumber = Gr(), G("<< /ShadingType " + I.type), G("/ColorSpace /DeviceRGB");
    var De = "/Coords [" + C(parseFloat(I.coords[0])) + " " + C(parseFloat(I.coords[1])) + " ";
    I.type === 2 ? De += C(parseFloat(I.coords[2])) + " " + C(parseFloat(I.coords[3])) : De += C(parseFloat(I.coords[2])) + " " + C(parseFloat(I.coords[3])) + " " + C(parseFloat(I.coords[4])) + " " + C(parseFloat(I.coords[5])), G(De += "]"), I.matrix && G("/Matrix [" + I.matrix.toString() + "]"), G("/Function " + oe + " 0 R"), G("/Extend [true true]"), G(">>"), G("endobj");
  }, Pn = function(I, K) {
    var oe = ur(), me = Gr();
    K.push({ resourcesOid: oe, objectOid: me }), I.objectNumber = me;
    var Se = [];
    Se.push({ key: "Type", value: "/Pattern" }), Se.push({ key: "PatternType", value: "1" }), Se.push({ key: "PaintType", value: "1" }), Se.push({ key: "TilingType", value: "1" }), Se.push({ key: "BBox", value: "[" + I.boundingBox.map(C).join(" ") + "]" }), Se.push({ key: "XStep", value: C(I.xStep) }), Se.push({ key: "YStep", value: C(I.yStep) }), Se.push({ key: "Resources", value: oe + " 0 R" }), I.matrix && Se.push({ key: "Matrix", value: "[" + I.matrix.toString() + "]" }), or({ data: I.stream, additionalKeyValues: Se, objectId: I.objectNumber }), G("endobj");
  }, Wr = function(I) {
    var K;
    for (K in Xt) Xt.hasOwnProperty(K) && (Xt[K] instanceof Po ? cr(Xt[K]) : Xt[K] instanceof $A && Pn(Xt[K], I));
  }, Zr = function(I) {
    for (var K in I.objectNumber = Gr(), G("<<"), I) switch (K) {
      case "opacity":
        G("/ca " + D(I[K]));
        break;
      case "stroke-opacity":
        G("/CA " + D(I[K]));
    }
    G(">>"), G("endobj");
  }, Hs = function() {
    var I;
    for (I in mr) mr.hasOwnProperty(I) && Zr(mr[I]);
  }, $r = function() {
    for (var I in G("/XObject <<"), Yr) Yr.hasOwnProperty(I) && Yr[I].objectNumber >= 0 && G("/" + I + " " + Yr[I].objectNumber + " 0 R");
    rr.publish("putXobjectDict"), G(">>");
  }, dA = function() {
    di.oid = Gr(), G("<<"), G("/Filter /Standard"), G("/V " + di.v), G("/R " + di.r), G("/U <" + di.toHexString(di.U) + ">"), G("/O <" + di.toHexString(di.O) + ">"), G("/P " + di.P), G(">>"), G("endobj");
  }, pA = function() {
    for (var I in G("/Font <<"), Wt) Wt.hasOwnProperty(I) && (c === !1 || c === !0 && h.hasOwnProperty(I)) && G("/" + I + " " + Wt[I].objectNumber + " 0 R");
    G(">>");
  }, eh = function() {
    if (Object.keys(Xt).length > 0) {
      for (var I in G("/Shading <<"), Xt) Xt.hasOwnProperty(I) && Xt[I] instanceof Po && Xt[I].objectNumber >= 0 && G("/" + I + " " + Xt[I].objectNumber + " 0 R");
      rr.publish("putShadingPatternDict"), G(">>");
    }
  }, vl = function(I) {
    if (Object.keys(Xt).length > 0) {
      for (var K in G("/Pattern <<"), Xt) Xt.hasOwnProperty(K) && Xt[K] instanceof f.TilingPattern && Xt[K].objectNumber >= 0 && Xt[K].objectNumber < I && G("/" + K + " " + Xt[K].objectNumber + " 0 R");
      rr.publish("putTilingPatternDict"), G(">>");
    }
  }, Jg = function() {
    if (Object.keys(mr).length > 0) {
      var I;
      for (I in G("/ExtGState <<"), mr) mr.hasOwnProperty(I) && mr[I].objectNumber >= 0 && G("/" + I + " " + mr[I].objectNumber + " 0 R");
      rr.publish("putGStateDict"), G(">>");
    }
  }, un = function(I) {
    En(I.resourcesOid, !0), G("<<"), G("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), pA(), eh(), vl(I.objectOid), Jg(), $r(), G(">>"), G("endobj");
  }, th = function() {
    var I = [];
    dt(), Hs(), Ze(), Wr(I), rr.publish("putResources"), I.forEach(un), un({ resourcesOid: Zn, objectOid: Number.MAX_SAFE_INTEGER }), rr.publish("postPutResources");
  }, rh = function() {
    rr.publish("putAdditionalObjects");
    for (var I = 0; I < Le.length; I++) {
      var K = Le[I];
      En(K.objId, !0), G(K.content), G("endobj");
    }
    rr.publish("postPutAdditionalObjects");
  }, nh = function(I) {
    kt[I.fontName] = kt[I.fontName] || {}, kt[I.fontName][I.fontStyle] = I.id;
  }, Vu = function(I, K, oe, me, Se) {
    var De = { id: "F" + (Object.keys(Wt).length + 1).toString(10), postScriptName: I, fontName: K, fontStyle: oe, encoding: me, isStandardFont: Se || !1, metadata: {} };
    return rr.publish("addFont", { font: De, instance: this }), Wt[De.id] = De, nh(De), De.id;
  }, Yg = function(I) {
    for (var K = 0, oe = ae.length; K < oe; K++) {
      var me = Vu.call(this, I[K][0], I[K][1], I[K][2], ae[K][3], !0);
      c === !1 && (h[me] = !0);
      var Se = I[K][0].split("-");
      nh({ id: me, fontName: Se[0], fontStyle: Se[1] || "" });
    }
    rr.publish("addFonts", { fonts: Wt, dictionary: kt });
  }, js = function(I) {
    return I.foo = function() {
      try {
        return I.apply(this, arguments);
      } catch (me) {
        var K = me.stack || "";
        ~K.indexOf(" at ") && (K = K.split(" at ")[1]);
        var oe = "Error in function " + K.split(`
`)[0].split("<")[0] + ": " + me.message;
        if (!Lt.console) throw new Error(oe);
        Lt.console.error(oe, me), Lt.alert && alert(oe);
      }
    }, I.foo.bar = I, I.foo;
  }, bl = function(I, K) {
    var oe, me, Se, De, Je, At, _t, Gt, Kt;
    if (Se = (K = K || {}).sourceEncoding || "Unicode", Je = K.outputEncoding, (K.autoencode || Je) && Wt[St].metadata && Wt[St].metadata[Se] && Wt[St].metadata[Se].encoding && (De = Wt[St].metadata[Se].encoding, !Je && Wt[St].encoding && (Je = Wt[St].encoding), !Je && De.codePages && (Je = De.codePages[0]), typeof Je == "string" && (Je = De[Je]), Je)) {
      for (_t = !1, At = [], oe = 0, me = I.length; oe < me; oe++) (Gt = Je[I.charCodeAt(oe)]) ? At.push(String.fromCharCode(Gt)) : At.push(I[oe]), At[oe].charCodeAt(0) >> 8 && (_t = !0);
      I = At.join("");
    }
    for (oe = I.length; _t === void 0 && oe !== 0; ) I.charCodeAt(oe - 1) >> 8 && (_t = !0), oe--;
    if (!_t) return I;
    for (At = K.noBOM ? [] : [254, 255], oe = 0, me = I.length; oe < me; oe++) {
      if ((Kt = (Gt = I.charCodeAt(oe)) >> 8) >> 8) throw new Error("Character at position " + oe + " of string '" + I + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      At.push(Kt), At.push(Gt - (Kt << 8));
    }
    return String.fromCharCode.apply(void 0, At);
  }, $i = f.__private__.pdfEscape = f.pdfEscape = function(I, K) {
    return bl(I, K).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, zu = f.__private__.beginPage = function(I) {
    de[++wr] = [], gt[wr] = { objId: 0, contentsObjId: 0, userUnit: Number(o), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(I[0]), topRightY: Number(I[1]) } }, sh(wr), Ae(de[P]);
  }, ih = function(I, K) {
    var oe, me, Se;
    switch (t = K || t, typeof I == "string" && (oe = m(I.toLowerCase()), Array.isArray(oe) && (me = oe[0], Se = oe[1])), Array.isArray(I) && (me = I[0] * et, Se = I[1] * et), isNaN(me) && (me = i[0], Se = i[1]), (me > 14400 || Se > 14400) && (Lr.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), me = Math.min(14400, me), Se = Math.min(14400, Se)), i = [me, Se], t.substr(0, 1)) {
      case "l":
        Se > me && (i = [Se, me]);
        break;
      case "p":
        me > Se && (i = [Se, me]);
    }
    zu(i), ch(Xu), G(Ks), Yu !== 0 && G(Yu + " J"), Zu !== 0 && G(Zu + " j"), rr.publish("addPage", { pageNumber: wr });
  }, Zg = function(I) {
    I > 0 && I <= wr && (de.splice(I, 1), gt.splice(I, 1), wr--, P > wr && (P = wr), this.setPage(P));
  }, sh = function(I) {
    I > 0 && I <= wr && (P = I);
  }, em = f.__private__.getNumberOfPages = f.getNumberOfPages = function() {
    return de.length - 1;
  }, ah = function(I, K, oe) {
    var me, Se = void 0;
    return oe = oe || {}, I = I !== void 0 ? I : Wt[St].fontName, K = K !== void 0 ? K : Wt[St].fontStyle, me = I.toLowerCase(), kt[me] !== void 0 && kt[me][K] !== void 0 ? Se = kt[me][K] : kt[I] !== void 0 && kt[I][K] !== void 0 ? Se = kt[I][K] : oe.disableWarning === !1 && Lr.warn("Unable to look up font label for font '" + I + "', '" + K + "'. Refer to getFontList() for available fonts."), Se || oe.noFallback || (Se = kt.times[K]) == null && (Se = kt.times.normal), Se;
  }, tm = f.__private__.putInfo = function() {
    var I = Gr(), K = function(me) {
      return me;
    };
    for (var oe in u !== null && (K = di.encryptor(I, 0)), G("<<"), G("/Producer (" + $i(K("jsPDF " + Ft.version)) + ")"), ut) ut.hasOwnProperty(oe) && ut[oe] && G("/" + oe.substr(0, 1).toUpperCase() + oe.substr(1) + " (" + $i(K(ut[oe])) + ")");
    G("/CreationDate (" + $i(K(X)) + ")"), G(">>"), G("endobj");
  }, Gu = f.__private__.putCatalog = function(I) {
    var K = (I = I || {}).rootDictionaryObjId || Ki;
    switch (Gr(), G("<<"), G("/Type /Catalog"), G("/Pages " + K + " 0 R"), ce || (ce = "fullwidth"), ce) {
      case "fullwidth":
        G("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        G("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        G("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        G("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var oe = "" + ce;
        oe.substr(oe.length - 1) === "%" && (ce = parseInt(ce) / 100), typeof ce == "number" && G("/OpenAction [3 0 R /XYZ null null " + D(ce) + "]");
    }
    switch (Ge || (Ge = "continuous"), Ge) {
      case "continuous":
        G("/PageLayout /OneColumn");
        break;
      case "single":
        G("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        G("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        G("/PageLayout /TwoColumnRight");
    }
    Oe && G("/PageMode /" + Oe), rr.publish("putCatalog"), G(">>"), G("endobj");
  }, rm = f.__private__.putTrailer = function() {
    G("trailer"), G("<<"), G("/Size " + (ie + 1)), G("/Root " + ie + " 0 R"), G("/Info " + (ie - 1) + " 0 R"), u !== null && G("/Encrypt " + di.oid + " 0 R"), G("/ID [ <" + z + "> <" + z + "> ]"), G(">>");
  }, nm = f.__private__.putHeader = function() {
    G("%PDF-" + d), G("%ºß¬à");
  }, im = f.__private__.putXRef = function() {
    var I = "0000000000";
    G("xref"), G("0 " + (ie + 1)), G("0000000000 65535 f ");
    for (var K = 1; K <= ie; K++)
      typeof ue[K] == "function" ? G((I + ue[K]()).slice(-10) + " 00000 n ") : ue[K] !== void 0 ? G((I + ue[K]).slice(-10) + " 00000 n ") : G("0000000000 00000 n ");
  }, Ra = f.__private__.buildDocument = function() {
    M(), Ae(he), rr.publish("buildDocument"), nm(), hs(), rh(), th(), u !== null && dA(), tm(), Gu();
    var I = ve;
    return im(), rm(), G("startxref"), G("" + I), G("%%EOF"), Ae(de[P]), he.join(`
`);
  }, yl = f.__private__.getBlob = function(I) {
    return new Blob([ee(I)], { type: "application/pdf" });
  }, wl = f.output = f.__private__.output = js(function(I, K) {
    switch (typeof (K = K || {}) == "string" ? K = { filename: K } : K.filename = K.filename || "generated.pdf", I) {
      case void 0:
        return Ra();
      case "save":
        f.save(K.filename);
        break;
      case "arraybuffer":
        return ee(Ra());
      case "blob":
        return yl(Ra());
      case "bloburi":
      case "bloburl":
        if (Lt.URL !== void 0 && typeof Lt.URL.createObjectURL == "function") return Lt.URL && Lt.URL.createObjectURL(yl(Ra())) || void 0;
        Lr.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var oe = "", me = Ra();
        try {
          oe = bv(me);
        } catch {
          oe = bv(unescape(encodeURIComponent(me)));
        }
        return "data:application/pdf;filename=" + K.filename + ";base64," + oe;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(Lt) === "[object Window]") {
          var Se = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", De = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          K.pdfObjectUrl && (Se = K.pdfObjectUrl, De = "");
          var Je = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + Se + '"' + De + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(K) + ");<\/script></body></html>", At = Lt.open();
          return At !== null && At.document.write(Je), At;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(Lt) === "[object Window]") {
          var _t = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (K.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + K.filename + '" width="500px" height="400px" /></body></html>', Gt = Lt.open();
          if (Gt !== null) {
            Gt.document.write(_t);
            var Kt = this;
            Gt.document.documentElement.querySelector("#pdfViewer").onload = function() {
              Gt.document.title = K.filename, Gt.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(Kt.output("bloburl"));
            };
          }
          return Gt;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(Lt) !== "[object Window]") throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var dr = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", K) + '"></iframe></body></html>', Xr = Lt.open();
        if (Xr !== null && (Xr.document.write(dr), Xr.document.title = K.filename), Xr || typeof safari > "u") return Xr;
        break;
      case "datauri":
      case "dataurl":
        return Lt.document.location.href = this.output("datauristring", K);
      default:
        return null;
    }
  }), oh = function(I) {
    return Array.isArray(Rs) === !0 && Rs.indexOf(I) > -1;
  };
  switch (n) {
    case "pt":
      et = 1;
      break;
    case "mm":
      et = 72 / 25.4;
      break;
    case "cm":
      et = 72 / 2.54;
      break;
    case "in":
      et = 72;
      break;
    case "px":
      et = oh("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      et = 12;
      break;
    case "ex":
      et = 6;
      break;
    default:
      if (typeof n != "number") throw new Error("Invalid unit: " + n);
      et = n;
  }
  var di = null;
  Z(), V();
  var sm = function(I) {
    return u !== null ? di.encryptor(I, 0) : function(K) {
      return K;
    };
  }, Ah = f.__private__.getPageInfo = f.getPageInfo = function(I) {
    if (isNaN(I) || I % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: gt[I].objId, pageNumber: I, pageContext: gt[I] };
  }, Rt = f.__private__.getPageInfoByObjId = function(I) {
    if (isNaN(I) || I % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var K in gt) if (gt[K].objId === I) break;
    return Ah(K);
  }, am = f.__private__.getCurrentPageInfo = f.getCurrentPageInfo = function() {
    return { objId: gt[P].objId, pageNumber: P, pageContext: gt[P] };
  };
  f.addPage = function() {
    return ih.apply(this, arguments), this;
  }, f.setPage = function() {
    return sh.apply(this, arguments), Ae.call(this, de[P]), this;
  }, f.insertPage = function(I) {
    return this.addPage(), this.movePage(P, I), this;
  }, f.movePage = function(I, K) {
    var oe, me;
    if (I > K) {
      oe = de[I], me = gt[I];
      for (var Se = I; Se > K; Se--) de[Se] = de[Se - 1], gt[Se] = gt[Se - 1];
      de[K] = oe, gt[K] = me, this.setPage(K);
    } else if (I < K) {
      oe = de[I], me = gt[I];
      for (var De = I; De < K; De++) de[De] = de[De + 1], gt[De] = gt[De + 1];
      de[K] = oe, gt[K] = me, this.setPage(K);
    }
    return this;
  }, f.deletePage = function() {
    return Zg.apply(this, arguments), this;
  }, f.__private__.text = f.text = function(I, K, oe, me, Se) {
    var De, Je, At, _t, Gt, Kt, dr, Xr, en, Sn = (me = me || {}).scope || this;
    if (typeof I == "number" && typeof K == "number" && (typeof oe == "string" || Array.isArray(oe))) {
      var pi = oe;
      oe = K, K = I, I = pi;
    }
    if (arguments[3] instanceof Ct ? (F("The transform parameter of text() with a Matrix value"), en = Se) : (At = arguments[4], _t = arguments[5], br(dr = arguments[3]) === "object" && dr !== null || (typeof At == "string" && (_t = At, At = null), typeof dr == "string" && (_t = dr, dr = null), typeof dr == "number" && (At = dr, dr = null), me = { flags: dr, angle: At, align: _t })), isNaN(K) || isNaN(oe) || I == null) throw new Error("Invalid arguments passed to jsPDF.text");
    if (I.length === 0) return Sn;
    var Hn = "", $s = !1, rs = typeof me.lineHeightFactor == "number" ? me.lineHeightFactor : mA, ma = Sn.internal.scaleFactor;
    function mh(Mr) {
      return Mr = Mr.split("	").join(Array(me.TabLen || 9).join(" ")), $i(Mr, dr);
    }
    function ic(Mr) {
      for (var Rr, fn = Mr.concat(), On = [], $a = fn.length; $a--; ) typeof (Rr = fn.shift()) == "string" ? On.push(Rr) : Array.isArray(Mr) && (Rr.length === 1 || Rr[1] === void 0 && Rr[2] === void 0) ? On.push(Rr[0]) : On.push([Rr[0], Rr[1], Rr[2]]);
      return On;
    }
    function sc(Mr, Rr) {
      var fn;
      if (typeof Mr == "string") fn = Rr(Mr)[0];
      else if (Array.isArray(Mr)) {
        for (var On, $a, hc = Mr.concat(), Ql = [], Bh = hc.length; Bh--; ) typeof (On = hc.shift()) == "string" ? Ql.push(Rr(On)[0]) : Array.isArray(On) && typeof On[0] == "string" && ($a = Rr(On[0], On[1], On[2]), Ql.push([$a[0], $a[1], $a[2]]));
        fn = Ql;
      }
      return fn;
    }
    var Il = !1, ac = !0;
    if (typeof I == "string") Il = !0;
    else if (Array.isArray(I)) {
      var oc = I.concat();
      Je = [];
      for (var Fl, ei = oc.length; ei--; ) (typeof (Fl = oc.shift()) != "string" || Array.isArray(Fl) && typeof Fl[0] != "string") && (ac = !1);
      Il = ac;
    }
    if (Il === !1) throw new Error('Type of text must be string or Array. "' + I + '" is not recognized.');
    typeof I == "string" && (I = I.match(/[\r?\n]/) ? I.split(/\r\n|\r|\n/g) : [I]);
    var Tl = re / Sn.internal.scaleFactor, xl = Tl * (rs - 1);
    switch (me.baseline) {
      case "bottom":
        oe -= xl;
        break;
      case "top":
        oe += Tl - xl;
        break;
      case "hanging":
        oe += Tl - 2 * xl;
        break;
      case "middle":
        oe += Tl / 2 - xl;
    }
    if ((Kt = me.maxWidth || 0) > 0 && (typeof I == "string" ? I = Sn.splitTextToSize(I, Kt) : Object.prototype.toString.call(I) === "[object Array]" && (I = I.reduce(function(Mr, Rr) {
      return Mr.concat(Sn.splitTextToSize(Rr, Kt));
    }, []))), De = { text: I, x: K, y: oe, options: me, mutex: { pdfEscape: $i, activeFontKey: St, fonts: Wt, activeFontSize: re } }, rr.publish("preProcessText", De), I = De.text, At = (me = De.options).angle, !(en instanceof Ct) && At && typeof At == "number") {
      At *= Math.PI / 180, me.rotationDirection === 0 && (At = -At), w === b.ADVANCED && (At = -At);
      var kl = Math.cos(At), Ac = Math.sin(At);
      en = new Ct(kl, Ac, -Ac, kl, 0, 0);
    } else At && At instanceof Ct && (en = At);
    w !== b.ADVANCED || en || (en = Yn), (Gt = me.charSpace || _l) !== void 0 && (Hn += C(E(Gt)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (Xr = me.horizontalScale) !== void 0 && (Hn += C(100 * Xr) + ` Tz
`), me.lang;
    var Vi = -1, gm = me.renderingMode !== void 0 ? me.renderingMode : me.stroke, lc = Sn.internal.getCurrentPageInfo().pageContext;
    switch (gm) {
      case 0:
      case !1:
      case "fill":
        Vi = 0;
        break;
      case 1:
      case !0:
      case "stroke":
        Vi = 1;
        break;
      case 2:
      case "fillThenStroke":
        Vi = 2;
        break;
      case 3:
      case "invisible":
        Vi = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        Vi = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        Vi = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        Vi = 6;
        break;
      case 7:
      case "addToPathForClipping":
        Vi = 7;
    }
    var vh = lc.usedRenderingMode !== void 0 ? lc.usedRenderingMode : -1;
    Vi !== -1 ? Hn += Vi + ` Tr
` : vh !== -1 && (Hn += `0 Tr
`), Vi !== -1 && (lc.usedRenderingMode = Vi), _t = me.align || "left";
    var ps, Ll = re * rs, bh = Sn.internal.pageSize.getWidth(), yh = Wt[St];
    Gt = me.charSpace || _l, Kt = me.maxWidth || 0, dr = Object.assign({ autoencode: !0, noBOM: !0 }, me.flags);
    var bo = [], yA = function(Mr) {
      return Sn.getStringUnitWidth(Mr, { font: yh, charSpace: Gt, fontSize: re, doKerning: !1 }) * re / ma;
    };
    if (Object.prototype.toString.call(I) === "[object Array]") {
      var zi;
      Je = ic(I), _t !== "left" && (ps = Je.map(yA));
      var xi, yo = 0;
      if (_t === "right") {
        K -= ps[0], I = [], ei = Je.length;
        for (var Ha = 0; Ha < ei; Ha++) Ha === 0 ? (xi = ga(K), zi = Pa(oe)) : (xi = E(yo - ps[Ha]), zi = -Ll), I.push([Je[Ha], xi, zi]), yo = ps[Ha];
      } else if (_t === "center") {
        K -= ps[0] / 2, I = [], ei = Je.length;
        for (var ja = 0; ja < ei; ja++) ja === 0 ? (xi = ga(K), zi = Pa(oe)) : (xi = E((yo - ps[ja]) / 2), zi = -Ll), I.push([Je[ja], xi, zi]), yo = ps[ja];
      } else if (_t === "left") {
        I = [], ei = Je.length;
        for (var Ul = 0; Ul < ei; Ul++) I.push(Je[Ul]);
      } else if (_t === "justify" && yh.encoding === "Identity-H") {
        I = [], ei = Je.length, Kt = Kt !== 0 ? Kt : bh;
        for (var Ka = 0, cn = 0; cn < ei; cn++) if (zi = cn === 0 ? Pa(oe) : -Ll, xi = cn === 0 ? ga(K) : Ka, cn < ei - 1) {
          var uc = E((Kt - ps[cn]) / (Je[cn].split(" ").length - 1)), ki = Je[cn].split(" ");
          I.push([ki[0] + " ", xi, zi]), Ka = 0;
          for (var gs = 1; gs < ki.length; gs++) {
            var Nl = (yA(ki[gs - 1] + " " + ki[gs]) - yA(ki[gs])) * ma + uc;
            gs == ki.length - 1 ? I.push([ki[gs], Nl, 0]) : I.push([ki[gs] + " ", Nl, 0]), Ka -= Nl;
          }
        } else I.push([Je[cn], xi, zi]);
        I.push(["", Ka, 0]);
      } else {
        if (_t !== "justify") throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        for (I = [], ei = Je.length, Kt = Kt !== 0 ? Kt : bh, cn = 0; cn < ei; cn++) zi = cn === 0 ? Pa(oe) : -Ll, xi = cn === 0 ? ga(K) : 0, cn < ei - 1 ? bo.push(C(E((Kt - ps[cn]) / (Je[cn].split(" ").length - 1)))) : bo.push(0), I.push([Je[cn], xi, zi]);
      }
    }
    var wh = typeof me.R2L == "boolean" ? me.R2L : Te;
    wh === !0 && (I = sc(I, function(Mr, Rr, fn) {
      return [Mr.split("").reverse().join(""), Rr, fn];
    })), De = { text: I, x: K, y: oe, options: me, mutex: { pdfEscape: $i, activeFontKey: St, fonts: Wt, activeFontSize: re } }, rr.publish("postProcessText", De), I = De.text, $s = De.mutex.isHex || !1;
    var cc = Wt[St].encoding;
    cc !== "WinAnsiEncoding" && cc !== "StandardEncoding" || (I = sc(I, function(Mr, Rr, fn) {
      return [mh(Mr), Rr, fn];
    })), Je = ic(I), I = [];
    for (var wA, BA, wo, CA = 0, Ol = 1, _A = Array.isArray(Je[0]) ? Ol : CA, Bo = "", fc = function(Mr, Rr, fn) {
      var On = "";
      return fn instanceof Ct ? (fn = typeof me.angle == "number" ? Ti(fn, new Ct(1, 0, 0, 1, Mr, Rr)) : Ti(new Ct(1, 0, 0, 1, Mr, Rr), fn), w === b.ADVANCED && (fn = Ti(new Ct(1, 0, 0, -1, 0, 0), fn)), On = fn.join(" ") + ` Tm
`) : On = C(Mr) + " " + C(Rr) + ` Td
`, On;
    }, ms = 0; ms < Je.length; ms++) {
      switch (Bo = "", _A) {
        case Ol:
          wo = ($s ? "<" : "(") + Je[ms][0] + ($s ? ">" : ")"), wA = parseFloat(Je[ms][1]), BA = parseFloat(Je[ms][2]);
          break;
        case CA:
          wo = ($s ? "<" : "(") + Je[ms] + ($s ? ">" : ")"), wA = ga(K), BA = Pa(oe);
      }
      bo !== void 0 && bo[ms] !== void 0 && (Bo = bo[ms] + ` Tw
`), ms === 0 ? I.push(Bo + fc(wA, BA, en) + wo) : _A === CA ? I.push(Bo + wo) : _A === Ol && I.push(Bo + fc(wA, BA, en) + wo);
    }
    I = _A === CA ? I.join(` Tj
T* `) : I.join(` Tj
`), I += ` Tj
`;
    var vs = `BT
/`;
    return vs += St + " " + re + ` Tf
`, vs += C(re * rs) + ` TL
`, vs += vA + `
`, vs += Hn, vs += I, G(vs += "ET"), h[St] = !0, Sn;
  };
  var om = f.__private__.clip = f.clip = function(I) {
    return G(I === "evenodd" ? "W*" : "W"), this;
  };
  f.clipEvenOdd = function() {
    return om("evenodd");
  }, f.__private__.discardPath = f.discardPath = function() {
    return G("n"), this;
  };
  var pa = f.__private__.isValidStyle = function(I) {
    var K = !1;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(I) !== -1 && (K = !0), K;
  };
  f.__private__.setDefaultPathOperation = f.setDefaultPathOperation = function(I) {
    return pa(I) && (l = I), this;
  };
  var lh = f.__private__.getStyle = f.getStyle = function(I) {
    var K = l;
    switch (I) {
      case "D":
      case "S":
        K = "S";
        break;
      case "F":
        K = "f";
        break;
      case "FD":
      case "DF":
        K = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        K = I;
    }
    return K;
  }, uh = f.close = function() {
    return G("h"), this;
  };
  f.stroke = function() {
    return G("S"), this;
  }, f.fill = function(I) {
    return Bl("f", I), this;
  }, f.fillEvenOdd = function(I) {
    return Bl("f*", I), this;
  }, f.fillStroke = function(I) {
    return Bl("B", I), this;
  }, f.fillStrokeEvenOdd = function(I) {
    return Bl("B*", I), this;
  };
  var Bl = function(I, K) {
    br(K) === "object" ? lm(K, I) : G(I);
  }, qu = function(I) {
    I === null || w === b.ADVANCED && I === void 0 || (I = lh(I), G(I));
  };
  function Am(I, K, oe, me, Se) {
    var De = new $A(K || this.boundingBox, oe || this.xStep, me || this.yStep, this.gState, Se || this.matrix);
    De.stream = this.stream;
    var Je = I + "$$" + this.cloneIndex++ + "$$";
    return _n(Je, De), De;
  }
  var lm = function(I, K) {
    var oe = Cn[I.key], me = Xt[oe];
    if (me instanceof Po) G("q"), G(um(K)), me.gState && f.setGState(me.gState), G(I.matrix.toString() + " cm"), G("/" + oe + " sh"), G("Q");
    else if (me instanceof $A) {
      var Se = new Ct(1, 0, 0, -1, 0, vo());
      I.matrix && (Se = Se.multiply(I.matrix || Yn), oe = Am.call(me, I.key, I.boundingBox, I.xStep, I.yStep, Se).id), G("q"), G("/Pattern cs"), G("/" + oe + " scn"), me.gState && f.setGState(me.gState), G(K), G("Q");
    }
  }, um = function(I) {
    switch (I) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, Wu = f.moveTo = function(I, K) {
    return G(C(E(I)) + " " + C(S(K)) + " m"), this;
  }, gA = f.lineTo = function(I, K) {
    return G(C(E(I)) + " " + C(S(K)) + " l"), this;
  }, go = f.curveTo = function(I, K, oe, me, Se, De) {
    return G([C(E(I)), C(S(K)), C(E(oe)), C(S(me)), C(E(Se)), C(S(De)), "c"].join(" ")), this;
  };
  f.__private__.line = f.line = function(I, K, oe, me, Se) {
    if (isNaN(I) || isNaN(K) || isNaN(oe) || isNaN(me) || !pa(Se)) throw new Error("Invalid arguments passed to jsPDF.line");
    return w === b.COMPAT ? this.lines([[oe - I, me - K]], I, K, [1, 1], Se || "S") : this.lines([[oe - I, me - K]], I, K, [1, 1]).stroke();
  }, f.__private__.lines = f.lines = function(I, K, oe, me, Se, De) {
    var Je, At, _t, Gt, Kt, dr, Xr, en, Sn, pi, Hn, $s;
    if (typeof I == "number" && ($s = oe, oe = K, K = I, I = $s), me = me || [1, 1], De = De || !1, isNaN(K) || isNaN(oe) || !Array.isArray(I) || !Array.isArray(me) || !pa(Se) || typeof De != "boolean") throw new Error("Invalid arguments passed to jsPDF.lines");
    for (Wu(K, oe), Je = me[0], At = me[1], Gt = I.length, pi = K, Hn = oe, _t = 0; _t < Gt; _t++) (Kt = I[_t]).length === 2 ? (pi = Kt[0] * Je + pi, Hn = Kt[1] * At + Hn, gA(pi, Hn)) : (dr = Kt[0] * Je + pi, Xr = Kt[1] * At + Hn, en = Kt[2] * Je + pi, Sn = Kt[3] * At + Hn, pi = Kt[4] * Je + pi, Hn = Kt[5] * At + Hn, go(dr, Xr, en, Sn, pi, Hn));
    return De && uh(), qu(Se), this;
  }, f.path = function(I) {
    for (var K = 0; K < I.length; K++) {
      var oe = I[K], me = oe.c;
      switch (oe.op) {
        case "m":
          Wu(me[0], me[1]);
          break;
        case "l":
          gA(me[0], me[1]);
          break;
        case "c":
          go.apply(this, me);
          break;
        case "h":
          uh();
      }
    }
    return this;
  }, f.__private__.rect = f.rect = function(I, K, oe, me, Se) {
    if (isNaN(I) || isNaN(K) || isNaN(oe) || isNaN(me) || !pa(Se)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return w === b.COMPAT && (me = -me), G([C(E(I)), C(S(K)), C(E(oe)), C(E(me)), "re"].join(" ")), qu(Se), this;
  }, f.__private__.triangle = f.triangle = function(I, K, oe, me, Se, De, Je) {
    if (isNaN(I) || isNaN(K) || isNaN(oe) || isNaN(me) || isNaN(Se) || isNaN(De) || !pa(Je)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[oe - I, me - K], [Se - oe, De - me], [I - Se, K - De]], I, K, [1, 1], Je, !0), this;
  }, f.__private__.roundedRect = f.roundedRect = function(I, K, oe, me, Se, De, Je) {
    if (isNaN(I) || isNaN(K) || isNaN(oe) || isNaN(me) || isNaN(Se) || isNaN(De) || !pa(Je)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var At = 4 / 3 * (Math.SQRT2 - 1);
    return Se = Math.min(Se, 0.5 * oe), De = Math.min(De, 0.5 * me), this.lines([[oe - 2 * Se, 0], [Se * At, 0, Se, De - De * At, Se, De], [0, me - 2 * De], [0, De * At, -Se * At, De, -Se, De], [2 * Se - oe, 0], [-Se * At, 0, -Se, -De * At, -Se, -De], [0, 2 * De - me], [0, -De * At, Se * At, -De, Se, -De]], I + Se, K, [1, 1], Je, !0), this;
  }, f.__private__.ellipse = f.ellipse = function(I, K, oe, me, Se) {
    if (isNaN(I) || isNaN(K) || isNaN(oe) || isNaN(me) || !pa(Se)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var De = 4 / 3 * (Math.SQRT2 - 1) * oe, Je = 4 / 3 * (Math.SQRT2 - 1) * me;
    return Wu(I + oe, K), go(I + oe, K - Je, I + De, K - me, I, K - me), go(I - De, K - me, I - oe, K - Je, I - oe, K), go(I - oe, K + Je, I - De, K + me, I, K + me), go(I + De, K + me, I + oe, K + Je, I + oe, K), qu(Se), this;
  }, f.__private__.circle = f.circle = function(I, K, oe, me) {
    if (isNaN(I) || isNaN(K) || isNaN(oe) || !pa(me)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(I, K, oe, oe, me);
  }, f.setFont = function(I, K, oe) {
    return oe && (K = x(K, oe)), St = ah(I, K, { disableWarning: !1 }), this;
  };
  var cm = f.__private__.getFont = f.getFont = function() {
    return Wt[ah.apply(f, arguments)];
  };
  f.__private__.getFontList = f.getFontList = function() {
    var I, K, oe = {};
    for (I in kt) if (kt.hasOwnProperty(I)) for (K in oe[I] = [], kt[I]) kt[I].hasOwnProperty(K) && oe[I].push(K);
    return oe;
  }, f.addFont = function(I, K, oe, me, Se) {
    var De = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && De.indexOf(arguments[3]) !== -1 ? Se = arguments[3] : arguments[3] && De.indexOf(arguments[3]) == -1 && (oe = x(oe, me)), Se = Se || "Identity-H", Vu.call(this, I, K, oe, Se);
  };
  var mA, Xu = r.lineWidth || 0.200025, Cl = f.__private__.getLineWidth = f.getLineWidth = function() {
    return Xu;
  }, ch = f.__private__.setLineWidth = f.setLineWidth = function(I) {
    return Xu = I, G(C(E(I)) + " w"), this;
  };
  f.__private__.setLineDash = Ft.API.setLineDash = Ft.API.setLineDashPattern = function(I, K) {
    if (I = I || [], K = K || 0, isNaN(K) || !Array.isArray(I)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return I = I.map(function(oe) {
      return C(E(oe));
    }).join(" "), K = C(E(K)), G("[" + I + "] " + K + " d"), this;
  };
  var fh = f.__private__.getLineHeight = f.getLineHeight = function() {
    return re * mA;
  };
  f.__private__.getLineHeight = f.getLineHeight = function() {
    return re * mA;
  };
  var hh = f.__private__.setLineHeightFactor = f.setLineHeightFactor = function(I) {
    return typeof (I = I || 1.15) == "number" && (mA = I), this;
  }, dh = f.__private__.getLineHeightFactor = f.getLineHeightFactor = function() {
    return mA;
  };
  hh(r.lineHeight);
  var ga = f.__private__.getHorizontalCoordinate = function(I) {
    return E(I);
  }, Pa = f.__private__.getVerticalCoordinate = function(I) {
    return w === b.ADVANCED ? I : gt[P].mediaBox.topRightY - gt[P].mediaBox.bottomLeftY - E(I);
  }, fm = f.__private__.getHorizontalCoordinateString = f.getHorizontalCoordinateString = function(I) {
    return C(ga(I));
  }, mo = f.__private__.getVerticalCoordinateString = f.getVerticalCoordinateString = function(I) {
    return C(Pa(I));
  }, Ks = r.strokeColor || "0 G";
  f.__private__.getStrokeColor = f.getDrawColor = function() {
    return Nn(Ks);
  }, f.__private__.setStrokeColor = f.setDrawColor = function(I, K, oe, me) {
    return Ks = qr({ ch1: I, ch2: K, ch3: oe, ch4: me, pdfColorType: "draw", precision: 2 }), G(Ks), this;
  };
  var Ju = r.fillColor || "0 g";
  f.__private__.getFillColor = f.getFillColor = function() {
    return Nn(Ju);
  }, f.__private__.setFillColor = f.setFillColor = function(I, K, oe, me) {
    return Ju = qr({ ch1: I, ch2: K, ch3: oe, ch4: me, pdfColorType: "fill", precision: 2 }), G(Ju), this;
  };
  var vA = r.textColor || "0 g", hm = f.__private__.getTextColor = f.getTextColor = function() {
    return Nn(vA);
  };
  f.__private__.setTextColor = f.setTextColor = function(I, K, oe, me) {
    return vA = qr({ ch1: I, ch2: K, ch3: oe, ch4: me, pdfColorType: "text", precision: 3 }), this;
  };
  var _l = r.charSpace, dm = f.__private__.getCharSpace = f.getCharSpace = function() {
    return parseFloat(_l || 0);
  };
  f.__private__.setCharSpace = f.setCharSpace = function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return _l = I, this;
  };
  var Yu = 0;
  f.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, f.__private__.setLineCap = f.setLineCap = function(I) {
    var K = f.CapJoinStyles[I];
    if (K === void 0) throw new Error("Line cap style of '" + I + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Yu = K, G(K + " J"), this;
  };
  var Zu = 0;
  f.__private__.setLineJoin = f.setLineJoin = function(I) {
    var K = f.CapJoinStyles[I];
    if (K === void 0) throw new Error("Line join style of '" + I + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Zu = K, G(K + " j"), this;
  }, f.__private__.setLineMiterLimit = f.__private__.setMiterLimit = f.setLineMiterLimit = f.setMiterLimit = function(I) {
    if (I = I || 0, isNaN(I)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return G(C(E(I)) + " M"), this;
  }, f.GState = Sf, f.setGState = function(I) {
    (I = typeof I == "string" ? mr[Ir[I]] : ph(null, I)).equals(hr) || (G("/" + I.id + " gs"), hr = I);
  };
  var ph = function(I, K) {
    if (!I || !Ir[I]) {
      var oe = !1;
      for (var me in mr) if (mr.hasOwnProperty(me) && mr[me].equals(K)) {
        oe = !0;
        break;
      }
      if (oe) K = mr[me];
      else {
        var Se = "GS" + (Object.keys(mr).length + 1).toString(10);
        mr[Se] = K, K.id = Se;
      }
      return I && (Ir[I] = K.id), rr.publish("addGState", K), K;
    }
  };
  f.addGState = function(I, K) {
    return ph(I, K), this;
  }, f.saveGraphicsState = function() {
    return G("q"), Dr.push({ key: St, size: re, color: vA }), this;
  }, f.restoreGraphicsState = function() {
    G("Q");
    var I = Dr.pop();
    return St = I.key, re = I.size, vA = I.color, hr = null, this;
  }, f.setCurrentTransformationMatrix = function(I) {
    return G(I.toString() + " cm"), this;
  }, f.comment = function(I) {
    return G("#" + I), this;
  };
  var El = function(I, K) {
    var oe = I || 0;
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return oe;
    }, set: function(De) {
      isNaN(De) || (oe = parseFloat(De));
    } });
    var me = K || 0;
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return me;
    }, set: function(De) {
      isNaN(De) || (me = parseFloat(De));
    } });
    var Se = "pt";
    return Object.defineProperty(this, "type", { enumerable: !0, get: function() {
      return Se;
    }, set: function(De) {
      Se = De.toString();
    } }), this;
  }, ec = function(I, K, oe, me) {
    El.call(this, I, K), this.type = "rect";
    var Se = oe || 0;
    Object.defineProperty(this, "w", { enumerable: !0, get: function() {
      return Se;
    }, set: function(Je) {
      isNaN(Je) || (Se = parseFloat(Je));
    } });
    var De = me || 0;
    return Object.defineProperty(this, "h", { enumerable: !0, get: function() {
      return De;
    }, set: function(Je) {
      isNaN(Je) || (De = parseFloat(Je));
    } }), this;
  }, tc = function() {
    this.page = wr, this.currentPage = P, this.pages = de.slice(0), this.pagesContext = gt.slice(0), this.x = gr, this.y = bt, this.matrix = Qr, this.width = bA(P), this.height = vo(P), this.outputDestination = Qe, this.id = "", this.objectNumber = -1;
  };
  tc.prototype.restore = function() {
    wr = this.page, P = this.currentPage, gt = this.pagesContext, de = this.pages, gr = this.x, bt = this.y, Qr = this.matrix, rc(P, this.width), nc(P, this.height), Qe = this.outputDestination;
  };
  var gh = function(I, K, oe, me, Se) {
    Fi.push(new tc()), wr = P = 0, de = [], gr = I, bt = K, Qr = Se, zu([oe, me]);
  }, pm = function(I) {
    if (fi[I]) Fi.pop().restore();
    else {
      var K = new tc(), oe = "Xo" + (Object.keys(Yr).length + 1).toString(10);
      K.id = oe, fi[I] = oe, Yr[oe] = K, rr.publish("addFormObject", K), Fi.pop().restore();
    }
  };
  for (var Sl in f.beginFormObject = function(I, K, oe, me, Se) {
    return gh(I, K, oe, me, Se), this;
  }, f.endFormObject = function(I) {
    return pm(I), this;
  }, f.doFormObject = function(I, K) {
    var oe = Yr[fi[I]];
    return G("q"), G(K.toString() + " cm"), G("/" + oe.id + " Do"), G("Q"), this;
  }, f.getFormObject = function(I) {
    var K = Yr[fi[I]];
    return { x: K.x, y: K.y, width: K.width, height: K.height, matrix: K.matrix };
  }, f.save = function(I, K) {
    return I = I || "generated.pdf", (K = K || {}).returnPromise = K.returnPromise || !1, K.returnPromise === !1 ? (NA(yl(Ra()), I), typeof NA.unload == "function" && Lt.setTimeout && setTimeout(NA.unload, 911), this) : new Promise(function(oe, me) {
      try {
        var Se = NA(yl(Ra()), I);
        typeof NA.unload == "function" && Lt.setTimeout && setTimeout(NA.unload, 911), oe(Se);
      } catch (De) {
        me(De.message);
      }
    });
  }, Ft.API) Ft.API.hasOwnProperty(Sl) && (Sl === "events" && Ft.API.events.length ? function(I, K) {
    var oe, me, Se;
    for (Se = K.length - 1; Se !== -1; Se--) oe = K[Se][0], me = K[Se][1], I.subscribe.apply(I, [oe].concat(typeof me == "function" ? [me] : me));
  }(rr, Ft.API.events) : f[Sl] = Ft.API[Sl]);
  var bA = f.getPageWidth = function(I) {
    return (gt[I = I || P].mediaBox.topRightX - gt[I].mediaBox.bottomLeftX) / et;
  }, rc = f.setPageWidth = function(I, K) {
    gt[I].mediaBox.topRightX = K * et + gt[I].mediaBox.bottomLeftX;
  }, vo = f.getPageHeight = function(I) {
    return (gt[I = I || P].mediaBox.topRightY - gt[I].mediaBox.bottomLeftY) / et;
  }, nc = f.setPageHeight = function(I, K) {
    gt[I].mediaBox.topRightY = K * et + gt[I].mediaBox.bottomLeftY;
  };
  return f.internal = { pdfEscape: $i, getStyle: lh, getFont: cm, getFontSize: le, getCharSpace: dm, getTextColor: hm, getLineHeight: fh, getLineHeightFactor: dh, getLineWidth: Cl, write: ne, getHorizontalCoordinate: ga, getVerticalCoordinate: Pa, getCoordinateString: fm, getVerticalCoordinateString: mo, collections: {}, newObject: Gr, newAdditionalObject: Ps, newObjectDeferred: ur, newObjectDeferredBegin: En, getFilters: Ee, putStream: or, events: rr, scaleFactor: et, pageSize: { getWidth: function() {
    return bA(P);
  }, setWidth: function(I) {
    rc(P, I);
  }, getHeight: function() {
    return vo(P);
  }, setHeight: function(I) {
    nc(P, I);
  } }, encryptionOptions: u, encryption: di, getEncryptor: sm, output: wl, getNumberOfPages: em, pages: de, out: G, f2: D, f3: T, getPageInfo: Ah, getPageInfoByObjId: Rt, getCurrentPageInfo: am, getPDFVersion: p, Point: El, Rectangle: ec, Matrix: Ct, hasHotfix: oh }, Object.defineProperty(f.internal.pageSize, "width", { get: function() {
    return bA(P);
  }, set: function(I) {
    rc(P, I);
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(f.internal.pageSize, "height", { get: function() {
    return vo(P);
  }, set: function(I) {
    nc(P, I);
  }, enumerable: !0, configurable: !0 }), Yg.call(f, ae), St = "F1", ih(i, t), rr.publish("initialized"), f;
}
au.prototype.lsbFirstWord = function(r) {
  return String.fromCharCode(r >> 0 & 255, r >> 8 & 255, r >> 16 & 255, r >> 24 & 255);
}, au.prototype.toHexString = function(r) {
  return r.split("").map(function(e) {
    return ("0" + (255 & e.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, au.prototype.hexToBytes = function(r) {
  for (var e = [], t = 0; t < r.length; t += 2) e.push(String.fromCharCode(parseInt(r.substr(t, 2), 16)));
  return e.join("");
}, au.prototype.processOwnerPassword = function(r, e) {
  return wv(yv(e).substr(0, 5), r);
}, au.prototype.encryptor = function(r, e) {
  var t = yv(this.encryptionKey + String.fromCharCode(255 & r, r >> 8 & 255, r >> 16 & 255, 255 & e, e >> 8 & 255)).substr(0, 10);
  return function(n) {
    return wv(t, n);
  };
}, Sf.prototype.equals = function(r) {
  var e, t = "id,objectNumber,equals";
  if (!r || br(r) !== br(this)) return !1;
  var n = 0;
  for (e in this) if (!(t.indexOf(e) >= 0)) {
    if (this.hasOwnProperty(e) && !r.hasOwnProperty(e) || this[e] !== r[e]) return !1;
    n++;
  }
  for (e in r) r.hasOwnProperty(e) && t.indexOf(e) < 0 && n--;
  return n === 0;
}, Ft.API = { events: [] }, Ft.version = "2.5.2";
var rn = Ft.API, gb = 1, cl = function(r) {
  return r.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, Vl = function(r) {
  return r.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, $t = function(r) {
  return r.toFixed(2);
}, ko = function(r) {
  return r.toFixed(5);
};
rn.__acroform__ = {};
var ts = function(r, e) {
  r.prototype = Object.create(e.prototype), r.prototype.constructor = r;
}, KB = function(r) {
  return r * gb;
}, wa = function(r) {
  var e = new R3(), t = mt.internal.getHeight(r) || 0, n = mt.internal.getWidth(r) || 0;
  return e.BBox = [0, 0, Number($t(n)), Number($t(t))], e;
}, sP = rn.__acroform__.setBit = function(r, e) {
  if (r = r || 0, e = e || 0, isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return r |= 1 << e;
}, aP = rn.__acroform__.clearBit = function(r, e) {
  if (r = r || 0, e = e || 0, isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return r &= ~(1 << e);
}, oP = rn.__acroform__.getBit = function(r, e) {
  if (isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return r & 1 << e ? 1 : 0;
}, gn = rn.__acroform__.getBitForPdf = function(r, e) {
  if (isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return oP(r, e - 1);
}, mn = rn.__acroform__.setBitForPdf = function(r, e) {
  if (isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return sP(r, e - 1);
}, vn = rn.__acroform__.clearBitForPdf = function(r, e) {
  if (isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return aP(r, e - 1);
}, AP = rn.__acroform__.calculateCoordinates = function(r, e) {
  var t = e.internal.getHorizontalCoordinate, n = e.internal.getVerticalCoordinate, i = r[0], s = r[1], a = r[2], o = r[3], A = {};
  return A.lowerLeft_X = t(i) || 0, A.lowerLeft_Y = n(s + o) || 0, A.upperRight_X = t(i + a) || 0, A.upperRight_Y = n(s) || 0, [Number($t(A.lowerLeft_X)), Number($t(A.lowerLeft_Y)), Number($t(A.upperRight_X)), Number($t(A.upperRight_Y))];
}, lP = function(r) {
  if (r.appearanceStreamContent) return r.appearanceStreamContent;
  if (r.V || r.DV) {
    var e = [], t = r._V || r.DV, n = Bv(r, t), i = r.scope.internal.getFont(r.fontName, r.fontStyle).id;
    e.push("/Tx BMC"), e.push("q"), e.push("BT"), e.push(r.scope.__private__.encodeColorString(r.color)), e.push("/" + i + " " + $t(n.fontSize) + " Tf"), e.push("1 0 0 1 0 0 Tm"), e.push(n.text), e.push("ET"), e.push("Q"), e.push("EMC");
    var s = wa(r);
    return s.scope = r.scope, s.stream = e.join(`
`), s;
  }
}, Bv = function(r, e) {
  var t = r.fontSize === 0 ? r.maxFontSize : r.fontSize, n = { text: "", fontSize: "" }, i = (e = (e = e.substr(0, 1) == "(" ? e.substr(1) : e).substr(e.length - 1) == ")" ? e.substr(0, e.length - 1) : e).split(" ");
  i = r.multiline ? i.map(function(T) {
    return T.split(`
`);
  }) : i.map(function(T) {
    return [T];
  });
  var s = t, a = mt.internal.getHeight(r) || 0;
  a = a < 0 ? -a : a;
  var o = mt.internal.getWidth(r) || 0;
  o = o < 0 ? -o : o;
  var A = function(T, E, L) {
    if (T + 1 < i.length) {
      var S = E + " " + i[T + 1][0];
      return id(S, r, L).width <= o - 4;
    }
    return !1;
  };
  s++;
  e: for (; s > 0; ) {
    e = "", s--;
    var l, u, c = id("3", r, s).height, h = r.multiline ? a - s : (a - c) / 2, f = h += 2, d = 0, p = 0, v = 0;
    if (s <= 0) {
      e = `(...) Tj
`, e += "% Width of Text: " + id(e, r, s = 12).width + ", FieldWidth:" + o + `
`;
      break;
    }
    for (var m = "", b = 0, w = 0; w < i.length; w++) if (i.hasOwnProperty(w)) {
      var B = !1;
      if (i[w].length !== 1 && v !== i[w].length - 1) {
        if ((c + 2) * (b + 2) + 2 > a) continue e;
        m += i[w][v], B = !0, p = w, w--;
      } else {
        m = (m += i[w][v] + " ").substr(m.length - 1) == " " ? m.substr(0, m.length - 1) : m;
        var _ = parseInt(w), x = A(_, m, s), C = w >= i.length - 1;
        if (x && !C) {
          m += " ", v = 0;
          continue;
        }
        if (x || C) {
          if (C) p = _;
          else if (r.multiline && (c + 2) * (b + 2) + 2 > a) continue e;
        } else {
          if (!r.multiline || (c + 2) * (b + 2) + 2 > a) continue e;
          p = _;
        }
      }
      for (var F = "", N = d; N <= p; N++) {
        var D = i[N];
        if (r.multiline) {
          if (N === p) {
            F += D[v] + " ", v = (v + 1) % D.length;
            continue;
          }
          if (N === d) {
            F += D[D.length - 1] + " ";
            continue;
          }
        }
        F += D[0] + " ";
      }
      switch (F = F.substr(F.length - 1) == " " ? F.substr(0, F.length - 1) : F, u = id(F, r, s).width, r.textAlign) {
        case "right":
          l = o - u - 2;
          break;
        case "center":
          l = (o - u) / 2;
          break;
        case "left":
        default:
          l = 2;
      }
      e += $t(l) + " " + $t(f) + ` Td
`, e += "(" + cl(F) + `) Tj
`, e += -$t(l) + ` 0 Td
`, f = -(s + 2), u = 0, d = B ? p : p + 1, b++, m = "";
    }
    break;
  }
  return n.text = e, n.fontSize = s, n;
}, id = function(r, e, t) {
  var n = e.scope.internal.getFont(e.fontName, e.fontStyle), i = e.scope.getStringUnitWidth(r, { font: n, fontSize: parseFloat(t), charSpace: 0 }) * parseFloat(t);
  return { height: e.scope.getStringUnitWidth("3", { font: n, fontSize: parseFloat(t), charSpace: 0 }) * parseFloat(t) * 1.5, width: i };
}, uP = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, cP = function(r, e) {
  var t = { type: "reference", object: r };
  e.internal.getPageInfo(r.page).pageContext.annotations.find(function(n) {
    return n.type === t.type && n.object === t.object;
  }) === void 0 && e.internal.getPageInfo(r.page).pageContext.annotations.push(t);
}, fP = function(r, e) {
  for (var t in r) if (r.hasOwnProperty(t)) {
    var n = t, i = r[t];
    e.internal.newObjectDeferredBegin(i.objId, !0), br(i) === "object" && typeof i.putStream == "function" && i.putStream(), delete r[n];
  }
}, hP = function(r, e) {
  if (e.scope = r, r.internal !== void 0 && (r.internal.acroformPlugin === void 0 || r.internal.acroformPlugin.isInitialized === !1)) {
    if (Aa.FieldNum = 0, r.internal.acroformPlugin = JSON.parse(JSON.stringify(uP)), r.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    gb = r.internal.scaleFactor, r.internal.acroformPlugin.acroFormDictionaryRoot = new P3(), r.internal.acroformPlugin.acroFormDictionaryRoot.scope = r, r.internal.acroformPlugin.acroFormDictionaryRoot._eventID = r.internal.events.subscribe("postPutResources", function() {
      (function(t) {
        t.internal.events.unsubscribe(t.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t.internal.acroformPlugin.printedOut = !0;
      })(r);
    }), r.internal.events.subscribe("buildDocument", function() {
      (function(t) {
        t.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var n = t.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var i in n) if (n.hasOwnProperty(i)) {
          var s = n[i];
          s.objId = void 0, s.hasAnnotation && cP(s, t);
        }
      })(r);
    }), r.internal.events.subscribe("putCatalog", function() {
      (function(t) {
        if (t.internal.acroformPlugin.acroFormDictionaryRoot === void 0) throw new Error("putCatalogCallback: Root missing.");
        t.internal.write("/AcroForm " + t.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(r);
    }), r.internal.events.subscribe("postPutPages", function(t) {
      (function(n, i) {
        var s = !n;
        for (var a in n || (i.internal.newObjectDeferredBegin(i.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), i.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), n = n || i.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (n.hasOwnProperty(a)) {
          var o = n[a], A = [], l = o.Rect;
          if (o.Rect && (o.Rect = AP(o.Rect, i)), i.internal.newObjectDeferredBegin(o.objId, !0), o.DA = mt.createDefaultAppearanceStream(o), br(o) === "object" && typeof o.getKeyValueListForStream == "function" && (A = o.getKeyValueListForStream()), o.Rect = l, o.hasAppearanceStream && !o.appearanceStreamContent) {
            var u = lP(o);
            A.push({ key: "AP", value: "<</N " + u + ">>" }), i.internal.acroformPlugin.xForms.push(u);
          }
          if (o.appearanceStreamContent) {
            var c = "";
            for (var h in o.appearanceStreamContent) if (o.appearanceStreamContent.hasOwnProperty(h)) {
              var f = o.appearanceStreamContent[h];
              if (c += "/" + h + " ", c += "<<", Object.keys(f).length >= 1 || Array.isArray(f)) {
                for (var a in f) if (f.hasOwnProperty(a)) {
                  var d = f[a];
                  typeof d == "function" && (d = d.call(i, o)), c += "/" + a + " " + d + " ", i.internal.acroformPlugin.xForms.indexOf(d) >= 0 || i.internal.acroformPlugin.xForms.push(d);
                }
              } else typeof (d = f) == "function" && (d = d.call(i, o)), c += "/" + a + " " + d, i.internal.acroformPlugin.xForms.indexOf(d) >= 0 || i.internal.acroformPlugin.xForms.push(d);
              c += ">>";
            }
            A.push({ key: "AP", value: `<<
` + c + ">>" });
          }
          i.internal.putStream({ additionalKeyValues: A, objectId: o.objId }), i.internal.out("endobj");
        }
        s && fP(i.internal.acroformPlugin.xForms, i);
      })(t, r);
    }), r.internal.acroformPlugin.isInitialized = !0;
  }
}, M3 = rn.__acroform__.arrayToPdfArray = function(r, e, t) {
  var n = function(a) {
    return a;
  };
  if (Array.isArray(r)) {
    for (var i = "[", s = 0; s < r.length; s++) switch (s !== 0 && (i += " "), br(r[s])) {
      case "boolean":
      case "number":
      case "object":
        i += r[s].toString();
        break;
      case "string":
        r[s].substr(0, 1) !== "/" ? (e !== void 0 && t && (n = t.internal.getEncryptor(e)), i += "(" + cl(n(r[s].toString())) + ")") : i += r[s].toString();
    }
    return i += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, f0 = function(r, e, t) {
  var n = function(i) {
    return i;
  };
  return e !== void 0 && t && (n = t.internal.getEncryptor(e)), (r = r || "").toString(), r = "(" + cl(n(r)) + ")";
}, _a = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(r) {
    this._objId = r;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 });
};
_a.prototype.toString = function() {
  return this.objId + " 0 R";
}, _a.prototype.putStream = function() {
  var r = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: r, objectId: this.objId }), this.scope.internal.out("endobj");
}, _a.prototype.getKeyValueListForStream = function() {
  var r = [], e = Object.getOwnPropertyNames(this).filter(function(s) {
    return s != "content" && s != "appearanceStreamContent" && s != "scope" && s != "objId" && s.substring(0, 1) != "_";
  });
  for (var t in e) if (Object.getOwnPropertyDescriptor(this, e[t]).configurable === !1) {
    var n = e[t], i = this[n];
    i && (Array.isArray(i) ? r.push({ key: n, value: M3(i, this.objId, this.scope) }) : i instanceof _a ? (i.scope = this.scope, r.push({ key: n, value: i.objId + " 0 R" })) : typeof i != "function" && r.push({ key: n, value: i }));
  }
  return r;
};
var R3 = function() {
  _a.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 });
  var r, e = [];
  Object.defineProperty(this, "BBox", { configurable: !1, get: function() {
    return e;
  }, set: function(t) {
    e = t;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function(t) {
    r = t.trim();
  }, get: function() {
    return r || null;
  } });
};
ts(R3, _a);
var P3 = function() {
  _a.call(this);
  var r, e = [];
  Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function() {
    return e.length > 0 ? e : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function() {
    return e;
  } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function() {
    if (r) {
      var t = function(n) {
        return n;
      };
      return this.scope && (t = this.scope.internal.getEncryptor(this.objId)), "(" + cl(t(r)) + ")";
    }
  }, set: function(t) {
    r = t;
  } });
};
ts(P3, _a);
var Aa = function r() {
  _a.call(this);
  var e = 4;
  Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function() {
    return e;
  }, set: function(m) {
    if (isNaN(m)) throw new Error('Invalid value "' + m + '" for attribute F supplied.');
    e = m;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(e, 3);
  }, set: function(m) {
    m ? this.F = mn(e, 3) : this.F = vn(e, 3);
  } });
  var t = 0;
  Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(m) {
    if (isNaN(m)) throw new Error('Invalid value "' + m + '" for attribute Ff supplied.');
    t = m;
  } });
  var n = [];
  Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function() {
    if (n.length !== 0) return n;
  }, set: function(m) {
    n = m !== void 0 ? m : [];
  } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function() {
    return !n || isNaN(n[0]) ? 0 : n[0];
  }, set: function(m) {
    n[0] = m;
  } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function() {
    return !n || isNaN(n[1]) ? 0 : n[1];
  }, set: function(m) {
    n[1] = m;
  } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function() {
    return !n || isNaN(n[2]) ? 0 : n[2];
  }, set: function(m) {
    n[2] = m;
  } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function() {
    return !n || isNaN(n[3]) ? 0 : n[3];
  }, set: function(m) {
    n[3] = m;
  } });
  var i = "";
  Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function() {
    return i;
  }, set: function(m) {
    switch (m) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        i = m;
        break;
      default:
        throw new Error('Invalid value "' + m + '" for attribute FT supplied.');
    }
  } });
  var s = null;
  Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function() {
    if (!s || s.length < 1) {
      if (this instanceof Up) return;
      s = "FieldObject" + r.FieldNum++;
    }
    var m = function(b) {
      return b;
    };
    return this.scope && (m = this.scope.internal.getEncryptor(this.objId)), "(" + cl(m(s)) + ")";
  }, set: function(m) {
    s = m.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function() {
    return s;
  }, set: function(m) {
    s = m;
  } });
  var a = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function() {
    return a;
  }, set: function(m) {
    a = m;
  } });
  var o = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function() {
    return o;
  }, set: function(m) {
    o = m;
  } });
  var A = 0;
  Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function() {
    return A;
  }, set: function(m) {
    A = m;
  } });
  var l = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function() {
    return l === void 0 ? 50 / gb : l;
  }, set: function(m) {
    l = m;
  } });
  var u = "black";
  Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function() {
    return u;
  }, set: function(m) {
    u = m;
  } });
  var c = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function() {
    if (!(!c || this instanceof Up || this instanceof tA)) return f0(c, this.objId, this.scope);
  }, set: function(m) {
    m = m.toString(), c = m;
  } });
  var h = null;
  Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function() {
    if (h) return this instanceof Dn ? h : f0(h, this.objId, this.scope);
  }, set: function(m) {
    m = m.toString(), h = this instanceof Dn ? m : m.substr(0, 1) === "(" ? Vl(m.substr(1, m.length - 2)) : Vl(m);
  } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof Dn ? Vl(h.substr(1, h.length - 1)) : h;
  }, set: function(m) {
    m = m.toString(), h = this instanceof Dn ? "/" + m : m;
  } });
  var f = null;
  Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function() {
    if (f) return f;
  }, set: function(m) {
    this.V = m;
  } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function() {
    if (f) return this instanceof Dn ? f : f0(f, this.objId, this.scope);
  }, set: function(m) {
    m = m.toString(), f = this instanceof Dn ? m : m.substr(0, 1) === "(" ? Vl(m.substr(1, m.length - 2)) : Vl(m);
  } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof Dn ? Vl(f.substr(1, f.length - 1)) : f;
  }, set: function(m) {
    m = m.toString(), f = this instanceof Dn ? "/" + m : m;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var d, p = !1;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return p;
  }, set: function(m) {
    m = !!m, p = m;
  } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function() {
    if (d) return d;
  }, set: function(m) {
    d = m;
  } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 1);
  }, set: function(m) {
    m ? this.Ff = mn(this.Ff, 1) : this.Ff = vn(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 2);
  }, set: function(m) {
    m ? this.Ff = mn(this.Ff, 2) : this.Ff = vn(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 3);
  }, set: function(m) {
    m ? this.Ff = mn(this.Ff, 3) : this.Ff = vn(this.Ff, 3);
  } });
  var v = null;
  Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function() {
    if (v !== null) return v;
  }, set: function(m) {
    if ([0, 1, 2].indexOf(m) === -1) throw new Error('Invalid value "' + m + '" for attribute Q supplied.');
    v = m;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var m;
    switch (v) {
      case 0:
      default:
        m = "left";
        break;
      case 1:
        m = "center";
        break;
      case 2:
        m = "right";
    }
    return m;
  }, configurable: !0, enumerable: !0, set: function(m) {
    switch (m) {
      case "right":
      case 2:
        v = 2;
        break;
      case "center":
      case 1:
        v = 1;
        break;
      case "left":
      case 0:
      default:
        v = 0;
    }
  } });
};
ts(Aa, _a);
var ZA = function() {
  Aa.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var r = 0;
  Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function() {
    return r;
  }, set: function(t) {
    r = t;
  } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function() {
    return r;
  }, set: function(t) {
    r = t;
  } });
  var e = [];
  Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function() {
    return M3(e, this.objId, this.scope);
  }, set: function(t) {
    var n, i;
    i = [], typeof (n = t) == "string" && (i = function(s, a, o) {
      o || (o = 1);
      for (var A, l = []; A = a.exec(s); ) l.push(A[o]);
      return l;
    }(n, /\((.*?)\)/g)), e = i;
  } }), this.getOptions = function() {
    return e;
  }, this.setOptions = function(t) {
    e = t, this.sort && e.sort();
  }, this.addOption = function(t) {
    t = (t = t || "").toString(), e.push(t), this.sort && e.sort();
  }, this.removeOption = function(t, n) {
    for (n = n || !1, t = (t = t || "").toString(); e.indexOf(t) !== -1 && (e.splice(e.indexOf(t), 1), n !== !1); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 18);
  }, set: function(t) {
    t ? this.Ff = mn(this.Ff, 18) : this.Ff = vn(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 19);
  }, set: function(t) {
    this.combo === !0 && (t ? this.Ff = mn(this.Ff, 19) : this.Ff = vn(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 20);
  }, set: function(t) {
    t ? (this.Ff = mn(this.Ff, 20), e.sort()) : this.Ff = vn(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 22);
  }, set: function(t) {
    t ? this.Ff = mn(this.Ff, 22) : this.Ff = vn(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 23);
  }, set: function(t) {
    t ? this.Ff = mn(this.Ff, 23) : this.Ff = vn(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 27);
  }, set: function(t) {
    t ? this.Ff = mn(this.Ff, 27) : this.Ff = vn(this.Ff, 27);
  } }), this.hasAppearanceStream = !1;
};
ts(ZA, Aa);
var el = function() {
  ZA.call(this), this.fontName = "helvetica", this.combo = !1;
};
ts(el, ZA);
var tl = function() {
  el.call(this), this.combo = !0;
};
ts(tl, el);
var rf = function() {
  tl.call(this), this.edit = !0;
};
ts(rf, tl);
var Dn = function() {
  Aa.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 15);
  }, set: function(t) {
    t ? this.Ff = mn(this.Ff, 15) : this.Ff = vn(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 16);
  }, set: function(t) {
    t ? this.Ff = mn(this.Ff, 16) : this.Ff = vn(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 17);
  }, set: function(t) {
    t ? this.Ff = mn(this.Ff, 17) : this.Ff = vn(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 26);
  }, set: function(t) {
    t ? this.Ff = mn(this.Ff, 26) : this.Ff = vn(this.Ff, 26);
  } });
  var r, e = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var t = function(s) {
      return s;
    };
    if (this.scope && (t = this.scope.internal.getEncryptor(this.objId)), Object.keys(e).length !== 0) {
      var n, i = [];
      for (n in i.push("<<"), e) i.push("/" + n + " (" + cl(t(e[n])) + ")");
      return i.push(">>"), i.join(`
`);
    }
  }, set: function(t) {
    br(t) === "object" && (e = t);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return e.CA || "";
  }, set: function(t) {
    typeof t == "string" && (e.CA = t);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return r;
  }, set: function(t) {
    r = t;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return r.substr(1, r.length - 1);
  }, set: function(t) {
    r = "/" + t;
  } });
};
ts(Dn, Aa);
var nf = function() {
  Dn.call(this), this.pushButton = !0;
};
ts(nf, Dn);
var rl = function() {
  Dn.call(this), this.radio = !0, this.pushButton = !1;
  var r = [];
  Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function() {
    return r;
  }, set: function(e) {
    r = e !== void 0 ? e : [];
  } });
};
ts(rl, Dn);
var Up = function() {
  var r, e;
  Aa.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function() {
    return r;
  }, set: function(i) {
    r = i;
  } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function() {
    return e;
  }, set: function(i) {
    e = i;
  } });
  var t, n = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var i = function(o) {
      return o;
    };
    this.scope && (i = this.scope.internal.getEncryptor(this.objId));
    var s, a = [];
    for (s in a.push("<<"), n) a.push("/" + s + " (" + cl(i(n[s])) + ")");
    return a.push(">>"), a.join(`
`);
  }, set: function(i) {
    br(i) === "object" && (n = i);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return n.CA || "";
  }, set: function(i) {
    typeof i == "string" && (n.CA = i);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(i) {
    t = i;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return t.substr(1, t.length - 1);
  }, set: function(i) {
    t = "/" + i;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = mt.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
ts(Up, Aa), rl.prototype.setAppearance = function(r) {
  if (!("createAppearanceStream" in r) || !("getCA" in r)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var e in this.Kids) if (this.Kids.hasOwnProperty(e)) {
    var t = this.Kids[e];
    t.appearanceStreamContent = r.createAppearanceStream(t.optionName), t.caption = r.getCA();
  }
}, rl.prototype.createOption = function(r) {
  var e = new Up();
  return e.Parent = this, e.optionName = r, this.Kids.push(e), dP.call(this.scope, e), e;
};
var sf = function() {
  Dn.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = mt.CheckBox.createAppearanceStream();
};
ts(sf, Dn);
var tA = function() {
  Aa.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 13);
  }, set: function(e) {
    e ? this.Ff = mn(this.Ff, 13) : this.Ff = vn(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 21);
  }, set: function(e) {
    e ? this.Ff = mn(this.Ff, 21) : this.Ff = vn(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 23);
  }, set: function(e) {
    e ? this.Ff = mn(this.Ff, 23) : this.Ff = vn(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 24);
  }, set: function(e) {
    e ? this.Ff = mn(this.Ff, 24) : this.Ff = vn(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 25);
  }, set: function(e) {
    e ? this.Ff = mn(this.Ff, 25) : this.Ff = vn(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 26);
  }, set: function(e) {
    e ? this.Ff = mn(this.Ff, 26) : this.Ff = vn(this.Ff, 26);
  } });
  var r = null;
  Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function() {
    return r;
  }, set: function(e) {
    r = e;
  } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function() {
    return r;
  }, set: function(e) {
    Number.isInteger(e) && (r = e);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return this.V || this.DV;
  } });
};
ts(tA, Aa);
var af = function() {
  tA.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function() {
    return !!gn(this.Ff, 14);
  }, set: function(r) {
    r ? this.Ff = mn(this.Ff, 14) : this.Ff = vn(this.Ff, 14);
  } }), this.password = !0;
};
ts(af, tA);
var mt = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: mt.CheckBox.YesNormal }, D: { On: mt.CheckBox.YesPushDown, Off: mt.CheckBox.OffPushDown } };
}, YesPushDown: function(r) {
  var e = wa(r);
  e.scope = r.scope;
  var t = [], n = r.scope.internal.getFont(r.fontName, r.fontStyle).id, i = r.scope.__private__.encodeColorString(r.color), s = Bv(r, r.caption);
  return t.push("0.749023 g"), t.push("0 0 " + $t(mt.internal.getWidth(r)) + " " + $t(mt.internal.getHeight(r)) + " re"), t.push("f"), t.push("BMC"), t.push("q"), t.push("0 0 1 rg"), t.push("/" + n + " " + $t(s.fontSize) + " Tf " + i), t.push("BT"), t.push(s.text), t.push("ET"), t.push("Q"), t.push("EMC"), e.stream = t.join(`
`), e;
}, YesNormal: function(r) {
  var e = wa(r);
  e.scope = r.scope;
  var t = r.scope.internal.getFont(r.fontName, r.fontStyle).id, n = r.scope.__private__.encodeColorString(r.color), i = [], s = mt.internal.getHeight(r), a = mt.internal.getWidth(r), o = Bv(r, r.caption);
  return i.push("1 g"), i.push("0 0 " + $t(a) + " " + $t(s) + " re"), i.push("f"), i.push("q"), i.push("0 0 1 rg"), i.push("0 0 " + $t(a - 1) + " " + $t(s - 1) + " re"), i.push("W"), i.push("n"), i.push("0 g"), i.push("BT"), i.push("/" + t + " " + $t(o.fontSize) + " Tf " + n), i.push(o.text), i.push("ET"), i.push("Q"), e.stream = i.join(`
`), e;
}, OffPushDown: function(r) {
  var e = wa(r);
  e.scope = r.scope;
  var t = [];
  return t.push("0.749023 g"), t.push("0 0 " + $t(mt.internal.getWidth(r)) + " " + $t(mt.internal.getHeight(r)) + " re"), t.push("f"), e.stream = t.join(`
`), e;
} }, RadioButton: { Circle: { createAppearanceStream: function(r) {
  var e = { D: { Off: mt.RadioButton.Circle.OffPushDown }, N: {} };
  return e.N[r] = mt.RadioButton.Circle.YesNormal, e.D[r] = mt.RadioButton.Circle.YesPushDown, e;
}, getCA: function() {
  return "l";
}, YesNormal: function(r) {
  var e = wa(r);
  e.scope = r.scope;
  var t = [], n = mt.internal.getWidth(r) <= mt.internal.getHeight(r) ? mt.internal.getWidth(r) / 4 : mt.internal.getHeight(r) / 4;
  n = Number((0.9 * n).toFixed(5));
  var i = mt.internal.Bezier_C, s = Number((n * i).toFixed(5));
  return t.push("q"), t.push("1 0 0 1 " + ko(mt.internal.getWidth(r) / 2) + " " + ko(mt.internal.getHeight(r) / 2) + " cm"), t.push(n + " 0 m"), t.push(n + " " + s + " " + s + " " + n + " 0 " + n + " c"), t.push("-" + s + " " + n + " -" + n + " " + s + " -" + n + " 0 c"), t.push("-" + n + " -" + s + " -" + s + " -" + n + " 0 -" + n + " c"), t.push(s + " -" + n + " " + n + " -" + s + " " + n + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
}, YesPushDown: function(r) {
  var e = wa(r);
  e.scope = r.scope;
  var t = [], n = mt.internal.getWidth(r) <= mt.internal.getHeight(r) ? mt.internal.getWidth(r) / 4 : mt.internal.getHeight(r) / 4;
  n = Number((0.9 * n).toFixed(5));
  var i = Number((2 * n).toFixed(5)), s = Number((i * mt.internal.Bezier_C).toFixed(5)), a = Number((n * mt.internal.Bezier_C).toFixed(5));
  return t.push("0.749023 g"), t.push("q"), t.push("1 0 0 1 " + ko(mt.internal.getWidth(r) / 2) + " " + ko(mt.internal.getHeight(r) / 2) + " cm"), t.push(i + " 0 m"), t.push(i + " " + s + " " + s + " " + i + " 0 " + i + " c"), t.push("-" + s + " " + i + " -" + i + " " + s + " -" + i + " 0 c"), t.push("-" + i + " -" + s + " -" + s + " -" + i + " 0 -" + i + " c"), t.push(s + " -" + i + " " + i + " -" + s + " " + i + " 0 c"), t.push("f"), t.push("Q"), t.push("0 g"), t.push("q"), t.push("1 0 0 1 " + ko(mt.internal.getWidth(r) / 2) + " " + ko(mt.internal.getHeight(r) / 2) + " cm"), t.push(n + " 0 m"), t.push(n + " " + a + " " + a + " " + n + " 0 " + n + " c"), t.push("-" + a + " " + n + " -" + n + " " + a + " -" + n + " 0 c"), t.push("-" + n + " -" + a + " -" + a + " -" + n + " 0 -" + n + " c"), t.push(a + " -" + n + " " + n + " -" + a + " " + n + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
}, OffPushDown: function(r) {
  var e = wa(r);
  e.scope = r.scope;
  var t = [], n = mt.internal.getWidth(r) <= mt.internal.getHeight(r) ? mt.internal.getWidth(r) / 4 : mt.internal.getHeight(r) / 4;
  n = Number((0.9 * n).toFixed(5));
  var i = Number((2 * n).toFixed(5)), s = Number((i * mt.internal.Bezier_C).toFixed(5));
  return t.push("0.749023 g"), t.push("q"), t.push("1 0 0 1 " + ko(mt.internal.getWidth(r) / 2) + " " + ko(mt.internal.getHeight(r) / 2) + " cm"), t.push(i + " 0 m"), t.push(i + " " + s + " " + s + " " + i + " 0 " + i + " c"), t.push("-" + s + " " + i + " -" + i + " " + s + " -" + i + " 0 c"), t.push("-" + i + " -" + s + " -" + s + " -" + i + " 0 -" + i + " c"), t.push(s + " -" + i + " " + i + " -" + s + " " + i + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
} }, Cross: { createAppearanceStream: function(r) {
  var e = { D: { Off: mt.RadioButton.Cross.OffPushDown }, N: {} };
  return e.N[r] = mt.RadioButton.Cross.YesNormal, e.D[r] = mt.RadioButton.Cross.YesPushDown, e;
}, getCA: function() {
  return "8";
}, YesNormal: function(r) {
  var e = wa(r);
  e.scope = r.scope;
  var t = [], n = mt.internal.calculateCross(r);
  return t.push("q"), t.push("1 1 " + $t(mt.internal.getWidth(r) - 2) + " " + $t(mt.internal.getHeight(r) - 2) + " re"), t.push("W"), t.push("n"), t.push($t(n.x1.x) + " " + $t(n.x1.y) + " m"), t.push($t(n.x2.x) + " " + $t(n.x2.y) + " l"), t.push($t(n.x4.x) + " " + $t(n.x4.y) + " m"), t.push($t(n.x3.x) + " " + $t(n.x3.y) + " l"), t.push("s"), t.push("Q"), e.stream = t.join(`
`), e;
}, YesPushDown: function(r) {
  var e = wa(r);
  e.scope = r.scope;
  var t = mt.internal.calculateCross(r), n = [];
  return n.push("0.749023 g"), n.push("0 0 " + $t(mt.internal.getWidth(r)) + " " + $t(mt.internal.getHeight(r)) + " re"), n.push("f"), n.push("q"), n.push("1 1 " + $t(mt.internal.getWidth(r) - 2) + " " + $t(mt.internal.getHeight(r) - 2) + " re"), n.push("W"), n.push("n"), n.push($t(t.x1.x) + " " + $t(t.x1.y) + " m"), n.push($t(t.x2.x) + " " + $t(t.x2.y) + " l"), n.push($t(t.x4.x) + " " + $t(t.x4.y) + " m"), n.push($t(t.x3.x) + " " + $t(t.x3.y) + " l"), n.push("s"), n.push("Q"), e.stream = n.join(`
`), e;
}, OffPushDown: function(r) {
  var e = wa(r);
  e.scope = r.scope;
  var t = [];
  return t.push("0.749023 g"), t.push("0 0 " + $t(mt.internal.getWidth(r)) + " " + $t(mt.internal.getHeight(r)) + " re"), t.push("f"), e.stream = t.join(`
`), e;
} } }, createDefaultAppearanceStream: function(r) {
  var e = r.scope.internal.getFont(r.fontName, r.fontStyle).id, t = r.scope.__private__.encodeColorString(r.color);
  return "/" + e + " " + r.fontSize + " Tf " + t;
} };
mt.internal = { Bezier_C: 0.551915024494, calculateCross: function(r) {
  var e = mt.internal.getWidth(r), t = mt.internal.getHeight(r), n = Math.min(e, t);
  return { x1: { x: (e - n) / 2, y: (t - n) / 2 + n }, x2: { x: (e - n) / 2 + n, y: (t - n) / 2 }, x3: { x: (e - n) / 2, y: (t - n) / 2 }, x4: { x: (e - n) / 2 + n, y: (t - n) / 2 + n } };
} }, mt.internal.getWidth = function(r) {
  var e = 0;
  return br(r) === "object" && (e = KB(r.Rect[2])), e;
}, mt.internal.getHeight = function(r) {
  var e = 0;
  return br(r) === "object" && (e = KB(r.Rect[3])), e;
};
var dP = rn.addField = function(r) {
  if (hP(this, r), !(r instanceof Aa)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var e;
  return (e = r).scope.internal.acroformPlugin.printedOut && (e.scope.internal.acroformPlugin.printedOut = !1, e.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e), r.page = r.scope.internal.getCurrentPageInfo().pageNumber, this;
};
rn.AcroFormChoiceField = ZA, rn.AcroFormListBox = el, rn.AcroFormComboBox = tl, rn.AcroFormEditBox = rf, rn.AcroFormButton = Dn, rn.AcroFormPushButton = nf, rn.AcroFormRadioButton = rl, rn.AcroFormCheckBox = sf, rn.AcroFormTextField = tA, rn.AcroFormPasswordField = af, rn.AcroFormAppearance = mt, rn.AcroForm = { ChoiceField: ZA, ListBox: el, ComboBox: tl, EditBox: rf, Button: Dn, PushButton: nf, RadioButton: rl, CheckBox: sf, TextField: tA, PasswordField: af, Appearance: mt }, Ft.AcroForm = { ChoiceField: ZA, ListBox: el, ComboBox: tl, EditBox: rf, Button: Dn, PushButton: nf, RadioButton: rl, CheckBox: sf, TextField: tA, PasswordField: af, Appearance: mt };
var pP = Ft.AcroForm;
function H3(r) {
  return r.reduce(function(e, t, n) {
    return e[t] = n, e;
  }, {});
}
(function(r) {
  r.__addimage__ = {};
  var e = "UNKNOWN", t = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, n = r.__addimage__.getImageFileTypeByImageData = function(T, E) {
    var L, S, X, z, R, V = e;
    if ((E = E || e) === "RGBA" || T.data !== void 0 && T.data instanceof Uint8ClampedArray && "height" in T && "width" in T) return "RGBA";
    if (x(T)) for (R in t) for (X = t[R], L = 0; L < X.length; L += 1) {
      for (z = !0, S = 0; S < X[L].length; S += 1) if (X[L][S] !== void 0 && X[L][S] !== T[S]) {
        z = !1;
        break;
      }
      if (z === !0) {
        V = R;
        break;
      }
    }
    else for (R in t) for (X = t[R], L = 0; L < X.length; L += 1) {
      for (z = !0, S = 0; S < X[L].length; S += 1) if (X[L][S] !== void 0 && X[L][S] !== T.charCodeAt(S)) {
        z = !1;
        break;
      }
      if (z === !0) {
        V = R;
        break;
      }
    }
    return V === e && E !== e && (V = E), V;
  }, i = function T(E) {
    for (var L = this.internal.write, S = this.internal.putStream, X = (0, this.internal.getFilters)(); X.indexOf("FlateEncode") !== -1; ) X.splice(X.indexOf("FlateEncode"), 1);
    E.objectId = this.internal.newObject();
    var z = [];
    if (z.push({ key: "Type", value: "/XObject" }), z.push({ key: "Subtype", value: "/Image" }), z.push({ key: "Width", value: E.width }), z.push({ key: "Height", value: E.height }), E.colorSpace === v.INDEXED ? z.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (E.palette.length / 3 - 1) + " " + ("sMask" in E && E.sMask !== void 0 ? E.objectId + 2 : E.objectId + 1) + " 0 R]" }) : (z.push({ key: "ColorSpace", value: "/" + E.colorSpace }), E.colorSpace === v.DEVICE_CMYK && z.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), z.push({ key: "BitsPerComponent", value: E.bitsPerComponent }), "decodeParameters" in E && E.decodeParameters !== void 0 && z.push({ key: "DecodeParms", value: "<<" + E.decodeParameters + ">>" }), "transparency" in E && Array.isArray(E.transparency)) {
      for (var R = "", V = 0, O = E.transparency.length; V < O; V++) R += E.transparency[V] + " " + E.transparency[V] + " ";
      z.push({ key: "Mask", value: "[" + R + "]" });
    }
    E.sMask !== void 0 && z.push({ key: "SMask", value: E.objectId + 1 + " 0 R" });
    var J = E.filter !== void 0 ? ["/" + E.filter] : void 0;
    if (S({ data: E.data, additionalKeyValues: z, alreadyAppliedFilters: J, objectId: E.objectId }), L("endobj"), "sMask" in E && E.sMask !== void 0) {
      var Z = "/Predictor " + E.predictor + " /Colors 1 /BitsPerComponent " + E.bitsPerComponent + " /Columns " + E.width, U = { width: E.width, height: E.height, colorSpace: "DeviceGray", bitsPerComponent: E.bitsPerComponent, decodeParameters: Z, data: E.sMask };
      "filter" in E && (U.filter = E.filter), T.call(this, U);
    }
    if (E.colorSpace === v.INDEXED) {
      var P = this.internal.newObject();
      S({ data: F(new Uint8Array(E.palette)), objectId: P }), L("endobj");
    }
  }, s = function() {
    var T = this.internal.collections.addImage_images;
    for (var E in T) i.call(this, T[E]);
  }, a = function() {
    var T, E = this.internal.collections.addImage_images, L = this.internal.write;
    for (var S in E) L("/I" + (T = E[S]).index, T.objectId, "0", "R");
  }, o = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", s), this.internal.events.subscribe("putXobjectDict", a));
  }, A = function() {
    var T = this.internal.collections.addImage_images;
    return o.call(this), T;
  }, l = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, u = function(T) {
    return typeof r["process" + T.toUpperCase()] == "function";
  }, c = function(T) {
    return br(T) === "object" && T.nodeType === 1;
  }, h = function(T, E) {
    if (T.nodeName === "IMG" && T.hasAttribute("src")) {
      var L = "" + T.getAttribute("src");
      if (L.indexOf("data:image/") === 0) return tf(unescape(L).split("base64,").pop());
      var S = r.loadFile(L, !0);
      if (S !== void 0) return S;
    }
    if (T.nodeName === "CANVAS") {
      if (T.width === 0 || T.height === 0) throw new Error("Given canvas must have data. Canvas width: " + T.width + ", height: " + T.height);
      var X;
      switch (E) {
        case "PNG":
          X = "image/png";
          break;
        case "WEBP":
          X = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          X = "image/jpeg";
      }
      return tf(T.toDataURL(X, 1).split("base64,").pop());
    }
  }, f = function(T) {
    var E = this.internal.collections.addImage_images;
    if (E) {
      for (var L in E) if (T === E[L].alias) return E[L];
    }
  }, d = function(T, E, L) {
    return T || E || (T = -96, E = -96), T < 0 && (T = -1 * L.width * 72 / T / this.internal.scaleFactor), E < 0 && (E = -1 * L.height * 72 / E / this.internal.scaleFactor), T === 0 && (T = E * L.width / L.height), E === 0 && (E = T * L.height / L.width), [T, E];
  }, p = function(T, E, L, S, X, z) {
    var R = d.call(this, L, S, X), V = this.internal.getCoordinateString, O = this.internal.getVerticalCoordinateString, J = A.call(this);
    if (L = R[0], S = R[1], J[X.index] = X, z) {
      z *= Math.PI / 180;
      var Z = Math.cos(z), U = Math.sin(z), P = function($) {
        return $.toFixed(4);
      }, H = [P(Z), P(U), P(-1 * U), P(Z), 0, 0, "cm"];
    }
    this.internal.write("q"), z ? (this.internal.write([1, "0", "0", 1, V(T), O(E + S), "cm"].join(" ")), this.internal.write(H.join(" ")), this.internal.write([V(L), "0", "0", V(S), "0", "0", "cm"].join(" "))) : this.internal.write([V(L), "0", "0", V(S), V(T), O(E + S), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + X.index + " Do"), this.internal.write("Q");
  }, v = r.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  r.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var m = r.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, b = r.__addimage__.sHashCode = function(T) {
    var E, L, S = 0;
    if (typeof T == "string") for (L = T.length, E = 0; E < L; E++) S = (S << 5) - S + T.charCodeAt(E), S |= 0;
    else if (x(T)) for (L = T.byteLength / 2, E = 0; E < L; E++) S = (S << 5) - S + T[E], S |= 0;
    return S;
  }, w = r.__addimage__.validateStringAsBase64 = function(T) {
    (T = T || "").toString().trim();
    var E = !0;
    return T.length === 0 && (E = !1), T.length % 4 != 0 && (E = !1), /^[A-Za-z0-9+/]+$/.test(T.substr(0, T.length - 2)) === !1 && (E = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(T.substr(-2)) === !1 && (E = !1), E;
  }, B = r.__addimage__.extractImageFromDataUrl = function(T) {
    var E = (T = T || "").split("base64,"), L = null;
    if (E.length === 2) {
      var S = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(E[0]);
      Array.isArray(S) && (L = { mimeType: S[1], charset: S[2], data: E[1] });
    }
    return L;
  }, _ = r.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer < "u" && typeof Uint8Array < "u";
  };
  r.__addimage__.isArrayBuffer = function(T) {
    return _() && T instanceof ArrayBuffer;
  };
  var x = r.__addimage__.isArrayBufferView = function(T) {
    return _() && typeof Uint32Array < "u" && (T instanceof Int8Array || T instanceof Uint8Array || typeof Uint8ClampedArray < "u" && T instanceof Uint8ClampedArray || T instanceof Int16Array || T instanceof Uint16Array || T instanceof Int32Array || T instanceof Uint32Array || T instanceof Float32Array || T instanceof Float64Array);
  }, C = r.__addimage__.binaryStringToUint8Array = function(T) {
    for (var E = T.length, L = new Uint8Array(E), S = 0; S < E; S++) L[S] = T.charCodeAt(S);
    return L;
  }, F = r.__addimage__.arrayBufferToBinaryString = function(T) {
    for (var E = "", L = x(T) ? T : new Uint8Array(T), S = 0; S < L.length; S += 8192) E += String.fromCharCode.apply(null, L.subarray(S, S + 8192));
    return E;
  };
  r.addImage = function() {
    var T, E, L, S, X, z, R, V, O;
    if (typeof arguments[1] == "number" ? (E = e, L = arguments[1], S = arguments[2], X = arguments[3], z = arguments[4], R = arguments[5], V = arguments[6], O = arguments[7]) : (E = arguments[1], L = arguments[2], S = arguments[3], X = arguments[4], z = arguments[5], R = arguments[6], V = arguments[7], O = arguments[8]), br(T = arguments[0]) === "object" && !c(T) && "imageData" in T) {
      var J = T;
      T = J.imageData, E = J.format || E || e, L = J.x || L || 0, S = J.y || S || 0, X = J.w || J.width || X, z = J.h || J.height || z, R = J.alias || R, V = J.compression || V, O = J.rotation || J.angle || O;
    }
    var Z = this.internal.getFilters();
    if (V === void 0 && Z.indexOf("FlateEncode") !== -1 && (V = "SLOW"), isNaN(L) || isNaN(S)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    o.call(this);
    var U = N.call(this, T, E, R, V);
    return p.call(this, L, S, X, z, U, O), this;
  };
  var N = function(T, E, L, S) {
    var X, z, R;
    if (typeof T == "string" && n(T) === e) {
      T = unescape(T);
      var V = D(T, !1);
      (V !== "" || (V = r.loadFile(T, !0)) !== void 0) && (T = V);
    }
    if (c(T) && (T = h(T, E)), E = n(T, E), !u(E)) throw new Error("addImage does not support files of type '" + E + "', please ensure that a plugin for '" + E + "' support is added.");
    if (((R = L) == null || R.length === 0) && (L = function(O) {
      return typeof O == "string" || x(O) ? b(O) : x(O.data) ? b(O.data) : null;
    }(T)), (X = f.call(this, L)) || (_() && (T instanceof Uint8Array || E === "RGBA" || (z = T, T = C(T))), X = this["process" + E.toUpperCase()](T, l.call(this), L, function(O) {
      return O && typeof O == "string" && (O = O.toUpperCase()), O in r.image_compression ? O : m.NONE;
    }(S), z)), !X) throw new Error("An unknown error occurred whilst processing the image.");
    return X;
  }, D = r.__addimage__.convertBase64ToBinaryString = function(T, E) {
    var L;
    E = typeof E != "boolean" || E;
    var S, X = "";
    if (typeof T == "string") {
      S = (L = B(T)) !== null ? L.data : T;
      try {
        X = tf(S);
      } catch (z) {
        if (E) throw w(S) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + z.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return X;
  };
  r.getImageProperties = function(T) {
    var E, L, S = "";
    if (c(T) && (T = h(T)), typeof T == "string" && n(T) === e && ((S = D(T, !1)) === "" && (S = r.loadFile(T) || ""), T = S), L = n(T), !u(L)) throw new Error("addImage does not support files of type '" + L + "', please ensure that a plugin for '" + L + "' support is added.");
    if (!_() || T instanceof Uint8Array || (T = C(T)), !(E = this["process" + L.toUpperCase()](T))) throw new Error("An unknown error occurred whilst processing the image");
    return E.fileType = L, E;
  };
})(Ft.API), /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(r) {
  var e = function(t) {
    if (t !== void 0 && t != "") return !0;
  };
  Ft.API.events.push(["addPage", function(t) {
    this.internal.getPageInfo(t.pageNumber).pageContext.annotations = [];
  }]), r.events.push(["putPage", function(t) {
    for (var n, i, s, a = this.internal.getCoordinateString, o = this.internal.getVerticalCoordinateString, A = this.internal.getPageInfoByObjId(t.objId), l = t.pageContext.annotations, u = !1, c = 0; c < l.length && !u; c++) switch ((n = l[c]).type) {
      case "link":
        (e(n.options.url) || e(n.options.pageNumber)) && (u = !0);
        break;
      case "reference":
      case "text":
      case "freetext":
        u = !0;
    }
    if (u != 0) {
      this.internal.write("/Annots [");
      for (var h = 0; h < l.length; h++) {
        n = l[h];
        var f = this.internal.pdfEscape, d = this.internal.getEncryptor(t.objId);
        switch (n.type) {
          case "reference":
            this.internal.write(" " + n.object.objId + " 0 R ");
            break;
          case "text":
            var p = this.internal.newAdditionalObject(), v = this.internal.newAdditionalObject(), m = this.internal.getEncryptor(p.objId), b = n.title || "Note";
            s = "<</Type /Annot /Subtype /Text " + (i = "/Rect [" + a(n.bounds.x) + " " + o(n.bounds.y + n.bounds.h) + " " + a(n.bounds.x + n.bounds.w) + " " + o(n.bounds.y) + "] ") + "/Contents (" + f(m(n.contents)) + ")", s += " /Popup " + v.objId + " 0 R", s += " /P " + A.objId + " 0 R", s += " /T (" + f(m(b)) + ") >>", p.content = s;
            var w = p.objId + " 0 R";
            s = "<</Type /Annot /Subtype /Popup " + (i = "/Rect [" + a(n.bounds.x + 30) + " " + o(n.bounds.y + n.bounds.h) + " " + a(n.bounds.x + n.bounds.w + 30) + " " + o(n.bounds.y) + "] ") + " /Parent " + w, n.open && (s += " /Open true"), s += " >>", v.content = s, this.internal.write(p.objId, "0 R", v.objId, "0 R");
            break;
          case "freetext":
            i = "/Rect [" + a(n.bounds.x) + " " + o(n.bounds.y) + " " + a(n.bounds.x + n.bounds.w) + " " + o(n.bounds.y + n.bounds.h) + "] ";
            var B = n.color || "#000000";
            s = "<</Type /Annot /Subtype /FreeText " + i + "/Contents (" + f(d(n.contents)) + ")", s += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + B + ")", s += " /Border [0 0 0]", s += " >>", this.internal.write(s);
            break;
          case "link":
            if (n.options.name) {
              var _ = this.annotations._nameMap[n.options.name];
              n.options.pageNumber = _.page, n.options.top = _.y;
            } else n.options.top || (n.options.top = 0);
            if (i = "/Rect [" + n.finalBounds.x + " " + n.finalBounds.y + " " + n.finalBounds.w + " " + n.finalBounds.h + "] ", s = "", n.options.url) s = "<</Type /Annot /Subtype /Link " + i + "/Border [0 0 0] /A <</S /URI /URI (" + f(d(n.options.url)) + ") >>";
            else if (n.options.pageNumber)
              switch (s = "<</Type /Annot /Subtype /Link " + i + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(n.options.pageNumber).objId + " 0 R", n.options.magFactor = n.options.magFactor || "XYZ", n.options.magFactor) {
                case "Fit":
                  s += " /Fit]";
                  break;
                case "FitH":
                  s += " /FitH " + n.options.top + "]";
                  break;
                case "FitV":
                  n.options.left = n.options.left || 0, s += " /FitV " + n.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var x = o(n.options.top);
                  n.options.left = n.options.left || 0, n.options.zoom === void 0 && (n.options.zoom = 0), s += " /XYZ " + n.options.left + " " + x + " " + n.options.zoom + "]";
              }
            s != "" && (s += " >>", this.internal.write(s));
        }
      }
      this.internal.write("]");
    }
  }]), r.createAnnotation = function(t) {
    var n = this.internal.getCurrentPageInfo();
    switch (t.type) {
      case "link":
        this.link(t.bounds.x, t.bounds.y, t.bounds.w, t.bounds.h, t);
        break;
      case "text":
      case "freetext":
        n.pageContext.annotations.push(t);
    }
  }, r.link = function(t, n, i, s, a) {
    var o = this.internal.getCurrentPageInfo(), A = this.internal.getCoordinateString, l = this.internal.getVerticalCoordinateString;
    o.pageContext.annotations.push({ finalBounds: { x: A(t), y: l(n), w: A(t + i), h: l(n + s) }, options: a, type: "link" });
  }, r.textWithLink = function(t, n, i, s) {
    var a, o, A = this.getTextWidth(t), l = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (s.maxWidth !== void 0) {
      o = s.maxWidth;
      var u = this.splitTextToSize(t, o).length;
      a = Math.ceil(l * u);
    } else o = A, a = l;
    return this.text(t, n, i, s), i += 0.2 * l, s.align === "center" && (n -= A / 2), s.align === "right" && (n -= A), this.link(n, i - l, o, a, s), A;
  }, r.getTextWidth = function(t) {
    var n = this.internal.getFontSize();
    return this.getStringUnitWidth(t) * n / this.internal.scaleFactor;
  };
}(Ft.API), /**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(r) {
  var e = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, t = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, n = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i = [1570, 1571, 1573, 1575];
  r.__arabicParser__ = {};
  var s = r.__arabicParser__.isInArabicSubstitutionA = function(p) {
    return e[p.charCodeAt(0)] !== void 0;
  }, a = r.__arabicParser__.isArabicLetter = function(p) {
    return typeof p == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(p);
  }, o = r.__arabicParser__.isArabicEndLetter = function(p) {
    return a(p) && s(p) && e[p.charCodeAt(0)].length <= 2;
  }, A = r.__arabicParser__.isArabicAlfLetter = function(p) {
    return a(p) && i.indexOf(p.charCodeAt(0)) >= 0;
  };
  r.__arabicParser__.arabicLetterHasIsolatedForm = function(p) {
    return a(p) && s(p) && e[p.charCodeAt(0)].length >= 1;
  };
  var l = r.__arabicParser__.arabicLetterHasFinalForm = function(p) {
    return a(p) && s(p) && e[p.charCodeAt(0)].length >= 2;
  };
  r.__arabicParser__.arabicLetterHasInitialForm = function(p) {
    return a(p) && s(p) && e[p.charCodeAt(0)].length >= 3;
  };
  var u = r.__arabicParser__.arabicLetterHasMedialForm = function(p) {
    return a(p) && s(p) && e[p.charCodeAt(0)].length == 4;
  }, c = r.__arabicParser__.resolveLigatures = function(p) {
    var v = 0, m = t, b = "", w = 0;
    for (v = 0; v < p.length; v += 1) m[p.charCodeAt(v)] !== void 0 ? (w++, typeof (m = m[p.charCodeAt(v)]) == "number" && (b += String.fromCharCode(m), m = t, w = 0), v === p.length - 1 && (m = t, b += p.charAt(v - (w - 1)), v -= w - 1, w = 0)) : (m = t, b += p.charAt(v - w), v -= w, w = 0);
    return b;
  };
  r.__arabicParser__.isArabicDiacritic = function(p) {
    return p !== void 0 && n[p.charCodeAt(0)] !== void 0;
  };
  var h = r.__arabicParser__.getCorrectForm = function(p, v, m) {
    return a(p) ? s(p) === !1 ? -1 : !l(p) || !a(v) && !a(m) || !a(m) && o(v) || o(p) && !a(v) || o(p) && A(v) || o(p) && o(v) ? 0 : u(p) && a(v) && !o(v) && a(m) && l(m) ? 3 : o(p) || !a(m) ? 1 : 2 : -1;
  }, f = function(p) {
    var v = 0, m = 0, b = 0, w = "", B = "", _ = "", x = (p = p || "").split("\\s+"), C = [];
    for (v = 0; v < x.length; v += 1) {
      for (C.push(""), m = 0; m < x[v].length; m += 1) w = x[v][m], B = x[v][m - 1], _ = x[v][m + 1], a(w) ? (b = h(w, B, _), C[v] += b !== -1 ? String.fromCharCode(e[w.charCodeAt(0)][b]) : w) : C[v] += w;
      C[v] = c(C[v]);
    }
    return C.join(" ");
  }, d = r.__arabicParser__.processArabic = r.processArabic = function() {
    var p, v = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, m = [];
    if (Array.isArray(v)) {
      var b = 0;
      for (m = [], b = 0; b < v.length; b += 1) Array.isArray(v[b]) ? m.push([f(v[b][0]), v[b][1], v[b][2]]) : m.push([f(v[b])]);
      p = m;
    } else p = f(v);
    return typeof arguments[0] == "string" ? p : (arguments[0].text = p, arguments[0]);
  };
  r.events.push(["preProcessText", d]);
}(Ft.API), Ft.API.autoPrint = function(r) {
  var e;
  switch ((r = r || {}).variant = r.variant || "non-conform", r.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        e = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + e + " 0 R");
      });
  }
  return this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(r) {
  var e = function() {
    var t = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return t;
    }, set: function(o) {
      t = o;
    } });
    var n = 150;
    Object.defineProperty(this, "width", { get: function() {
      return n;
    }, set: function(o) {
      n = isNaN(o) || Number.isInteger(o) === !1 || o < 0 ? 150 : o, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = n + 1);
    } });
    var i = 300;
    Object.defineProperty(this, "height", { get: function() {
      return i;
    }, set: function(o) {
      i = isNaN(o) || Number.isInteger(o) === !1 || o < 0 ? 300 : o, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = i + 1);
    } });
    var s = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return s;
    }, set: function(o) {
      s = o;
    } });
    var a = {};
    Object.defineProperty(this, "style", { get: function() {
      return a;
    }, set: function(o) {
      a = o;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  e.prototype.getContext = function(t, n) {
    var i;
    if ((t = t || "2d") !== "2d") return null;
    for (i in n) this.pdf.context2d.hasOwnProperty(i) && (this.pdf.context2d[i] = n[i]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, e.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, r.events.push(["initialized", function() {
    this.canvas = new e(), this.canvas.pdf = this;
  }]);
}(Ft.API), function(r) {
  var e = { left: 0, top: 0, bottom: 0, right: 0 }, t = !1, n = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, e), this.internal.__cell__.margins.width = this.getPageWidth(), i.call(this));
  }, i = function() {
    this.internal.__cell__.lastCell = new s(), this.internal.__cell__.pages = 1;
  }, s = function() {
    var A = arguments[0];
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return A;
    }, set: function(p) {
      A = p;
    } });
    var l = arguments[1];
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return l;
    }, set: function(p) {
      l = p;
    } });
    var u = arguments[2];
    Object.defineProperty(this, "width", { enumerable: !0, get: function() {
      return u;
    }, set: function(p) {
      u = p;
    } });
    var c = arguments[3];
    Object.defineProperty(this, "height", { enumerable: !0, get: function() {
      return c;
    }, set: function(p) {
      c = p;
    } });
    var h = arguments[4];
    Object.defineProperty(this, "text", { enumerable: !0, get: function() {
      return h;
    }, set: function(p) {
      h = p;
    } });
    var f = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function() {
      return f;
    }, set: function(p) {
      f = p;
    } });
    var d = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: !0, get: function() {
      return d;
    }, set: function(p) {
      d = p;
    } }), this;
  };
  s.prototype.clone = function() {
    return new s(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, s.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, r.setHeaderFunction = function(A) {
    return n.call(this), this.internal.__cell__.headerFunction = typeof A == "function" ? A : void 0, this;
  }, r.getTextDimensions = function(A, l) {
    n.call(this);
    var u = (l = l || {}).fontSize || this.getFontSize(), c = l.font || this.getFont(), h = l.scaleFactor || this.internal.scaleFactor, f = 0, d = 0, p = 0, v = this;
    if (!Array.isArray(A) && typeof A != "string") {
      if (typeof A != "number") throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      A = String(A);
    }
    var m = l.maxWidth;
    m > 0 ? typeof A == "string" ? A = this.splitTextToSize(A, m) : Object.prototype.toString.call(A) === "[object Array]" && (A = A.reduce(function(w, B) {
      return w.concat(v.splitTextToSize(B, m));
    }, [])) : A = Array.isArray(A) ? A : [A];
    for (var b = 0; b < A.length; b++) f < (p = this.getStringUnitWidth(A[b], { font: c }) * u) && (f = p);
    return f !== 0 && (d = A.length), { w: f /= h, h: Math.max((d * u * this.getLineHeightFactor() - u * (this.getLineHeightFactor() - 1)) / h, 0) };
  }, r.cellAddPage = function() {
    n.call(this), this.addPage();
    var A = this.internal.__cell__.margins || e;
    return this.internal.__cell__.lastCell = new s(A.left, A.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var a = r.cell = function() {
    var A;
    A = arguments[0] instanceof s ? arguments[0] : new s(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), n.call(this);
    var l = this.internal.__cell__.lastCell, u = this.internal.__cell__.padding, c = this.internal.__cell__.margins || e, h = this.internal.__cell__.tableHeaderRow, f = this.internal.__cell__.printHeaders;
    return l.lineNumber !== void 0 && (l.lineNumber === A.lineNumber ? (A.x = (l.x || 0) + (l.width || 0), A.y = l.y || 0) : l.y + l.height + A.height + c.bottom > this.getPageHeight() ? (this.cellAddPage(), A.y = c.top, f && h && (this.printHeaderRow(A.lineNumber, !0), A.y += h[0].height)) : A.y = l.y + l.height || A.y), A.text[0] !== void 0 && (this.rect(A.x, A.y, A.width, A.height, t === !0 ? "FD" : void 0), A.align === "right" ? this.text(A.text, A.x + A.width - u, A.y + u, { align: "right", baseline: "top" }) : A.align === "center" ? this.text(A.text, A.x + A.width / 2, A.y + u, { align: "center", baseline: "top", maxWidth: A.width - u - u }) : this.text(A.text, A.x + u, A.y + u, { align: "left", baseline: "top", maxWidth: A.width - u - u })), this.internal.__cell__.lastCell = A, this;
  };
  r.table = function(A, l, u, c, h) {
    if (n.call(this), !u) throw new Error("No data for PDF table.");
    var f, d, p, v, m = [], b = [], w = [], B = {}, _ = {}, x = [], C = [], F = (h = h || {}).autoSize || !1, N = h.printHeaders !== !1, D = h.css && h.css["font-size"] !== void 0 ? 16 * h.css["font-size"] : h.fontSize || 12, T = h.margins || Object.assign({ width: this.getPageWidth() }, e), E = typeof h.padding == "number" ? h.padding : 3, L = h.headerBackgroundColor || "#c8c8c8", S = h.headerTextColor || "#000";
    if (i.call(this), this.internal.__cell__.printHeaders = N, this.internal.__cell__.margins = T, this.internal.__cell__.table_font_size = D, this.internal.__cell__.padding = E, this.internal.__cell__.headerBackgroundColor = L, this.internal.__cell__.headerTextColor = S, this.setFontSize(D), c == null) b = m = Object.keys(u[0]), w = m.map(function() {
      return "left";
    });
    else if (Array.isArray(c) && br(c[0]) === "object") for (m = c.map(function(J) {
      return J.name;
    }), b = c.map(function(J) {
      return J.prompt || J.name || "";
    }), w = c.map(function(J) {
      return J.align || "left";
    }), f = 0; f < c.length; f += 1) _[c[f].name] = c[f].width * (19.049976 / 25.4);
    else Array.isArray(c) && typeof c[0] == "string" && (b = m = c, w = m.map(function() {
      return "left";
    }));
    if (F || Array.isArray(c) && typeof c[0] == "string") for (f = 0; f < m.length; f += 1) {
      for (B[v = m[f]] = u.map(function(J) {
        return J[v];
      }), this.setFont(void 0, "bold"), x.push(this.getTextDimensions(b[f], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), d = B[v], this.setFont(void 0, "normal"), p = 0; p < d.length; p += 1) x.push(this.getTextDimensions(d[p], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      _[v] = Math.max.apply(null, x) + E + E, x = [];
    }
    if (N) {
      var X = {};
      for (f = 0; f < m.length; f += 1) X[m[f]] = {}, X[m[f]].text = b[f], X[m[f]].align = w[f];
      var z = o.call(this, X, _);
      C = m.map(function(J) {
        return new s(A, l, _[J], z, X[J].text, void 0, X[J].align);
      }), this.setTableHeaderRow(C), this.printHeaderRow(1, !1);
    }
    var R = c.reduce(function(J, Z) {
      return J[Z.name] = Z.align, J;
    }, {});
    for (f = 0; f < u.length; f += 1) {
      "rowStart" in h && h.rowStart instanceof Function && h.rowStart({ row: f, data: u[f] }, this);
      var V = o.call(this, u[f], _);
      for (p = 0; p < m.length; p += 1) {
        var O = u[f][m[p]];
        "cellStart" in h && h.cellStart instanceof Function && h.cellStart({ row: f, col: p, data: O }, this), a.call(this, new s(A, l, _[m[p]], V, O, f + 2, R[m[p]]));
      }
    }
    return this.internal.__cell__.table_x = A, this.internal.__cell__.table_y = l, this;
  };
  var o = function(A, l) {
    var u = this.internal.__cell__.padding, c = this.internal.__cell__.table_font_size, h = this.internal.scaleFactor;
    return Object.keys(A).map(function(f) {
      var d = A[f];
      return this.splitTextToSize(d.hasOwnProperty("text") ? d.text : d, l[f] - u - u);
    }, this).map(function(f) {
      return this.getLineHeightFactor() * f.length * c / h + u + u;
    }, this).reduce(function(f, d) {
      return Math.max(f, d);
    }, 0);
  };
  r.setTableHeaderRow = function(A) {
    n.call(this), this.internal.__cell__.tableHeaderRow = A;
  }, r.printHeaderRow = function(A, l) {
    if (n.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var u;
    if (t = !0, typeof this.internal.__cell__.headerFunction == "function") {
      var c = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new s(c[0], c[1], c[2], c[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var h = [], f = 0; f < this.internal.__cell__.tableHeaderRow.length; f += 1) {
      u = this.internal.__cell__.tableHeaderRow[f].clone(), l && (u.y = this.internal.__cell__.margins.top || 0, h.push(u)), u.lineNumber = A;
      var d = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), a.call(this, u), this.setTextColor(d);
    }
    h.length > 0 && this.setTableHeaderRow(h), this.setFont(void 0, "normal"), t = !1;
  };
}(Ft.API);
var j3 = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, K3 = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], Cv = H3(K3), $3 = [100, 200, 300, 400, 500, 600, 700, 800, 900], gP = H3($3);
function _v(r) {
  var e = r.family.replace(/"|'/g, "").toLowerCase(), t = function(s) {
    return j3[s = s || "normal"] ? s : "normal";
  }(r.style), n = function(s) {
    if (!s) return 400;
    if (typeof s == "number") return s >= 100 && s <= 900 && s % 100 == 0 ? s : 400;
    if (/^\d00$/.test(s)) return parseInt(s);
    switch (s) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(r.weight), i = function(s) {
    return typeof Cv[s = s || "normal"] == "number" ? s : "normal";
  }(r.stretch);
  return { family: e, style: t, weight: n, stretch: i, src: r.src || [], ref: r.ref || { name: e, style: [i, t, n].join(" ") } };
}
function $B(r, e, t, n) {
  var i;
  for (i = t; i >= 0 && i < e.length; i += n) if (r[e[i]]) return r[e[i]];
  for (i = t; i >= 0 && i < e.length; i -= n) if (r[e[i]]) return r[e[i]];
}
var mP = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, VB = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function zB(r) {
  return [r.stretch, r.style, r.weight, r.family].join(" ");
}
function vP(r, e, t) {
  for (var n = (t = t || {}).defaultFontFamily || "times", i = Object.assign({}, mP, t.genericFontFamilies || {}), s = null, a = null, o = 0; o < e.length; ++o) if (i[(s = _v(e[o])).family] && (s.family = i[s.family]), r.hasOwnProperty(s.family)) {
    a = r[s.family];
    break;
  }
  if (!(a = a || r[n])) throw new Error("Could not find a font-family for the rule '" + zB(s) + "' and default family '" + n + "'.");
  if (a = function(A, l) {
    if (l[A]) return l[A];
    var u = Cv[A], c = u <= Cv.normal ? -1 : 1, h = $B(l, K3, u, c);
    if (!h) throw new Error("Could not find a matching font-stretch value for " + A);
    return h;
  }(s.stretch, a), a = function(A, l) {
    if (l[A]) return l[A];
    for (var u = j3[A], c = 0; c < u.length; ++c) if (l[u[c]]) return l[u[c]];
    throw new Error("Could not find a matching font-style for " + A);
  }(s.style, a), !(a = function(A, l) {
    if (l[A]) return l[A];
    if (A === 400 && l[500]) return l[500];
    if (A === 500 && l[400]) return l[400];
    var u = gP[A], c = $B(l, $3, u, A < 400 ? -1 : 1);
    if (!c) throw new Error("Could not find a matching font-weight for value " + A);
    return c;
  }(s.weight, a))) throw new Error("Failed to resolve a font for the rule '" + zB(s) + "'.");
  return a;
}
function GB(r) {
  return r.trimLeft();
}
function bP(r, e) {
  for (var t = 0; t < r.length; ) {
    if (r.charAt(t) === e) return [r.substring(0, t), r.substring(t + 1)];
    t += 1;
  }
  return null;
}
function yP(r) {
  var e = r.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return e === null ? null : [e[0], r.substring(e[0].length)];
}
var sd, qB, WB, h0 = ["times"];
(function(r) {
  var e, t, n, i, s, a, o, A, l, u = function(U) {
    return U = U || {}, this.isStrokeTransparent = U.isStrokeTransparent || !1, this.strokeOpacity = U.strokeOpacity || 1, this.strokeStyle = U.strokeStyle || "#000000", this.fillStyle = U.fillStyle || "#000000", this.isFillTransparent = U.isFillTransparent || !1, this.fillOpacity = U.fillOpacity || 1, this.font = U.font || "10px sans-serif", this.textBaseline = U.textBaseline || "alphabetic", this.textAlign = U.textAlign || "left", this.lineWidth = U.lineWidth || 1, this.lineJoin = U.lineJoin || "miter", this.lineCap = U.lineCap || "butt", this.path = U.path || [], this.transform = U.transform !== void 0 ? U.transform.clone() : new A(), this.globalCompositeOperation = U.globalCompositeOperation || "normal", this.globalAlpha = U.globalAlpha || 1, this.clip_path = U.clip_path || [], this.currentPoint = U.currentPoint || new a(), this.miterLimit = U.miterLimit || 10, this.lastPoint = U.lastPoint || new a(), this.lineDashOffset = U.lineDashOffset || 0, this.lineDash = U.lineDash || [], this.margin = U.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = U.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof U.ignoreClearRect != "boolean" || U.ignoreClearRect, this;
  };
  r.events.push(["initialized", function() {
    this.context2d = new c(this), e = this.internal.f2, t = this.internal.getCoordinateString, n = this.internal.getVerticalCoordinateString, i = this.internal.getHorizontalCoordinate, s = this.internal.getVerticalCoordinate, a = this.internal.Point, o = this.internal.Rectangle, A = this.internal.Matrix, l = new u();
  }]);
  var c = function(U) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: !1, style: !1 };
    } });
    var P = U;
    Object.defineProperty(this, "pdf", { get: function() {
      return P;
    } });
    var H = !1;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return H;
    }, set: function(Ae) {
      H = !!Ae;
    } });
    var $ = !1;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return $;
    }, set: function(Ae) {
      $ = !!Ae;
    } });
    var ie = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return ie;
    }, set: function(Ae) {
      isNaN(Ae) || (ie = Ae);
    } });
    var ue = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return ue;
    }, set: function(Ae) {
      isNaN(Ae) || (ue = Ae);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return l.margin;
    }, set: function(Ae) {
      var G;
      typeof Ae == "number" ? G = [Ae, Ae, Ae, Ae] : ((G = new Array(4))[0] = Ae[0], G[1] = Ae.length >= 2 ? Ae[1] : G[0], G[2] = Ae.length >= 3 ? Ae[2] : G[0], G[3] = Ae.length >= 4 ? Ae[3] : G[1]), l.margin = G;
    } });
    var he = !1;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return he;
    }, set: function(Ae) {
      he = Ae;
    } });
    var ve = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return ve;
    }, set: function(Ae) {
      ve = Ae;
    } });
    var Le = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return Le;
    }, set: function(Ae) {
      Le = Ae;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return l;
    }, set: function(Ae) {
      Ae instanceof u && (l = Ae);
    } }), Object.defineProperty(this, "path", { get: function() {
      return l.path;
    }, set: function(Ae) {
      l.path = Ae;
    } });
    var de = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return de;
    }, set: function(Ae) {
      de = Ae;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(Ae) {
      var G;
      G = h(Ae), this.ctx.fillStyle = G.style, this.ctx.isFillTransparent = G.a === 0, this.ctx.fillOpacity = G.a, this.pdf.setFillColor(G.r, G.g, G.b, { a: G.a }), this.pdf.setTextColor(G.r, G.g, G.b, { a: G.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(Ae) {
      var G = h(Ae);
      this.ctx.strokeStyle = G.style, this.ctx.isStrokeTransparent = G.a === 0, this.ctx.strokeOpacity = G.a, G.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (G.a, this.pdf.setDrawColor(G.r, G.g, G.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(Ae) {
      ["butt", "round", "square"].indexOf(Ae) !== -1 && (this.ctx.lineCap = Ae, this.pdf.setLineCap(Ae));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(Ae) {
      isNaN(Ae) || (this.ctx.lineWidth = Ae, this.pdf.setLineWidth(Ae));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(Ae) {
      ["bevel", "round", "miter"].indexOf(Ae) !== -1 && (this.ctx.lineJoin = Ae, this.pdf.setLineJoin(Ae));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(Ae) {
      isNaN(Ae) || (this.ctx.miterLimit = Ae, this.pdf.setMiterLimit(Ae));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(Ae) {
      this.ctx.textBaseline = Ae;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(Ae) {
      ["right", "end", "center", "left", "start"].indexOf(Ae) !== -1 && (this.ctx.textAlign = Ae);
    } });
    var Ce = null;
    function Qe(Ae, G) {
      if (Ce === null) {
        var ne = function(ee) {
          var ae = [];
          return Object.keys(ee).forEach(function(re) {
            ee[re].forEach(function(ce) {
              var le = null;
              switch (ce) {
                case "bold":
                  le = { family: re, weight: "bold" };
                  break;
                case "italic":
                  le = { family: re, style: "italic" };
                  break;
                case "bolditalic":
                  le = { family: re, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  le = { family: re };
              }
              le !== null && (le.ref = { name: re, style: ce }, ae.push(le));
            });
          }), ae;
        }(Ae.getFontList());
        Ce = function(ee) {
          for (var ae = {}, re = 0; re < ee.length; ++re) {
            var ce = _v(ee[re]), le = ce.family, Te = ce.stretch, Oe = ce.style, Ue = ce.weight;
            ae[le] = ae[le] || {}, ae[le][Te] = ae[le][Te] || {}, ae[le][Te][Oe] = ae[le][Te][Oe] || {}, ae[le][Te][Oe][Ue] = ce;
          }
          return ae;
        }(ne.concat(G));
      }
      return Ce;
    }
    var M = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return M;
    }, set: function(Ae) {
      Ce = null, M = Ae;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(Ae) {
      var G;
      if (this.ctx.font = Ae, (G = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(Ae)) !== null) {
        var ne = G[1], ee = (G[2], G[3]), ae = G[4], re = (G[5], G[6]), ce = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(ae)[2];
        ae = Math.floor(ce === "px" ? parseFloat(ae) * this.pdf.internal.scaleFactor : ce === "em" ? parseFloat(ae) * this.pdf.getFontSize() : parseFloat(ae) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(ae);
        var le = function(ut) {
          var St, et, gr = [], bt = ut.trim();
          if (bt === "") return h0;
          if (bt in VB) return [VB[bt]];
          for (; bt !== ""; ) {
            switch (et = null, St = (bt = GB(bt)).charAt(0)) {
              case '"':
              case "'":
                et = bP(bt.substring(1), St);
                break;
              default:
                et = yP(bt);
            }
            if (et === null || (gr.push(et[0]), (bt = GB(et[1])) !== "" && bt.charAt(0) !== ",")) return h0;
            bt = bt.replace(/^,/, "");
          }
          return gr;
        }(re);
        if (this.fontFaces) {
          var Te = vP(Qe(this.pdf, this.fontFaces), le.map(function(ut) {
            return { family: ut, stretch: "normal", weight: ee, style: ne };
          }));
          this.pdf.setFont(Te.ref.name, Te.ref.style);
        } else {
          var Oe = "";
          (ee === "bold" || parseInt(ee, 10) >= 700 || ne === "bold") && (Oe = "bold"), ne === "italic" && (Oe += "italic"), Oe.length === 0 && (Oe = "normal");
          for (var Ue = "", Ge = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, at = 0; at < le.length; at++) {
            if (this.pdf.internal.getFont(le[at], Oe, { noFallback: !0, disableWarning: !0 }) !== void 0) {
              Ue = le[at];
              break;
            }
            if (Oe === "bolditalic" && this.pdf.internal.getFont(le[at], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0) Ue = le[at], Oe = "bold";
            else if (this.pdf.internal.getFont(le[at], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) {
              Ue = le[at], Oe = "normal";
              break;
            }
          }
          if (Ue === "") {
            for (var it = 0; it < le.length; it++) if (Ge[le[it]]) {
              Ue = Ge[le[it]];
              break;
            }
          }
          Ue = Ue === "" ? "Times" : Ue, this.pdf.setFont(Ue, Oe);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(Ae) {
      this.ctx.globalCompositeOperation = Ae;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(Ae) {
      this.ctx.globalAlpha = Ae;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(Ae) {
      this.ctx.lineDashOffset = Ae, Z.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(Ae) {
      this.ctx.lineDash = Ae, Z.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(Ae) {
      this.ctx.ignoreClearRect = !!Ae;
    } });
  };
  c.prototype.setLineDash = function(U) {
    this.lineDash = U;
  }, c.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, c.prototype.fill = function() {
    B.call(this, "fill", !1);
  }, c.prototype.stroke = function() {
    B.call(this, "stroke", !1);
  }, c.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, c.prototype.moveTo = function(U, P) {
    if (isNaN(U) || isNaN(P)) throw Lr.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var H = this.ctx.transform.applyToPoint(new a(U, P));
    this.path.push({ type: "mt", x: H.x, y: H.y }), this.ctx.lastPoint = new a(U, P);
  }, c.prototype.closePath = function() {
    var U = new a(0, 0), P = 0;
    for (P = this.path.length - 1; P !== -1; P--) if (this.path[P].type === "begin" && br(this.path[P + 1]) === "object" && typeof this.path[P + 1].x == "number") {
      U = new a(this.path[P + 1].x, this.path[P + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new a(U.x, U.y);
  }, c.prototype.lineTo = function(U, P) {
    if (isNaN(U) || isNaN(P)) throw Lr.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var H = this.ctx.transform.applyToPoint(new a(U, P));
    this.path.push({ type: "lt", x: H.x, y: H.y }), this.ctx.lastPoint = new a(H.x, H.y);
  }, c.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), B.call(this, null, !0);
  }, c.prototype.quadraticCurveTo = function(U, P, H, $) {
    if (isNaN(H) || isNaN($) || isNaN(U) || isNaN(P)) throw Lr.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var ie = this.ctx.transform.applyToPoint(new a(H, $)), ue = this.ctx.transform.applyToPoint(new a(U, P));
    this.path.push({ type: "qct", x1: ue.x, y1: ue.y, x: ie.x, y: ie.y }), this.ctx.lastPoint = new a(ie.x, ie.y);
  }, c.prototype.bezierCurveTo = function(U, P, H, $, ie, ue) {
    if (isNaN(ie) || isNaN(ue) || isNaN(U) || isNaN(P) || isNaN(H) || isNaN($)) throw Lr.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var he = this.ctx.transform.applyToPoint(new a(ie, ue)), ve = this.ctx.transform.applyToPoint(new a(U, P)), Le = this.ctx.transform.applyToPoint(new a(H, $));
    this.path.push({ type: "bct", x1: ve.x, y1: ve.y, x2: Le.x, y2: Le.y, x: he.x, y: he.y }), this.ctx.lastPoint = new a(he.x, he.y);
  }, c.prototype.arc = function(U, P, H, $, ie, ue) {
    if (isNaN(U) || isNaN(P) || isNaN(H) || isNaN($) || isNaN(ie)) throw Lr.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (ue = !!ue, !this.ctx.transform.isIdentity) {
      var he = this.ctx.transform.applyToPoint(new a(U, P));
      U = he.x, P = he.y;
      var ve = this.ctx.transform.applyToPoint(new a(0, H)), Le = this.ctx.transform.applyToPoint(new a(0, 0));
      H = Math.sqrt(Math.pow(ve.x - Le.x, 2) + Math.pow(ve.y - Le.y, 2));
    }
    Math.abs(ie - $) >= 2 * Math.PI && ($ = 0, ie = 2 * Math.PI), this.path.push({ type: "arc", x: U, y: P, radius: H, startAngle: $, endAngle: ie, counterclockwise: ue });
  }, c.prototype.arcTo = function(U, P, H, $, ie) {
    throw new Error("arcTo not implemented.");
  }, c.prototype.rect = function(U, P, H, $) {
    if (isNaN(U) || isNaN(P) || isNaN(H) || isNaN($)) throw Lr.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(U, P), this.lineTo(U + H, P), this.lineTo(U + H, P + $), this.lineTo(U, P + $), this.lineTo(U, P), this.lineTo(U + H, P), this.lineTo(U, P);
  }, c.prototype.fillRect = function(U, P, H, $) {
    if (isNaN(U) || isNaN(P) || isNaN(H) || isNaN($)) throw Lr.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!f.call(this)) {
      var ie = {};
      this.lineCap !== "butt" && (ie.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (ie.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(U, P, H, $), this.fill(), ie.hasOwnProperty("lineCap") && (this.lineCap = ie.lineCap), ie.hasOwnProperty("lineJoin") && (this.lineJoin = ie.lineJoin);
    }
  }, c.prototype.strokeRect = function(U, P, H, $) {
    if (isNaN(U) || isNaN(P) || isNaN(H) || isNaN($)) throw Lr.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    d.call(this) || (this.beginPath(), this.rect(U, P, H, $), this.stroke());
  }, c.prototype.clearRect = function(U, P, H, $) {
    if (isNaN(U) || isNaN(P) || isNaN(H) || isNaN($)) throw Lr.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(U, P, H, $));
  }, c.prototype.save = function(U) {
    U = typeof U != "boolean" || U;
    for (var P = this.pdf.internal.getCurrentPageInfo().pageNumber, H = 0; H < this.pdf.internal.getNumberOfPages(); H++) this.pdf.setPage(H + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(P), U) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var $ = new u(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = $;
    }
  }, c.prototype.restore = function(U) {
    U = typeof U != "boolean" || U;
    for (var P = this.pdf.internal.getCurrentPageInfo().pageNumber, H = 0; H < this.pdf.internal.getNumberOfPages(); H++) this.pdf.setPage(H + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(P), U && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, c.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var h = function(U) {
    var P, H, $, ie;
    if (U.isCanvasGradient === !0 && (U = U.getColor()), !U) return { r: 0, g: 0, b: 0, a: 0, style: U };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(U)) P = 0, H = 0, $ = 0, ie = 0;
    else {
      var ue = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(U);
      if (ue !== null) P = parseInt(ue[1]), H = parseInt(ue[2]), $ = parseInt(ue[3]), ie = 1;
      else if ((ue = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(U)) !== null) P = parseInt(ue[1]), H = parseInt(ue[2]), $ = parseInt(ue[3]), ie = parseFloat(ue[4]);
      else {
        if (ie = 1, typeof U == "string" && U.charAt(0) !== "#") {
          var he = new O3(U);
          U = he.ok ? he.toHex() : "#000000";
        }
        U.length === 4 ? (P = U.substring(1, 2), P += P, H = U.substring(2, 3), H += H, $ = U.substring(3, 4), $ += $) : (P = U.substring(1, 3), H = U.substring(3, 5), $ = U.substring(5, 7)), P = parseInt(P, 16), H = parseInt(H, 16), $ = parseInt($, 16);
      }
    }
    return { r: P, g: H, b: $, a: ie, style: U };
  }, f = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, d = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  c.prototype.fillText = function(U, P, H, $) {
    if (isNaN(P) || isNaN(H) || typeof U != "string") throw Lr.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if ($ = isNaN($) ? void 0 : $, !f.call(this)) {
      var ie = V(this.ctx.transform.rotation), ue = this.ctx.transform.scaleX;
      E.call(this, { text: U, x: P, y: H, scale: ue, angle: ie, align: this.textAlign, maxWidth: $ });
    }
  }, c.prototype.strokeText = function(U, P, H, $) {
    if (isNaN(P) || isNaN(H) || typeof U != "string") throw Lr.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!d.call(this)) {
      $ = isNaN($) ? void 0 : $;
      var ie = V(this.ctx.transform.rotation), ue = this.ctx.transform.scaleX;
      E.call(this, { text: U, x: P, y: H, scale: ue, renderingMode: "stroke", angle: ie, align: this.textAlign, maxWidth: $ });
    }
  }, c.prototype.measureText = function(U) {
    if (typeof U != "string") throw Lr.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var P = this.pdf, H = this.pdf.internal.scaleFactor, $ = P.internal.getFontSize(), ie = P.getStringUnitWidth(U) * $ / P.internal.scaleFactor, ue = function(he) {
      var ve = (he = he || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return ve;
      } }), this;
    };
    return new ue({ width: ie *= Math.round(96 * H / 72 * 1e4) / 1e4 });
  }, c.prototype.scale = function(U, P) {
    if (isNaN(U) || isNaN(P)) throw Lr.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var H = new A(U, 0, 0, P, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(H);
  }, c.prototype.rotate = function(U) {
    if (isNaN(U)) throw Lr.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var P = new A(Math.cos(U), Math.sin(U), -Math.sin(U), Math.cos(U), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(P);
  }, c.prototype.translate = function(U, P) {
    if (isNaN(U) || isNaN(P)) throw Lr.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var H = new A(1, 0, 0, 1, U, P);
    this.ctx.transform = this.ctx.transform.multiply(H);
  }, c.prototype.transform = function(U, P, H, $, ie, ue) {
    if (isNaN(U) || isNaN(P) || isNaN(H) || isNaN($) || isNaN(ie) || isNaN(ue)) throw Lr.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var he = new A(U, P, H, $, ie, ue);
    this.ctx.transform = this.ctx.transform.multiply(he);
  }, c.prototype.setTransform = function(U, P, H, $, ie, ue) {
    U = isNaN(U) ? 1 : U, P = isNaN(P) ? 0 : P, H = isNaN(H) ? 0 : H, $ = isNaN($) ? 1 : $, ie = isNaN(ie) ? 0 : ie, ue = isNaN(ue) ? 0 : ue, this.ctx.transform = new A(U, P, H, $, ie, ue);
  };
  var p = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  c.prototype.drawImage = function(U, P, H, $, ie, ue, he, ve, Le) {
    var de = this.pdf.getImageProperties(U), Ce = 1, Qe = 1, M = 1, Ae = 1;
    $ !== void 0 && ve !== void 0 && (M = ve / $, Ae = Le / ie, Ce = de.width / $ * ve / $, Qe = de.height / ie * Le / ie), ue === void 0 && (ue = P, he = H, P = 0, H = 0), $ !== void 0 && ve === void 0 && (ve = $, Le = ie), $ === void 0 && ve === void 0 && (ve = de.width, Le = de.height);
    for (var G, ne = this.ctx.transform.decompose(), ee = V(ne.rotate.shx), ae = new A(), re = (ae = (ae = (ae = ae.multiply(ne.translate)).multiply(ne.skew)).multiply(ne.scale)).applyToRectangle(new o(ue - P * M, he - H * Ae, $ * Ce, ie * Qe)), ce = v.call(this, re), le = [], Te = 0; Te < ce.length; Te += 1) le.indexOf(ce[Te]) === -1 && le.push(ce[Te]);
    if (w(le), this.autoPaging) for (var Oe = le[0], Ue = le[le.length - 1], Ge = Oe; Ge < Ue + 1; Ge++) {
      this.pdf.setPage(Ge);
      var at = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], it = Ge === 1 ? this.posY + this.margin[0] : this.margin[0], ut = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], St = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], et = Ge === 1 ? 0 : ut + (Ge - 2) * St;
      if (this.ctx.clip_path.length !== 0) {
        var gr = this.path;
        G = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = b(G, this.posX + this.margin[3], -et + it + this.ctx.prevPageLastElemOffset), _.call(this, "fill", !0), this.path = gr;
      }
      var bt = JSON.parse(JSON.stringify(re));
      bt = b([bt], this.posX + this.margin[3], -et + it + this.ctx.prevPageLastElemOffset)[0];
      var Qr = (Ge > Oe || Ge < Ue) && p.call(this);
      Qr && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], at, St, null).clip().discardPath()), this.pdf.addImage(U, "JPEG", bt.x, bt.y, bt.w, bt.h, null, null, ee), Qr && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(U, "JPEG", re.x, re.y, re.w, re.h, null, null, ee);
  };
  var v = function(U, P, H) {
    var $ = [];
    P = P || this.pdf.internal.pageSize.width, H = H || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var ie = this.posY + this.ctx.prevPageLastElemOffset;
    switch (U.type) {
      default:
      case "mt":
      case "lt":
        $.push(Math.floor((U.y + ie) / H) + 1);
        break;
      case "arc":
        $.push(Math.floor((U.y + ie - U.radius) / H) + 1), $.push(Math.floor((U.y + ie + U.radius) / H) + 1);
        break;
      case "qct":
        var ue = O(this.ctx.lastPoint.x, this.ctx.lastPoint.y, U.x1, U.y1, U.x, U.y);
        $.push(Math.floor((ue.y + ie) / H) + 1), $.push(Math.floor((ue.y + ue.h + ie) / H) + 1);
        break;
      case "bct":
        var he = J(this.ctx.lastPoint.x, this.ctx.lastPoint.y, U.x1, U.y1, U.x2, U.y2, U.x, U.y);
        $.push(Math.floor((he.y + ie) / H) + 1), $.push(Math.floor((he.y + he.h + ie) / H) + 1);
        break;
      case "rect":
        $.push(Math.floor((U.y + ie) / H) + 1), $.push(Math.floor((U.y + U.h + ie) / H) + 1);
    }
    for (var ve = 0; ve < $.length; ve += 1) for (; this.pdf.internal.getNumberOfPages() < $[ve]; ) m.call(this);
    return $;
  }, m = function() {
    var U = this.fillStyle, P = this.strokeStyle, H = this.font, $ = this.lineCap, ie = this.lineWidth, ue = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = U, this.strokeStyle = P, this.font = H, this.lineCap = $, this.lineWidth = ie, this.lineJoin = ue;
  }, b = function(U, P, H) {
    for (var $ = 0; $ < U.length; $++) switch (U[$].type) {
      case "bct":
        U[$].x2 += P, U[$].y2 += H;
      case "qct":
        U[$].x1 += P, U[$].y1 += H;
      case "mt":
      case "lt":
      case "arc":
      default:
        U[$].x += P, U[$].y += H;
    }
    return U;
  }, w = function(U) {
    return U.sort(function(P, H) {
      return P - H;
    });
  }, B = function(U, P) {
    for (var H, $, ie = this.fillStyle, ue = this.strokeStyle, he = this.lineCap, ve = this.lineWidth, Le = Math.abs(ve * this.ctx.transform.scaleX), de = this.lineJoin, Ce = JSON.parse(JSON.stringify(this.path)), Qe = JSON.parse(JSON.stringify(this.path)), M = [], Ae = 0; Ae < Qe.length; Ae++) if (Qe[Ae].x !== void 0) for (var G = v.call(this, Qe[Ae]), ne = 0; ne < G.length; ne += 1) M.indexOf(G[ne]) === -1 && M.push(G[ne]);
    for (var ee = 0; ee < M.length; ee++) for (; this.pdf.internal.getNumberOfPages() < M[ee]; ) m.call(this);
    if (w(M), this.autoPaging) for (var ae = M[0], re = M[M.length - 1], ce = ae; ce < re + 1; ce++) {
      this.pdf.setPage(ce), this.fillStyle = ie, this.strokeStyle = ue, this.lineCap = he, this.lineWidth = Le, this.lineJoin = de;
      var le = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], Te = ce === 1 ? this.posY + this.margin[0] : this.margin[0], Oe = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Ue = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Ge = ce === 1 ? 0 : Oe + (ce - 2) * Ue;
      if (this.ctx.clip_path.length !== 0) {
        var at = this.path;
        H = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = b(H, this.posX + this.margin[3], -Ge + Te + this.ctx.prevPageLastElemOffset), _.call(this, U, !0), this.path = at;
      }
      if ($ = JSON.parse(JSON.stringify(Ce)), this.path = b($, this.posX + this.margin[3], -Ge + Te + this.ctx.prevPageLastElemOffset), P === !1 || ce === 0) {
        var it = (ce > ae || ce < re) && p.call(this);
        it && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], le, Ue, null).clip().discardPath()), _.call(this, U, P), it && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = ve;
    }
    else this.lineWidth = Le, _.call(this, U, P), this.lineWidth = ve;
    this.path = Ce;
  }, _ = function(U, P) {
    if ((U !== "stroke" || P || !d.call(this)) && (U === "stroke" || P || !f.call(this))) {
      for (var H, $, ie = [], ue = this.path, he = 0; he < ue.length; he++) {
        var ve = ue[he];
        switch (ve.type) {
          case "begin":
            ie.push({ begin: !0 });
            break;
          case "close":
            ie.push({ close: !0 });
            break;
          case "mt":
            ie.push({ start: ve, deltas: [], abs: [] });
            break;
          case "lt":
            var Le = ie.length;
            if (ue[he - 1] && !isNaN(ue[he - 1].x) && (H = [ve.x - ue[he - 1].x, ve.y - ue[he - 1].y], Le > 0)) {
              for (; Le >= 0; Le--) if (ie[Le - 1].close !== !0 && ie[Le - 1].begin !== !0) {
                ie[Le - 1].deltas.push(H), ie[Le - 1].abs.push(ve);
                break;
              }
            }
            break;
          case "bct":
            H = [ve.x1 - ue[he - 1].x, ve.y1 - ue[he - 1].y, ve.x2 - ue[he - 1].x, ve.y2 - ue[he - 1].y, ve.x - ue[he - 1].x, ve.y - ue[he - 1].y], ie[ie.length - 1].deltas.push(H);
            break;
          case "qct":
            var de = ue[he - 1].x + 2 / 3 * (ve.x1 - ue[he - 1].x), Ce = ue[he - 1].y + 2 / 3 * (ve.y1 - ue[he - 1].y), Qe = ve.x + 2 / 3 * (ve.x1 - ve.x), M = ve.y + 2 / 3 * (ve.y1 - ve.y), Ae = ve.x, G = ve.y;
            H = [de - ue[he - 1].x, Ce - ue[he - 1].y, Qe - ue[he - 1].x, M - ue[he - 1].y, Ae - ue[he - 1].x, G - ue[he - 1].y], ie[ie.length - 1].deltas.push(H);
            break;
          case "arc":
            ie.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(ie[ie.length - 1].abs) && ie[ie.length - 1].abs.push(ve);
        }
      }
      $ = P ? null : U === "stroke" ? "stroke" : "fill";
      for (var ne = !1, ee = 0; ee < ie.length; ee++) if (ie[ee].arc) for (var ae = ie[ee].abs, re = 0; re < ae.length; re++) {
        var ce = ae[re];
        ce.type === "arc" ? F.call(this, ce.x, ce.y, ce.radius, ce.startAngle, ce.endAngle, ce.counterclockwise, void 0, P, !ne) : L.call(this, ce.x, ce.y), ne = !0;
      }
      else if (ie[ee].close === !0) this.pdf.internal.out("h"), ne = !1;
      else if (ie[ee].begin !== !0) {
        var le = ie[ee].start.x, Te = ie[ee].start.y;
        S.call(this, ie[ee].deltas, le, Te), ne = !0;
      }
      $ && N.call(this, $), P && D.call(this);
    }
  }, x = function(U) {
    var P = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, H = P * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return U - H;
      case "top":
        return U + P - H;
      case "hanging":
        return U + P - 2 * H;
      case "middle":
        return U + P / 2 - H;
      case "ideographic":
        return U;
      case "alphabetic":
      default:
        return U;
    }
  }, C = function(U) {
    return U + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  c.prototype.createLinearGradient = function() {
    var U = function() {
    };
    return U.colorStops = [], U.addColorStop = function(P, H) {
      this.colorStops.push([P, H]);
    }, U.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, U.isCanvasGradient = !0, U;
  }, c.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, c.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var F = function(U, P, H, $, ie, ue, he, ve, Le) {
    for (var de = z.call(this, H, $, ie, ue), Ce = 0; Ce < de.length; Ce++) {
      var Qe = de[Ce];
      Ce === 0 && (Le ? T.call(this, Qe.x1 + U, Qe.y1 + P) : L.call(this, Qe.x1 + U, Qe.y1 + P)), X.call(this, U, P, Qe.x2, Qe.y2, Qe.x3, Qe.y3, Qe.x4, Qe.y4);
    }
    ve ? D.call(this) : N.call(this, he);
  }, N = function(U) {
    switch (U) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, D = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, T = function(U, P) {
    this.pdf.internal.out(t(U) + " " + n(P) + " m");
  }, E = function(U) {
    var P;
    switch (U.align) {
      case "right":
      case "end":
        P = "right";
        break;
      case "center":
        P = "center";
        break;
      case "left":
      case "start":
      default:
        P = "left";
    }
    var H = this.pdf.getTextDimensions(U.text), $ = x.call(this, U.y), ie = C.call(this, $) - H.h, ue = this.ctx.transform.applyToPoint(new a(U.x, $)), he = this.ctx.transform.decompose(), ve = new A();
    ve = (ve = (ve = ve.multiply(he.translate)).multiply(he.skew)).multiply(he.scale);
    for (var Le, de, Ce, Qe = this.ctx.transform.applyToRectangle(new o(U.x, $, H.w, H.h)), M = ve.applyToRectangle(new o(U.x, ie, H.w, H.h)), Ae = v.call(this, M), G = [], ne = 0; ne < Ae.length; ne += 1) G.indexOf(Ae[ne]) === -1 && G.push(Ae[ne]);
    if (w(G), this.autoPaging) for (var ee = G[0], ae = G[G.length - 1], re = ee; re < ae + 1; re++) {
      this.pdf.setPage(re);
      var ce = re === 1 ? this.posY + this.margin[0] : this.margin[0], le = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Te = this.pdf.internal.pageSize.height - this.margin[2], Oe = Te - this.margin[0], Ue = this.pdf.internal.pageSize.width - this.margin[1], Ge = Ue - this.margin[3], at = re === 1 ? 0 : le + (re - 2) * Oe;
      if (this.ctx.clip_path.length !== 0) {
        var it = this.path;
        Le = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = b(Le, this.posX + this.margin[3], -1 * at + ce), _.call(this, "fill", !0), this.path = it;
      }
      var ut = b([JSON.parse(JSON.stringify(M))], this.posX + this.margin[3], -at + ce + this.ctx.prevPageLastElemOffset)[0];
      U.scale >= 0.01 && (de = this.pdf.internal.getFontSize(), this.pdf.setFontSize(de * U.scale), Ce = this.lineWidth, this.lineWidth = Ce * U.scale);
      var St = this.autoPaging !== "text";
      if (St || ut.y + ut.h <= Te) {
        if (St || ut.y >= ce && ut.x <= Ue) {
          var et = St ? U.text : this.pdf.splitTextToSize(U.text, U.maxWidth || Ue - ut.x)[0], gr = b([JSON.parse(JSON.stringify(Qe))], this.posX + this.margin[3], -at + ce + this.ctx.prevPageLastElemOffset)[0], bt = St && (re > ee || re < ae) && p.call(this);
          bt && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Ge, Oe, null).clip().discardPath()), this.pdf.text(et, gr.x, gr.y, { angle: U.angle, align: P, renderingMode: U.renderingMode }), bt && this.pdf.restoreGraphicsState();
        }
      } else ut.y < Te && (this.ctx.prevPageLastElemOffset += Te - ut.y);
      U.scale >= 0.01 && (this.pdf.setFontSize(de), this.lineWidth = Ce);
    }
    else U.scale >= 0.01 && (de = this.pdf.internal.getFontSize(), this.pdf.setFontSize(de * U.scale), Ce = this.lineWidth, this.lineWidth = Ce * U.scale), this.pdf.text(U.text, ue.x + this.posX, ue.y + this.posY, { angle: U.angle, align: P, renderingMode: U.renderingMode, maxWidth: U.maxWidth }), U.scale >= 0.01 && (this.pdf.setFontSize(de), this.lineWidth = Ce);
  }, L = function(U, P, H, $) {
    H = H || 0, $ = $ || 0, this.pdf.internal.out(t(U + H) + " " + n(P + $) + " l");
  }, S = function(U, P, H) {
    return this.pdf.lines(U, P, H, null, null);
  }, X = function(U, P, H, $, ie, ue, he, ve) {
    this.pdf.internal.out([e(i(H + U)), e(s($ + P)), e(i(ie + U)), e(s(ue + P)), e(i(he + U)), e(s(ve + P)), "c"].join(" "));
  }, z = function(U, P, H, $) {
    for (var ie = 2 * Math.PI, ue = Math.PI / 2; P > H; ) P -= ie;
    var he = Math.abs(H - P);
    he < ie && $ && (he = ie - he);
    for (var ve = [], Le = $ ? -1 : 1, de = P; he > 1e-5; ) {
      var Ce = de + Le * Math.min(he, ue);
      ve.push(R.call(this, U, de, Ce)), he -= Math.abs(Ce - de), de = Ce;
    }
    return ve;
  }, R = function(U, P, H) {
    var $ = (H - P) / 2, ie = U * Math.cos($), ue = U * Math.sin($), he = ie, ve = -ue, Le = he * he + ve * ve, de = Le + he * ie + ve * ue, Ce = 4 / 3 * (Math.sqrt(2 * Le * de) - de) / (he * ue - ve * ie), Qe = he - Ce * ve, M = ve + Ce * he, Ae = Qe, G = -M, ne = $ + P, ee = Math.cos(ne), ae = Math.sin(ne);
    return { x1: U * Math.cos(P), y1: U * Math.sin(P), x2: Qe * ee - M * ae, y2: Qe * ae + M * ee, x3: Ae * ee - G * ae, y3: Ae * ae + G * ee, x4: U * Math.cos(H), y4: U * Math.sin(H) };
  }, V = function(U) {
    return 180 * U / Math.PI;
  }, O = function(U, P, H, $, ie, ue) {
    var he = U + 0.5 * (H - U), ve = P + 0.5 * ($ - P), Le = ie + 0.5 * (H - ie), de = ue + 0.5 * ($ - ue), Ce = Math.min(U, ie, he, Le), Qe = Math.max(U, ie, he, Le), M = Math.min(P, ue, ve, de), Ae = Math.max(P, ue, ve, de);
    return new o(Ce, M, Qe - Ce, Ae - M);
  }, J = function(U, P, H, $, ie, ue, he, ve) {
    var Le, de, Ce, Qe, M, Ae, G, ne, ee, ae, re, ce, le, Te, Oe = H - U, Ue = $ - P, Ge = ie - H, at = ue - $, it = he - ie, ut = ve - ue;
    for (de = 0; de < 41; de++) ee = (G = (Ce = U + (Le = de / 40) * Oe) + Le * ((M = H + Le * Ge) - Ce)) + Le * (M + Le * (ie + Le * it - M) - G), ae = (ne = (Qe = P + Le * Ue) + Le * ((Ae = $ + Le * at) - Qe)) + Le * (Ae + Le * (ue + Le * ut - Ae) - ne), de == 0 ? (re = ee, ce = ae, le = ee, Te = ae) : (re = Math.min(re, ee), ce = Math.min(ce, ae), le = Math.max(le, ee), Te = Math.max(Te, ae));
    return new o(Math.round(re), Math.round(ce), Math.round(le - re), Math.round(Te - ce));
  }, Z = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var U, P, H = (U = this.ctx.lineDash, P = this.ctx.lineDashOffset, JSON.stringify({ lineDash: U, lineDashOffset: P }));
      this.prevLineDash !== H && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = H);
    }
  };
})(Ft.API), /**
 * @license
 * jsPDF filters PlugIn
 * Copyright (c) 2014 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(r) {
  var e = function(s) {
    var a, o, A, l, u, c, h, f, d, p;
    for (o = [], A = 0, l = (s += a = "\0\0\0\0".slice(s.length % 4 || 4)).length; l > A; A += 4) (u = (s.charCodeAt(A) << 24) + (s.charCodeAt(A + 1) << 16) + (s.charCodeAt(A + 2) << 8) + s.charCodeAt(A + 3)) !== 0 ? (c = (u = ((u = ((u = ((u = (u - (p = u % 85)) / 85) - (d = u % 85)) / 85) - (f = u % 85)) / 85) - (h = u % 85)) / 85) % 85, o.push(c + 33, h + 33, f + 33, d + 33, p + 33)) : o.push(122);
    return function(v, m) {
      for (var b = m; b > 0; b--) v.pop();
    }(o, a.length), String.fromCharCode.apply(String, o) + "~>";
  }, t = function(s) {
    var a, o, A, l, u, c = String, h = "length", f = 255, d = "charCodeAt", p = "slice", v = "replace";
    for (s[p](-2), s = s[p](0, -2)[v](/\s/g, "")[v]("z", "!!!!!"), A = [], l = 0, u = (s += a = "uuuuu"[p](s[h] % 5 || 5))[h]; u > l; l += 5) o = 52200625 * (s[d](l) - 33) + 614125 * (s[d](l + 1) - 33) + 7225 * (s[d](l + 2) - 33) + 85 * (s[d](l + 3) - 33) + (s[d](l + 4) - 33), A.push(f & o >> 24, f & o >> 16, f & o >> 8, f & o);
    return function(m, b) {
      for (var w = b; w > 0; w--) m.pop();
    }(A, a[h]), c.fromCharCode.apply(c, A);
  }, n = function(s) {
    var a = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((s = s.replace(/\s/g, "")).indexOf(">") !== -1 && (s = s.substr(0, s.indexOf(">"))), s.length % 2 && (s += "0"), a.test(s) === !1) return "";
    for (var o = "", A = 0; A < s.length; A += 2) o += String.fromCharCode("0x" + (s[A] + s[A + 1]));
    return o;
  }, i = function(s) {
    for (var a = new Uint8Array(s.length), o = s.length; o--; ) a[o] = s.charCodeAt(o);
    return s = (a = vv(a)).reduce(function(A, l) {
      return A + String.fromCharCode(l);
    }, "");
  };
  r.processDataByFilters = function(s, a) {
    var o = 0, A = s || "", l = [];
    for (typeof (a = a || []) == "string" && (a = [a]), o = 0; o < a.length; o += 1) switch (a[o]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        A = t(A), l.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        A = e(A), l.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        A = n(A), l.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        A = A.split("").map(function(u) {
          return ("0" + u.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">", l.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        A = i(A), l.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + a[o] + '" is not implemented');
    }
    return { data: A, reverseChain: l.reverse().join(" ") };
  };
}(Ft.API), /**
 * @license
 * jsPDF fileloading PlugIn
 * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(r) {
  r.loadFile = function(e, t, n) {
    return function(i, s, a) {
      s = s !== !1, a = typeof a == "function" ? a : function() {
      };
      var o = void 0;
      try {
        o = function(A, l, u) {
          var c = new XMLHttpRequest(), h = 0, f = function(d) {
            var p = d.length, v = [], m = String.fromCharCode;
            for (h = 0; h < p; h += 1) v.push(m(255 & d.charCodeAt(h)));
            return v.join("");
          };
          if (c.open("GET", A, !l), c.overrideMimeType("text/plain; charset=x-user-defined"), l === !1 && (c.onload = function() {
            c.status === 200 ? u(f(this.responseText)) : u(void 0);
          }), c.send(null), l && c.status === 200) return f(c.responseText);
        }(i, s, a);
      } catch {
      }
      return o;
    }(e, t, n);
  }, r.loadImageFile = r.loadFile;
}(Ft.API), function(r) {
  function e() {
    return (Lt.html2canvas ? Promise.resolve(Lt.html2canvas) : Promise.resolve().then(() => rq)).catch(function(a) {
      return Promise.reject(new Error("Could not load html2canvas: " + a));
    }).then(function(a) {
      return a.default ? a.default : a;
    });
  }
  function t() {
    return (Lt.DOMPurify ? Promise.resolve(Lt.DOMPurify) : Promise.resolve().then(() => Lq)).catch(function(a) {
      return Promise.reject(new Error("Could not load dompurify: " + a));
    }).then(function(a) {
      return a.default ? a.default : a;
    });
  }
  var n = function(a) {
    var o = br(a);
    return o === "undefined" ? "undefined" : o === "string" || a instanceof String ? "string" : o === "number" || a instanceof Number ? "number" : o === "function" || a instanceof Function ? "function" : a && a.constructor === Array ? "array" : a && a.nodeType === 1 ? "element" : o === "object" ? "object" : "unknown";
  }, i = function(a, o) {
    var A = document.createElement(a);
    for (var l in o.className && (A.className = o.className), o.innerHTML && o.dompurify && (A.innerHTML = o.dompurify.sanitize(o.innerHTML)), o.style) A.style[l] = o.style[l];
    return A;
  }, s = function a(o) {
    var A = Object.assign(a.convert(Promise.resolve()), JSON.parse(JSON.stringify(a.template))), l = a.convert(Promise.resolve(), A);
    return l = (l = l.setProgress(1, a, 1, [a])).set(o);
  };
  (s.prototype = Object.create(Promise.prototype)).constructor = s, s.convert = function(a, o) {
    return a.__proto__ = o || s.prototype, a;
  }, s.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s.prototype.from = function(a, o) {
    return this.then(function() {
      switch (o = o || function(A) {
        switch (n(A)) {
          case "string":
            return "string";
          case "element":
            return A.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(a)) {
        case "string":
          return this.then(t).then(function(A) {
            return this.set({ src: i("div", { innerHTML: a, dompurify: A }) });
          });
        case "element":
          return this.set({ src: a });
        case "canvas":
          return this.set({ canvas: a });
        case "img":
          return this.set({ img: a });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, s.prototype.to = function(a) {
    switch (a) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, s.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var a = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, o = function A(l, u) {
        for (var c = l.nodeType === 3 ? document.createTextNode(l.nodeValue) : l.cloneNode(!1), h = l.firstChild; h; h = h.nextSibling) u !== !0 && h.nodeType === 1 && h.nodeName === "SCRIPT" || c.appendChild(A(h, u));
        return l.nodeType === 1 && (l.nodeName === "CANVAS" ? (c.width = l.width, c.height = l.height, c.getContext("2d").drawImage(l, 0, 0)) : l.nodeName !== "TEXTAREA" && l.nodeName !== "SELECT" || (c.value = l.value), c.addEventListener("load", function() {
          c.scrollTop = l.scrollTop, c.scrollLeft = l.scrollLeft;
        }, !0)), c;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      o.tagName === "BODY" && (a.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = i("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = i("div", { className: "html2pdf__container", style: a }), this.prop.container.appendChild(o), this.prop.container.firstChild.appendChild(i("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, s.prototype.toCanvas = function() {
    var a = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(a).then(e).then(function(o) {
      var A = Object.assign({}, this.opt.html2canvas);
      return delete A.onrendered, o(this.prop.container, A);
    }).then(function(o) {
      (this.opt.html2canvas.onrendered || function() {
      })(o), this.prop.canvas = o, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toContext2d = function() {
    var a = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(a).then(e).then(function(o) {
      var A = this.opt.jsPDF, l = this.opt.fontFaces, u = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, c = Object.assign({ async: !0, allowTaint: !0, scale: u, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas);
      if (delete c.onrendered, A.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, A.context2d.posX = this.opt.x, A.context2d.posY = this.opt.y, A.context2d.margin = this.opt.margin, A.context2d.fontFaces = l, l) for (var h = 0; h < l.length; ++h) {
        var f = l[h], d = f.src.find(function(p) {
          return p.format === "truetype";
        });
        d && A.addFont(d.url, f.ref.name, f.ref.style);
      }
      return c.windowHeight = c.windowHeight || 0, c.windowHeight = c.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : c.windowHeight, A.context2d.save(!0), o(this.prop.container, c);
    }).then(function(o) {
      this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {
      })(o), this.prop.canvas = o, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var a = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = a;
    });
  }, s.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, s.prototype.output = function(a, o, A) {
    return (A = A || "pdf").toLowerCase() === "img" || A.toLowerCase() === "image" ? this.outputImg(a, o) : this.outputPdf(a, o);
  }, s.prototype.outputPdf = function(a, o) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(a, o);
    });
  }, s.prototype.outputImg = function(a) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (a) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + a + '" is not supported.';
      }
    });
  }, s.prototype.save = function(a) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(a ? { filename: a } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, s.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, s.prototype.set = function(a) {
    if (n(a) !== "object") return this;
    var o = Object.keys(a || {}).map(function(A) {
      if (A in s.template.prop) return function() {
        this.prop[A] = a[A];
      };
      switch (A) {
        case "margin":
          return this.setMargin.bind(this, a.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = a.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, a.pageSize);
        default:
          return function() {
            this.opt[A] = a[A];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(o);
    });
  }, s.prototype.get = function(a, o) {
    return this.then(function() {
      var A = a in s.template.prop ? this.prop[a] : this.opt[a];
      return o ? o(A) : A;
    });
  }, s.prototype.setMargin = function(a) {
    return this.then(function() {
      switch (n(a)) {
        case "number":
          a = [a, a, a, a];
        case "array":
          if (a.length === 2 && (a = [a[0], a[1], a[0], a[1]]), a.length === 4) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = a;
    }).then(this.setPageSize);
  }, s.prototype.setPageSize = function(a) {
    function o(A, l) {
      return Math.floor(A * l / 72 * 96);
    }
    return this.then(function() {
      (a = a || Ft.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (a.inner = { width: a.width - this.opt.margin[1] - this.opt.margin[3], height: a.height - this.opt.margin[0] - this.opt.margin[2] }, a.inner.px = { width: o(a.inner.width, a.k), height: o(a.inner.height, a.k) }, a.inner.ratio = a.inner.height / a.inner.width), this.prop.pageSize = a;
    });
  }, s.prototype.setProgress = function(a, o, A, l) {
    return a != null && (this.progress.val = a), o != null && (this.progress.state = o), A != null && (this.progress.n = A), l != null && (this.progress.stack = l), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, s.prototype.updateProgress = function(a, o, A, l) {
    return this.setProgress(a ? this.progress.val + a : null, o || null, A ? this.progress.n + A : null, l ? this.progress.stack.concat(l) : null);
  }, s.prototype.then = function(a, o) {
    var A = this;
    return this.thenCore(a, o, function(l, u) {
      return A.updateProgress(null, null, 1, [l]), Promise.prototype.then.call(this, function(c) {
        return A.updateProgress(null, l), c;
      }).then(l, u).then(function(c) {
        return A.updateProgress(1), c;
      });
    });
  }, s.prototype.thenCore = function(a, o, A) {
    A = A || Promise.prototype.then, a && (a = a.bind(this)), o && (o = o.bind(this));
    var l = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : s.convert(Object.assign({}, this), Promise.prototype), u = A.call(l, a, o);
    return s.convert(u, this.__proto__);
  }, s.prototype.thenExternal = function(a, o) {
    return Promise.prototype.then.call(this, a, o);
  }, s.prototype.thenList = function(a) {
    var o = this;
    return a.forEach(function(A) {
      o = o.thenCore(A);
    }), o;
  }, s.prototype.catch = function(a) {
    a && (a = a.bind(this));
    var o = Promise.prototype.catch.call(this, a);
    return s.convert(o, this);
  }, s.prototype.catchExternal = function(a) {
    return Promise.prototype.catch.call(this, a);
  }, s.prototype.error = function(a) {
    return this.then(function() {
      throw new Error(a);
    });
  }, s.prototype.using = s.prototype.set, s.prototype.saveAs = s.prototype.save, s.prototype.export = s.prototype.output, s.prototype.run = s.prototype.then, Ft.getPageSize = function(a, o, A) {
    if (br(a) === "object") {
      var l = a;
      a = l.orientation, o = l.unit || o, A = l.format || A;
    }
    o = o || "mm", A = A || "a4", a = ("" + (a || "P")).toLowerCase();
    var u, c = ("" + A).toLowerCase(), h = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (o) {
      case "pt":
        u = 1;
        break;
      case "mm":
        u = 72 / 25.4;
        break;
      case "cm":
        u = 72 / 2.54;
        break;
      case "in":
        u = 72;
        break;
      case "px":
        u = 0.75;
        break;
      case "pc":
      case "em":
        u = 12;
        break;
      case "ex":
        u = 6;
        break;
      default:
        throw "Invalid unit: " + o;
    }
    var f, d = 0, p = 0;
    if (h.hasOwnProperty(c)) d = h[c][1] / u, p = h[c][0] / u;
    else try {
      d = A[1], p = A[0];
    } catch {
      throw new Error("Invalid format: " + A);
    }
    if (a === "p" || a === "portrait") a = "p", p > d && (f = p, p = d, d = f);
    else {
      if (a !== "l" && a !== "landscape") throw "Invalid orientation: " + a;
      a = "l", d > p && (f = p, p = d, d = f);
    }
    return { width: p, height: d, unit: o, k: u, orientation: a };
  }, r.html = function(a, o) {
    (o = o || {}).callback = o.callback || function() {
    }, o.html2canvas = o.html2canvas || {}, o.html2canvas.canvas = o.html2canvas.canvas || this.canvas, o.jsPDF = o.jsPDF || this, o.fontFaces = o.fontFaces ? o.fontFaces.map(_v) : null;
    var A = new s(o);
    return o.worker ? A : A.from(a).doCallback();
  };
}(Ft.API), Ft.API.addJS = function(r) {
  return WB = r, this.internal.events.subscribe("postPutResources", function() {
    sd = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (sd + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), qB = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + WB + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    sd !== void 0 && qB !== void 0 && this.internal.out("/Names <</JavaScript " + sd + " 0 R>>");
  }), this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(r) {
  var e;
  r.events.push(["postPutResources", function() {
    var t = this, n = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var i = t.outline.render().split(/\r\n/), s = 0; s < i.length; s++) {
      var a = i[s], o = n.exec(a);
      if (o != null) {
        var A = o[1];
        t.internal.newObjectDeferredBegin(A, !1);
      }
      t.internal.write(a);
    }
    if (this.outline.createNamedDestinations) {
      var l = this.internal.pages.length, u = [];
      for (s = 0; s < l; s++) {
        var c = t.internal.newObject();
        u.push(c);
        var h = t.internal.getPageInfo(s + 1);
        t.internal.write("<< /D[" + h.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var f = t.internal.newObject();
      for (t.internal.write("<< /Names [ "), s = 0; s < u.length; s++) t.internal.write("(page_" + (s + 1) + ")" + u[s] + " 0 R");
      t.internal.write(" ] >>", "endobj"), e = t.internal.newObject(), t.internal.write("<< /Dests " + f + " 0 R"), t.internal.write(">>", "endobj");
    }
  }]), r.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e + " 0 R"));
  }]), r.events.push(["initialized", function() {
    var t = this;
    t.outline = { createNamedDestinations: !1, root: { children: [] } }, t.outline.add = function(n, i, s) {
      var a = { title: i, options: s, children: [] };
      return n == null && (n = this.root), n.children.push(a), a;
    }, t.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, t.outline.genIds_r = function(n) {
      n.id = t.internal.newObjectDeferred();
      for (var i = 0; i < n.children.length; i++) this.genIds_r(n.children[i]);
    }, t.outline.renderRoot = function(n) {
      this.objStart(n), this.line("/Type /Outlines"), n.children.length > 0 && (this.line("/First " + this.makeRef(n.children[0])), this.line("/Last " + this.makeRef(n.children[n.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, n)), this.objEnd();
    }, t.outline.renderItems = function(n) {
      for (var i = this.ctx.pdf.internal.getVerticalCoordinateString, s = 0; s < n.children.length; s++) {
        var a = n.children[s];
        this.objStart(a), this.line("/Title " + this.makeString(a.title)), this.line("/Parent " + this.makeRef(n)), s > 0 && this.line("/Prev " + this.makeRef(n.children[s - 1])), s < n.children.length - 1 && this.line("/Next " + this.makeRef(n.children[s + 1])), a.children.length > 0 && (this.line("/First " + this.makeRef(a.children[0])), this.line("/Last " + this.makeRef(a.children[a.children.length - 1])));
        var o = this.count = this.count_r({ count: 0 }, a);
        if (o > 0 && this.line("/Count " + o), a.options && a.options.pageNumber) {
          var A = t.internal.getPageInfo(a.options.pageNumber);
          this.line("/Dest [" + A.objId + " 0 R /XYZ 0 " + i(0) + " 0]");
        }
        this.objEnd();
      }
      for (var l = 0; l < n.children.length; l++) this.renderItems(n.children[l]);
    }, t.outline.line = function(n) {
      this.ctx.val += n + `\r
`;
    }, t.outline.makeRef = function(n) {
      return n.id + " 0 R";
    }, t.outline.makeString = function(n) {
      return "(" + t.internal.pdfEscape(n) + ")";
    }, t.outline.objStart = function(n) {
      this.ctx.val += `\r
` + n.id + ` 0 obj\r
<<\r
`;
    }, t.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, t.outline.count_r = function(n, i) {
      for (var s = 0; s < i.children.length; s++) n.count++, this.count_r(n, i.children[s]);
      return n.count;
    };
  }]);
}(Ft.API), /**
 * @license
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(r) {
  var e = [192, 193, 194, 195, 196, 197, 198, 199];
  r.processJPEG = function(t, n, i, s, a, o) {
    var A, l = this.decode.DCT_DECODE, u = null;
    if (typeof t == "string" || this.__addimage__.isArrayBuffer(t) || this.__addimage__.isArrayBufferView(t)) {
      switch (t = a || t, t = this.__addimage__.isArrayBuffer(t) ? new Uint8Array(t) : t, (A = function(c) {
        for (var h, f = 256 * c.charCodeAt(4) + c.charCodeAt(5), d = c.length, p = { width: 0, height: 0, numcomponents: 1 }, v = 4; v < d; v += 2) {
          if (v += f, e.indexOf(c.charCodeAt(v + 1)) !== -1) {
            h = 256 * c.charCodeAt(v + 5) + c.charCodeAt(v + 6), p = { width: 256 * c.charCodeAt(v + 7) + c.charCodeAt(v + 8), height: h, numcomponents: c.charCodeAt(v + 9) };
            break;
          }
          f = 256 * c.charCodeAt(v + 2) + c.charCodeAt(v + 3);
        }
        return p;
      }(t = this.__addimage__.isArrayBufferView(t) ? this.__addimage__.arrayBufferToBinaryString(t) : t)).numcomponents) {
        case 1:
          o = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          o = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          o = this.color_spaces.DEVICE_RGB;
      }
      u = { data: t, width: A.width, height: A.height, colorSpace: o, bitsPerComponent: 8, filter: l, index: n, alias: i };
    }
    return u;
  };
}(Ft.API);
var zl, ad, XB, JB, YB, wP = function() {
  var r, e, t;
  function n(s) {
    var a, o, A, l, u, c, h, f, d, p, v, m, b, w;
    for (this.data = s, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, c = null; ; ) {
      switch (a = this.readUInt32(), d = (function() {
        var B, _;
        for (_ = [], B = 0; B < 4; ++B) _.push(String.fromCharCode(this.data[this.pos++]));
        return _;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(a);
          break;
        case "fcTL":
          c && this.animation.frames.push(c), this.pos += 4, c = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, u = this.readUInt16(), l = this.readUInt16() || 100, c.delay = 1e3 * u / l, c.disposeOp = this.data[this.pos++], c.blendOp = this.data[this.pos++], c.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (d === "fdAT" && (this.pos += 4, a -= 4), s = (c != null ? c.data : void 0) || this.imgData, m = 0; 0 <= a ? m < a : m > a; 0 <= a ? ++m : --m) s.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (A = this.palette.length / 3, this.transparency.indexed = this.read(a), this.transparency.indexed.length > A) throw new Error("More transparent colors than palette size");
              if ((p = A - this.transparency.indexed.length) > 0) for (b = 0; 0 <= p ? b < p : b > p; 0 <= p ? ++b : --b) this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(a)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(a);
          }
          break;
        case "tEXt":
          h = (v = this.read(a)).indexOf(0), f = String.fromCharCode.apply(String, v.slice(0, h)), this.text[f] = String.fromCharCode.apply(String, v.slice(h + 1));
          break;
        case "IEND":
          return c && this.animation.frames.push(c), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = (w = this.colorType) === 4 || w === 6, o = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * o, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += a;
      }
      if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
    }
  }
  n.prototype.read = function(s) {
    var a, o;
    for (o = [], a = 0; 0 <= s ? a < s : a > s; 0 <= s ? ++a : --a) o.push(this.data[this.pos++]);
    return o;
  }, n.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, n.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, n.prototype.decodePixels = function(s) {
    var a = this.pixelBitlength / 8, o = new Uint8Array(this.width * this.height * a), A = 0, l = this;
    if (s == null && (s = this.imgData), s.length === 0) return new Uint8Array(0);
    function u(c, h, f, d) {
      var p, v, m, b, w, B, _, x, C, F, N, D, T, E, L, S, X, z, R, V, O, J = Math.ceil((l.width - c) / f), Z = Math.ceil((l.height - h) / d), U = l.width == J && l.height == Z;
      for (E = a * J, D = U ? o : new Uint8Array(E * Z), B = s.length, T = 0, v = 0; T < Z && A < B; ) {
        switch (s[A++]) {
          case 0:
            for (b = X = 0; X < E; b = X += 1) D[v++] = s[A++];
            break;
          case 1:
            for (b = z = 0; z < E; b = z += 1) p = s[A++], w = b < a ? 0 : D[v - a], D[v++] = (p + w) % 256;
            break;
          case 2:
            for (b = R = 0; R < E; b = R += 1) p = s[A++], m = (b - b % a) / a, L = T && D[(T - 1) * E + m * a + b % a], D[v++] = (L + p) % 256;
            break;
          case 3:
            for (b = V = 0; V < E; b = V += 1) p = s[A++], m = (b - b % a) / a, w = b < a ? 0 : D[v - a], L = T && D[(T - 1) * E + m * a + b % a], D[v++] = (p + Math.floor((w + L) / 2)) % 256;
            break;
          case 4:
            for (b = O = 0; O < E; b = O += 1) p = s[A++], m = (b - b % a) / a, w = b < a ? 0 : D[v - a], T === 0 ? L = S = 0 : (L = D[(T - 1) * E + m * a + b % a], S = m && D[(T - 1) * E + (m - 1) * a + b % a]), _ = w + L - S, x = Math.abs(_ - w), F = Math.abs(_ - L), N = Math.abs(_ - S), C = x <= F && x <= N ? w : F <= N ? L : S, D[v++] = (p + C) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + s[A - 1]);
        }
        if (!U) {
          var P = ((h + T * d) * l.width + c) * a, H = T * E;
          for (b = 0; b < J; b += 1) {
            for (var $ = 0; $ < a; $ += 1) o[P++] = D[H++];
            P += (f - 1) * a;
          }
        }
        T++;
      }
    }
    return s = YR(s), l.interlaceMethod == 1 ? (u(0, 0, 8, 8), u(4, 0, 8, 8), u(0, 4, 4, 8), u(2, 0, 4, 4), u(0, 2, 2, 4), u(1, 0, 2, 2), u(0, 1, 1, 2)) : u(0, 0, 1, 1), o;
  }, n.prototype.decodePalette = function() {
    var s, a, o, A, l, u, c, h, f;
    for (o = this.palette, u = this.transparency.indexed || [], l = new Uint8Array((u.length || 0) + o.length), A = 0, s = 0, a = c = 0, h = o.length; c < h; a = c += 3) l[A++] = o[a], l[A++] = o[a + 1], l[A++] = o[a + 2], l[A++] = (f = u[s++]) != null ? f : 255;
    return l;
  }, n.prototype.copyToImageData = function(s, a) {
    var o, A, l, u, c, h, f, d, p, v, m;
    if (A = this.colors, p = null, o = this.hasAlphaChannel, this.palette.length && (p = (m = this._decodedPalette) != null ? m : this._decodedPalette = this.decodePalette(), A = 4, o = !0), d = (l = s.data || s).length, c = p || a, u = h = 0, A === 1) for (; u < d; ) f = p ? 4 * a[u / 4] : h, v = c[f++], l[u++] = v, l[u++] = v, l[u++] = v, l[u++] = o ? c[f++] : 255, h = f;
    else for (; u < d; ) f = p ? 4 * a[u / 4] : h, l[u++] = c[f++], l[u++] = c[f++], l[u++] = c[f++], l[u++] = o ? c[f++] : 255, h = f;
  }, n.prototype.decode = function() {
    var s;
    return s = new Uint8Array(this.width * this.height * 4), this.copyToImageData(s, this.decodePixels()), s;
  };
  var i = function() {
    if (Object.prototype.toString.call(Lt) === "[object Window]") {
      try {
        e = Lt.document.createElement("canvas"), t = e.getContext("2d");
      } catch {
        return !1;
      }
      return !0;
    }
    return !1;
  };
  return i(), r = function(s) {
    var a;
    if (i() === !0) return t.width = s.width, t.height = s.height, t.clearRect(0, 0, s.width, s.height), t.putImageData(s, 0, 0), (a = new Image()).src = e.toDataURL(), a;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, n.prototype.decodeFrames = function(s) {
    var a, o, A, l, u, c, h, f;
    if (this.animation) {
      for (f = [], o = u = 0, c = (h = this.animation.frames).length; u < c; o = ++u) a = h[o], A = s.createImageData(a.width, a.height), l = this.decodePixels(new Uint8Array(a.data)), this.copyToImageData(A, l), a.imageData = A, f.push(a.image = r(A));
      return f;
    }
  }, n.prototype.renderFrame = function(s, a) {
    var o, A, l;
    return o = (A = this.animation.frames)[a], l = A[a - 1], a === 0 && s.clearRect(0, 0, this.width, this.height), (l != null ? l.disposeOp : void 0) === 1 ? s.clearRect(l.xOffset, l.yOffset, l.width, l.height) : (l != null ? l.disposeOp : void 0) === 2 && s.putImageData(l.imageData, l.xOffset, l.yOffset), o.blendOp === 0 && s.clearRect(o.xOffset, o.yOffset, o.width, o.height), s.drawImage(o.image, o.xOffset, o.yOffset);
  }, n.prototype.animate = function(s) {
    var a, o, A, l, u, c, h = this;
    return o = 0, c = this.animation, l = c.numFrames, A = c.frames, u = c.numPlays, (a = function() {
      var f, d;
      if (f = o++ % l, d = A[f], h.renderFrame(s, f), l > 1 && o / l < u) return h.animation._timeout = setTimeout(a, d.delay);
    })();
  }, n.prototype.stopAnimation = function() {
    var s;
    return clearTimeout((s = this.animation) != null ? s._timeout : void 0);
  }, n.prototype.render = function(s) {
    var a, o;
    return s._png && s._png.stopAnimation(), s._png = this, s.width = this.width, s.height = this.height, a = s.getContext("2d"), this.animation ? (this.decodeFrames(a), this.animate(a)) : (o = a.createImageData(this.width, this.height), this.copyToImageData(o, this.decodePixels()), a.putImageData(o, 0, 0));
  }, n;
}();
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
function BP(r) {
  var e = 0;
  if (r[e++] !== 71 || r[e++] !== 73 || r[e++] !== 70 || r[e++] !== 56 || (r[e++] + 1 & 253) != 56 || r[e++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
  var t = r[e++] | r[e++] << 8, n = r[e++] | r[e++] << 8, i = r[e++], s = i >> 7, a = 1 << (7 & i) + 1;
  r[e++], r[e++];
  var o = null, A = null;
  s && (o = e, A = a, e += 3 * a);
  var l = !0, u = [], c = 0, h = null, f = 0, d = null;
  for (this.width = t, this.height = n; l && e < r.length; ) switch (r[e++]) {
    case 33:
      switch (r[e++]) {
        case 255:
          if (r[e] !== 11 || r[e + 1] == 78 && r[e + 2] == 69 && r[e + 3] == 84 && r[e + 4] == 83 && r[e + 5] == 67 && r[e + 6] == 65 && r[e + 7] == 80 && r[e + 8] == 69 && r[e + 9] == 50 && r[e + 10] == 46 && r[e + 11] == 48 && r[e + 12] == 3 && r[e + 13] == 1 && r[e + 16] == 0) e += 14, d = r[e++] | r[e++] << 8, e++;
          else for (e += 12; ; ) {
            if (!((T = r[e++]) >= 0)) throw Error("Invalid block size");
            if (T === 0) break;
            e += T;
          }
          break;
        case 249:
          if (r[e++] !== 4 || r[e + 4] !== 0) throw new Error("Invalid graphics extension block.");
          var p = r[e++];
          c = r[e++] | r[e++] << 8, h = r[e++], !(1 & p) && (h = null), f = p >> 2 & 7, e++;
          break;
        case 254:
          for (; ; ) {
            if (!((T = r[e++]) >= 0)) throw Error("Invalid block size");
            if (T === 0) break;
            e += T;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + r[e - 1].toString(16));
      }
      break;
    case 44:
      var v = r[e++] | r[e++] << 8, m = r[e++] | r[e++] << 8, b = r[e++] | r[e++] << 8, w = r[e++] | r[e++] << 8, B = r[e++], _ = B >> 6 & 1, x = 1 << (7 & B) + 1, C = o, F = A, N = !1;
      B >> 7 && (N = !0, C = e, F = x, e += 3 * x);
      var D = e;
      for (e++; ; ) {
        var T;
        if (!((T = r[e++]) >= 0)) throw Error("Invalid block size");
        if (T === 0) break;
        e += T;
      }
      u.push({ x: v, y: m, width: b, height: w, has_local_palette: N, palette_offset: C, palette_size: F, data_offset: D, data_length: e - D, transparent_index: h, interlaced: !!_, delay: c, disposal: f });
      break;
    case 59:
      l = !1;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + r[e - 1].toString(16));
  }
  this.numFrames = function() {
    return u.length;
  }, this.loopCount = function() {
    return d;
  }, this.frameInfo = function(E) {
    if (E < 0 || E >= u.length) throw new Error("Frame index out of range.");
    return u[E];
  }, this.decodeAndBlitFrameBGRA = function(E, L) {
    var S = this.frameInfo(E), X = S.width * S.height, z = new Uint8Array(X);
    ZB(r, S.data_offset, z, X);
    var R = S.palette_offset, V = S.transparent_index;
    V === null && (V = 256);
    var O = S.width, J = t - O, Z = O, U = 4 * (S.y * t + S.x), P = 4 * ((S.y + S.height) * t + S.x), H = U, $ = 4 * J;
    S.interlaced === !0 && ($ += 4 * t * 7);
    for (var ie = 8, ue = 0, he = z.length; ue < he; ++ue) {
      var ve = z[ue];
      if (Z === 0 && (Z = O, (H += $) >= P && ($ = 4 * J + 4 * t * (ie - 1), H = U + (O + J) * (ie << 1), ie >>= 1)), ve === V) H += 4;
      else {
        var Le = r[R + 3 * ve], de = r[R + 3 * ve + 1], Ce = r[R + 3 * ve + 2];
        L[H++] = Ce, L[H++] = de, L[H++] = Le, L[H++] = 255;
      }
      --Z;
    }
  }, this.decodeAndBlitFrameRGBA = function(E, L) {
    var S = this.frameInfo(E), X = S.width * S.height, z = new Uint8Array(X);
    ZB(r, S.data_offset, z, X);
    var R = S.palette_offset, V = S.transparent_index;
    V === null && (V = 256);
    var O = S.width, J = t - O, Z = O, U = 4 * (S.y * t + S.x), P = 4 * ((S.y + S.height) * t + S.x), H = U, $ = 4 * J;
    S.interlaced === !0 && ($ += 4 * t * 7);
    for (var ie = 8, ue = 0, he = z.length; ue < he; ++ue) {
      var ve = z[ue];
      if (Z === 0 && (Z = O, (H += $) >= P && ($ = 4 * J + 4 * t * (ie - 1), H = U + (O + J) * (ie << 1), ie >>= 1)), ve === V) H += 4;
      else {
        var Le = r[R + 3 * ve], de = r[R + 3 * ve + 1], Ce = r[R + 3 * ve + 2];
        L[H++] = Le, L[H++] = de, L[H++] = Ce, L[H++] = 255;
      }
      --Z;
    }
  };
}
function ZB(r, e, t, n) {
  for (var i = r[e++], s = 1 << i, a = s + 1, o = a + 1, A = i + 1, l = (1 << A) - 1, u = 0, c = 0, h = 0, f = r[e++], d = new Int32Array(4096), p = null; ; ) {
    for (; u < 16 && f !== 0; ) c |= r[e++] << u, u += 8, f === 1 ? f = r[e++] : --f;
    if (u < A) break;
    var v = c & l;
    if (c >>= A, u -= A, v !== s) {
      if (v === a) break;
      for (var m = v < o ? v : p, b = 0, w = m; w > s; ) w = d[w] >> 8, ++b;
      var B = w;
      if (h + b + (m !== v ? 1 : 0) > n) return void Lr.log("Warning, gif stream longer than expected.");
      t[h++] = B;
      var _ = h += b;
      for (m !== v && (t[h++] = B), w = m; b--; ) w = d[w], t[--_] = 255 & w, w >>= 8;
      p !== null && o < 4096 && (d[o++] = p << 8 | B, o >= l + 1 && A < 12 && (++A, l = l << 1 | 1)), p = v;
    } else o = a + 1, l = (1 << (A = i + 1)) - 1, p = null;
  }
  return h !== n && Lr.log("Warning, gif stream shorter than expected."), t;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function d0(r) {
  var e, t, n, i, s, a = Math.floor, o = new Array(64), A = new Array(64), l = new Array(64), u = new Array(64), c = new Array(65535), h = new Array(65535), f = new Array(64), d = new Array(64), p = [], v = 0, m = 7, b = new Array(64), w = new Array(64), B = new Array(64), _ = new Array(256), x = new Array(2048), C = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], F = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], N = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], D = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], T = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], E = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], L = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], S = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], X = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function z(U, P) {
    for (var H = 0, $ = 0, ie = new Array(), ue = 1; ue <= 16; ue++) {
      for (var he = 1; he <= U[ue]; he++) ie[P[$]] = [], ie[P[$]][0] = H, ie[P[$]][1] = ue, $++, H++;
      H *= 2;
    }
    return ie;
  }
  function R(U) {
    for (var P = U[0], H = U[1] - 1; H >= 0; ) P & 1 << H && (v |= 1 << m), H--, --m < 0 && (v == 255 ? (V(255), V(0)) : V(v), m = 7, v = 0);
  }
  function V(U) {
    p.push(U);
  }
  function O(U) {
    V(U >> 8 & 255), V(255 & U);
  }
  function J(U, P, H, $, ie) {
    for (var ue, he = ie[0], ve = ie[240], Le = function(ae, re) {
      var ce, le, Te, Oe, Ue, Ge, at, it, ut, St, et = 0;
      for (ut = 0; ut < 8; ++ut) {
        ce = ae[et], le = ae[et + 1], Te = ae[et + 2], Oe = ae[et + 3], Ue = ae[et + 4], Ge = ae[et + 5], at = ae[et + 6];
        var gr = ce + (it = ae[et + 7]), bt = ce - it, Qr = le + at, Wt = le - at, kt = Te + Ge, Dr = Te - Ge, Xt = Oe + Ue, Cn = Oe - Ue, mr = gr + Xt, Ir = gr - Xt, hr = Qr + kt, wr = Qr - kt;
        ae[et] = mr + hr, ae[et + 4] = mr - hr;
        var gt = 0.707106781 * (wr + Ir);
        ae[et + 2] = Ir + gt, ae[et + 6] = Ir - gt;
        var rr = 0.382683433 * ((mr = Cn + Dr) - (wr = Wt + bt)), Rs = 0.5411961 * mr + rr, Yr = 1.306562965 * wr + rr, fi = 0.707106781 * (hr = Dr + Wt), Fi = bt + fi, Ct = bt - fi;
        ae[et + 5] = Ct + Rs, ae[et + 3] = Ct - Rs, ae[et + 1] = Fi + Yr, ae[et + 7] = Fi - Yr, et += 8;
      }
      for (et = 0, ut = 0; ut < 8; ++ut) {
        ce = ae[et], le = ae[et + 8], Te = ae[et + 16], Oe = ae[et + 24], Ue = ae[et + 32], Ge = ae[et + 40], at = ae[et + 48];
        var Ti = ce + (it = ae[et + 56]), Yn = ce - it, _n = le + at, Gr = le - at, ur = Te + Ge, En = Te - Ge, Ps = Oe + Ue, Ki = Oe - Ue, Zn = Ti + Ps, Nn = Ti - Ps, qr = _n + ur, Ee = _n - ur;
        ae[et] = Zn + qr, ae[et + 32] = Zn - qr;
        var or = 0.707106781 * (Ee + Nn);
        ae[et + 16] = Nn + or, ae[et + 48] = Nn - or;
        var hi = 0.382683433 * ((Zn = Ki + En) - (Ee = Gr + Yn)), hs = 0.5411961 * Zn + hi, ds = 1.306562965 * Ee + hi, dt = 0.707106781 * (qr = En + Gr), be = Yn + dt, Ze = Yn - dt;
        ae[et + 40] = Ze + hs, ae[et + 24] = Ze - hs, ae[et + 8] = be + ds, ae[et + 56] = be - ds, et++;
      }
      for (ut = 0; ut < 64; ++ut) St = ae[ut] * re[ut], f[ut] = St > 0 ? St + 0.5 | 0 : St - 0.5 | 0;
      return f;
    }(U, P), de = 0; de < 64; ++de) d[C[de]] = Le[de];
    var Ce = d[0] - H;
    H = d[0], Ce == 0 ? R($[0]) : (R($[h[ue = 32767 + Ce]]), R(c[ue]));
    for (var Qe = 63; Qe > 0 && d[Qe] == 0; ) Qe--;
    if (Qe == 0) return R(he), H;
    for (var M, Ae = 1; Ae <= Qe; ) {
      for (var G = Ae; d[Ae] == 0 && Ae <= Qe; ) ++Ae;
      var ne = Ae - G;
      if (ne >= 16) {
        M = ne >> 4;
        for (var ee = 1; ee <= M; ++ee) R(ve);
        ne &= 15;
      }
      ue = 32767 + d[Ae], R(ie[(ne << 4) + h[ue]]), R(c[ue]), Ae++;
    }
    return Qe != 63 && R(he), H;
  }
  function Z(U) {
    U = Math.min(Math.max(U, 1), 100), s != U && (function(P) {
      for (var H = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], $ = 0; $ < 64; $++) {
        var ie = a((H[$] * P + 50) / 100);
        ie = Math.min(Math.max(ie, 1), 255), o[C[$]] = ie;
      }
      for (var ue = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], he = 0; he < 64; he++) {
        var ve = a((ue[he] * P + 50) / 100);
        ve = Math.min(Math.max(ve, 1), 255), A[C[he]] = ve;
      }
      for (var Le = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], de = 0, Ce = 0; Ce < 8; Ce++) for (var Qe = 0; Qe < 8; Qe++) l[de] = 1 / (o[C[de]] * Le[Ce] * Le[Qe] * 8), u[de] = 1 / (A[C[de]] * Le[Ce] * Le[Qe] * 8), de++;
    }(U < 50 ? Math.floor(5e3 / U) : Math.floor(200 - 2 * U)), s = U);
  }
  this.encode = function(U, P) {
    P && Z(P), p = new Array(), v = 0, m = 7, O(65496), O(65504), O(16), V(74), V(70), V(73), V(70), V(0), V(1), V(1), V(0), O(1), O(1), V(0), V(0), function() {
      O(65499), O(132), V(0);
      for (var le = 0; le < 64; le++) V(o[le]);
      V(1);
      for (var Te = 0; Te < 64; Te++) V(A[Te]);
    }(), function(le, Te) {
      O(65472), O(17), V(8), O(Te), O(le), V(3), V(1), V(17), V(0), V(2), V(17), V(1), V(3), V(17), V(1);
    }(U.width, U.height), function() {
      O(65476), O(418), V(0);
      for (var le = 0; le < 16; le++) V(F[le + 1]);
      for (var Te = 0; Te <= 11; Te++) V(N[Te]);
      V(16);
      for (var Oe = 0; Oe < 16; Oe++) V(D[Oe + 1]);
      for (var Ue = 0; Ue <= 161; Ue++) V(T[Ue]);
      V(1);
      for (var Ge = 0; Ge < 16; Ge++) V(E[Ge + 1]);
      for (var at = 0; at <= 11; at++) V(L[at]);
      V(17);
      for (var it = 0; it < 16; it++) V(S[it + 1]);
      for (var ut = 0; ut <= 161; ut++) V(X[ut]);
    }(), O(65498), O(12), V(3), V(1), V(0), V(2), V(17), V(3), V(17), V(0), V(63), V(0);
    var H = 0, $ = 0, ie = 0;
    v = 0, m = 7, this.encode.displayName = "_encode_";
    for (var ue, he, ve, Le, de, Ce, Qe, M, Ae, G = U.data, ne = U.width, ee = U.height, ae = 4 * ne, re = 0; re < ee; ) {
      for (ue = 0; ue < ae; ) {
        for (de = ae * re + ue, Qe = -1, M = 0, Ae = 0; Ae < 64; Ae++) Ce = de + (M = Ae >> 3) * ae + (Qe = 4 * (7 & Ae)), re + M >= ee && (Ce -= ae * (re + 1 + M - ee)), ue + Qe >= ae && (Ce -= ue + Qe - ae + 4), he = G[Ce++], ve = G[Ce++], Le = G[Ce++], b[Ae] = (x[he] + x[ve + 256 >> 0] + x[Le + 512 >> 0] >> 16) - 128, w[Ae] = (x[he + 768 >> 0] + x[ve + 1024 >> 0] + x[Le + 1280 >> 0] >> 16) - 128, B[Ae] = (x[he + 1280 >> 0] + x[ve + 1536 >> 0] + x[Le + 1792 >> 0] >> 16) - 128;
        H = J(b, l, H, e, n), $ = J(w, u, $, t, i), ie = J(B, u, ie, t, i), ue += 32;
      }
      re += 8;
    }
    if (m >= 0) {
      var ce = [];
      ce[1] = m + 1, ce[0] = (1 << m + 1) - 1, R(ce);
    }
    return O(65497), new Uint8Array(p);
  }, r = r || 50, function() {
    for (var U = String.fromCharCode, P = 0; P < 256; P++) _[P] = U(P);
  }(), e = z(F, N), t = z(E, L), n = z(D, T), i = z(S, X), function() {
    for (var U = 1, P = 2, H = 1; H <= 15; H++) {
      for (var $ = U; $ < P; $++) h[32767 + $] = H, c[32767 + $] = [], c[32767 + $][1] = H, c[32767 + $][0] = $;
      for (var ie = -(P - 1); ie <= -U; ie++) h[32767 + ie] = H, c[32767 + ie] = [], c[32767 + ie][1] = H, c[32767 + ie][0] = P - 1 + ie;
      U <<= 1, P <<= 1;
    }
  }(), function() {
    for (var U = 0; U < 256; U++) x[U] = 19595 * U, x[U + 256 >> 0] = 38470 * U, x[U + 512 >> 0] = 7471 * U + 32768, x[U + 768 >> 0] = -11059 * U, x[U + 1024 >> 0] = -21709 * U, x[U + 1280 >> 0] = 32768 * U + 8421375, x[U + 1536 >> 0] = -27439 * U, x[U + 1792 >> 0] = -5329 * U;
  }(), Z(r);
}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function qs(r, e) {
  if (this.pos = 0, this.buffer = r, this.datav = new DataView(r.buffer), this.is_with_alpha = !!e, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function e5(r) {
  function e(F) {
    if (!F) throw Error("assert :P");
  }
  function t(F, N, D) {
    for (var T = 0; 4 > T; T++) if (F[N + T] != D.charCodeAt(T)) return !0;
    return !1;
  }
  function n(F, N, D, T, E) {
    for (var L = 0; L < E; L++) F[N + L] = D[T + L];
  }
  function i(F, N, D, T) {
    for (var E = 0; E < T; E++) F[N + E] = D;
  }
  function s(F) {
    return new Int32Array(F);
  }
  function a(F, N) {
    for (var D = [], T = 0; T < F; T++) D.push(new N());
    return D;
  }
  function o(F, N) {
    var D = [];
    return function T(E, L, S) {
      for (var X = S[L], z = 0; z < X && (E.push(S.length > L + 1 ? [] : new N()), !(S.length < L + 1)); z++) T(E[z], L + 1, S);
    }(D, 0, F), D;
  }
  var A = function() {
    var F = this;
    function N(g, y) {
      for (var k = 1 << y - 1 >>> 0; g & k; ) k >>>= 1;
      return k ? (g & k - 1) + k : g;
    }
    function D(g, y, k, Q, j) {
      e(!(Q % k));
      do
        g[y + (Q -= k)] = j;
      while (0 < Q);
    }
    function T(g, y, k, Q, j) {
      if (e(2328 >= j), 512 >= j) var q = s(512);
      else if ((q = s(j)) == null) return 0;
      return function(W, Y, te, se, ye, Ie) {
        var Fe, _e, He = Y, Ne = 1 << te, we = s(16), Be = s(16);
        for (e(ye != 0), e(se != null), e(W != null), e(0 < te), _e = 0; _e < ye; ++_e) {
          if (15 < se[_e]) return 0;
          ++we[se[_e]];
        }
        if (we[0] == ye) return 0;
        for (Be[1] = 0, Fe = 1; 15 > Fe; ++Fe) {
          if (we[Fe] > 1 << Fe) return 0;
          Be[Fe + 1] = Be[Fe] + we[Fe];
        }
        for (_e = 0; _e < ye; ++_e) Fe = se[_e], 0 < se[_e] && (Ie[Be[Fe]++] = _e);
        if (Be[15] == 1) return (se = new E()).g = 0, se.value = Ie[0], D(W, He, 1, Ne, se), Ne;
        var Re, qe = -1, Pe = Ne - 1, ct = 0, nt = 1, It = 1, st = 1 << te;
        for (_e = 0, Fe = 1, ye = 2; Fe <= te; ++Fe, ye <<= 1) {
          if (nt += It <<= 1, 0 > (It -= we[Fe])) return 0;
          for (; 0 < we[Fe]; --we[Fe]) (se = new E()).g = Fe, se.value = Ie[_e++], D(W, He + ct, ye, st, se), ct = N(ct, Fe);
        }
        for (Fe = te + 1, ye = 2; 15 >= Fe; ++Fe, ye <<= 1) {
          if (nt += It <<= 1, 0 > (It -= we[Fe])) return 0;
          for (; 0 < we[Fe]; --we[Fe]) {
            if (se = new E(), (ct & Pe) != qe) {
              for (He += st, Re = 1 << (qe = Fe) - te; 15 > qe && !(0 >= (Re -= we[qe])); ) ++qe, Re <<= 1;
              Ne += st = 1 << (Re = qe - te), W[Y + (qe = ct & Pe)].g = Re + te, W[Y + qe].value = He - Y - qe;
            }
            se.g = Fe - te, se.value = Ie[_e++], D(W, He + (ct >> te), ye, st, se), ct = N(ct, Fe);
          }
        }
        return nt != 2 * Be[15] - 1 ? 0 : Ne;
      }(g, y, k, Q, j, q);
    }
    function E() {
      this.value = this.g = 0;
    }
    function L() {
      this.value = this.g = 0;
    }
    function S() {
      this.G = a(5, E), this.H = s(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = a(ei, L);
    }
    function X(g, y, k, Q) {
      e(g != null), e(y != null), e(2147483648 > Q), g.Ca = 254, g.I = 0, g.b = -8, g.Ka = 0, g.oa = y, g.pa = k, g.Jd = y, g.Yc = k + Q, g.Zc = 4 <= Q ? k + Q - 4 + 1 : k, ue(g);
    }
    function z(g, y) {
      for (var k = 0; 0 < y--; ) k |= ve(g, 128) << y;
      return k;
    }
    function R(g, y) {
      var k = z(g, y);
      return he(g) ? -k : k;
    }
    function V(g, y, k, Q) {
      var j, q = 0;
      for (e(g != null), e(y != null), e(4294967288 > Q), g.Sb = Q, g.Ra = 0, g.u = 0, g.h = 0, 4 < Q && (Q = 4), j = 0; j < Q; ++j) q += y[k + j] << 8 * j;
      g.Ra = q, g.bb = Q, g.oa = y, g.pa = k;
    }
    function O(g) {
      for (; 8 <= g.u && g.bb < g.Sb; ) g.Ra >>>= 8, g.Ra += g.oa[g.pa + g.bb] << kl - 8 >>> 0, ++g.bb, g.u -= 8;
      H(g) && (g.h = 1, g.u = 0);
    }
    function J(g, y) {
      if (e(0 <= y), !g.h && y <= xl) {
        var k = P(g) & Tl[y];
        return g.u += y, O(g), k;
      }
      return g.h = 1, g.u = 0;
    }
    function Z() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function U() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function P(g) {
      return g.Ra >>> (g.u & kl - 1) >>> 0;
    }
    function H(g) {
      return e(g.bb <= g.Sb), g.h || g.bb == g.Sb && g.u > kl;
    }
    function $(g, y) {
      g.u = y, g.h = H(g);
    }
    function ie(g) {
      g.u >= Ac && (e(g.u >= Ac), O(g));
    }
    function ue(g) {
      e(g != null && g.oa != null), g.pa < g.Zc ? (g.I = (g.oa[g.pa++] | g.I << 8) >>> 0, g.b += 8) : (e(g != null && g.oa != null), g.pa < g.Yc ? (g.b += 8, g.I = g.oa[g.pa++] | g.I << 8) : g.Ka ? g.b = 0 : (g.I <<= 8, g.b += 8, g.Ka = 1));
    }
    function he(g) {
      return z(g, 1);
    }
    function ve(g, y) {
      var k = g.Ca;
      0 > g.b && ue(g);
      var Q = g.b, j = k * y >>> 8, q = (g.I >>> Q > j) + 0;
      for (q ? (k -= j, g.I -= j + 1 << Q >>> 0) : k = j + 1, Q = k, j = 0; 256 <= Q; ) j += 8, Q >>= 8;
      return Q = 7 ^ j + Vi[Q], g.b -= Q, g.Ca = (k << Q) - 1, q;
    }
    function Le(g, y, k) {
      g[y + 0] = k >> 24 & 255, g[y + 1] = k >> 16 & 255, g[y + 2] = k >> 8 & 255, g[y + 3] = k >> 0 & 255;
    }
    function de(g, y) {
      return g[y + 0] << 0 | g[y + 1] << 8;
    }
    function Ce(g, y) {
      return de(g, y) | g[y + 2] << 16;
    }
    function Qe(g, y) {
      return de(g, y) | de(g, y + 2) << 16;
    }
    function M(g, y) {
      var k = 1 << y;
      return e(g != null), e(0 < y), g.X = s(k), g.X == null ? 0 : (g.Mb = 32 - y, g.Xa = y, 1);
    }
    function Ae(g, y) {
      e(g != null), e(y != null), e(g.Xa == y.Xa), n(y.X, 0, g.X, 0, 1 << y.Xa);
    }
    function G() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function ne(g, y, k, Q) {
      e(k != null), e(Q != null);
      var j = k[0], q = Q[0];
      return j == 0 && (j = (g * q + y / 2) / y), q == 0 && (q = (y * j + g / 2) / g), 0 >= j || 0 >= q ? 0 : (k[0] = j, Q[0] = q, 1);
    }
    function ee(g, y) {
      return g + (1 << y) - 1 >>> y;
    }
    function ae(g, y) {
      return ((4278255360 & g) + (4278255360 & y) >>> 0 & 4278255360) + ((16711935 & g) + (16711935 & y) >>> 0 & 16711935) >>> 0;
    }
    function re(g, y) {
      F[y] = function(k, Q, j, q, W, Y, te) {
        var se;
        for (se = 0; se < W; ++se) {
          var ye = F[g](Y[te + se - 1], j, q + se);
          Y[te + se] = ae(k[Q + se], ye);
        }
      };
    }
    function ce() {
      this.ud = this.hd = this.jd = 0;
    }
    function le(g, y) {
      return ((4278124286 & (g ^ y)) >>> 1) + (g & y) >>> 0;
    }
    function Te(g) {
      return 0 <= g && 256 > g ? g : 0 > g ? 0 : 255 < g ? 255 : void 0;
    }
    function Oe(g, y) {
      return Te(g + (g - y + 0.5 >> 1));
    }
    function Ue(g, y, k) {
      return Math.abs(y - k) - Math.abs(g - k);
    }
    function Ge(g, y, k, Q, j, q, W) {
      for (Q = q[W - 1], k = 0; k < j; ++k) q[W + k] = Q = ae(g[y + k], Q);
    }
    function at(g, y, k, Q, j) {
      var q;
      for (q = 0; q < k; ++q) {
        var W = g[y + q], Y = W >> 8 & 255, te = 16711935 & (te = (te = 16711935 & W) + ((Y << 16) + Y));
        Q[j + q] = (4278255360 & W) + te >>> 0;
      }
    }
    function it(g, y) {
      y.jd = g >> 0 & 255, y.hd = g >> 8 & 255, y.ud = g >> 16 & 255;
    }
    function ut(g, y, k, Q, j, q) {
      var W;
      for (W = 0; W < Q; ++W) {
        var Y = y[k + W], te = Y >>> 8, se = Y, ye = 255 & (ye = (ye = Y >>> 16) + ((g.jd << 24 >> 24) * (te << 24 >> 24) >>> 5));
        se = 255 & (se = (se = se + ((g.hd << 24 >> 24) * (te << 24 >> 24) >>> 5)) + ((g.ud << 24 >> 24) * (ye << 24 >> 24) >>> 5)), j[q + W] = (4278255360 & Y) + (ye << 16) + se;
      }
    }
    function St(g, y, k, Q, j) {
      F[y] = function(q, W, Y, te, se, ye, Ie, Fe, _e) {
        for (te = Ie; te < Fe; ++te) for (Ie = 0; Ie < _e; ++Ie) se[ye++] = j(Y[Q(q[W++])]);
      }, F[g] = function(q, W, Y, te, se, ye, Ie) {
        var Fe = 8 >> q.b, _e = q.Ea, He = q.K[0], Ne = q.w;
        if (8 > Fe) for (q = (1 << q.b) - 1, Ne = (1 << Fe) - 1; W < Y; ++W) {
          var we, Be = 0;
          for (we = 0; we < _e; ++we) we & q || (Be = Q(te[se++])), ye[Ie++] = j(He[Be & Ne]), Be >>= Fe;
        }
        else F["VP8LMapColor" + k](te, se, He, Ne, ye, Ie, W, Y, _e);
      };
    }
    function et(g, y, k, Q, j) {
      for (k = y + k; y < k; ) {
        var q = g[y++];
        Q[j++] = q >> 16 & 255, Q[j++] = q >> 8 & 255, Q[j++] = q >> 0 & 255;
      }
    }
    function gr(g, y, k, Q, j) {
      for (k = y + k; y < k; ) {
        var q = g[y++];
        Q[j++] = q >> 16 & 255, Q[j++] = q >> 8 & 255, Q[j++] = q >> 0 & 255, Q[j++] = q >> 24 & 255;
      }
    }
    function bt(g, y, k, Q, j) {
      for (k = y + k; y < k; ) {
        var q = (W = g[y++]) >> 16 & 240 | W >> 12 & 15, W = W >> 0 & 240 | W >> 28 & 15;
        Q[j++] = q, Q[j++] = W;
      }
    }
    function Qr(g, y, k, Q, j) {
      for (k = y + k; y < k; ) {
        var q = (W = g[y++]) >> 16 & 248 | W >> 13 & 7, W = W >> 5 & 224 | W >> 3 & 31;
        Q[j++] = q, Q[j++] = W;
      }
    }
    function Wt(g, y, k, Q, j) {
      for (k = y + k; y < k; ) {
        var q = g[y++];
        Q[j++] = q >> 0 & 255, Q[j++] = q >> 8 & 255, Q[j++] = q >> 16 & 255;
      }
    }
    function kt(g, y, k, Q, j, q) {
      if (q == 0) for (k = y + k; y < k; ) Le(Q, ((q = g[y++])[0] >> 24 | q[1] >> 8 & 65280 | q[2] << 8 & 16711680 | q[3] << 24) >>> 0), j += 32;
      else n(Q, j, g, y, k);
    }
    function Dr(g, y) {
      F[y][0] = F[g + "0"], F[y][1] = F[g + "1"], F[y][2] = F[g + "2"], F[y][3] = F[g + "3"], F[y][4] = F[g + "4"], F[y][5] = F[g + "5"], F[y][6] = F[g + "6"], F[y][7] = F[g + "7"], F[y][8] = F[g + "8"], F[y][9] = F[g + "9"], F[y][10] = F[g + "10"], F[y][11] = F[g + "11"], F[y][12] = F[g + "12"], F[y][13] = F[g + "13"], F[y][14] = F[g + "0"], F[y][15] = F[g + "0"];
    }
    function Xt(g) {
      return g == bm || g == ym || g == Fh || g == wm;
    }
    function Cn() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function mr() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function Ir() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new Cn(), this.f.kb = new mr(), this.sd = null;
    }
    function hr() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function wr() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function gt(g) {
      return alert("todo:WebPSamplerProcessPlane"), g.T;
    }
    function rr(g, y) {
      var k = g.T, Q = y.ba.f.RGBA, j = Q.eb, q = Q.fb + g.ka * Q.A, W = ys[y.ba.S], Y = g.y, te = g.O, se = g.f, ye = g.N, Ie = g.ea, Fe = g.W, _e = y.cc, He = y.dc, Ne = y.Mc, we = y.Nc, Be = g.ka, Re = g.ka + g.T, qe = g.U, Pe = qe + 1 >> 1;
      for (Be == 0 ? W(Y, te, null, null, se, ye, Ie, Fe, se, ye, Ie, Fe, j, q, null, null, qe) : (W(y.ec, y.fc, Y, te, _e, He, Ne, we, se, ye, Ie, Fe, j, q - Q.A, j, q, qe), ++k); Be + 2 < Re; Be += 2) _e = se, He = ye, Ne = Ie, we = Fe, ye += g.Rc, Fe += g.Rc, q += 2 * Q.A, W(Y, (te += 2 * g.fa) - g.fa, Y, te, _e, He, Ne, we, se, ye, Ie, Fe, j, q - Q.A, j, q, qe);
      return te += g.fa, g.j + Re < g.o ? (n(y.ec, y.fc, Y, te, qe), n(y.cc, y.dc, se, ye, Pe), n(y.Mc, y.Nc, Ie, Fe, Pe), k--) : 1 & Re || W(Y, te, null, null, se, ye, Ie, Fe, se, ye, Ie, Fe, j, q + Q.A, null, null, qe), k;
    }
    function Rs(g, y, k) {
      var Q = g.F, j = [g.J];
      if (Q != null) {
        var q = g.U, W = y.ba.S, Y = W == Ih || W == Fh;
        y = y.ba.f.RGBA;
        var te = [0], se = g.ka;
        te[0] = g.T, g.Kb && (se == 0 ? --te[0] : (--se, j[0] -= g.width), g.j + g.ka + g.T == g.o && (te[0] = g.o - g.j - se));
        var ye = y.eb;
        se = y.fb + se * y.A, g = Rr(Q, j[0], g.width, q, te, ye, se + (Y ? 0 : 3), y.A), e(k == te), g && Xt(W) && vs(ye, se, Y, q, te, y.A);
      }
      return 0;
    }
    function Yr(g) {
      var y = g.ma, k = y.ba.S, Q = 11 > k, j = k == Eh || k == Sh || k == Ih || k == vm || k == 12 || Xt(k);
      if (y.memory = null, y.Ib = null, y.Jb = null, y.Nd = null, !ac(y.Oa, g, j ? 11 : 12)) return 0;
      if (j && Xt(k) && Je(), g.da) alert("todo:use_scaling");
      else {
        if (Q) {
          if (y.Ib = gt, g.Kb) {
            if (k = g.U + 1 >> 1, y.memory = s(g.U + 2 * k), y.memory == null) return 0;
            y.ec = y.memory, y.fc = 0, y.cc = y.ec, y.dc = y.fc + g.U, y.Mc = y.cc, y.Nc = y.dc + k, y.Ib = rr, Je();
          }
        } else alert("todo:EmitYUV");
        j && (y.Jb = Rs, Q && Se());
      }
      if (Q && !Sy) {
        for (g = 0; 256 > g; ++g) uk[g] = 89858 * (g - 128) + xh >> Th, hk[g] = -22014 * (g - 128) + xh, fk[g] = -45773 * (g - 128), ck[g] = 113618 * (g - 128) + xh >> Th;
        for (g = pc; g < _m; ++g) y = 76283 * (g - 16) + xh >> Th, dk[g - pc] = rs(y, 255), pk[g - pc] = rs(y + 8 >> 4, 15);
        Sy = 1;
      }
      return 1;
    }
    function fi(g) {
      var y = g.ma, k = g.U, Q = g.T;
      return e(!(1 & g.ka)), 0 >= k || 0 >= Q ? 0 : (k = y.Ib(g, y), y.Jb != null && y.Jb(g, y, k), y.Dc += k, 1);
    }
    function Fi(g) {
      g.ma.memory = null;
    }
    function Ct(g, y, k, Q) {
      return J(g, 8) != 47 ? 0 : (y[0] = J(g, 14) + 1, k[0] = J(g, 14) + 1, Q[0] = J(g, 1), J(g, 3) != 0 ? 0 : !g.h);
    }
    function Ti(g, y) {
      if (4 > g) return g + 1;
      var k = g - 2 >> 1;
      return (2 + (1 & g) << k) + J(y, k) + 1;
    }
    function Yn(g, y) {
      return 120 < y ? y - 120 : 1 <= (k = ((k = Xx[y - 1]) >> 4) * g + (8 - (15 & k))) ? k : 1;
      var k;
    }
    function _n(g, y, k) {
      var Q = P(k), j = g[y += 255 & Q].g - 8;
      return 0 < j && ($(k, k.u + 8), Q = P(k), y += g[y].value, y += Q & (1 << j) - 1), $(k, k.u + g[y].g), g[y].value;
    }
    function Gr(g, y, k) {
      return k.g += g.g, k.value += g.value << y >>> 0, e(8 >= k.g), g.g;
    }
    function ur(g, y, k) {
      var Q = g.xc;
      return e((y = Q == 0 ? 0 : g.vc[g.md * (k >> Q) + (y >> Q)]) < g.Wb), g.Ya[y];
    }
    function En(g, y, k, Q) {
      var j = g.ab, q = g.c * y, W = g.C;
      y = W + y;
      var Y = k, te = Q;
      for (Q = g.Ta, k = g.Ua; 0 < j--; ) {
        var se = g.gc[j], ye = W, Ie = y, Fe = Y, _e = te, He = (te = Q, Y = k, se.Ea);
        switch (e(ye < Ie), e(Ie <= se.nc), se.hc) {
          case 2:
            vh(Fe, _e, (Ie - ye) * He, te, Y);
            break;
          case 0:
            var Ne = ye, we = Ie, Be = te, Re = Y, qe = (st = se).Ea;
            Ne == 0 && (gm(Fe, _e, null, null, 1, Be, Re), Ge(Fe, _e + 1, 0, 0, qe - 1, Be, Re + 1), _e += qe, Re += qe, ++Ne);
            for (var Pe = 1 << st.b, ct = Pe - 1, nt = ee(qe, st.b), It = st.K, st = st.w + (Ne >> st.b) * nt; Ne < we; ) {
              var Br = It, Er = st, vr = 1;
              for (lc(Fe, _e, Be, Re - qe, 1, Be, Re); vr < qe; ) {
                var Ar = (vr & ~ct) + Pe;
                Ar > qe && (Ar = qe), (0, bo[Br[Er++] >> 8 & 15])(Fe, _e + +vr, Be, Re + vr - qe, Ar - vr, Be, Re + vr), vr = Ar;
              }
              _e += qe, Re += qe, ++Ne & ct || (st += nt);
            }
            Ie != se.nc && n(te, Y - He, te, Y + (Ie - ye - 1) * He, He);
            break;
          case 1:
            for (He = Fe, we = _e, qe = (Fe = se.Ea) - (Re = Fe & ~(Be = (_e = 1 << se.b) - 1)), Ne = ee(Fe, se.b), Pe = se.K, se = se.w + (ye >> se.b) * Ne; ye < Ie; ) {
              for (ct = Pe, nt = se, It = new ce(), st = we + Re, Br = we + Fe; we < st; ) it(ct[nt++], It), yA(It, He, we, _e, te, Y), we += _e, Y += _e;
              we < Br && (it(ct[nt++], It), yA(It, He, we, qe, te, Y), we += qe, Y += qe), ++ye & Be || (se += Ne);
            }
            break;
          case 3:
            if (Fe == te && _e == Y && 0 < se.b) {
              for (we = te, Fe = He = Y + (Ie - ye) * He - (Re = (Ie - ye) * ee(se.Ea, se.b)), _e = te, Be = Y, Ne = [], Re = (qe = Re) - 1; 0 <= Re; --Re) Ne[Re] = _e[Be + Re];
              for (Re = qe - 1; 0 <= Re; --Re) we[Fe + Re] = Ne[Re];
              ps(se, ye, Ie, te, He, te, Y);
            } else ps(se, ye, Ie, Fe, _e, te, Y);
        }
        Y = Q, te = k;
      }
      te != k && n(Q, k, Y, te, q);
    }
    function Ps(g, y) {
      var k = g.V, Q = g.Ba + g.c * g.C, j = y - g.C;
      if (e(y <= g.l.o), e(16 >= j), 0 < j) {
        var q = g.l, W = g.Ta, Y = g.Ua, te = q.width;
        if (En(g, j, k, Q), j = Y = [Y], e((k = g.C) < (Q = y)), e(q.v < q.va), Q > q.o && (Q = q.o), k < q.j) {
          var se = q.j - k;
          k = q.j, j[0] += se * te;
        }
        if (k >= Q ? k = 0 : (j[0] += 4 * q.v, q.ka = k - q.j, q.U = q.va - q.v, q.T = Q - k, k = 1), k) {
          if (Y = Y[0], 11 > (k = g.ca).S) {
            var ye = k.f.RGBA, Ie = (Q = k.S, j = q.U, q = q.T, se = ye.eb, ye.A), Fe = q;
            for (ye = ye.fb + g.Ma * ye.A; 0 < Fe--; ) {
              var _e = W, He = Y, Ne = j, we = se, Be = ye;
              switch (Q) {
                case _h:
                  zi(_e, He, Ne, we, Be);
                  break;
                case Eh:
                  xi(_e, He, Ne, we, Be);
                  break;
                case bm:
                  xi(_e, He, Ne, we, Be), vs(we, Be, 0, Ne, 1, 0);
                  break;
                case gy:
                  ja(_e, He, Ne, we, Be);
                  break;
                case Sh:
                  kt(_e, He, Ne, we, Be, 1);
                  break;
                case ym:
                  kt(_e, He, Ne, we, Be, 1), vs(we, Be, 0, Ne, 1, 0);
                  break;
                case Ih:
                  kt(_e, He, Ne, we, Be, 0);
                  break;
                case Fh:
                  kt(_e, He, Ne, we, Be, 0), vs(we, Be, 1, Ne, 1, 0);
                  break;
                case vm:
                  yo(_e, He, Ne, we, Be);
                  break;
                case wm:
                  yo(_e, He, Ne, we, Be), Mr(we, Be, Ne, 1, 0);
                  break;
                case my:
                  Ha(_e, He, Ne, we, Be);
                  break;
                default:
                  e(0);
              }
              Y += te, ye += Ie;
            }
            g.Ma += q;
          } else alert("todo:EmitRescaledRowsYUVA");
          e(g.Ma <= k.height);
        }
      }
      g.C = y, e(g.C <= g.i);
    }
    function Ki(g) {
      var y;
      if (0 < g.ua) return 0;
      for (y = 0; y < g.Wb; ++y) {
        var k = g.Ya[y].G, Q = g.Ya[y].H;
        if (0 < k[1][Q[1] + 0].g || 0 < k[2][Q[2] + 0].g || 0 < k[3][Q[3] + 0].g) return 0;
      }
      return 1;
    }
    function Zn(g, y, k, Q, j, q) {
      if (g.Z != 0) {
        var W = g.qd, Y = g.rd;
        for (e(_o[g.Z] != null); y < k; ++y) _o[g.Z](W, Y, Q, j, Q, j, q), W = Q, Y = j, j += q;
        g.qd = W, g.rd = Y;
      }
    }
    function Nn(g, y) {
      var k = g.l.ma, Q = k.Z == 0 || k.Z == 1 ? g.l.j : g.C;
      if (Q = g.C < Q ? Q : g.C, e(y <= g.l.o), y > Q) {
        var j = g.l.width, q = k.ca, W = k.tb + j * Q, Y = g.V, te = g.Ba + g.c * Q, se = g.gc;
        e(g.ab == 1), e(se[0].hc == 3), bh(se[0], Q, y, Y, te, q, W), Zn(k, Q, y, q, W, j);
      }
      g.C = g.Ma = y;
    }
    function qr(g, y, k, Q, j, q, W) {
      var Y = g.$ / Q, te = g.$ % Q, se = g.m, ye = g.s, Ie = k + g.$, Fe = Ie;
      j = k + Q * j;
      var _e = k + Q * q, He = 280 + ye.ua, Ne = g.Pb ? Y : 16777216, we = 0 < ye.ua ? ye.Wa : null, Be = ye.wc, Re = Ie < _e ? ur(ye, te, Y) : null;
      e(g.C < q), e(_e <= j);
      var qe = !1;
      e: for (; ; ) {
        for (; qe || Ie < _e; ) {
          var Pe = 0;
          if (Y >= Ne) {
            var ct = Ie - k;
            e((Ne = g).Pb), Ne.wd = Ne.m, Ne.xd = ct, 0 < Ne.s.ua && Ae(Ne.s.Wa, Ne.s.vb), Ne = Y + Yx;
          }
          if (te & Be || (Re = ur(ye, te, Y)), e(Re != null), Re.Qb && (y[Ie] = Re.qb, qe = !0), !qe) if (ie(se), Re.jc) {
            Pe = se, ct = y;
            var nt = Ie, It = Re.pd[P(Pe) & ei - 1];
            e(Re.jc), 256 > It.g ? ($(Pe, Pe.u + It.g), ct[nt] = It.value, Pe = 0) : ($(Pe, Pe.u + It.g - 256), e(256 <= It.value), Pe = It.value), Pe == 0 && (qe = !0);
          } else Pe = _n(Re.G[0], Re.H[0], se);
          if (se.h) break;
          if (qe || 256 > Pe) {
            if (!qe) if (Re.nd) y[Ie] = (Re.qb | Pe << 8) >>> 0;
            else {
              if (ie(se), qe = _n(Re.G[1], Re.H[1], se), ie(se), ct = _n(Re.G[2], Re.H[2], se), nt = _n(Re.G[3], Re.H[3], se), se.h) break;
              y[Ie] = (nt << 24 | qe << 16 | Pe << 8 | ct) >>> 0;
            }
            if (qe = !1, ++Ie, ++te >= Q && (te = 0, ++Y, W != null && Y <= q && !(Y % 16) && W(g, Y), we != null)) for (; Fe < Ie; ) Pe = y[Fe++], we.X[(506832829 * Pe & 4294967295) >>> we.Mb] = Pe;
          } else if (280 > Pe) {
            if (Pe = Ti(Pe - 256, se), ct = _n(Re.G[4], Re.H[4], se), ie(se), ct = Yn(Q, ct = Ti(ct, se)), se.h) break;
            if (Ie - k < ct || j - Ie < Pe) break e;
            for (nt = 0; nt < Pe; ++nt) y[Ie + nt] = y[Ie + nt - ct];
            for (Ie += Pe, te += Pe; te >= Q; ) te -= Q, ++Y, W != null && Y <= q && !(Y % 16) && W(g, Y);
            if (e(Ie <= j), te & Be && (Re = ur(ye, te, Y)), we != null) for (; Fe < Ie; ) Pe = y[Fe++], we.X[(506832829 * Pe & 4294967295) >>> we.Mb] = Pe;
          } else {
            if (!(Pe < He)) break e;
            for (qe = Pe - 280, e(we != null); Fe < Ie; ) Pe = y[Fe++], we.X[(506832829 * Pe & 4294967295) >>> we.Mb] = Pe;
            Pe = Ie, e(!(qe >>> (ct = we).Xa)), y[Pe] = ct.X[qe], qe = !0;
          }
          qe || e(se.h == H(se));
        }
        if (g.Pb && se.h && Ie < j) e(g.m.h), g.a = 5, g.m = g.wd, g.$ = g.xd, 0 < g.s.ua && Ae(g.s.vb, g.s.Wa);
        else {
          if (se.h) break e;
          W != null && W(g, Y > q ? q : Y), g.a = 0, g.$ = Ie - k;
        }
        return 1;
      }
      return g.a = 3, 0;
    }
    function Ee(g) {
      e(g != null), g.vc = null, g.yc = null, g.Ya = null;
      var y = g.Wa;
      y != null && (y.X = null), g.vb = null, e(g != null);
    }
    function or() {
      var g = new pm();
      return g == null ? null : (g.a = 0, g.xb = yy, Dr("Predictor", "VP8LPredictors"), Dr("Predictor", "VP8LPredictors_C"), Dr("PredictorAdd", "VP8LPredictorsAdd"), Dr("PredictorAdd", "VP8LPredictorsAdd_C"), vh = at, yA = ut, zi = et, xi = gr, yo = bt, Ha = Qr, ja = Wt, F.VP8LMapColor32b = Ll, F.VP8LMapColor8b = yh, g);
    }
    function hi(g, y, k, Q, j) {
      var q = 1, W = [g], Y = [y], te = Q.m, se = Q.s, ye = null, Ie = 0;
      e: for (; ; ) {
        if (k) for (; q && J(te, 1); ) {
          var Fe = W, _e = Y, He = Q, Ne = 1, we = He.m, Be = He.gc[He.ab], Re = J(we, 2);
          if (He.Oc & 1 << Re) q = 0;
          else {
            switch (He.Oc |= 1 << Re, Be.hc = Re, Be.Ea = Fe[0], Be.nc = _e[0], Be.K = [null], ++He.ab, e(4 >= He.ab), Re) {
              case 0:
              case 1:
                Be.b = J(we, 3) + 2, Ne = hi(ee(Be.Ea, Be.b), ee(Be.nc, Be.b), 0, He, Be.K), Be.K = Be.K[0];
                break;
              case 3:
                var qe, Pe = J(we, 8) + 1, ct = 16 < Pe ? 0 : 4 < Pe ? 1 : 2 < Pe ? 2 : 3;
                if (Fe[0] = ee(Be.Ea, ct), Be.b = ct, qe = Ne = hi(Pe, 1, 0, He, Be.K)) {
                  var nt, It = Pe, st = Be, Br = 1 << (8 >> st.b), Er = s(Br);
                  if (Er == null) qe = 0;
                  else {
                    var vr = st.K[0], Ar = st.w;
                    for (Er[0] = st.K[0][0], nt = 1; nt < 1 * It; ++nt) Er[nt] = ae(vr[Ar + nt], Er[nt - 1]);
                    for (; nt < 4 * Br; ++nt) Er[nt] = 0;
                    st.K[0] = null, st.K[0] = Er, qe = 1;
                  }
                }
                Ne = qe;
                break;
              case 2:
                break;
              default:
                e(0);
            }
            q = Ne;
          }
        }
        if (W = W[0], Y = Y[0], q && J(te, 1) && !(q = 1 <= (Ie = J(te, 4)) && 11 >= Ie)) {
          Q.a = 3;
          break e;
        }
        var kr;
        if (kr = q) t: {
          var Fr, Jt, In, Gi = Q, Fn = W, qi = Y, Sr = Ie, is = k, ss = Gi.m, jn = Gi.s, ti = [null], Li = 1, ws = 0, va = Jx[Sr];
          r: for (; ; ) {
            if (is && J(ss, 1)) {
              var Kn = J(ss, 3) + 2, za = ee(Fn, Kn), EA = ee(qi, Kn), Dl = za * EA;
              if (!hi(za, EA, 0, Gi, ti)) break r;
              for (ti = ti[0], jn.xc = Kn, Fr = 0; Fr < Dl; ++Fr) {
                var Eo = ti[Fr] >> 8 & 65535;
                ti[Fr] = Eo, Eo >= Li && (Li = Eo + 1);
              }
            }
            if (ss.h) break r;
            for (Jt = 0; 5 > Jt; ++Jt) {
              var tn = vy[Jt];
              !Jt && 0 < Sr && (tn += 1 << Sr), ws < tn && (ws = tn);
            }
            var Em = a(Li * va, E), Ty = Li, xy = a(Ty, S);
            if (xy == null) var Lh = null;
            else e(65536 >= Ty), Lh = xy;
            var gc = s(ws);
            if (Lh == null || gc == null || Em == null) {
              Gi.a = 1;
              break r;
            }
            var Uh = Em;
            for (Fr = In = 0; Fr < Li; ++Fr) {
              var zs = Lh[Fr], Ml = zs.G, Rl = zs.H, ky = 0, Nh = 1, Ly = 0;
              for (Jt = 0; 5 > Jt; ++Jt) {
                tn = vy[Jt], Ml[Jt] = Uh, Rl[Jt] = In, !Jt && 0 < Sr && (tn += 1 << Sr);
                i: {
                  var Oh, Sm = tn, Qh = Gi, mc = gc, vk = Uh, bk = In, Im = 0, So = Qh.m, yk = J(So, 1);
                  if (i(mc, 0, 0, Sm), yk) {
                    var wk = J(So, 1) + 1, Bk = J(So, 1), Uy = J(So, Bk == 0 ? 1 : 8);
                    mc[Uy] = 1, wk == 2 && (mc[Uy = J(So, 8)] = 1);
                    var Dh = 1;
                  } else {
                    var Ny = s(19), Oy = J(So, 4) + 4;
                    if (19 < Oy) {
                      Qh.a = 3;
                      var Mh = 0;
                      break i;
                    }
                    for (Oh = 0; Oh < Oy; ++Oh) Ny[Wx[Oh]] = J(So, 3);
                    var Fm = void 0, vc = void 0, Qy = Qh, Ck = Ny, Rh = Sm, Dy = mc, Tm = 0, Io = Qy.m, My = 8, Ry = a(128, E);
                    n: for (; T(Ry, 0, 7, Ck, 19); ) {
                      if (J(Io, 1)) {
                        var _k = 2 + 2 * J(Io, 3);
                        if ((Fm = 2 + J(Io, _k)) > Rh) break n;
                      } else Fm = Rh;
                      for (vc = 0; vc < Rh && Fm--; ) {
                        ie(Io);
                        var Py = Ry[0 + (127 & P(Io))];
                        $(Io, Io.u + Py.g);
                        var Pl = Py.value;
                        if (16 > Pl) Dy[vc++] = Pl, Pl != 0 && (My = Pl);
                        else {
                          var Ek = Pl == 16, Hy = Pl - 16, Sk = Gx[Hy], jy = J(Io, zx[Hy]) + Sk;
                          if (vc + jy > Rh) break n;
                          for (var Ik = Ek ? My : 0; 0 < jy--; ) Dy[vc++] = Ik;
                        }
                      }
                      Tm = 1;
                      break n;
                    }
                    Tm || (Qy.a = 3), Dh = Tm;
                  }
                  (Dh = Dh && !So.h) && (Im = T(vk, bk, 8, mc, Sm)), Dh && Im != 0 ? Mh = Im : (Qh.a = 3, Mh = 0);
                }
                if (Mh == 0) break r;
                if (Nh && qx[Jt] == 1 && (Nh = Uh[In].g == 0), ky += Uh[In].g, In += Mh, 3 >= Jt) {
                  var bc, xm = gc[0];
                  for (bc = 1; bc < tn; ++bc) gc[bc] > xm && (xm = gc[bc]);
                  Ly += xm;
                }
              }
              if (zs.nd = Nh, zs.Qb = 0, Nh && (zs.qb = (Ml[3][Rl[3] + 0].value << 24 | Ml[1][Rl[1] + 0].value << 16 | Ml[2][Rl[2] + 0].value) >>> 0, ky == 0 && 256 > Ml[0][Rl[0] + 0].value && (zs.Qb = 1, zs.qb += Ml[0][Rl[0] + 0].value << 8)), zs.jc = !zs.Qb && 6 > Ly, zs.jc) {
                var Ph, Ga = zs;
                for (Ph = 0; Ph < ei; ++Ph) {
                  var Fo = Ph, To = Ga.pd[Fo], Hh = Ga.G[0][Ga.H[0] + Fo];
                  256 <= Hh.value ? (To.g = Hh.g + 256, To.value = Hh.value) : (To.g = 0, To.value = 0, Fo >>= Gr(Hh, 8, To), Fo >>= Gr(Ga.G[1][Ga.H[1] + Fo], 16, To), Fo >>= Gr(Ga.G[2][Ga.H[2] + Fo], 0, To), Gr(Ga.G[3][Ga.H[3] + Fo], 24, To));
                }
              }
            }
            jn.vc = ti, jn.Wb = Li, jn.Ya = Lh, jn.yc = Em, kr = 1;
            break t;
          }
          kr = 0;
        }
        if (!(q = kr)) {
          Q.a = 3;
          break e;
        }
        if (0 < Ie) {
          if (se.ua = 1 << Ie, !M(se.Wa, Ie)) {
            Q.a = 1, q = 0;
            break e;
          }
        } else se.ua = 0;
        var km = Q, Ky = W, Fk = Y, Lm = km.s, Um = Lm.xc;
        if (km.c = Ky, km.i = Fk, Lm.md = ee(Ky, Um), Lm.wc = Um == 0 ? -1 : (1 << Um) - 1, k) {
          Q.xb = sk;
          break e;
        }
        if ((ye = s(W * Y)) == null) {
          Q.a = 1, q = 0;
          break e;
        }
        q = (q = qr(Q, ye, 0, W, Y, Y, null)) && !te.h;
        break e;
      }
      return q ? (j != null ? j[0] = ye : (e(ye == null), e(k)), Q.$ = 0, k || Ee(se)) : Ee(se), q;
    }
    function hs(g, y) {
      var k = g.c * g.i, Q = k + y + 16 * y;
      return e(g.c <= y), g.V = s(Q), g.V == null ? (g.Ta = null, g.Ua = 0, g.a = 1, 0) : (g.Ta = g.V, g.Ua = g.Ba + k + y, 1);
    }
    function ds(g, y) {
      var k = g.C, Q = y - k, j = g.V, q = g.Ba + g.c * k;
      for (e(y <= g.l.o); 0 < Q; ) {
        var W = 16 < Q ? 16 : Q, Y = g.l.ma, te = g.l.width, se = te * W, ye = Y.ca, Ie = Y.tb + te * k, Fe = g.Ta, _e = g.Ua;
        En(g, W, j, q), fn(Fe, _e, ye, Ie, se), Zn(Y, k, k + W, ye, Ie, te), Q -= W, j += W * g.c, k += W;
      }
      e(k == y), g.C = g.Ma = y;
    }
    function dt() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function be() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Ze() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = s(4), this.Lb = s(4);
    }
    function rt() {
      this.Yb = function() {
        var g = [];
        return function y(k, Q, j) {
          for (var q = j[Q], W = 0; W < q && (k.push(j.length > Q + 1 ? [] : 0), !(j.length < Q + 1)); W++) y(k[W], Q + 1, j);
        }(g, 0, [3, 11]), g;
      }();
    }
    function cr() {
      this.jb = s(3), this.Wc = o([4, 8], rt), this.Xc = o([4, 17], rt);
    }
    function Pn() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new s(4), this.od = new s(4);
    }
    function Wr() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Zr() {
      this.Na = this.la = 0;
    }
    function Hs() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function $r() {
      this.ad = s(384), this.Za = 0, this.Ob = s(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function dA() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Wr()), this.Y = 0, this.ya = Array(new $r()), this.aa = 0, this.l = new vl();
    }
    function pA() {
      this.y = s(16), this.f = s(8), this.ea = s(8);
    }
    function eh() {
      this.cb = this.a = 0, this.sc = "", this.m = new Z(), this.Od = new dt(), this.Kc = new be(), this.ed = new Pn(), this.Qa = new Ze(), this.Ic = this.$c = this.Aa = 0, this.D = new dA(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = a(8, Z), this.ia = 0, this.pb = a(4, Hs), this.Pa = new cr(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new pA()), this.Hd = 0, this.rb = Array(new Zr()), this.sb = 0, this.wa = Array(new Wr()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new $r()), this.L = this.aa = 0, this.gd = o([4, 2], Wr), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function vl() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Jg() {
      var g = new eh();
      return g != null && (g.a = 0, g.sc = "OK", g.cb = 0, g.Xb = 0, dc || (dc = nh)), g;
    }
    function un(g, y, k) {
      return g.a == 0 && (g.a = y, g.sc = k, g.cb = 0), 0;
    }
    function th(g, y, k) {
      return 3 <= k && g[y + 0] == 157 && g[y + 1] == 1 && g[y + 2] == 42;
    }
    function rh(g, y) {
      if (g == null) return 0;
      if (g.a = 0, g.sc = "OK", y == null) return un(g, 2, "null VP8Io passed to VP8GetHeaders()");
      var k = y.data, Q = y.w, j = y.ha;
      if (4 > j) return un(g, 7, "Truncated header.");
      var q = k[Q + 0] | k[Q + 1] << 8 | k[Q + 2] << 16, W = g.Od;
      if (W.Rb = !(1 & q), W.td = q >> 1 & 7, W.yd = q >> 4 & 1, W.ub = q >> 5, 3 < W.td) return un(g, 3, "Incorrect keyframe parameters.");
      if (!W.yd) return un(g, 4, "Frame not displayable.");
      Q += 3, j -= 3;
      var Y = g.Kc;
      if (W.Rb) {
        if (7 > j) return un(g, 7, "cannot parse picture header");
        if (!th(k, Q, j)) return un(g, 3, "Bad code word");
        Y.c = 16383 & (k[Q + 4] << 8 | k[Q + 3]), Y.Td = k[Q + 4] >> 6, Y.i = 16383 & (k[Q + 6] << 8 | k[Q + 5]), Y.Ud = k[Q + 6] >> 6, Q += 7, j -= 7, g.za = Y.c + 15 >> 4, g.Ub = Y.i + 15 >> 4, y.width = Y.c, y.height = Y.i, y.Da = 0, y.j = 0, y.v = 0, y.va = y.width, y.o = y.height, y.da = 0, y.ib = y.width, y.hb = y.height, y.U = y.width, y.T = y.height, i((q = g.Pa).jb, 0, 255, q.jb.length), e((q = g.Qa) != null), q.Cb = 0, q.Bb = 0, q.Fb = 1, i(q.Zb, 0, 0, q.Zb.length), i(q.Lb, 0, 0, q.Lb);
      }
      if (W.ub > j) return un(g, 7, "bad partition length");
      X(q = g.m, k, Q, W.ub), Q += W.ub, j -= W.ub, W.Rb && (Y.Ld = he(q), Y.Kd = he(q)), Y = g.Qa;
      var te, se = g.Pa;
      if (e(q != null), e(Y != null), Y.Cb = he(q), Y.Cb) {
        if (Y.Bb = he(q), he(q)) {
          for (Y.Fb = he(q), te = 0; 4 > te; ++te) Y.Zb[te] = he(q) ? R(q, 7) : 0;
          for (te = 0; 4 > te; ++te) Y.Lb[te] = he(q) ? R(q, 6) : 0;
        }
        if (Y.Bb) for (te = 0; 3 > te; ++te) se.jb[te] = he(q) ? z(q, 8) : 255;
      } else Y.Bb = 0;
      if (q.Ka) return un(g, 3, "cannot parse segment header");
      if ((Y = g.ed).zd = he(q), Y.Tb = z(q, 6), Y.wb = z(q, 3), Y.Pc = he(q), Y.Pc && he(q)) {
        for (se = 0; 4 > se; ++se) he(q) && (Y.vd[se] = R(q, 6));
        for (se = 0; 4 > se; ++se) he(q) && (Y.od[se] = R(q, 6));
      }
      if (g.L = Y.Tb == 0 ? 0 : Y.zd ? 1 : 2, q.Ka) return un(g, 3, "cannot parse filter header");
      var ye = j;
      if (j = te = Q, Q = te + ye, Y = ye, g.Xb = (1 << z(g.m, 2)) - 1, ye < 3 * (se = g.Xb)) k = 7;
      else {
        for (te += 3 * se, Y -= 3 * se, ye = 0; ye < se; ++ye) {
          var Ie = k[j + 0] | k[j + 1] << 8 | k[j + 2] << 16;
          Ie > Y && (Ie = Y), X(g.Jc[+ye], k, te, Ie), te += Ie, Y -= Ie, j += 3;
        }
        X(g.Jc[+se], k, te, Y), k = te < Q ? 0 : 5;
      }
      if (k != 0) return un(g, k, "cannot parse partitions");
      for (k = z(te = g.m, 7), j = he(te) ? R(te, 4) : 0, Q = he(te) ? R(te, 4) : 0, Y = he(te) ? R(te, 4) : 0, se = he(te) ? R(te, 4) : 0, te = he(te) ? R(te, 4) : 0, ye = g.Qa, Ie = 0; 4 > Ie; ++Ie) {
        if (ye.Cb) {
          var Fe = ye.Zb[Ie];
          ye.Fb || (Fe += k);
        } else {
          if (0 < Ie) {
            g.pb[Ie] = g.pb[0];
            continue;
          }
          Fe = k;
        }
        var _e = g.pb[Ie];
        _e.Sc[0] = Bm[rs(Fe + j, 127)], _e.Sc[1] = Cm[rs(Fe + 0, 127)], _e.Eb[0] = 2 * Bm[rs(Fe + Q, 127)], _e.Eb[1] = 101581 * Cm[rs(Fe + Y, 127)] >> 16, 8 > _e.Eb[1] && (_e.Eb[1] = 8), _e.Qc[0] = Bm[rs(Fe + se, 117)], _e.Qc[1] = Cm[rs(Fe + te, 127)], _e.lc = Fe + te;
      }
      if (!W.Rb) return un(g, 4, "Not a key frame.");
      for (he(q), W = g.Pa, k = 0; 4 > k; ++k) {
        for (j = 0; 8 > j; ++j) for (Q = 0; 3 > Q; ++Q) for (Y = 0; 11 > Y; ++Y) se = ve(q, nk[k][j][Q][Y]) ? z(q, 8) : tk[k][j][Q][Y], W.Wc[k][j].Yb[Q][Y] = se;
        for (j = 0; 17 > j; ++j) W.Xc[k][j] = W.Wc[k][ik[j]];
      }
      return g.kc = he(q), g.kc && (g.Bd = z(q, 8)), g.cb = 1;
    }
    function nh(g, y, k, Q, j, q, W) {
      var Y = y[j].Yb[k];
      for (k = 0; 16 > j; ++j) {
        if (!ve(g, Y[k + 0])) return j;
        for (; !ve(g, Y[k + 1]); ) if (Y = y[++j].Yb[0], k = 0, j == 16) return 16;
        var te = y[j + 1].Yb;
        if (ve(g, Y[k + 2])) {
          var se = g, ye = 0;
          if (ve(se, (Fe = Y)[(Ie = k) + 3])) if (ve(se, Fe[Ie + 6])) {
            for (Y = 0, Ie = 2 * (ye = ve(se, Fe[Ie + 8])) + (Fe = ve(se, Fe[Ie + 9 + ye])), ye = 0, Fe = Zx[Ie]; Fe[Y]; ++Y) ye += ye + ve(se, Fe[Y]);
            ye += 3 + (8 << Ie);
          } else ve(se, Fe[Ie + 7]) ? (ye = 7 + 2 * ve(se, 165), ye += ve(se, 145)) : ye = 5 + ve(se, 159);
          else ye = ve(se, Fe[Ie + 4]) ? 3 + ve(se, Fe[Ie + 5]) : 2;
          Y = te[2];
        } else ye = 1, Y = te[1];
        te = W + ek[j], 0 > (se = g).b && ue(se);
        var Ie, Fe = se.b, _e = (Ie = se.Ca >> 1) - (se.I >> Fe) >> 31;
        --se.b, se.Ca += _e, se.Ca |= 1, se.I -= (Ie + 1 & _e) << Fe, q[te] = ((ye ^ _e) - _e) * Q[(0 < j) + 0];
      }
      return 16;
    }
    function Vu(g) {
      var y = g.rb[g.sb - 1];
      y.la = 0, y.Na = 0, i(g.zc, 0, 0, g.zc.length), g.ja = 0;
    }
    function Yg(g, y) {
      if (g == null) return 0;
      if (y == null) return un(g, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!g.cb && !rh(g, y)) return 0;
      if (e(g.cb), y.ac == null || y.ac(y)) {
        y.ob && (g.L = 0);
        var k = kh[g.L];
        if (g.L == 2 ? (g.yb = 0, g.zb = 0) : (g.yb = y.v - k >> 4, g.zb = y.j - k >> 4, 0 > g.yb && (g.yb = 0), 0 > g.zb && (g.zb = 0)), g.Va = y.o + 15 + k >> 4, g.Hb = y.va + 15 + k >> 4, g.Hb > g.za && (g.Hb = g.za), g.Va > g.Ub && (g.Va = g.Ub), 0 < g.L) {
          var Q = g.ed;
          for (k = 0; 4 > k; ++k) {
            var j;
            if (g.Qa.Cb) {
              var q = g.Qa.Lb[k];
              g.Qa.Fb || (q += Q.Tb);
            } else q = Q.Tb;
            for (j = 0; 1 >= j; ++j) {
              var W = g.gd[k][j], Y = q;
              if (Q.Pc && (Y += Q.vd[0], j && (Y += Q.od[0])), 0 < (Y = 0 > Y ? 0 : 63 < Y ? 63 : Y)) {
                var te = Y;
                0 < Q.wb && (te = 4 < Q.wb ? te >> 2 : te >> 1) > 9 - Q.wb && (te = 9 - Q.wb), 1 > te && (te = 1), W.dd = te, W.tc = 2 * Y + te, W.ld = 40 <= Y ? 2 : 15 <= Y ? 1 : 0;
              } else W.tc = 0;
              W.La = j;
            }
          }
        }
        k = 0;
      } else un(g, 6, "Frame setup failed"), k = g.a;
      if (k = k == 0) {
        if (k) {
          g.$c = 0, 0 < g.Aa || (g.Ic = mk);
          e: {
            k = g.Ic, Q = 4 * (te = g.za);
            var se = 32 * te, ye = te + 1, Ie = 0 < g.L ? te * (0 < g.Aa ? 2 : 1) : 0, Fe = (g.Aa == 2 ? 2 : 1) * te;
            if ((W = Q + 832 + (j = 3 * (16 * k + kh[g.L]) / 2 * se) + (q = g.Fa != null && 0 < g.Fa.length ? g.Kc.c * g.Kc.i : 0)) != W) k = 0;
            else {
              if (W > g.Vb) {
                if (g.Vb = 0, g.Ec = s(W), g.Fc = 0, g.Ec == null) {
                  k = un(g, 1, "no memory during frame initialization.");
                  break e;
                }
                g.Vb = W;
              }
              W = g.Ec, Y = g.Fc, g.Ac = W, g.Bc = Y, Y += Q, g.Gd = a(se, pA), g.Hd = 0, g.rb = a(ye + 1, Zr), g.sb = 1, g.wa = Ie ? a(Ie, Wr) : null, g.Y = 0, g.D.Nb = 0, g.D.wa = g.wa, g.D.Y = g.Y, 0 < g.Aa && (g.D.Y += te), e(!0), g.oc = W, g.pc = Y, Y += 832, g.ya = a(Fe, $r), g.aa = 0, g.D.ya = g.ya, g.D.aa = g.aa, g.Aa == 2 && (g.D.aa += te), g.R = 16 * te, g.B = 8 * te, te = (se = kh[g.L]) * g.R, se = se / 2 * g.B, g.sa = W, g.ta = Y + te, g.qa = g.sa, g.ra = g.ta + 16 * k * g.R + se, g.Ha = g.qa, g.Ia = g.ra + 8 * k * g.B + se, g.$c = 0, Y += j, g.mb = q ? W : null, g.nb = q ? Y : null, e(Y + q <= g.Fc + g.Vb), Vu(g), i(g.Ac, g.Bc, 0, Q), k = 1;
            }
          }
          if (k) {
            if (y.ka = 0, y.y = g.sa, y.O = g.ta, y.f = g.qa, y.N = g.ra, y.ea = g.Ha, y.Vd = g.Ia, y.fa = g.R, y.Rc = g.B, y.F = null, y.J = 0, !Bh) {
              for (k = -255; 255 >= k; ++k) On[255 + k] = 0 > k ? -k : k;
              for (k = -1020; 1020 >= k; ++k) $a[1020 + k] = -128 > k ? -128 : 127 < k ? 127 : k;
              for (k = -112; 112 >= k; ++k) hc[112 + k] = -16 > k ? -16 : 15 < k ? 15 : k;
              for (k = -255; 510 >= k; ++k) Ql[255 + k] = 0 > k ? 0 : 255 < k ? 255 : k;
              Bh = 1;
            }
            Ul = tm, Ka = Zg, uc = sh, ki = em, gs = ah, cn = ih, Nl = Ju, wh = vA, cc = dm, wA = Yu, BA = hm, wo = _l, CA = Zu, Ol = ph, _A = dh, Bo = ga, fc = Pa, ms = fm, Vs[0] = pa, Vs[1] = rm, Vs[2] = am, Vs[3] = om, Vs[4] = lh, Vs[5] = Bl, Vs[6] = uh, Vs[7] = qu, Vs[8] = lm, Vs[9] = Am, Co[0] = oh, Co[1] = im, Co[2] = Ra, Co[3] = yl, Co[4] = di, Co[5] = sm, Co[6] = Ah, Va[0] = go, Va[1] = nm, Va[2] = um, Va[3] = Wu, Va[4] = mA, Va[5] = cm, Va[6] = Xu, k = 1;
          } else k = 0;
        }
        k && (k = function(_e, He) {
          for (_e.M = 0; _e.M < _e.Va; ++_e.M) {
            var Ne, we = _e.Jc[_e.M & _e.Xb], Be = _e.m, Re = _e;
            for (Ne = 0; Ne < Re.za; ++Ne) {
              var qe = Be, Pe = Re, ct = Pe.Ac, nt = Pe.Bc + 4 * Ne, It = Pe.zc, st = Pe.ya[Pe.aa + Ne];
              if (Pe.Qa.Bb ? st.$b = ve(qe, Pe.Pa.jb[0]) ? 2 + ve(qe, Pe.Pa.jb[2]) : ve(qe, Pe.Pa.jb[1]) : st.$b = 0, Pe.kc && (st.Ad = ve(qe, Pe.Bd)), st.Za = !ve(qe, 145) + 0, st.Za) {
                var Br = st.Ob, Er = 0;
                for (Pe = 0; 4 > Pe; ++Pe) {
                  var vr, Ar = It[0 + Pe];
                  for (vr = 0; 4 > vr; ++vr) {
                    Ar = rk[ct[nt + vr]][Ar];
                    for (var kr = by[ve(qe, Ar[0])]; 0 < kr; ) kr = by[2 * kr + ve(qe, Ar[kr])];
                    Ar = -kr, ct[nt + vr] = Ar;
                  }
                  n(Br, Er, ct, nt, 4), Er += 4, It[0 + Pe] = Ar;
                }
              } else Ar = ve(qe, 156) ? ve(qe, 128) ? 1 : 3 : ve(qe, 163) ? 2 : 0, st.Ob[0] = Ar, i(ct, nt, Ar, 4), i(It, 0, Ar, 4);
              st.Dd = ve(qe, 142) ? ve(qe, 114) ? ve(qe, 183) ? 1 : 3 : 2 : 0;
            }
            if (Re.m.Ka) return un(_e, 7, "Premature end-of-partition0 encountered.");
            for (; _e.ja < _e.za; ++_e.ja) {
              if (Re = we, qe = (Be = _e).rb[Be.sb - 1], ct = Be.rb[Be.sb + Be.ja], Ne = Be.ya[Be.aa + Be.ja], nt = Be.kc ? Ne.Ad : 0) qe.la = ct.la = 0, Ne.Za || (qe.Na = ct.Na = 0), Ne.Hc = 0, Ne.Gc = 0, Ne.ia = 0;
              else {
                var Fr, Jt;
                if (qe = ct, ct = Re, nt = Be.Pa.Xc, It = Be.ya[Be.aa + Be.ja], st = Be.pb[It.$b], Pe = It.ad, Br = 0, Er = Be.rb[Be.sb - 1], Ar = vr = 0, i(Pe, Br, 0, 384), It.Za) var In = 0, Gi = nt[3];
                else {
                  kr = s(16);
                  var Fn = qe.Na + Er.Na;
                  if (Fn = dc(ct, nt[1], Fn, st.Eb, 0, kr, 0), qe.Na = Er.Na = (0 < Fn) + 0, 1 < Fn) Ul(kr, 0, Pe, Br);
                  else {
                    var qi = kr[0] + 3 >> 3;
                    for (kr = 0; 256 > kr; kr += 16) Pe[Br + kr] = qi;
                  }
                  In = 1, Gi = nt[0];
                }
                var Sr = 15 & qe.la, is = 15 & Er.la;
                for (kr = 0; 4 > kr; ++kr) {
                  var ss = 1 & is;
                  for (qi = Jt = 0; 4 > qi; ++qi) Sr = Sr >> 1 | (ss = (Fn = dc(ct, Gi, Fn = ss + (1 & Sr), st.Sc, In, Pe, Br)) > In) << 7, Jt = Jt << 2 | (3 < Fn ? 3 : 1 < Fn ? 2 : Pe[Br + 0] != 0), Br += 16;
                  Sr >>= 4, is = is >> 1 | ss << 7, vr = (vr << 8 | Jt) >>> 0;
                }
                for (Gi = Sr, In = is >> 4, Fr = 0; 4 > Fr; Fr += 2) {
                  for (Jt = 0, Sr = qe.la >> 4 + Fr, is = Er.la >> 4 + Fr, kr = 0; 2 > kr; ++kr) {
                    for (ss = 1 & is, qi = 0; 2 > qi; ++qi) Fn = ss + (1 & Sr), Sr = Sr >> 1 | (ss = 0 < (Fn = dc(ct, nt[2], Fn, st.Qc, 0, Pe, Br))) << 3, Jt = Jt << 2 | (3 < Fn ? 3 : 1 < Fn ? 2 : Pe[Br + 0] != 0), Br += 16;
                    Sr >>= 2, is = is >> 1 | ss << 5;
                  }
                  Ar |= Jt << 4 * Fr, Gi |= Sr << 4 << Fr, In |= (240 & is) << Fr;
                }
                qe.la = Gi, Er.la = In, It.Hc = vr, It.Gc = Ar, It.ia = 43690 & Ar ? 0 : st.ia, nt = !(vr | Ar);
              }
              if (0 < Be.L && (Be.wa[Be.Y + Be.ja] = Be.gd[Ne.$b][Ne.Za], Be.wa[Be.Y + Be.ja].La |= !nt), Re.Ka) return un(_e, 7, "Premature end-of-file encountered.");
            }
            if (Vu(_e), Be = He, Re = 1, Ne = (we = _e).D, qe = 0 < we.L && we.M >= we.zb && we.M <= we.Va, we.Aa == 0) e: {
              if (Ne.M = we.M, Ne.uc = qe, sc(we, Ne), Re = 1, Ne = (Jt = we.D).Nb, qe = (Ar = kh[we.L]) * we.R, ct = Ar / 2 * we.B, kr = 16 * Ne * we.R, qi = 8 * Ne * we.B, nt = we.sa, It = we.ta - qe + kr, st = we.qa, Pe = we.ra - ct + qi, Br = we.Ha, Er = we.Ia - ct + qi, is = (Sr = Jt.M) == 0, vr = Sr >= we.Va - 1, we.Aa == 2 && sc(we, Jt), Jt.uc) for (ss = (Fn = we).D.M, e(Fn.D.uc), Jt = Fn.yb; Jt < Fn.Hb; ++Jt) {
                In = Jt, Gi = ss;
                var jn = (ti = (tn = Fn).D).Nb;
                Fr = tn.R;
                var ti = ti.wa[ti.Y + In], Li = tn.sa, ws = tn.ta + 16 * jn * Fr + 16 * In, va = ti.dd, Kn = ti.tc;
                if (Kn != 0) if (e(3 <= Kn), tn.L == 1) 0 < In && Bo(Li, ws, Fr, Kn + 4), ti.La && ms(Li, ws, Fr, Kn), 0 < Gi && _A(Li, ws, Fr, Kn + 4), ti.La && fc(Li, ws, Fr, Kn);
                else {
                  var za = tn.B, EA = tn.qa, Dl = tn.ra + 8 * jn * za + 8 * In, Eo = tn.Ha, tn = tn.Ia + 8 * jn * za + 8 * In;
                  jn = ti.ld, 0 < In && (wh(Li, ws, Fr, Kn + 4, va, jn), wA(EA, Dl, Eo, tn, za, Kn + 4, va, jn)), ti.La && (wo(Li, ws, Fr, Kn, va, jn), Ol(EA, Dl, Eo, tn, za, Kn, va, jn)), 0 < Gi && (Nl(Li, ws, Fr, Kn + 4, va, jn), cc(EA, Dl, Eo, tn, za, Kn + 4, va, jn)), ti.La && (BA(Li, ws, Fr, Kn, va, jn), CA(EA, Dl, Eo, tn, za, Kn, va, jn));
                }
              }
              if (we.ia && alert("todo:DitherRow"), Be.put != null) {
                if (Jt = 16 * Sr, Sr = 16 * (Sr + 1), is ? (Be.y = we.sa, Be.O = we.ta + kr, Be.f = we.qa, Be.N = we.ra + qi, Be.ea = we.Ha, Be.W = we.Ia + qi) : (Jt -= Ar, Be.y = nt, Be.O = It, Be.f = st, Be.N = Pe, Be.ea = Br, Be.W = Er), vr || (Sr -= Ar), Sr > Be.o && (Sr = Be.o), Be.F = null, Be.J = null, we.Fa != null && 0 < we.Fa.length && Jt < Sr && (Be.J = nc(we, Be, Jt, Sr - Jt), Be.F = we.mb, Be.F == null && Be.F.length == 0)) {
                  Re = un(we, 3, "Could not decode alpha data.");
                  break e;
                }
                Jt < Be.j && (Ar = Be.j - Jt, Jt = Be.j, e(!(1 & Ar)), Be.O += we.R * Ar, Be.N += we.B * (Ar >> 1), Be.W += we.B * (Ar >> 1), Be.F != null && (Be.J += Be.width * Ar)), Jt < Sr && (Be.O += Be.v, Be.N += Be.v >> 1, Be.W += Be.v >> 1, Be.F != null && (Be.J += Be.v), Be.ka = Jt - Be.j, Be.U = Be.va - Be.v, Be.T = Sr - Jt, Re = Be.put(Be));
              }
              Ne + 1 != we.Ic || vr || (n(we.sa, we.ta - qe, nt, It + 16 * we.R, qe), n(we.qa, we.ra - ct, st, Pe + 8 * we.B, ct), n(we.Ha, we.Ia - ct, Br, Er + 8 * we.B, ct));
            }
            if (!Re) return un(_e, 6, "Output aborted.");
          }
          return 1;
        }(g, y)), y.bc != null && y.bc(y), k &= 1;
      }
      return k ? (g.cb = 0, k) : 0;
    }
    function js(g, y, k, Q, j) {
      j = g[y + k + 32 * Q] + (j >> 3), g[y + k + 32 * Q] = -256 & j ? 0 > j ? 0 : 255 : j;
    }
    function bl(g, y, k, Q, j, q) {
      js(g, y, 0, k, Q + j), js(g, y, 1, k, Q + q), js(g, y, 2, k, Q - q), js(g, y, 3, k, Q - j);
    }
    function $i(g) {
      return (20091 * g >> 16) + g;
    }
    function zu(g, y, k, Q) {
      var j, q = 0, W = s(16);
      for (j = 0; 4 > j; ++j) {
        var Y = g[y + 0] + g[y + 8], te = g[y + 0] - g[y + 8], se = (35468 * g[y + 4] >> 16) - $i(g[y + 12]), ye = $i(g[y + 4]) + (35468 * g[y + 12] >> 16);
        W[q + 0] = Y + ye, W[q + 1] = te + se, W[q + 2] = te - se, W[q + 3] = Y - ye, q += 4, y++;
      }
      for (j = q = 0; 4 > j; ++j) Y = (g = W[q + 0] + 4) + W[q + 8], te = g - W[q + 8], se = (35468 * W[q + 4] >> 16) - $i(W[q + 12]), js(k, Q, 0, 0, Y + (ye = $i(W[q + 4]) + (35468 * W[q + 12] >> 16))), js(k, Q, 1, 0, te + se), js(k, Q, 2, 0, te - se), js(k, Q, 3, 0, Y - ye), q++, Q += 32;
    }
    function ih(g, y, k, Q) {
      var j = g[y + 0] + 4, q = 35468 * g[y + 4] >> 16, W = $i(g[y + 4]), Y = 35468 * g[y + 1] >> 16;
      bl(k, Q, 0, j + W, g = $i(g[y + 1]), Y), bl(k, Q, 1, j + q, g, Y), bl(k, Q, 2, j - q, g, Y), bl(k, Q, 3, j - W, g, Y);
    }
    function Zg(g, y, k, Q, j) {
      zu(g, y, k, Q), j && zu(g, y + 16, k, Q + 4);
    }
    function sh(g, y, k, Q) {
      Ka(g, y + 0, k, Q, 1), Ka(g, y + 32, k, Q + 128, 1);
    }
    function em(g, y, k, Q) {
      var j;
      for (g = g[y + 0] + 4, j = 0; 4 > j; ++j) for (y = 0; 4 > y; ++y) js(k, Q, y, j, g);
    }
    function ah(g, y, k, Q) {
      g[y + 0] && ki(g, y + 0, k, Q), g[y + 16] && ki(g, y + 16, k, Q + 4), g[y + 32] && ki(g, y + 32, k, Q + 128), g[y + 48] && ki(g, y + 48, k, Q + 128 + 4);
    }
    function tm(g, y, k, Q) {
      var j, q = s(16);
      for (j = 0; 4 > j; ++j) {
        var W = g[y + 0 + j] + g[y + 12 + j], Y = g[y + 4 + j] + g[y + 8 + j], te = g[y + 4 + j] - g[y + 8 + j], se = g[y + 0 + j] - g[y + 12 + j];
        q[0 + j] = W + Y, q[8 + j] = W - Y, q[4 + j] = se + te, q[12 + j] = se - te;
      }
      for (j = 0; 4 > j; ++j) W = (g = q[0 + 4 * j] + 3) + q[3 + 4 * j], Y = q[1 + 4 * j] + q[2 + 4 * j], te = q[1 + 4 * j] - q[2 + 4 * j], se = g - q[3 + 4 * j], k[Q + 0] = W + Y >> 3, k[Q + 16] = se + te >> 3, k[Q + 32] = W - Y >> 3, k[Q + 48] = se - te >> 3, Q += 64;
    }
    function Gu(g, y, k) {
      var Q, j = y - 32, q = ns, W = 255 - g[j - 1];
      for (Q = 0; Q < k; ++Q) {
        var Y, te = q, se = W + g[y - 1];
        for (Y = 0; Y < k; ++Y) g[y + Y] = te[se + g[j + Y]];
        y += 32;
      }
    }
    function rm(g, y) {
      Gu(g, y, 4);
    }
    function nm(g, y) {
      Gu(g, y, 8);
    }
    function im(g, y) {
      Gu(g, y, 16);
    }
    function Ra(g, y) {
      var k;
      for (k = 0; 16 > k; ++k) n(g, y + 32 * k, g, y - 32, 16);
    }
    function yl(g, y) {
      var k;
      for (k = 16; 0 < k; --k) i(g, y, g[y - 1], 16), y += 32;
    }
    function wl(g, y, k) {
      var Q;
      for (Q = 0; 16 > Q; ++Q) i(y, k + 32 * Q, g, 16);
    }
    function oh(g, y) {
      var k, Q = 16;
      for (k = 0; 16 > k; ++k) Q += g[y - 1 + 32 * k] + g[y + k - 32];
      wl(Q >> 5, g, y);
    }
    function di(g, y) {
      var k, Q = 8;
      for (k = 0; 16 > k; ++k) Q += g[y - 1 + 32 * k];
      wl(Q >> 4, g, y);
    }
    function sm(g, y) {
      var k, Q = 8;
      for (k = 0; 16 > k; ++k) Q += g[y + k - 32];
      wl(Q >> 4, g, y);
    }
    function Ah(g, y) {
      wl(128, g, y);
    }
    function Rt(g, y, k) {
      return g + 2 * y + k + 2 >> 2;
    }
    function am(g, y) {
      var k, Q = y - 32;
      for (Q = new Uint8Array([Rt(g[Q - 1], g[Q + 0], g[Q + 1]), Rt(g[Q + 0], g[Q + 1], g[Q + 2]), Rt(g[Q + 1], g[Q + 2], g[Q + 3]), Rt(g[Q + 2], g[Q + 3], g[Q + 4])]), k = 0; 4 > k; ++k) n(g, y + 32 * k, Q, 0, Q.length);
    }
    function om(g, y) {
      var k = g[y - 1], Q = g[y - 1 + 32], j = g[y - 1 + 64], q = g[y - 1 + 96];
      Le(g, y + 0, 16843009 * Rt(g[y - 1 - 32], k, Q)), Le(g, y + 32, 16843009 * Rt(k, Q, j)), Le(g, y + 64, 16843009 * Rt(Q, j, q)), Le(g, y + 96, 16843009 * Rt(j, q, q));
    }
    function pa(g, y) {
      var k, Q = 4;
      for (k = 0; 4 > k; ++k) Q += g[y + k - 32] + g[y - 1 + 32 * k];
      for (Q >>= 3, k = 0; 4 > k; ++k) i(g, y + 32 * k, Q, 4);
    }
    function lh(g, y) {
      var k = g[y - 1 + 0], Q = g[y - 1 + 32], j = g[y - 1 + 64], q = g[y - 1 - 32], W = g[y + 0 - 32], Y = g[y + 1 - 32], te = g[y + 2 - 32], se = g[y + 3 - 32];
      g[y + 0 + 96] = Rt(Q, j, g[y - 1 + 96]), g[y + 1 + 96] = g[y + 0 + 64] = Rt(k, Q, j), g[y + 2 + 96] = g[y + 1 + 64] = g[y + 0 + 32] = Rt(q, k, Q), g[y + 3 + 96] = g[y + 2 + 64] = g[y + 1 + 32] = g[y + 0 + 0] = Rt(W, q, k), g[y + 3 + 64] = g[y + 2 + 32] = g[y + 1 + 0] = Rt(Y, W, q), g[y + 3 + 32] = g[y + 2 + 0] = Rt(te, Y, W), g[y + 3 + 0] = Rt(se, te, Y);
    }
    function uh(g, y) {
      var k = g[y + 1 - 32], Q = g[y + 2 - 32], j = g[y + 3 - 32], q = g[y + 4 - 32], W = g[y + 5 - 32], Y = g[y + 6 - 32], te = g[y + 7 - 32];
      g[y + 0 + 0] = Rt(g[y + 0 - 32], k, Q), g[y + 1 + 0] = g[y + 0 + 32] = Rt(k, Q, j), g[y + 2 + 0] = g[y + 1 + 32] = g[y + 0 + 64] = Rt(Q, j, q), g[y + 3 + 0] = g[y + 2 + 32] = g[y + 1 + 64] = g[y + 0 + 96] = Rt(j, q, W), g[y + 3 + 32] = g[y + 2 + 64] = g[y + 1 + 96] = Rt(q, W, Y), g[y + 3 + 64] = g[y + 2 + 96] = Rt(W, Y, te), g[y + 3 + 96] = Rt(Y, te, te);
    }
    function Bl(g, y) {
      var k = g[y - 1 + 0], Q = g[y - 1 + 32], j = g[y - 1 + 64], q = g[y - 1 - 32], W = g[y + 0 - 32], Y = g[y + 1 - 32], te = g[y + 2 - 32], se = g[y + 3 - 32];
      g[y + 0 + 0] = g[y + 1 + 64] = q + W + 1 >> 1, g[y + 1 + 0] = g[y + 2 + 64] = W + Y + 1 >> 1, g[y + 2 + 0] = g[y + 3 + 64] = Y + te + 1 >> 1, g[y + 3 + 0] = te + se + 1 >> 1, g[y + 0 + 96] = Rt(j, Q, k), g[y + 0 + 64] = Rt(Q, k, q), g[y + 0 + 32] = g[y + 1 + 96] = Rt(k, q, W), g[y + 1 + 32] = g[y + 2 + 96] = Rt(q, W, Y), g[y + 2 + 32] = g[y + 3 + 96] = Rt(W, Y, te), g[y + 3 + 32] = Rt(Y, te, se);
    }
    function qu(g, y) {
      var k = g[y + 0 - 32], Q = g[y + 1 - 32], j = g[y + 2 - 32], q = g[y + 3 - 32], W = g[y + 4 - 32], Y = g[y + 5 - 32], te = g[y + 6 - 32], se = g[y + 7 - 32];
      g[y + 0 + 0] = k + Q + 1 >> 1, g[y + 1 + 0] = g[y + 0 + 64] = Q + j + 1 >> 1, g[y + 2 + 0] = g[y + 1 + 64] = j + q + 1 >> 1, g[y + 3 + 0] = g[y + 2 + 64] = q + W + 1 >> 1, g[y + 0 + 32] = Rt(k, Q, j), g[y + 1 + 32] = g[y + 0 + 96] = Rt(Q, j, q), g[y + 2 + 32] = g[y + 1 + 96] = Rt(j, q, W), g[y + 3 + 32] = g[y + 2 + 96] = Rt(q, W, Y), g[y + 3 + 64] = Rt(W, Y, te), g[y + 3 + 96] = Rt(Y, te, se);
    }
    function Am(g, y) {
      var k = g[y - 1 + 0], Q = g[y - 1 + 32], j = g[y - 1 + 64], q = g[y - 1 + 96];
      g[y + 0 + 0] = k + Q + 1 >> 1, g[y + 2 + 0] = g[y + 0 + 32] = Q + j + 1 >> 1, g[y + 2 + 32] = g[y + 0 + 64] = j + q + 1 >> 1, g[y + 1 + 0] = Rt(k, Q, j), g[y + 3 + 0] = g[y + 1 + 32] = Rt(Q, j, q), g[y + 3 + 32] = g[y + 1 + 64] = Rt(j, q, q), g[y + 3 + 64] = g[y + 2 + 64] = g[y + 0 + 96] = g[y + 1 + 96] = g[y + 2 + 96] = g[y + 3 + 96] = q;
    }
    function lm(g, y) {
      var k = g[y - 1 + 0], Q = g[y - 1 + 32], j = g[y - 1 + 64], q = g[y - 1 + 96], W = g[y - 1 - 32], Y = g[y + 0 - 32], te = g[y + 1 - 32], se = g[y + 2 - 32];
      g[y + 0 + 0] = g[y + 2 + 32] = k + W + 1 >> 1, g[y + 0 + 32] = g[y + 2 + 64] = Q + k + 1 >> 1, g[y + 0 + 64] = g[y + 2 + 96] = j + Q + 1 >> 1, g[y + 0 + 96] = q + j + 1 >> 1, g[y + 3 + 0] = Rt(Y, te, se), g[y + 2 + 0] = Rt(W, Y, te), g[y + 1 + 0] = g[y + 3 + 32] = Rt(k, W, Y), g[y + 1 + 32] = g[y + 3 + 64] = Rt(Q, k, W), g[y + 1 + 64] = g[y + 3 + 96] = Rt(j, Q, k), g[y + 1 + 96] = Rt(q, j, Q);
    }
    function um(g, y) {
      var k;
      for (k = 0; 8 > k; ++k) n(g, y + 32 * k, g, y - 32, 8);
    }
    function Wu(g, y) {
      var k;
      for (k = 0; 8 > k; ++k) i(g, y, g[y - 1], 8), y += 32;
    }
    function gA(g, y, k) {
      var Q;
      for (Q = 0; 8 > Q; ++Q) i(y, k + 32 * Q, g, 8);
    }
    function go(g, y) {
      var k, Q = 8;
      for (k = 0; 8 > k; ++k) Q += g[y + k - 32] + g[y - 1 + 32 * k];
      gA(Q >> 4, g, y);
    }
    function cm(g, y) {
      var k, Q = 4;
      for (k = 0; 8 > k; ++k) Q += g[y + k - 32];
      gA(Q >> 3, g, y);
    }
    function mA(g, y) {
      var k, Q = 4;
      for (k = 0; 8 > k; ++k) Q += g[y - 1 + 32 * k];
      gA(Q >> 3, g, y);
    }
    function Xu(g, y) {
      gA(128, g, y);
    }
    function Cl(g, y, k) {
      var Q = g[y - k], j = g[y + 0], q = 3 * (j - Q) + mm[1020 + g[y - 2 * k] - g[y + k]], W = Ch[112 + (q + 4 >> 3)];
      g[y - k] = ns[255 + Q + Ch[112 + (q + 3 >> 3)]], g[y + 0] = ns[255 + j - W];
    }
    function ch(g, y, k, Q) {
      var j = g[y + 0], q = g[y + k];
      return bs[255 + g[y - 2 * k] - g[y - k]] > Q || bs[255 + q - j] > Q;
    }
    function fh(g, y, k, Q) {
      return 4 * bs[255 + g[y - k] - g[y + 0]] + bs[255 + g[y - 2 * k] - g[y + k]] <= Q;
    }
    function hh(g, y, k, Q, j) {
      var q = g[y - 3 * k], W = g[y - 2 * k], Y = g[y - k], te = g[y + 0], se = g[y + k], ye = g[y + 2 * k], Ie = g[y + 3 * k];
      return 4 * bs[255 + Y - te] + bs[255 + W - se] > Q ? 0 : bs[255 + g[y - 4 * k] - q] <= j && bs[255 + q - W] <= j && bs[255 + W - Y] <= j && bs[255 + Ie - ye] <= j && bs[255 + ye - se] <= j && bs[255 + se - te] <= j;
    }
    function dh(g, y, k, Q) {
      var j = 2 * Q + 1;
      for (Q = 0; 16 > Q; ++Q) fh(g, y + Q, k, j) && Cl(g, y + Q, k);
    }
    function ga(g, y, k, Q) {
      var j = 2 * Q + 1;
      for (Q = 0; 16 > Q; ++Q) fh(g, y + Q * k, 1, j) && Cl(g, y + Q * k, 1);
    }
    function Pa(g, y, k, Q) {
      var j;
      for (j = 3; 0 < j; --j) dh(g, y += 4 * k, k, Q);
    }
    function fm(g, y, k, Q) {
      var j;
      for (j = 3; 0 < j; --j) ga(g, y += 4, k, Q);
    }
    function mo(g, y, k, Q, j, q, W, Y) {
      for (q = 2 * q + 1; 0 < j--; ) {
        if (hh(g, y, k, q, W)) if (ch(g, y, k, Y)) Cl(g, y, k);
        else {
          var te = g, se = y, ye = k, Ie = te[se - 2 * ye], Fe = te[se - ye], _e = te[se + 0], He = te[se + ye], Ne = te[se + 2 * ye], we = 27 * (Re = mm[1020 + 3 * (_e - Fe) + mm[1020 + Ie - He]]) + 63 >> 7, Be = 18 * Re + 63 >> 7, Re = 9 * Re + 63 >> 7;
          te[se - 3 * ye] = ns[255 + te[se - 3 * ye] + Re], te[se - 2 * ye] = ns[255 + Ie + Be], te[se - ye] = ns[255 + Fe + we], te[se + 0] = ns[255 + _e - we], te[se + ye] = ns[255 + He - Be], te[se + 2 * ye] = ns[255 + Ne - Re];
        }
        y += Q;
      }
    }
    function Ks(g, y, k, Q, j, q, W, Y) {
      for (q = 2 * q + 1; 0 < j--; ) {
        if (hh(g, y, k, q, W)) if (ch(g, y, k, Y)) Cl(g, y, k);
        else {
          var te = g, se = y, ye = k, Ie = te[se - ye], Fe = te[se + 0], _e = te[se + ye], He = Ch[112 + ((Ne = 3 * (Fe - Ie)) + 4 >> 3)], Ne = Ch[112 + (Ne + 3 >> 3)], we = He + 1 >> 1;
          te[se - 2 * ye] = ns[255 + te[se - 2 * ye] + we], te[se - ye] = ns[255 + Ie + Ne], te[se + 0] = ns[255 + Fe - He], te[se + ye] = ns[255 + _e - we];
        }
        y += Q;
      }
    }
    function Ju(g, y, k, Q, j, q) {
      mo(g, y, k, 1, 16, Q, j, q);
    }
    function vA(g, y, k, Q, j, q) {
      mo(g, y, 1, k, 16, Q, j, q);
    }
    function hm(g, y, k, Q, j, q) {
      var W;
      for (W = 3; 0 < W; --W) Ks(g, y += 4 * k, k, 1, 16, Q, j, q);
    }
    function _l(g, y, k, Q, j, q) {
      var W;
      for (W = 3; 0 < W; --W) Ks(g, y += 4, 1, k, 16, Q, j, q);
    }
    function dm(g, y, k, Q, j, q, W, Y) {
      mo(g, y, j, 1, 8, q, W, Y), mo(k, Q, j, 1, 8, q, W, Y);
    }
    function Yu(g, y, k, Q, j, q, W, Y) {
      mo(g, y, 1, j, 8, q, W, Y), mo(k, Q, 1, j, 8, q, W, Y);
    }
    function Zu(g, y, k, Q, j, q, W, Y) {
      Ks(g, y + 4 * j, j, 1, 8, q, W, Y), Ks(k, Q + 4 * j, j, 1, 8, q, W, Y);
    }
    function ph(g, y, k, Q, j, q, W, Y) {
      Ks(g, y + 4, 1, j, 8, q, W, Y), Ks(k, Q + 4, 1, j, 8, q, W, Y);
    }
    function El() {
      this.ba = new Ir(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new wr(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function ec() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function tc() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function gh() {
      this.ua = 0, this.Wa = new G(), this.vb = new G(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new S(), this.yc = new E();
    }
    function pm() {
      this.xb = this.a = 0, this.l = new vl(), this.ca = new Ir(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new U(), this.Pb = 0, this.wd = new U(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new gh(), this.ab = 0, this.gc = a(4, tc), this.Oc = 0;
    }
    function Sl() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new vl(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function bA(g, y, k, Q, j, q, W) {
      for (g = g == null ? 0 : g[y + 0], y = 0; y < W; ++y) j[q + y] = g + k[Q + y] & 255, g = j[q + y];
    }
    function rc(g, y, k, Q, j, q, W) {
      var Y;
      if (g == null) bA(null, null, k, Q, j, q, W);
      else for (Y = 0; Y < W; ++Y) j[q + Y] = g[y + Y] + k[Q + Y] & 255;
    }
    function vo(g, y, k, Q, j, q, W) {
      if (g == null) bA(null, null, k, Q, j, q, W);
      else {
        var Y, te = g[y + 0], se = te, ye = te;
        for (Y = 0; Y < W; ++Y) se = ye + (te = g[y + Y]) - se, ye = k[Q + Y] + (-256 & se ? 0 > se ? 0 : 255 : se) & 255, se = te, j[q + Y] = ye;
      }
    }
    function nc(g, y, k, Q) {
      var j = y.width, q = y.o;
      if (e(g != null && y != null), 0 > k || 0 >= Q || k + Q > q) return null;
      if (!g.Cc) {
        if (g.ga == null) {
          var W;
          if (g.ga = new Sl(), (W = g.ga == null) || (W = y.width * y.o, e(g.Gb.length == 0), g.Gb = s(W), g.Uc = 0, g.Gb == null ? W = 0 : (g.mb = g.Gb, g.nb = g.Uc, g.rc = null, W = 1), W = !W), !W) {
            W = g.ga;
            var Y = g.Fa, te = g.P, se = g.qc, ye = g.mb, Ie = g.nb, Fe = te + 1, _e = se - 1, He = W.l;
            if (e(Y != null && ye != null && y != null), _o[0] = null, _o[1] = bA, _o[2] = rc, _o[3] = vo, W.ca = ye, W.tb = Ie, W.c = y.width, W.i = y.height, e(0 < W.c && 0 < W.i), 1 >= se) y = 0;
            else if (W.$a = Y[te + 0] >> 0 & 3, W.Z = Y[te + 0] >> 2 & 3, W.Lc = Y[te + 0] >> 4 & 3, te = Y[te + 0] >> 6 & 3, 0 > W.$a || 1 < W.$a || 4 <= W.Z || 1 < W.Lc || te) y = 0;
            else if (He.put = fi, He.ac = Yr, He.bc = Fi, He.ma = W, He.width = y.width, He.height = y.height, He.Da = y.Da, He.v = y.v, He.va = y.va, He.j = y.j, He.o = y.o, W.$a) e: {
              e(W.$a == 1), y = or();
              t: for (; ; ) {
                if (y == null) {
                  y = 0;
                  break e;
                }
                if (e(W != null), W.mc = y, y.c = W.c, y.i = W.i, y.l = W.l, y.l.ma = W, y.l.width = W.c, y.l.height = W.i, y.a = 0, V(y.m, Y, Fe, _e), !hi(W.c, W.i, 1, y, null) || (y.ab == 1 && y.gc[0].hc == 3 && Ki(y.s) ? (W.ic = 1, Y = y.c * y.i, y.Ta = null, y.Ua = 0, y.V = s(Y), y.Ba = 0, y.V == null ? (y.a = 1, y = 0) : y = 1) : (W.ic = 0, y = hs(y, W.c)), !y)) break t;
                y = 1;
                break e;
              }
              W.mc = null, y = 0;
            }
            else y = _e >= W.c * W.i;
            W = !y;
          }
          if (W) return null;
          g.ga.Lc != 1 ? g.Ga = 0 : Q = q - k;
        }
        e(g.ga != null), e(k + Q <= q);
        e: {
          if (y = (Y = g.ga).c, q = Y.l.o, Y.$a == 0) {
            if (Fe = g.rc, _e = g.Vc, He = g.Fa, te = g.P + 1 + k * y, se = g.mb, ye = g.nb + k * y, e(te <= g.P + g.qc), Y.Z != 0) for (e(_o[Y.Z] != null), W = 0; W < Q; ++W) _o[Y.Z](Fe, _e, He, te, se, ye, y), Fe = se, _e = ye, ye += y, te += y;
            else for (W = 0; W < Q; ++W) n(se, ye, He, te, y), Fe = se, _e = ye, ye += y, te += y;
            g.rc = Fe, g.Vc = _e;
          } else {
            if (e(Y.mc != null), y = k + Q, e((W = Y.mc) != null), e(y <= W.i), W.C >= y) y = 1;
            else if (Y.ic || Se(), Y.ic) {
              Y = W.V, Fe = W.Ba, _e = W.c;
              var Ne = W.i, we = (He = 1, te = W.$ / _e, se = W.$ % _e, ye = W.m, Ie = W.s, W.$), Be = _e * Ne, Re = _e * y, qe = Ie.wc, Pe = we < Re ? ur(Ie, se, te) : null;
              e(we <= Be), e(y <= Ne), e(Ki(Ie));
              t: for (; ; ) {
                for (; !ye.h && we < Re; ) {
                  if (se & qe || (Pe = ur(Ie, se, te)), e(Pe != null), ie(ye), 256 > (Ne = _n(Pe.G[0], Pe.H[0], ye))) Y[Fe + we] = Ne, ++we, ++se >= _e && (se = 0, ++te <= y && !(te % 16) && Nn(W, te));
                  else {
                    if (!(280 > Ne)) {
                      He = 0;
                      break t;
                    }
                    Ne = Ti(Ne - 256, ye);
                    var ct, nt = _n(Pe.G[4], Pe.H[4], ye);
                    if (ie(ye), !(we >= (nt = Yn(_e, nt = Ti(nt, ye))) && Be - we >= Ne)) {
                      He = 0;
                      break t;
                    }
                    for (ct = 0; ct < Ne; ++ct) Y[Fe + we + ct] = Y[Fe + we + ct - nt];
                    for (we += Ne, se += Ne; se >= _e; ) se -= _e, ++te <= y && !(te % 16) && Nn(W, te);
                    we < Re && se & qe && (Pe = ur(Ie, se, te));
                  }
                  e(ye.h == H(ye));
                }
                Nn(W, te > y ? y : te);
                break t;
              }
              !He || ye.h && we < Be ? (He = 0, W.a = ye.h ? 5 : 3) : W.$ = we, y = He;
            } else y = qr(W, W.V, W.Ba, W.c, W.i, y, ds);
            if (!y) {
              Q = 0;
              break e;
            }
          }
          k + Q >= q && (g.Cc = 1), Q = 1;
        }
        if (!Q) return null;
        if (g.Cc && ((Q = g.ga) != null && (Q.mc = null), g.ga = null, 0 < g.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return g.nb + k * j;
    }
    function I(g, y, k, Q, j, q) {
      for (; 0 < j--; ) {
        var W, Y = g, te = y + (k ? 1 : 0), se = g, ye = y + (k ? 0 : 3);
        for (W = 0; W < Q; ++W) {
          var Ie = se[ye + 4 * W];
          Ie != 255 && (Ie *= 32897, Y[te + 4 * W + 0] = Y[te + 4 * W + 0] * Ie >> 23, Y[te + 4 * W + 1] = Y[te + 4 * W + 1] * Ie >> 23, Y[te + 4 * W + 2] = Y[te + 4 * W + 2] * Ie >> 23);
        }
        y += q;
      }
    }
    function K(g, y, k, Q, j) {
      for (; 0 < Q--; ) {
        var q;
        for (q = 0; q < k; ++q) {
          var W = g[y + 2 * q + 0], Y = 15 & (se = g[y + 2 * q + 1]), te = 4369 * Y, se = (240 & se | se >> 4) * te >> 16;
          g[y + 2 * q + 0] = (240 & W | W >> 4) * te >> 16 & 240 | (15 & W | W << 4) * te >> 16 >> 4 & 15, g[y + 2 * q + 1] = 240 & se | Y;
        }
        y += j;
      }
    }
    function oe(g, y, k, Q, j, q, W, Y) {
      var te, se, ye = 255;
      for (se = 0; se < j; ++se) {
        for (te = 0; te < Q; ++te) {
          var Ie = g[y + te];
          q[W + 4 * te] = Ie, ye &= Ie;
        }
        y += k, W += Y;
      }
      return ye != 255;
    }
    function me(g, y, k, Q, j) {
      var q;
      for (q = 0; q < j; ++q) k[Q + q] = g[y + q] >> 8;
    }
    function Se() {
      vs = I, Mr = K, Rr = oe, fn = me;
    }
    function De(g, y, k) {
      F[g] = function(Q, j, q, W, Y, te, se, ye, Ie, Fe, _e, He, Ne, we, Be, Re, qe) {
        var Pe, ct = qe - 1 >> 1, nt = Y[te + 0] | se[ye + 0] << 16, It = Ie[Fe + 0] | _e[He + 0] << 16;
        e(Q != null);
        var st = 3 * nt + It + 131074 >> 2;
        for (y(Q[j + 0], 255 & st, st >> 16, Ne, we), q != null && (st = 3 * It + nt + 131074 >> 2, y(q[W + 0], 255 & st, st >> 16, Be, Re)), Pe = 1; Pe <= ct; ++Pe) {
          var Br = Y[te + Pe] | se[ye + Pe] << 16, Er = Ie[Fe + Pe] | _e[He + Pe] << 16, vr = nt + Br + It + Er + 524296, Ar = vr + 2 * (Br + It) >> 3;
          st = Ar + nt >> 1, nt = (vr = vr + 2 * (nt + Er) >> 3) + Br >> 1, y(Q[j + 2 * Pe - 1], 255 & st, st >> 16, Ne, we + (2 * Pe - 1) * k), y(Q[j + 2 * Pe - 0], 255 & nt, nt >> 16, Ne, we + (2 * Pe - 0) * k), q != null && (st = vr + It >> 1, nt = Ar + Er >> 1, y(q[W + 2 * Pe - 1], 255 & st, st >> 16, Be, Re + (2 * Pe - 1) * k), y(q[W + 2 * Pe + 0], 255 & nt, nt >> 16, Be, Re + (2 * Pe + 0) * k)), nt = Br, It = Er;
        }
        1 & qe || (st = 3 * nt + It + 131074 >> 2, y(Q[j + qe - 1], 255 & st, st >> 16, Ne, we + (qe - 1) * k), q != null && (st = 3 * It + nt + 131074 >> 2, y(q[W + qe - 1], 255 & st, st >> 16, Be, Re + (qe - 1) * k)));
      };
    }
    function Je() {
      ys[_h] = ak, ys[Eh] = wy, ys[gy] = ok, ys[Sh] = By, ys[Ih] = Cy, ys[vm] = _y, ys[my] = Ak, ys[bm] = wy, ys[ym] = By, ys[Fh] = Cy, ys[wm] = _y;
    }
    function At(g) {
      return g & ~lk ? 0 > g ? 0 : 255 : g >> Ey;
    }
    function _t(g, y) {
      return At((19077 * g >> 8) + (26149 * y >> 8) - 14234);
    }
    function Gt(g, y, k) {
      return At((19077 * g >> 8) - (6419 * y >> 8) - (13320 * k >> 8) + 8708);
    }
    function Kt(g, y) {
      return At((19077 * g >> 8) + (33050 * y >> 8) - 17685);
    }
    function dr(g, y, k, Q, j) {
      Q[j + 0] = _t(g, k), Q[j + 1] = Gt(g, y, k), Q[j + 2] = Kt(g, y);
    }
    function Xr(g, y, k, Q, j) {
      Q[j + 0] = Kt(g, y), Q[j + 1] = Gt(g, y, k), Q[j + 2] = _t(g, k);
    }
    function en(g, y, k, Q, j) {
      var q = Gt(g, y, k);
      y = q << 3 & 224 | Kt(g, y) >> 3, Q[j + 0] = 248 & _t(g, k) | q >> 5, Q[j + 1] = y;
    }
    function Sn(g, y, k, Q, j) {
      var q = 240 & Kt(g, y) | 15;
      Q[j + 0] = 240 & _t(g, k) | Gt(g, y, k) >> 4, Q[j + 1] = q;
    }
    function pi(g, y, k, Q, j) {
      Q[j + 0] = 255, dr(g, y, k, Q, j + 1);
    }
    function Hn(g, y, k, Q, j) {
      Xr(g, y, k, Q, j), Q[j + 3] = 255;
    }
    function $s(g, y, k, Q, j) {
      dr(g, y, k, Q, j), Q[j + 3] = 255;
    }
    function rs(g, y) {
      return 0 > g ? 0 : g > y ? y : g;
    }
    function ma(g, y, k) {
      F[g] = function(Q, j, q, W, Y, te, se, ye, Ie) {
        for (var Fe = ye + (-2 & Ie) * k; ye != Fe; ) y(Q[j + 0], q[W + 0], Y[te + 0], se, ye), y(Q[j + 1], q[W + 0], Y[te + 0], se, ye + k), j += 2, ++W, ++te, ye += 2 * k;
        1 & Ie && y(Q[j + 0], q[W + 0], Y[te + 0], se, ye);
      };
    }
    function mh(g, y, k) {
      return k == 0 ? g == 0 ? y == 0 ? 6 : 5 : y == 0 ? 4 : 0 : k;
    }
    function ic(g, y, k, Q, j) {
      switch (g >>> 30) {
        case 3:
          Ka(y, k, Q, j, 0);
          break;
        case 2:
          cn(y, k, Q, j);
          break;
        case 1:
          ki(y, k, Q, j);
      }
    }
    function sc(g, y) {
      var k, Q, j = y.M, q = y.Nb, W = g.oc, Y = g.pc + 40, te = g.oc, se = g.pc + 584, ye = g.oc, Ie = g.pc + 600;
      for (k = 0; 16 > k; ++k) W[Y + 32 * k - 1] = 129;
      for (k = 0; 8 > k; ++k) te[se + 32 * k - 1] = 129, ye[Ie + 32 * k - 1] = 129;
      for (0 < j ? W[Y - 1 - 32] = te[se - 1 - 32] = ye[Ie - 1 - 32] = 129 : (i(W, Y - 32 - 1, 127, 21), i(te, se - 32 - 1, 127, 9), i(ye, Ie - 32 - 1, 127, 9)), Q = 0; Q < g.za; ++Q) {
        var Fe = y.ya[y.aa + Q];
        if (0 < Q) {
          for (k = -1; 16 > k; ++k) n(W, Y + 32 * k - 4, W, Y + 32 * k + 12, 4);
          for (k = -1; 8 > k; ++k) n(te, se + 32 * k - 4, te, se + 32 * k + 4, 4), n(ye, Ie + 32 * k - 4, ye, Ie + 32 * k + 4, 4);
        }
        var _e = g.Gd, He = g.Hd + Q, Ne = Fe.ad, we = Fe.Hc;
        if (0 < j && (n(W, Y - 32, _e[He].y, 0, 16), n(te, se - 32, _e[He].f, 0, 8), n(ye, Ie - 32, _e[He].ea, 0, 8)), Fe.Za) {
          var Be = W, Re = Y - 32 + 16;
          for (0 < j && (Q >= g.za - 1 ? i(Be, Re, _e[He].y[15], 4) : n(Be, Re, _e[He + 1].y, 0, 4)), k = 0; 4 > k; k++) Be[Re + 128 + k] = Be[Re + 256 + k] = Be[Re + 384 + k] = Be[Re + 0 + k];
          for (k = 0; 16 > k; ++k, we <<= 2) Be = W, Re = Y + Iy[k], Vs[Fe.Ob[k]](Be, Re), ic(we, Ne, 16 * +k, Be, Re);
        } else if (Be = mh(Q, j, Fe.Ob[0]), Co[Be](W, Y), we != 0) for (k = 0; 16 > k; ++k, we <<= 2) ic(we, Ne, 16 * +k, W, Y + Iy[k]);
        for (k = Fe.Gc, Be = mh(Q, j, Fe.Dd), Va[Be](te, se), Va[Be](ye, Ie), we = Ne, Be = te, Re = se, 255 & (Fe = k >> 0) && (170 & Fe ? uc(we, 256, Be, Re) : gs(we, 256, Be, Re)), Fe = ye, we = Ie, 255 & (k >>= 8) && (170 & k ? uc(Ne, 320, Fe, we) : gs(Ne, 320, Fe, we)), j < g.Ub - 1 && (n(_e[He].y, 0, W, Y + 480, 16), n(_e[He].f, 0, te, se + 224, 8), n(_e[He].ea, 0, ye, Ie + 224, 8)), k = 8 * q * g.B, _e = g.sa, He = g.ta + 16 * Q + 16 * q * g.R, Ne = g.qa, Fe = g.ra + 8 * Q + k, we = g.Ha, Be = g.Ia + 8 * Q + k, k = 0; 16 > k; ++k) n(_e, He + k * g.R, W, Y + 32 * k, 16);
        for (k = 0; 8 > k; ++k) n(Ne, Fe + k * g.B, te, se + 32 * k, 8), n(we, Be + k * g.B, ye, Ie + 32 * k, 8);
      }
    }
    function Il(g, y, k, Q, j, q, W, Y, te) {
      var se = [0], ye = [0], Ie = 0, Fe = te != null ? te.kd : 0, _e = te ?? new ec();
      if (g == null || 12 > k) return 7;
      _e.data = g, _e.w = y, _e.ha = k, y = [y], k = [k], _e.gb = [_e.gb];
      e: {
        var He = y, Ne = k, we = _e.gb;
        if (e(g != null), e(Ne != null), e(we != null), we[0] = 0, 12 <= Ne[0] && !t(g, He[0], "RIFF")) {
          if (t(g, He[0] + 8, "WEBP")) {
            we = 3;
            break e;
          }
          var Be = Qe(g, He[0] + 4);
          if (12 > Be || 4294967286 < Be) {
            we = 3;
            break e;
          }
          if (Fe && Be > Ne[0] - 8) {
            we = 7;
            break e;
          }
          we[0] = Be, He[0] += 12, Ne[0] -= 12;
        }
        we = 0;
      }
      if (we != 0) return we;
      for (Be = 0 < _e.gb[0], k = k[0]; ; ) {
        e: {
          var Re = g;
          Ne = y, we = k;
          var qe = se, Pe = ye, ct = He = [0];
          if ((st = Ie = [Ie])[0] = 0, 8 > we[0]) we = 7;
          else {
            if (!t(Re, Ne[0], "VP8X")) {
              if (Qe(Re, Ne[0] + 4) != 10) {
                we = 3;
                break e;
              }
              if (18 > we[0]) {
                we = 7;
                break e;
              }
              var nt = Qe(Re, Ne[0] + 8), It = 1 + Ce(Re, Ne[0] + 12);
              if (2147483648 <= It * (Re = 1 + Ce(Re, Ne[0] + 15))) {
                we = 3;
                break e;
              }
              ct != null && (ct[0] = nt), qe != null && (qe[0] = It), Pe != null && (Pe[0] = Re), Ne[0] += 18, we[0] -= 18, st[0] = 1;
            }
            we = 0;
          }
        }
        if (Ie = Ie[0], He = He[0], we != 0) return we;
        if (Ne = !!(2 & He), !Be && Ie) return 3;
        if (q != null && (q[0] = !!(16 & He)), W != null && (W[0] = Ne), Y != null && (Y[0] = 0), W = se[0], He = ye[0], Ie && Ne && te == null) {
          we = 0;
          break;
        }
        if (4 > k) {
          we = 7;
          break;
        }
        if (Be && Ie || !Be && !Ie && !t(g, y[0], "ALPH")) {
          k = [k], _e.na = [_e.na], _e.P = [_e.P], _e.Sa = [_e.Sa];
          e: {
            nt = g, we = y, Be = k;
            var st = _e.gb;
            qe = _e.na, Pe = _e.P, ct = _e.Sa, It = 22, e(nt != null), e(Be != null), Re = we[0];
            var Br = Be[0];
            for (e(qe != null), e(ct != null), qe[0] = null, Pe[0] = null, ct[0] = 0; ; ) {
              if (we[0] = Re, Be[0] = Br, 8 > Br) {
                we = 7;
                break e;
              }
              var Er = Qe(nt, Re + 4);
              if (4294967286 < Er) {
                we = 3;
                break e;
              }
              var vr = 8 + Er + 1 & -2;
              if (It += vr, 0 < st && It > st) {
                we = 3;
                break e;
              }
              if (!t(nt, Re, "VP8 ") || !t(nt, Re, "VP8L")) {
                we = 0;
                break e;
              }
              if (Br[0] < vr) {
                we = 7;
                break e;
              }
              t(nt, Re, "ALPH") || (qe[0] = nt, Pe[0] = Re + 8, ct[0] = Er), Re += vr, Br -= vr;
            }
          }
          if (k = k[0], _e.na = _e.na[0], _e.P = _e.P[0], _e.Sa = _e.Sa[0], we != 0) break;
        }
        k = [k], _e.Ja = [_e.Ja], _e.xa = [_e.xa];
        e: if (st = g, we = y, Be = k, qe = _e.gb[0], Pe = _e.Ja, ct = _e.xa, nt = we[0], Re = !t(st, nt, "VP8 "), It = !t(st, nt, "VP8L"), e(st != null), e(Be != null), e(Pe != null), e(ct != null), 8 > Be[0]) we = 7;
        else {
          if (Re || It) {
            if (st = Qe(st, nt + 4), 12 <= qe && st > qe - 12) {
              we = 3;
              break e;
            }
            if (Fe && st > Be[0] - 8) {
              we = 7;
              break e;
            }
            Pe[0] = st, we[0] += 8, Be[0] -= 8, ct[0] = It;
          } else ct[0] = 5 <= Be[0] && st[nt + 0] == 47 && !(st[nt + 4] >> 5), Pe[0] = Be[0];
          we = 0;
        }
        if (k = k[0], _e.Ja = _e.Ja[0], _e.xa = _e.xa[0], y = y[0], we != 0) break;
        if (4294967286 < _e.Ja) return 3;
        if (Y == null || Ne || (Y[0] = _e.xa ? 2 : 1), W = [W], He = [He], _e.xa) {
          if (5 > k) {
            we = 7;
            break;
          }
          Y = W, Fe = He, Ne = q, g == null || 5 > k ? g = 0 : 5 <= k && g[y + 0] == 47 && !(g[y + 4] >> 5) ? (Be = [0], st = [0], qe = [0], V(Pe = new U(), g, y, k), Ct(Pe, Be, st, qe) ? (Y != null && (Y[0] = Be[0]), Fe != null && (Fe[0] = st[0]), Ne != null && (Ne[0] = qe[0]), g = 1) : g = 0) : g = 0;
        } else {
          if (10 > k) {
            we = 7;
            break;
          }
          Y = He, g == null || 10 > k || !th(g, y + 3, k - 3) ? g = 0 : (Fe = g[y + 0] | g[y + 1] << 8 | g[y + 2] << 16, Ne = 16383 & (g[y + 7] << 8 | g[y + 6]), g = 16383 & (g[y + 9] << 8 | g[y + 8]), 1 & Fe || 3 < (Fe >> 1 & 7) || !(Fe >> 4 & 1) || Fe >> 5 >= _e.Ja || !Ne || !g ? g = 0 : (W && (W[0] = Ne), Y && (Y[0] = g), g = 1));
        }
        if (!g || (W = W[0], He = He[0], Ie && (se[0] != W || ye[0] != He))) return 3;
        te != null && (te[0] = _e, te.offset = y - te.w, e(4294967286 > y - te.w), e(te.offset == te.ha - k));
        break;
      }
      return we == 0 || we == 7 && Ie && te == null ? (q != null && (q[0] |= _e.na != null && 0 < _e.na.length), Q != null && (Q[0] = W), j != null && (j[0] = He), 0) : we;
    }
    function ac(g, y, k) {
      var Q = y.width, j = y.height, q = 0, W = 0, Y = Q, te = j;
      if (y.Da = g != null && 0 < g.Da, y.Da && (Y = g.cd, te = g.bd, q = g.v, W = g.j, 11 > k || (q &= -2, W &= -2), 0 > q || 0 > W || 0 >= Y || 0 >= te || q + Y > Q || W + te > j)) return 0;
      if (y.v = q, y.j = W, y.va = q + Y, y.o = W + te, y.U = Y, y.T = te, y.da = g != null && 0 < g.da, y.da) {
        if (!ne(Y, te, k = [g.ib], q = [g.hb])) return 0;
        y.ib = k[0], y.hb = q[0];
      }
      return y.ob = g != null && g.ob, y.Kb = g == null || !g.Sd, y.da && (y.ob = y.ib < 3 * Q / 4 && y.hb < 3 * j / 4, y.Kb = 0), 1;
    }
    function oc(g) {
      if (g == null) return 2;
      if (11 > g.S) {
        var y = g.f.RGBA;
        y.fb += (g.height - 1) * y.A, y.A = -y.A;
      } else y = g.f.kb, g = g.height, y.O += (g - 1) * y.fa, y.fa = -y.fa, y.N += (g - 1 >> 1) * y.Ab, y.Ab = -y.Ab, y.W += (g - 1 >> 1) * y.Db, y.Db = -y.Db, y.F != null && (y.J += (g - 1) * y.lb, y.lb = -y.lb);
      return 0;
    }
    function Fl(g, y, k, Q) {
      if (Q == null || 0 >= g || 0 >= y) return 2;
      if (k != null) {
        if (k.Da) {
          var j = k.cd, q = k.bd, W = -2 & k.v, Y = -2 & k.j;
          if (0 > W || 0 > Y || 0 >= j || 0 >= q || W + j > g || Y + q > y) return 2;
          g = j, y = q;
        }
        if (k.da) {
          if (!ne(g, y, j = [k.ib], q = [k.hb])) return 2;
          g = j[0], y = q[0];
        }
      }
      Q.width = g, Q.height = y;
      e: {
        var te = Q.width, se = Q.height;
        if (g = Q.S, 0 >= te || 0 >= se || !(g >= _h && 13 > g)) g = 2;
        else {
          if (0 >= Q.Rd && Q.sd == null) {
            W = q = j = y = 0;
            var ye = (Y = te * Fy[g]) * se;
            if (11 > g || (q = (se + 1) / 2 * (y = (te + 1) / 2), g == 12 && (W = (j = te) * se)), (se = s(ye + 2 * q + W)) == null) {
              g = 1;
              break e;
            }
            Q.sd = se, 11 > g ? ((te = Q.f.RGBA).eb = se, te.fb = 0, te.A = Y, te.size = ye) : ((te = Q.f.kb).y = se, te.O = 0, te.fa = Y, te.Fd = ye, te.f = se, te.N = 0 + ye, te.Ab = y, te.Cd = q, te.ea = se, te.W = 0 + ye + q, te.Db = y, te.Ed = q, g == 12 && (te.F = se, te.J = 0 + ye + 2 * q), te.Tc = W, te.lb = j);
          }
          if (y = 1, j = Q.S, q = Q.width, W = Q.height, j >= _h && 13 > j) if (11 > j) g = Q.f.RGBA, y &= (Y = Math.abs(g.A)) * (W - 1) + q <= g.size, y &= Y >= q * Fy[j], y &= g.eb != null;
          else {
            g = Q.f.kb, Y = (q + 1) / 2, ye = (W + 1) / 2, te = Math.abs(g.fa), se = Math.abs(g.Ab);
            var Ie = Math.abs(g.Db), Fe = Math.abs(g.lb), _e = Fe * (W - 1) + q;
            y &= te * (W - 1) + q <= g.Fd, y &= se * (ye - 1) + Y <= g.Cd, y = (y &= Ie * (ye - 1) + Y <= g.Ed) & te >= q & se >= Y & Ie >= Y, y &= g.y != null, y &= g.f != null, y &= g.ea != null, j == 12 && (y &= Fe >= q, y &= _e <= g.Tc, y &= g.F != null);
          }
          else y = 0;
          g = y ? 0 : 2;
        }
      }
      return g != 0 || k != null && k.fd && (g = oc(Q)), g;
    }
    var ei = 64, Tl = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], xl = 24, kl = 32, Ac = 8, Vi = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    re("Predictor0", "PredictorAdd0"), F.Predictor0 = function() {
      return 4278190080;
    }, F.Predictor1 = function(g) {
      return g;
    }, F.Predictor2 = function(g, y, k) {
      return y[k + 0];
    }, F.Predictor3 = function(g, y, k) {
      return y[k + 1];
    }, F.Predictor4 = function(g, y, k) {
      return y[k - 1];
    }, F.Predictor5 = function(g, y, k) {
      return le(le(g, y[k + 1]), y[k + 0]);
    }, F.Predictor6 = function(g, y, k) {
      return le(g, y[k - 1]);
    }, F.Predictor7 = function(g, y, k) {
      return le(g, y[k + 0]);
    }, F.Predictor8 = function(g, y, k) {
      return le(y[k - 1], y[k + 0]);
    }, F.Predictor9 = function(g, y, k) {
      return le(y[k + 0], y[k + 1]);
    }, F.Predictor10 = function(g, y, k) {
      return le(le(g, y[k - 1]), le(y[k + 0], y[k + 1]));
    }, F.Predictor11 = function(g, y, k) {
      var Q = y[k + 0];
      return 0 >= Ue(Q >> 24 & 255, g >> 24 & 255, (y = y[k - 1]) >> 24 & 255) + Ue(Q >> 16 & 255, g >> 16 & 255, y >> 16 & 255) + Ue(Q >> 8 & 255, g >> 8 & 255, y >> 8 & 255) + Ue(255 & Q, 255 & g, 255 & y) ? Q : g;
    }, F.Predictor12 = function(g, y, k) {
      var Q = y[k + 0];
      return (Te((g >> 24 & 255) + (Q >> 24 & 255) - ((y = y[k - 1]) >> 24 & 255)) << 24 | Te((g >> 16 & 255) + (Q >> 16 & 255) - (y >> 16 & 255)) << 16 | Te((g >> 8 & 255) + (Q >> 8 & 255) - (y >> 8 & 255)) << 8 | Te((255 & g) + (255 & Q) - (255 & y))) >>> 0;
    }, F.Predictor13 = function(g, y, k) {
      var Q = y[k - 1];
      return (Oe((g = le(g, y[k + 0])) >> 24 & 255, Q >> 24 & 255) << 24 | Oe(g >> 16 & 255, Q >> 16 & 255) << 16 | Oe(g >> 8 & 255, Q >> 8 & 255) << 8 | Oe(g >> 0 & 255, Q >> 0 & 255)) >>> 0;
    };
    var gm = F.PredictorAdd0;
    F.PredictorAdd1 = Ge, re("Predictor2", "PredictorAdd2"), re("Predictor3", "PredictorAdd3"), re("Predictor4", "PredictorAdd4"), re("Predictor5", "PredictorAdd5"), re("Predictor6", "PredictorAdd6"), re("Predictor7", "PredictorAdd7"), re("Predictor8", "PredictorAdd8"), re("Predictor9", "PredictorAdd9"), re("Predictor10", "PredictorAdd10"), re("Predictor11", "PredictorAdd11"), re("Predictor12", "PredictorAdd12"), re("Predictor13", "PredictorAdd13");
    var lc = F.PredictorAdd2;
    St("ColorIndexInverseTransform", "MapARGB", "32b", function(g) {
      return g >> 8 & 255;
    }, function(g) {
      return g;
    }), St("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(g) {
      return g;
    }, function(g) {
      return g >> 8 & 255;
    });
    var vh, ps = F.ColorIndexInverseTransform, Ll = F.MapARGB, bh = F.VP8LColorIndexInverseTransformAlpha, yh = F.MapAlpha, bo = F.VP8LPredictorsAdd = [];
    bo.length = 16, (F.VP8LPredictors = []).length = 16, (F.VP8LPredictorsAdd_C = []).length = 16, (F.VP8LPredictors_C = []).length = 16;
    var yA, zi, xi, yo, Ha, ja, Ul, Ka, cn, uc, ki, gs, Nl, wh, cc, wA, BA, wo, CA, Ol, _A, Bo, fc, ms, vs, Mr, Rr, fn, On = s(511), $a = s(2041), hc = s(225), Ql = s(767), Bh = 0, mm = $a, Ch = hc, ns = Ql, bs = On, _h = 0, Eh = 1, gy = 2, Sh = 3, Ih = 4, vm = 5, my = 6, bm = 7, ym = 8, Fh = 9, wm = 10, zx = [2, 3, 7], Gx = [3, 3, 11], vy = [280, 256, 256, 256, 40], qx = [0, 1, 1, 1, 0], Wx = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], Xx = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Jx = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], Yx = 8, Bm = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], Cm = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], dc = null, Zx = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], ek = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], by = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], tk = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], rk = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], nk = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], ik = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], Co = [], Vs = [], Va = [], sk = 1, yy = 2, _o = [], ys = [];
    De("UpsampleRgbLinePair", dr, 3), De("UpsampleBgrLinePair", Xr, 3), De("UpsampleRgbaLinePair", $s, 4), De("UpsampleBgraLinePair", Hn, 4), De("UpsampleArgbLinePair", pi, 4), De("UpsampleRgba4444LinePair", Sn, 2), De("UpsampleRgb565LinePair", en, 2);
    var ak = F.UpsampleRgbLinePair, ok = F.UpsampleBgrLinePair, wy = F.UpsampleRgbaLinePair, By = F.UpsampleBgraLinePair, Cy = F.UpsampleArgbLinePair, _y = F.UpsampleRgba4444LinePair, Ak = F.UpsampleRgb565LinePair, Th = 16, xh = 1 << Th - 1, pc = -227, _m = 482, Ey = 6, lk = (256 << Ey) - 1, Sy = 0, uk = s(256), ck = s(256), fk = s(256), hk = s(256), dk = s(_m - pc), pk = s(_m - pc);
    ma("YuvToRgbRow", dr, 3), ma("YuvToBgrRow", Xr, 3), ma("YuvToRgbaRow", $s, 4), ma("YuvToBgraRow", Hn, 4), ma("YuvToArgbRow", pi, 4), ma("YuvToRgba4444Row", Sn, 2), ma("YuvToRgb565Row", en, 2);
    var Iy = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], kh = [0, 2, 8], gk = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], mk = 1;
    this.WebPDecodeRGBA = function(g, y, k, Q, j) {
      var q = Eh, W = new El(), Y = new Ir();
      W.ba = Y, Y.S = q, Y.width = [Y.width], Y.height = [Y.height];
      var te = Y.width, se = Y.height, ye = new hr();
      if (ye == null || g == null) var Ie = 2;
      else e(ye != null), Ie = Il(g, y, k, ye.width, ye.height, ye.Pd, ye.Qd, ye.format, null);
      if (Ie != 0 ? te = 0 : (te != null && (te[0] = ye.width[0]), se != null && (se[0] = ye.height[0]), te = 1), te) {
        Y.width = Y.width[0], Y.height = Y.height[0], Q != null && (Q[0] = Y.width), j != null && (j[0] = Y.height);
        e: {
          if (Q = new vl(), (j = new ec()).data = g, j.w = y, j.ha = k, j.kd = 1, y = [0], e(j != null), ((g = Il(j.data, j.w, j.ha, null, null, null, y, null, j)) == 0 || g == 7) && y[0] && (g = 4), (y = g) == 0) {
            if (e(W != null), Q.data = j.data, Q.w = j.w + j.offset, Q.ha = j.ha - j.offset, Q.put = fi, Q.ac = Yr, Q.bc = Fi, Q.ma = W, j.xa) {
              if ((g = or()) == null) {
                W = 1;
                break e;
              }
              if (function(Fe, _e) {
                var He = [0], Ne = [0], we = [0];
                t: for (; ; ) {
                  if (Fe == null) return 0;
                  if (_e == null) return Fe.a = 2, 0;
                  if (Fe.l = _e, Fe.a = 0, V(Fe.m, _e.data, _e.w, _e.ha), !Ct(Fe.m, He, Ne, we)) {
                    Fe.a = 3;
                    break t;
                  }
                  if (Fe.xb = yy, _e.width = He[0], _e.height = Ne[0], !hi(He[0], Ne[0], 1, Fe, null)) break t;
                  return 1;
                }
                return e(Fe.a != 0), 0;
              }(g, Q)) {
                if (Q = (y = Fl(Q.width, Q.height, W.Oa, W.ba)) == 0) {
                  t: {
                    Q = g;
                    r: for (; ; ) {
                      if (Q == null) {
                        Q = 0;
                        break t;
                      }
                      if (e(Q.s.yc != null), e(Q.s.Ya != null), e(0 < Q.s.Wb), e((k = Q.l) != null), e((j = k.ma) != null), Q.xb != 0) {
                        if (Q.ca = j.ba, Q.tb = j.tb, e(Q.ca != null), !ac(j.Oa, k, Sh)) {
                          Q.a = 2;
                          break r;
                        }
                        if (!hs(Q, k.width) || k.da) break r;
                        if ((k.da || Xt(Q.ca.S)) && Se(), 11 > Q.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), Q.ca.f.kb.F != null && Se()), Q.Pb && 0 < Q.s.ua && Q.s.vb.X == null && !M(Q.s.vb, Q.s.Wa.Xa)) {
                          Q.a = 1;
                          break r;
                        }
                        Q.xb = 0;
                      }
                      if (!qr(Q, Q.V, Q.Ba, Q.c, Q.i, k.o, Ps)) break r;
                      j.Dc = Q.Ma, Q = 1;
                      break t;
                    }
                    e(Q.a != 0), Q = 0;
                  }
                  Q = !Q;
                }
                Q && (y = g.a);
              } else y = g.a;
            } else {
              if ((g = new Jg()) == null) {
                W = 1;
                break e;
              }
              if (g.Fa = j.na, g.P = j.P, g.qc = j.Sa, rh(g, Q)) {
                if ((y = Fl(Q.width, Q.height, W.Oa, W.ba)) == 0) {
                  if (g.Aa = 0, k = W.Oa, e((j = g) != null), k != null) {
                    if (0 < (te = 0 > (te = k.Md) ? 0 : 100 < te ? 255 : 255 * te / 100)) {
                      for (se = ye = 0; 4 > se; ++se) 12 > (Ie = j.pb[se]).lc && (Ie.ia = te * gk[0 > Ie.lc ? 0 : Ie.lc] >> 3), ye |= Ie.ia;
                      ye && (alert("todo:VP8InitRandom"), j.ia = 1);
                    }
                    j.Ga = k.Id, 100 < j.Ga ? j.Ga = 100 : 0 > j.Ga && (j.Ga = 0);
                  }
                  Yg(g, Q) || (y = g.a);
                }
              } else y = g.a;
            }
            y == 0 && W.Oa != null && W.Oa.fd && (y = oc(W.ba));
          }
          W = y;
        }
        q = W != 0 ? null : 11 > q ? Y.f.RGBA.eb : Y.f.kb.y;
      } else q = null;
      return q;
    };
    var Fy = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function l(F, N) {
    for (var D = "", T = 0; T < 4; T++) D += String.fromCharCode(F[N++]);
    return D;
  }
  function u(F, N) {
    return (F[N + 0] << 0 | F[N + 1] << 8 | F[N + 2] << 16) >>> 0;
  }
  function c(F, N) {
    return (F[N + 0] << 0 | F[N + 1] << 8 | F[N + 2] << 16 | F[N + 3] << 24) >>> 0;
  }
  new A();
  var h = [0], f = [0], d = [], p = new A(), v = r, m = function(F, N) {
    var D = {}, T = 0, E = !1, L = 0, S = 0;
    if (D.frames = [], !/** @license
       * Copyright (c) 2017 Dominik Homberger
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      https://webpjs.appspot.com
      WebPRiffParser dominikhlbg@gmail.com
      */
    function(P, H, $, ie) {
      for (var ue = 0; ue < ie; ue++) if (P[H + ue] != $.charCodeAt(ue)) return !0;
      return !1;
    }(F, N, "RIFF", 4)) {
      var X, z;
      for (c(F, N += 4), N += 8; N < F.length; ) {
        var R = l(F, N), V = c(F, N += 4);
        N += 4;
        var O = V + (1 & V);
        switch (R) {
          case "VP8 ":
          case "VP8L":
            D.frames[T] === void 0 && (D.frames[T] = {}), (U = D.frames[T]).src_off = E ? S : N - 8, U.src_size = L + V + 8, T++, E && (E = !1, L = 0, S = 0);
            break;
          case "VP8X":
            (U = D.header = {}).feature_flags = F[N];
            var J = N + 4;
            U.canvas_width = 1 + u(F, J), J += 3, U.canvas_height = 1 + u(F, J), J += 3;
            break;
          case "ALPH":
            E = !0, L = O + 8, S = N - 8;
            break;
          case "ANIM":
            (U = D.header).bgcolor = c(F, N), J = N + 4, U.loop_count = (X = F)[(z = J) + 0] << 0 | X[z + 1] << 8, J += 2;
            break;
          case "ANMF":
            var Z, U;
            (U = D.frames[T] = {}).offset_x = 2 * u(F, N), N += 3, U.offset_y = 2 * u(F, N), N += 3, U.width = 1 + u(F, N), N += 3, U.height = 1 + u(F, N), N += 3, U.duration = u(F, N), N += 3, Z = F[N++], U.dispose = 1 & Z, U.blend = Z >> 1 & 1;
        }
        R != "ANMF" && (N += O);
      }
      return D;
    }
  }(v, 0);
  m.response = v, m.rgbaoutput = !0, m.dataurl = !1;
  var b = m.header ? m.header : null, w = m.frames ? m.frames : null;
  if (b) {
    b.loop_counter = b.loop_count, h = [b.canvas_height], f = [b.canvas_width];
    for (var B = 0; B < w.length && w[B].blend != 0; B++) ;
  }
  var _ = w[0], x = p.WebPDecodeRGBA(v, _.src_off, _.src_size, f, h);
  _.rgba = x, _.imgwidth = f[0], _.imgheight = h[0];
  for (var C = 0; C < f[0] * h[0] * 4; C++) d[C] = x[C];
  return this.width = f, this.height = h, this.data = d, this;
}
(function(r) {
  var e = function() {
    return typeof vv == "function";
  }, t = function(h, f, d, p) {
    var v = 4, m = a;
    switch (p) {
      case r.image_compression.FAST:
        v = 1, m = s;
        break;
      case r.image_compression.MEDIUM:
        v = 6, m = o;
        break;
      case r.image_compression.SLOW:
        v = 9, m = A;
    }
    h = n(h, f, d, m);
    var b = vv(h, { level: v });
    return r.__addimage__.arrayBufferToBinaryString(b);
  }, n = function(h, f, d, p) {
    for (var v, m, b, w = h.length / f, B = new Uint8Array(h.length + w), _ = u(), x = 0; x < w; x += 1) {
      if (b = x * f, v = h.subarray(b, b + f), p) B.set(p(v, d, m), b + x);
      else {
        for (var C, F = _.length, N = []; C < F; C += 1) N[C] = _[C](v, d, m);
        var D = c(N.concat());
        B.set(N[D], b + x);
      }
      m = v;
    }
    return B;
  }, i = function(h) {
    var f = Array.apply([], h);
    return f.unshift(0), f;
  }, s = function(h, f) {
    var d, p = [], v = h.length;
    p[0] = 1;
    for (var m = 0; m < v; m += 1) d = h[m - f] || 0, p[m + 1] = h[m] - d + 256 & 255;
    return p;
  }, a = function(h, f, d) {
    var p, v = [], m = h.length;
    v[0] = 2;
    for (var b = 0; b < m; b += 1) p = d && d[b] || 0, v[b + 1] = h[b] - p + 256 & 255;
    return v;
  }, o = function(h, f, d) {
    var p, v, m = [], b = h.length;
    m[0] = 3;
    for (var w = 0; w < b; w += 1) p = h[w - f] || 0, v = d && d[w] || 0, m[w + 1] = h[w] + 256 - (p + v >>> 1) & 255;
    return m;
  }, A = function(h, f, d) {
    var p, v, m, b, w = [], B = h.length;
    w[0] = 4;
    for (var _ = 0; _ < B; _ += 1) p = h[_ - f] || 0, v = d && d[_] || 0, m = d && d[_ - f] || 0, b = l(p, v, m), w[_ + 1] = h[_] - b + 256 & 255;
    return w;
  }, l = function(h, f, d) {
    if (h === f && f === d) return h;
    var p = Math.abs(f - d), v = Math.abs(h - d), m = Math.abs(h + f - d - d);
    return p <= v && p <= m ? h : v <= m ? f : d;
  }, u = function() {
    return [i, s, a, o, A];
  }, c = function(h) {
    var f = h.map(function(d) {
      return d.reduce(function(p, v) {
        return p + Math.abs(v);
      }, 0);
    });
    return f.indexOf(Math.min.apply(null, f));
  };
  r.processPNG = function(h, f, d, p) {
    var v, m, b, w, B, _, x, C, F, N, D, T, E, L, S, X = this.decode.FLATE_DECODE, z = "";
    if (this.__addimage__.isArrayBuffer(h) && (h = new Uint8Array(h)), this.__addimage__.isArrayBufferView(h)) {
      if (h = (b = new wP(h)).imgData, m = b.bits, v = b.colorSpace, B = b.colors, [4, 6].indexOf(b.colorType) !== -1) {
        if (b.bits === 8) {
          F = (C = b.pixelBitlength == 32 ? new Uint32Array(b.decodePixels().buffer) : b.pixelBitlength == 16 ? new Uint16Array(b.decodePixels().buffer) : new Uint8Array(b.decodePixels().buffer)).length, D = new Uint8Array(F * b.colors), N = new Uint8Array(F);
          var R, V = b.pixelBitlength - b.bits;
          for (L = 0, S = 0; L < F; L++) {
            for (E = C[L], R = 0; R < V; ) D[S++] = E >>> R & 255, R += b.bits;
            N[L] = E >>> R & 255;
          }
        }
        if (b.bits === 16) {
          F = (C = new Uint32Array(b.decodePixels().buffer)).length, D = new Uint8Array(F * (32 / b.pixelBitlength) * b.colors), N = new Uint8Array(F * (32 / b.pixelBitlength)), T = b.colors > 1, L = 0, S = 0;
          for (var O = 0; L < F; ) E = C[L++], D[S++] = E >>> 0 & 255, T && (D[S++] = E >>> 16 & 255, E = C[L++], D[S++] = E >>> 0 & 255), N[O++] = E >>> 16 & 255;
          m = 8;
        }
        p !== r.image_compression.NONE && e() ? (h = t(D, b.width * b.colors, b.colors, p), x = t(N, b.width, 1, p)) : (h = D, x = N, X = void 0);
      }
      if (b.colorType === 3 && (v = this.color_spaces.INDEXED, _ = b.palette, b.transparency.indexed)) {
        var J = b.transparency.indexed, Z = 0;
        for (L = 0, F = J.length; L < F; ++L) Z += J[L];
        if ((Z /= 255) === F - 1 && J.indexOf(0) !== -1) w = [J.indexOf(0)];
        else if (Z !== F) {
          for (C = b.decodePixels(), N = new Uint8Array(C.length), L = 0, F = C.length; L < F; L++) N[L] = J[C[L]];
          x = t(N, b.width, 1);
        }
      }
      var U = function(P) {
        var H;
        switch (P) {
          case r.image_compression.FAST:
            H = 11;
            break;
          case r.image_compression.MEDIUM:
            H = 13;
            break;
          case r.image_compression.SLOW:
            H = 14;
            break;
          default:
            H = 12;
        }
        return H;
      }(p);
      return X === this.decode.FLATE_DECODE && (z = "/Predictor " + U + " "), z += "/Colors " + B + " /BitsPerComponent " + m + " /Columns " + b.width, (this.__addimage__.isArrayBuffer(h) || this.__addimage__.isArrayBufferView(h)) && (h = this.__addimage__.arrayBufferToBinaryString(h)), (x && this.__addimage__.isArrayBuffer(x) || this.__addimage__.isArrayBufferView(x)) && (x = this.__addimage__.arrayBufferToBinaryString(x)), { alias: d, data: h, index: f, filter: X, decodeParameters: z, transparency: w, palette: _, sMask: x, predictor: U, width: b.width, height: b.height, bitsPerComponent: m, colorSpace: v };
    }
  };
})(Ft.API), function(r) {
  r.processGIF89A = function(e, t, n, i) {
    var s = new BP(e), a = s.width, o = s.height, A = [];
    s.decodeAndBlitFrameRGBA(0, A);
    var l = { data: A, width: a, height: o }, u = new d0(100).encode(l, 100);
    return r.processJPEG.call(this, u, t, n, i);
  }, r.processGIF87A = r.processGIF89A;
}(Ft.API), qs.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var r = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(r);
    for (var e = 0; e < r; e++) {
      var t = this.datav.getUint8(this.pos++, !0), n = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0);
      this.palette[e] = { red: i, green: n, blue: t, quad: s };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, qs.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var r = "bit" + this.bitPP, e = this.width * this.height * 4;
    this.data = new Uint8Array(e), this[r]();
  } catch (t) {
    Lr.log("bit decode error:" + t);
  }
}, qs.prototype.bit1 = function() {
  var r, e = Math.ceil(this.width / 8), t = e % 4;
  for (r = this.height - 1; r >= 0; r--) {
    for (var n = this.bottom_up ? r : this.height - 1 - r, i = 0; i < e; i++) for (var s = this.datav.getUint8(this.pos++, !0), a = n * this.width * 4 + 8 * i * 4, o = 0; o < 8 && 8 * i + o < this.width; o++) {
      var A = this.palette[s >> 7 - o & 1];
      this.data[a + 4 * o] = A.blue, this.data[a + 4 * o + 1] = A.green, this.data[a + 4 * o + 2] = A.red, this.data[a + 4 * o + 3] = 255;
    }
    t !== 0 && (this.pos += 4 - t);
  }
}, qs.prototype.bit4 = function() {
  for (var r = Math.ceil(this.width / 2), e = r % 4, t = this.height - 1; t >= 0; t--) {
    for (var n = this.bottom_up ? t : this.height - 1 - t, i = 0; i < r; i++) {
      var s = this.datav.getUint8(this.pos++, !0), a = n * this.width * 4 + 2 * i * 4, o = s >> 4, A = 15 & s, l = this.palette[o];
      if (this.data[a] = l.blue, this.data[a + 1] = l.green, this.data[a + 2] = l.red, this.data[a + 3] = 255, 2 * i + 1 >= this.width) break;
      l = this.palette[A], this.data[a + 4] = l.blue, this.data[a + 4 + 1] = l.green, this.data[a + 4 + 2] = l.red, this.data[a + 4 + 3] = 255;
    }
    e !== 0 && (this.pos += 4 - e);
  }
}, qs.prototype.bit8 = function() {
  for (var r = this.width % 4, e = this.height - 1; e >= 0; e--) {
    for (var t = this.bottom_up ? e : this.height - 1 - e, n = 0; n < this.width; n++) {
      var i = this.datav.getUint8(this.pos++, !0), s = t * this.width * 4 + 4 * n;
      if (i < this.palette.length) {
        var a = this.palette[i];
        this.data[s] = a.red, this.data[s + 1] = a.green, this.data[s + 2] = a.blue, this.data[s + 3] = 255;
      } else this.data[s] = 255, this.data[s + 1] = 255, this.data[s + 2] = 255, this.data[s + 3] = 255;
    }
    r !== 0 && (this.pos += 4 - r);
  }
}, qs.prototype.bit15 = function() {
  for (var r = this.width % 3, e = parseInt("11111", 2), t = this.height - 1; t >= 0; t--) {
    for (var n = this.bottom_up ? t : this.height - 1 - t, i = 0; i < this.width; i++) {
      var s = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var a = (s & e) / e * 255 | 0, o = (s >> 5 & e) / e * 255 | 0, A = (s >> 10 & e) / e * 255 | 0, l = s >> 15 ? 255 : 0, u = n * this.width * 4 + 4 * i;
      this.data[u] = A, this.data[u + 1] = o, this.data[u + 2] = a, this.data[u + 3] = l;
    }
    this.pos += r;
  }
}, qs.prototype.bit16 = function() {
  for (var r = this.width % 3, e = parseInt("11111", 2), t = parseInt("111111", 2), n = this.height - 1; n >= 0; n--) {
    for (var i = this.bottom_up ? n : this.height - 1 - n, s = 0; s < this.width; s++) {
      var a = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var o = (a & e) / e * 255 | 0, A = (a >> 5 & t) / t * 255 | 0, l = (a >> 11) / e * 255 | 0, u = i * this.width * 4 + 4 * s;
      this.data[u] = l, this.data[u + 1] = A, this.data[u + 2] = o, this.data[u + 3] = 255;
    }
    this.pos += r;
  }
}, qs.prototype.bit24 = function() {
  for (var r = this.height - 1; r >= 0; r--) {
    for (var e = this.bottom_up ? r : this.height - 1 - r, t = 0; t < this.width; t++) {
      var n = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), a = e * this.width * 4 + 4 * t;
      this.data[a] = s, this.data[a + 1] = i, this.data[a + 2] = n, this.data[a + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, qs.prototype.bit32 = function() {
  for (var r = this.height - 1; r >= 0; r--) for (var e = this.bottom_up ? r : this.height - 1 - r, t = 0; t < this.width; t++) {
    var n = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), a = this.datav.getUint8(this.pos++, !0), o = e * this.width * 4 + 4 * t;
    this.data[o] = s, this.data[o + 1] = i, this.data[o + 2] = n, this.data[o + 3] = a;
  }
}, qs.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2018 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(r) {
  r.processBMP = function(e, t, n, i) {
    var s = new qs(e, !1), a = s.width, o = s.height, A = { data: s.getData(), width: a, height: o }, l = new d0(100).encode(A, 100);
    return r.processJPEG.call(this, l, t, n, i);
  };
}(Ft.API), e5.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2019 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(r) {
  r.processWEBP = function(e, t, n, i) {
    var s = new e5(e), a = s.width, o = s.height, A = { data: s.getData(), width: a, height: o }, l = new d0(100).encode(A, 100);
    return r.processJPEG.call(this, l, t, n, i);
  };
}(Ft.API), Ft.API.processRGBA = function(r, e, t) {
  for (var n = r.data, i = n.length, s = new Uint8Array(i / 4 * 3), a = new Uint8Array(i / 4), o = 0, A = 0, l = 0; l < i; l += 4) {
    var u = n[l], c = n[l + 1], h = n[l + 2], f = n[l + 3];
    s[o++] = u, s[o++] = c, s[o++] = h, a[A++] = f;
  }
  var d = this.__addimage__.arrayBufferToBinaryString(s);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(a), data: d, index: e, alias: t, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: r.width, height: r.height };
}, Ft.API.setLanguage = function(r) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[r] !== void 0 && (this.internal.languageSettings.languageCode = r, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = !0)), this;
}, zl = Ft.API, ad = zl.getCharWidthsArray = function(r, e) {
  var t, n, i = (e = e || {}).font || this.internal.getFont(), s = e.fontSize || this.internal.getFontSize(), a = e.charSpace || this.internal.getCharSpace(), o = e.widths ? e.widths : i.metadata.Unicode.widths, A = o.fof ? o.fof : 1, l = e.kerning ? e.kerning : i.metadata.Unicode.kerning, u = l.fof ? l.fof : 1, c = e.doKerning !== !1, h = 0, f = r.length, d = 0, p = o[0] || A, v = [];
  for (t = 0; t < f; t++) n = r.charCodeAt(t), typeof i.metadata.widthOfString == "function" ? v.push((i.metadata.widthOfGlyph(i.metadata.characterToGlyph(n)) + a * (1e3 / s) || 0) / 1e3) : (h = c && br(l[n]) === "object" && !isNaN(parseInt(l[n][d], 10)) ? l[n][d] / u : 0, v.push((o[n] || p) / A + h)), d = n;
  return v;
}, XB = zl.getStringUnitWidth = function(r, e) {
  var t = (e = e || {}).fontSize || this.internal.getFontSize(), n = e.font || this.internal.getFont(), i = e.charSpace || this.internal.getCharSpace();
  return zl.processArabic && (r = zl.processArabic(r)), typeof n.metadata.widthOfString == "function" ? n.metadata.widthOfString(r, t, i) / t : ad.apply(this, arguments).reduce(function(s, a) {
    return s + a;
  }, 0);
}, JB = function(r, e, t, n) {
  for (var i = [], s = 0, a = r.length, o = 0; s !== a && o + e[s] < t; ) o += e[s], s++;
  i.push(r.slice(0, s));
  var A = s;
  for (o = 0; s !== a; ) o + e[s] > n && (i.push(r.slice(A, s)), o = 0, A = s), o += e[s], s++;
  return A !== s && i.push(r.slice(A, s)), i;
}, YB = function(r, e, t) {
  t || (t = {});
  var n, i, s, a, o, A, l, u = [], c = [u], h = t.textIndent || 0, f = 0, d = 0, p = r.split(" "), v = ad.apply(this, [" ", t])[0];
  if (A = t.lineIndent === -1 ? p[0].length + 2 : t.lineIndent || 0) {
    var m = Array(A).join(" "), b = [];
    p.map(function(B) {
      (B = B.split(/\s*\n/)).length > 1 ? b = b.concat(B.map(function(_, x) {
        return (x && _.length ? `
` : "") + _;
      })) : b.push(B[0]);
    }), p = b, A = XB.apply(this, [m, t]);
  }
  for (s = 0, a = p.length; s < a; s++) {
    var w = 0;
    if (n = p[s], A && n[0] == `
` && (n = n.substr(1), w = 1), h + f + (d = (i = ad.apply(this, [n, t])).reduce(function(B, _) {
      return B + _;
    }, 0)) > e || w) {
      if (d > e) {
        for (o = JB.apply(this, [n, i, e - (h + f), e]), u.push(o.shift()), u = [o.pop()]; o.length; ) c.push([o.shift()]);
        d = i.slice(n.length - (u[0] ? u[0].length : 0)).reduce(function(B, _) {
          return B + _;
        }, 0);
      } else u = [n];
      c.push(u), h = d + A, f = v;
    } else u.push(n), h += f + d, f = v;
  }
  return l = A ? function(B, _) {
    return (_ ? m : "") + B.join(" ");
  } : function(B) {
    return B.join(" ");
  }, c.map(l);
}, zl.splitTextToSize = function(r, e, t) {
  var n, i = (t = t || {}).fontSize || this.internal.getFontSize(), s = (function(u) {
    if (u.widths && u.kerning) return { widths: u.widths, kerning: u.kerning };
    var c = this.internal.getFont(u.fontName, u.fontStyle);
    return c.metadata.Unicode ? { widths: c.metadata.Unicode.widths || { 0: 1 }, kerning: c.metadata.Unicode.kerning || {} } : { font: c.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, t);
  n = Array.isArray(r) ? r : String(r).split(/\r?\n/);
  var a = 1 * this.internal.scaleFactor * e / i;
  s.textIndent = t.textIndent ? 1 * t.textIndent * this.internal.scaleFactor / i : 0, s.lineIndent = t.lineIndent;
  var o, A, l = [];
  for (o = 0, A = n.length; o < A; o++) l = l.concat(YB.apply(this, [n[o], a, s]));
  return l;
}, function(r) {
  r.__fontmetrics__ = r.__fontmetrics__ || {};
  for (var e = "klmnopqrstuvwxyz", t = {}, n = {}, i = 0; i < e.length; i++) t[e[i]] = "0123456789abcdef"[i], n["0123456789abcdef"[i]] = e[i];
  var s = function(c) {
    return "0x" + parseInt(c, 10).toString(16);
  }, a = r.__fontmetrics__.compress = function(c) {
    var h, f, d, p, v = ["{"];
    for (var m in c) {
      if (h = c[m], isNaN(parseInt(m, 10)) ? f = "'" + m + "'" : (m = parseInt(m, 10), f = (f = s(m).slice(2)).slice(0, -1) + n[f.slice(-1)]), typeof h == "number") h < 0 ? (d = s(h).slice(3), p = "-") : (d = s(h).slice(2), p = ""), d = p + d.slice(0, -1) + n[d.slice(-1)];
      else {
        if (br(h) !== "object") throw new Error("Don't know what to do with value type " + br(h) + ".");
        d = a(h);
      }
      v.push(f + d);
    }
    return v.push("}"), v.join("");
  }, o = r.__fontmetrics__.uncompress = function(c) {
    if (typeof c != "string") throw new Error("Invalid argument passed to uncompress.");
    for (var h, f, d, p, v = {}, m = 1, b = v, w = [], B = "", _ = "", x = c.length - 1, C = 1; C < x; C += 1) (p = c[C]) == "'" ? h ? (d = h.join(""), h = void 0) : h = [] : h ? h.push(p) : p == "{" ? (w.push([b, d]), b = {}, d = void 0) : p == "}" ? ((f = w.pop())[0][f[1]] = b, d = void 0, b = f[0]) : p == "-" ? m = -1 : d === void 0 ? t.hasOwnProperty(p) ? (B += t[p], d = parseInt(B, 16) * m, m = 1, B = "") : B += p : t.hasOwnProperty(p) ? (_ += t[p], b[d] = parseInt(_, 16) * m, m = 1, d = void 0, _ = "") : _ += p;
    return v;
  }, A = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: o("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, l = { Unicode: { Courier: A, "Courier-Bold": A, "Courier-BoldOblique": A, "Courier-Oblique": A, Helvetica: A, "Helvetica-Bold": A, "Helvetica-BoldOblique": A, "Helvetica-Oblique": A, "Times-Roman": A, "Times-Bold": A, "Times-BoldItalic": A, "Times-Italic": A } }, u = { Unicode: { "Courier-Oblique": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": o("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": o("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": o("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: o("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: o("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": o("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: o("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": o("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": o("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": o("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  r.events.push(["addFont", function(c) {
    var h = c.font, f = u.Unicode[h.postScriptName];
    f && (h.metadata.Unicode = {}, h.metadata.Unicode.widths = f.widths, h.metadata.Unicode.kerning = f.kerning);
    var d = l.Unicode[h.postScriptName];
    d && (h.metadata.Unicode.encoding = d, h.encoding = d.codePages[0]);
  }]);
}(Ft.API), /**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(r) {
  var e = function(t) {
    for (var n = t.length, i = new Uint8Array(n), s = 0; s < n; s++) i[s] = t.charCodeAt(s);
    return i;
  };
  r.API.events.push(["addFont", function(t) {
    var n = void 0, i = t.font, s = t.instance;
    if (!i.isStandardFont) {
      if (s === void 0) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i.postScriptName + "').");
      if (typeof (n = s.existsFileInVFS(i.postScriptName) === !1 ? s.loadFile(i.postScriptName) : s.getFileFromVFS(i.postScriptName)) != "string") throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i.postScriptName + "').");
      (function(a, o) {
        o = /^\x00\x01\x00\x00/.test(o) ? e(o) : e(tf(o)), a.metadata = r.API.TTFFont.open(o), a.metadata.Unicode = a.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, a.metadata.glyIdsUsed = [0];
      })(i, n);
    }
  }]);
}(Ft), /** @license
 * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(r) {
  function e() {
    return (Lt.canvg ? Promise.resolve(Lt.canvg) : Promise.resolve().then(() => Cae)).catch(function(t) {
      return Promise.reject(new Error("Could not load canvg: " + t));
    }).then(function(t) {
      return t.default ? t.default : t;
    });
  }
  Ft.API.addSvgAsImage = function(t, n, i, s, a, o, A, l) {
    if (isNaN(n) || isNaN(i)) throw Lr.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(s) || isNaN(a)) throw Lr.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var u = document.createElement("canvas");
    u.width = s, u.height = a;
    var c = u.getContext("2d");
    c.fillStyle = "#fff", c.fillRect(0, 0, u.width, u.height);
    var h = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, f = this;
    return e().then(function(d) {
      return d.fromString(c, t, h);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(d) {
      return d.render(h);
    }).then(function() {
      f.addImage(u.toDataURL("image/jpeg", 1), n, i, s, a, A, l);
    });
  };
}(), Ft.API.putTotalPages = function(r) {
  var e, t = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e = new RegExp(r, "g"), t = this.internal.getNumberOfPages()) : (e = new RegExp(this.pdfEscape16(r, this.internal.getFont()), "g"), t = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var n = 1; n <= this.internal.getNumberOfPages(); n++) for (var i = 0; i < this.internal.pages[n].length; i++) this.internal.pages[n][i] = this.internal.pages[n][i].replace(e, t);
  return this;
}, Ft.API.viewerPreferences = function(r, e) {
  var t;
  r = r || {}, e = e || !1;
  var n, i, s, a = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, o = Object.keys(a), A = [], l = 0, u = 0, c = 0;
  function h(d, p) {
    var v, m = !1;
    for (v = 0; v < d.length; v += 1) d[v] === p && (m = !0);
    return m;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(a)), this.internal.viewerpreferences.isSubscribed = !1), t = this.internal.viewerpreferences.configuration, r === "reset" || e === !0) {
    var f = o.length;
    for (c = 0; c < f; c += 1) t[o[c]].value = t[o[c]].defaultValue, t[o[c]].explicitSet = !1;
  }
  if (br(r) === "object") {
    for (i in r) if (s = r[i], h(o, i) && s !== void 0) {
      if (t[i].type === "boolean" && typeof s == "boolean") t[i].value = s;
      else if (t[i].type === "name" && h(t[i].valueSet, s)) t[i].value = s;
      else if (t[i].type === "integer" && Number.isInteger(s)) t[i].value = s;
      else if (t[i].type === "array") {
        for (l = 0; l < s.length; l += 1) if (n = !0, s[l].length === 1 && typeof s[l][0] == "number") A.push(String(s[l] - 1));
        else if (s[l].length > 1) {
          for (u = 0; u < s[l].length; u += 1) typeof s[l][u] != "number" && (n = !1);
          n === !0 && A.push([s[l][0] - 1, s[l][1] - 1].join(" "));
        }
        t[i].value = "[" + A.join(" ") + "]";
      } else t[i].value = t[i].defaultValue;
      t[i].explicitSet = !0;
    }
  }
  return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    var d, p = [];
    for (d in t) t[d].explicitSet === !0 && (t[d].type === "name" ? p.push("/" + d + " /" + t[d].value) : p.push("/" + d + " " + t[d].value));
    p.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + p.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = t, this;
}, /** ====================================================================
 * @license
 * jsPDF XMP metadata plugin
 * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(r) {
  var e = function() {
    var n = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', i = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), s = unescape(encodeURIComponent(n)), a = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), o = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), A = unescape(encodeURIComponent("</x:xmpmeta>")), l = s.length + a.length + o.length + i.length + A.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + l + " >>"), this.internal.write("stream"), this.internal.write(i + s + a + o + A), this.internal.write("endstream"), this.internal.write("endobj");
  }, t = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  r.addMetadata = function(n, i) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: n, namespaceuri: i || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", t), this.internal.events.subscribe("postPutResources", e)), this;
  };
}(Ft.API), function(r) {
  var e = r.API, t = e.pdfEscape16 = function(s, a) {
    for (var o, A = a.metadata.Unicode.widths, l = ["", "0", "00", "000", "0000"], u = [""], c = 0, h = s.length; c < h; ++c) {
      if (o = a.metadata.characterToGlyph(s.charCodeAt(c)), a.metadata.glyIdsUsed.push(o), a.metadata.toUnicode[o] = s.charCodeAt(c), A.indexOf(o) == -1 && (A.push(o), A.push([parseInt(a.metadata.widthOfGlyph(o), 10)])), o == "0") return u.join("");
      o = o.toString(16), u.push(l[4 - o.length], o);
    }
    return u.join("");
  }, n = function(s) {
    var a, o, A, l, u, c, h;
    for (u = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, A = [], c = 0, h = (o = Object.keys(s).sort(function(f, d) {
      return f - d;
    })).length; c < h; c++) a = o[c], A.length >= 100 && (u += `
` + A.length + ` beginbfchar
` + A.join(`
`) + `
endbfchar`, A = []), s[a] !== void 0 && s[a] !== null && typeof s[a].toString == "function" && (l = ("0000" + s[a].toString(16)).slice(-4), a = ("0000" + (+a).toString(16)).slice(-4), A.push("<" + a + "><" + l + ">"));
    return A.length && (u += `
` + A.length + ` beginbfchar
` + A.join(`
`) + `
endbfchar
`), u += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  e.events.push(["putFont", function(s) {
    (function(a) {
      var o = a.font, A = a.out, l = a.newObject, u = a.putStream;
      if (o.metadata instanceof r.API.TTFFont && o.encoding === "Identity-H") {
        for (var c = o.metadata.Unicode.widths, h = o.metadata.subset.encode(o.metadata.glyIdsUsed, 1), f = "", d = 0; d < h.length; d++) f += String.fromCharCode(h[d]);
        var p = l();
        u({ data: f, addLength1: !0, objectId: p }), A("endobj");
        var v = l();
        u({ data: n(o.metadata.toUnicode), addLength1: !0, objectId: v }), A("endobj");
        var m = l();
        A("<<"), A("/Type /FontDescriptor"), A("/FontName /" + ou(o.fontName)), A("/FontFile2 " + p + " 0 R"), A("/FontBBox " + r.API.PDFObject.convert(o.metadata.bbox)), A("/Flags " + o.metadata.flags), A("/StemV " + o.metadata.stemV), A("/ItalicAngle " + o.metadata.italicAngle), A("/Ascent " + o.metadata.ascender), A("/Descent " + o.metadata.decender), A("/CapHeight " + o.metadata.capHeight), A(">>"), A("endobj");
        var b = l();
        A("<<"), A("/Type /Font"), A("/BaseFont /" + ou(o.fontName)), A("/FontDescriptor " + m + " 0 R"), A("/W " + r.API.PDFObject.convert(c)), A("/CIDToGIDMap /Identity"), A("/DW 1000"), A("/Subtype /CIDFontType2"), A("/CIDSystemInfo"), A("<<"), A("/Supplement 0"), A("/Registry (Adobe)"), A("/Ordering (" + o.encoding + ")"), A(">>"), A(">>"), A("endobj"), o.objectNumber = l(), A("<<"), A("/Type /Font"), A("/Subtype /Type0"), A("/ToUnicode " + v + " 0 R"), A("/BaseFont /" + ou(o.fontName)), A("/Encoding /" + o.encoding), A("/DescendantFonts [" + b + " 0 R]"), A(">>"), A("endobj"), o.isAlreadyPutted = !0;
      }
    })(s);
  }]), e.events.push(["putFont", function(s) {
    (function(a) {
      var o = a.font, A = a.out, l = a.newObject, u = a.putStream;
      if (o.metadata instanceof r.API.TTFFont && o.encoding === "WinAnsiEncoding") {
        for (var c = o.metadata.rawData, h = "", f = 0; f < c.length; f++) h += String.fromCharCode(c[f]);
        var d = l();
        u({ data: h, addLength1: !0, objectId: d }), A("endobj");
        var p = l();
        u({ data: n(o.metadata.toUnicode), addLength1: !0, objectId: p }), A("endobj");
        var v = l();
        A("<<"), A("/Descent " + o.metadata.decender), A("/CapHeight " + o.metadata.capHeight), A("/StemV " + o.metadata.stemV), A("/Type /FontDescriptor"), A("/FontFile2 " + d + " 0 R"), A("/Flags 96"), A("/FontBBox " + r.API.PDFObject.convert(o.metadata.bbox)), A("/FontName /" + ou(o.fontName)), A("/ItalicAngle " + o.metadata.italicAngle), A("/Ascent " + o.metadata.ascender), A(">>"), A("endobj"), o.objectNumber = l();
        for (var m = 0; m < o.metadata.hmtx.widths.length; m++) o.metadata.hmtx.widths[m] = parseInt(o.metadata.hmtx.widths[m] * (1e3 / o.metadata.head.unitsPerEm));
        A("<</Subtype/TrueType/Type/Font/ToUnicode " + p + " 0 R/BaseFont/" + ou(o.fontName) + "/FontDescriptor " + v + " 0 R/Encoding/" + o.encoding + " /FirstChar 29 /LastChar 255 /Widths " + r.API.PDFObject.convert(o.metadata.hmtx.widths) + ">>"), A("endobj"), o.isAlreadyPutted = !0;
      }
    })(s);
  }]);
  var i = function(s) {
    var a, o = s.text || "", A = s.x, l = s.y, u = s.options || {}, c = s.mutex || {}, h = c.pdfEscape, f = c.activeFontKey, d = c.fonts, p = f, v = "", m = 0, b = "", w = d[p].encoding;
    if (d[p].encoding !== "Identity-H") return { text: o, x: A, y: l, options: u, mutex: c };
    for (b = o, p = f, Array.isArray(o) && (b = o[0]), m = 0; m < b.length; m += 1) d[p].metadata.hasOwnProperty("cmap") && (a = d[p].metadata.cmap.unicode.codeMap[b[m].charCodeAt(0)]), a || b[m].charCodeAt(0) < 256 && d[p].metadata.hasOwnProperty("Unicode") ? v += b[m] : v += "";
    var B = "";
    return parseInt(p.slice(1)) < 14 || w === "WinAnsiEncoding" ? B = h(v, p).split("").map(function(_) {
      return _.charCodeAt(0).toString(16);
    }).join("") : w === "Identity-H" && (B = t(v, d[p])), c.isHex = !0, { text: B, x: A, y: l, options: u, mutex: c };
  };
  e.events.push(["postProcessText", function(s) {
    var a = s.text || "", o = [], A = { text: a, x: s.x, y: s.y, options: s.options, mutex: s.mutex };
    if (Array.isArray(a)) {
      var l = 0;
      for (l = 0; l < a.length; l += 1) Array.isArray(a[l]) && a[l].length === 3 ? o.push([i(Object.assign({}, A, { text: a[l][0] })).text, a[l][1], a[l][2]]) : o.push(i(Object.assign({}, A, { text: a[l] })).text);
      s.text = o;
    } else s.text = i(Object.assign({}, A, { text: a })).text;
  }]);
}(Ft), /**
 * @license
 * jsPDF virtual FileSystem functionality
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(r) {
  var e = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0;
  };
  r.existsFileInVFS = function(t) {
    return e.call(this), this.internal.vFS[t] !== void 0;
  }, r.addFileToVFS = function(t, n) {
    return e.call(this), this.internal.vFS[t] = n, this;
  }, r.getFileFromVFS = function(t) {
    return e.call(this), this.internal.vFS[t] !== void 0 ? this.internal.vFS[t] : null;
  };
}(Ft.API), /**
 * @license
 * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
 * MIT License
 */
function(r) {
  r.__bidiEngine__ = r.prototype.__bidiEngine__ = function(n) {
    var i, s, a, o, A, l, u, c = e, h = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], f = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], d = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, p = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, v = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "«", "»", "«", "‹", "›", "‹", "⁅", "⁆", "⁅", "⁽", "⁾", "⁽", "₍", "₎", "₍", "≤", "≥", "≤", "〈", "〉", "〈", "﹙", "﹚", "﹙", "﹛", "﹜", "﹛", "﹝", "﹞", "﹝", "﹤", "﹥", "﹤"], m = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), b = !1, w = 0;
    this.__bidiEngine__ = {};
    var B = function(T) {
      var E = T.charCodeAt(), L = E >> 8, S = p[L];
      return S !== void 0 ? c[256 * S + (255 & E)] : L === 252 || L === 253 ? "AL" : m.test(L) ? "L" : L === 8 ? "R" : "N";
    }, _ = function(T) {
      for (var E, L = 0; L < T.length; L++) {
        if ((E = B(T.charAt(L))) === "L") return !1;
        if (E === "R") return !0;
      }
      return !1;
    }, x = function(T, E, L, S) {
      var X, z, R, V, O = E[S];
      switch (O) {
        case "L":
        case "R":
          b = !1;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          b && (O = "AN");
          break;
        case "AL":
          b = !0, O = "R";
          break;
        case "WS":
          O = "N";
          break;
        case "CS":
          S < 1 || S + 1 >= E.length || (X = L[S - 1]) !== "EN" && X !== "AN" || (z = E[S + 1]) !== "EN" && z !== "AN" ? O = "N" : b && (z = "AN"), O = z === X ? z : "N";
          break;
        case "ES":
          O = (X = S > 0 ? L[S - 1] : "B") === "EN" && S + 1 < E.length && E[S + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (S > 0 && L[S - 1] === "EN") {
            O = "EN";
            break;
          }
          if (b) {
            O = "N";
            break;
          }
          for (R = S + 1, V = E.length; R < V && E[R] === "ET"; ) R++;
          O = R < V && E[R] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (a && !o) {
            for (V = E.length, R = S + 1; R < V && E[R] === "NSM"; ) R++;
            if (R < V) {
              var J = T[S], Z = J >= 1425 && J <= 2303 || J === 64286;
              if (X = E[R], Z && (X === "R" || X === "AL")) {
                O = "R";
                break;
              }
            }
          }
          O = S < 1 || (X = E[S - 1]) === "B" ? "N" : L[S - 1];
          break;
        case "B":
          b = !1, i = !0, O = w;
          break;
        case "S":
          s = !0, O = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          b = !1;
          break;
        case "BN":
          O = "N";
      }
      return O;
    }, C = function(T, E, L) {
      var S = T.split("");
      return L && F(S, L, { hiLevel: w }), S.reverse(), E && E.reverse(), S.join("");
    }, F = function(T, E, L) {
      var S, X, z, R, V, O = -1, J = T.length, Z = 0, U = [], P = w ? f : h, H = [];
      for (b = !1, i = !1, s = !1, X = 0; X < J; X++) H[X] = B(T[X]);
      for (z = 0; z < J; z++) {
        if (V = Z, U[z] = x(T, H, U, z), S = 240 & (Z = P[V][d[U[z]]]), Z &= 15, E[z] = R = P[Z][5], S > 0) if (S === 16) {
          for (X = O; X < z; X++) E[X] = 1;
          O = -1;
        } else O = -1;
        if (P[Z][6]) O === -1 && (O = z);
        else if (O > -1) {
          for (X = O; X < z; X++) E[X] = R;
          O = -1;
        }
        H[z] === "B" && (E[z] = 0), L.hiLevel |= R;
      }
      s && function($, ie, ue) {
        for (var he = 0; he < ue; he++) if ($[he] === "S") {
          ie[he] = w;
          for (var ve = he - 1; ve >= 0 && $[ve] === "WS"; ve--) ie[ve] = w;
        }
      }(H, E, J);
    }, N = function(T, E, L, S, X) {
      if (!(X.hiLevel < T)) {
        if (T === 1 && w === 1 && !i) return E.reverse(), void (L && L.reverse());
        for (var z, R, V, O, J = E.length, Z = 0; Z < J; ) {
          if (S[Z] >= T) {
            for (V = Z + 1; V < J && S[V] >= T; ) V++;
            for (O = Z, R = V - 1; O < R; O++, R--) z = E[O], E[O] = E[R], E[R] = z, L && (z = L[O], L[O] = L[R], L[R] = z);
            Z = V;
          }
          Z++;
        }
      }
    }, D = function(T, E, L) {
      var S = T.split(""), X = { hiLevel: w };
      return L || (L = []), F(S, L, X), function(z, R, V) {
        if (V.hiLevel !== 0 && u) for (var O, J = 0; J < z.length; J++) R[J] === 1 && (O = v.indexOf(z[J])) >= 0 && (z[J] = v[O + 1]);
      }(S, L, X), N(2, S, E, L, X), N(1, S, E, L, X), S.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(T, E, L) {
      if (function(X, z) {
        if (z) for (var R = 0; R < X.length; R++) z[R] = R;
        o === void 0 && (o = _(X)), l === void 0 && (l = _(X));
      }(T, E), a || !A || l) if (a && A && o ^ l) w = o ? 1 : 0, T = C(T, E, L);
      else if (!a && A && l) w = o ? 1 : 0, T = D(T, E, L), T = C(T, E);
      else if (!a || o || A || l) {
        if (a && !A && o ^ l) T = C(T, E), o ? (w = 0, T = D(T, E, L)) : (w = 1, T = D(T, E, L), T = C(T, E));
        else if (a && o && !A && l) w = 1, T = D(T, E, L), T = C(T, E);
        else if (!a && !A && o ^ l) {
          var S = u;
          o ? (w = 1, T = D(T, E, L), w = 0, u = !1, T = D(T, E, L), u = S) : (w = 0, T = D(T, E, L), T = C(T, E), w = 1, u = !1, T = D(T, E, L), u = S, T = C(T, E));
        }
      } else w = 0, T = D(T, E, L);
      else w = o ? 1 : 0, T = D(T, E, L);
      return T;
    }, this.__bidiEngine__.setOptions = function(T) {
      T && (a = T.isInputVisual, A = T.isOutputVisual, o = T.isInputRtl, l = T.isOutputRtl, u = T.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(n), this.__bidiEngine__;
  };
  var e = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], t = new r.__bidiEngine__({ isInputVisual: !0 });
  r.API.events.push(["postProcessText", function(n) {
    var i = n.text, s = (n.x, n.y, n.options || {}), a = (n.mutex, s.lang, []);
    if (s.isInputVisual = typeof s.isInputVisual != "boolean" || s.isInputVisual, t.setOptions(s), Object.prototype.toString.call(i) === "[object Array]") {
      var o = 0;
      for (a = [], o = 0; o < i.length; o += 1) Object.prototype.toString.call(i[o]) === "[object Array]" ? a.push([t.doBidiReorder(i[o][0]), i[o][1], i[o][2]]) : a.push([t.doBidiReorder(i[o])]);
      n.text = a;
    } else n.text = t.doBidiReorder(i);
    t.setOptions({ isInputVisual: !0 });
  }]);
}(Ft), Ft.API.TTFFont = function() {
  function r(e) {
    var t;
    if (this.rawData = e, t = this.contents = new aA(e), this.contents.pos = 4, t.readString(4) === "ttcf") throw new Error("TTCF not supported.");
    t.pos = 0, this.parse(), this.subset = new DP(this), this.registerTTF();
  }
  return r.open = function(e) {
    return new r(e);
  }, r.prototype.parse = function() {
    return this.directory = new CP(this.contents), this.head = new EP(this), this.name = new xP(this), this.cmap = new V3(this), this.toUnicode = {}, this.hhea = new SP(this), this.maxp = new kP(this), this.hmtx = new LP(this), this.post = new FP(this), this.os2 = new IP(this), this.loca = new QP(this), this.glyf = new UP(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, r.prototype.registerTTF = function() {
    var e, t, n, i, s;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var a, o, A, l;
      for (l = [], a = 0, o = (A = this.bbox).length; a < o; a++) e = A[a], l.push(Math.round(e * this.scaleFactor));
      return l;
    }).call(this), this.stemV = 0, this.post.exists ? (n = 255 & (i = this.post.italic_angle), 32768 & (t = i >> 16) && (t = -(1 + (65535 ^ t))), this.italicAngle = +(t + "." + n)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (s = this.familyClass) === 1 || s === 2 || s === 3 || s === 4 || s === 5 || s === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, r.prototype.characterToGlyph = function(e) {
    var t;
    return ((t = this.cmap.unicode) != null ? t.codeMap[e] : void 0) || 0;
  }, r.prototype.widthOfGlyph = function(e) {
    var t;
    return t = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(e).advance * t;
  }, r.prototype.widthOfString = function(e, t, n) {
    var i, s, a, o;
    for (a = 0, s = 0, o = (e = "" + e).length; 0 <= o ? s < o : s > o; s = 0 <= o ? ++s : --s) i = e.charCodeAt(s), a += this.widthOfGlyph(this.characterToGlyph(i)) + n * (1e3 / t) || 0;
    return a * (t / 1e3);
  }, r.prototype.lineHeight = function(e, t) {
    var n;
    return t == null && (t = !1), n = t ? this.lineGap : 0, (this.ascender + n - this.decender) / 1e3 * e;
  }, r;
}();
var la, aA = function() {
  function r(e) {
    this.data = e ?? [], this.pos = 0, this.length = this.data.length;
  }
  return r.prototype.readByte = function() {
    return this.data[this.pos++];
  }, r.prototype.writeByte = function(e) {
    return this.data[this.pos++] = e;
  }, r.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, r.prototype.writeUInt32 = function(e) {
    return this.writeByte(e >>> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e);
  }, r.prototype.readInt32 = function() {
    var e;
    return (e = this.readUInt32()) >= 2147483648 ? e - 4294967296 : e;
  }, r.prototype.writeInt32 = function(e) {
    return e < 0 && (e += 4294967296), this.writeUInt32(e);
  }, r.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, r.prototype.writeUInt16 = function(e) {
    return this.writeByte(e >> 8 & 255), this.writeByte(255 & e);
  }, r.prototype.readInt16 = function() {
    var e;
    return (e = this.readUInt16()) >= 32768 ? e - 65536 : e;
  }, r.prototype.writeInt16 = function(e) {
    return e < 0 && (e += 65536), this.writeUInt16(e);
  }, r.prototype.readString = function(e) {
    var t, n;
    for (n = [], t = 0; 0 <= e ? t < e : t > e; t = 0 <= e ? ++t : --t) n[t] = String.fromCharCode(this.readByte());
    return n.join("");
  }, r.prototype.writeString = function(e) {
    var t, n, i;
    for (i = [], t = 0, n = e.length; 0 <= n ? t < n : t > n; t = 0 <= n ? ++t : --t) i.push(this.writeByte(e.charCodeAt(t)));
    return i;
  }, r.prototype.readShort = function() {
    return this.readInt16();
  }, r.prototype.writeShort = function(e) {
    return this.writeInt16(e);
  }, r.prototype.readLongLong = function() {
    var e, t, n, i, s, a, o, A;
    return e = this.readByte(), t = this.readByte(), n = this.readByte(), i = this.readByte(), s = this.readByte(), a = this.readByte(), o = this.readByte(), A = this.readByte(), 128 & e ? -1 * (72057594037927940 * (255 ^ e) + 281474976710656 * (255 ^ t) + 1099511627776 * (255 ^ n) + 4294967296 * (255 ^ i) + 16777216 * (255 ^ s) + 65536 * (255 ^ a) + 256 * (255 ^ o) + (255 ^ A) + 1) : 72057594037927940 * e + 281474976710656 * t + 1099511627776 * n + 4294967296 * i + 16777216 * s + 65536 * a + 256 * o + A;
  }, r.prototype.writeLongLong = function(e) {
    var t, n;
    return t = Math.floor(e / 4294967296), n = 4294967295 & e, this.writeByte(t >> 24 & 255), this.writeByte(t >> 16 & 255), this.writeByte(t >> 8 & 255), this.writeByte(255 & t), this.writeByte(n >> 24 & 255), this.writeByte(n >> 16 & 255), this.writeByte(n >> 8 & 255), this.writeByte(255 & n);
  }, r.prototype.readInt = function() {
    return this.readInt32();
  }, r.prototype.writeInt = function(e) {
    return this.writeInt32(e);
  }, r.prototype.read = function(e) {
    var t, n;
    for (t = [], n = 0; 0 <= e ? n < e : n > e; n = 0 <= e ? ++n : --n) t.push(this.readByte());
    return t;
  }, r.prototype.write = function(e) {
    var t, n, i, s;
    for (s = [], n = 0, i = e.length; n < i; n++) t = e[n], s.push(this.writeByte(t));
    return s;
  }, r;
}(), CP = function() {
  var r;
  function e(t) {
    var n, i, s;
    for (this.scalarType = t.readInt(), this.tableCount = t.readShort(), this.searchRange = t.readShort(), this.entrySelector = t.readShort(), this.rangeShift = t.readShort(), this.tables = {}, i = 0, s = this.tableCount; 0 <= s ? i < s : i > s; i = 0 <= s ? ++i : --i) n = { tag: t.readString(4), checksum: t.readInt(), offset: t.readInt(), length: t.readInt() }, this.tables[n.tag] = n;
  }
  return e.prototype.encode = function(t) {
    var n, i, s, a, o, A, l, u, c, h, f, d, p;
    for (p in f = Object.keys(t).length, A = Math.log(2), c = 16 * Math.floor(Math.log(f) / A), a = Math.floor(c / A), u = 16 * f - c, (i = new aA()).writeInt(this.scalarType), i.writeShort(f), i.writeShort(c), i.writeShort(a), i.writeShort(u), s = 16 * f, l = i.pos + s, o = null, d = [], t) for (h = t[p], i.writeString(p), i.writeInt(r(h)), i.writeInt(l), i.writeInt(h.length), d = d.concat(h), p === "head" && (o = l), l += h.length; l % 4; ) d.push(0), l++;
    return i.write(d), n = 2981146554 - r(i.data), i.pos = o + 8, i.writeUInt32(n), i.data;
  }, r = function(t) {
    var n, i, s, a;
    for (t = z3.call(t); t.length % 4; ) t.push(0);
    for (s = new aA(t), i = 0, n = 0, a = t.length; n < a; n = n += 4) i += s.readUInt32();
    return 4294967295 & i;
  }, e;
}(), _P = {}.hasOwnProperty, Oa = function(r, e) {
  for (var t in e) _P.call(e, t) && (r[t] = e[t]);
  function n() {
    this.constructor = r;
  }
  return n.prototype = e.prototype, r.prototype = new n(), r.__super__ = e.prototype, r;
};
la = function() {
  function r(e) {
    var t;
    this.file = e, t = this.file.directory.tables[this.tag], this.exists = !!t, t && (this.offset = t.offset, this.length = t.length, this.parse(this.file.contents));
  }
  return r.prototype.parse = function() {
  }, r.prototype.encode = function() {
  }, r.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, r;
}();
var EP = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Oa(e, la), e.prototype.tag = "head", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.revision = t.readInt(), this.checkSumAdjustment = t.readInt(), this.magicNumber = t.readInt(), this.flags = t.readShort(), this.unitsPerEm = t.readShort(), this.created = t.readLongLong(), this.modified = t.readLongLong(), this.xMin = t.readShort(), this.yMin = t.readShort(), this.xMax = t.readShort(), this.yMax = t.readShort(), this.macStyle = t.readShort(), this.lowestRecPPEM = t.readShort(), this.fontDirectionHint = t.readShort(), this.indexToLocFormat = t.readShort(), this.glyphDataFormat = t.readShort();
  }, e.prototype.encode = function(t) {
    var n;
    return (n = new aA()).writeInt(this.version), n.writeInt(this.revision), n.writeInt(this.checkSumAdjustment), n.writeInt(this.magicNumber), n.writeShort(this.flags), n.writeShort(this.unitsPerEm), n.writeLongLong(this.created), n.writeLongLong(this.modified), n.writeShort(this.xMin), n.writeShort(this.yMin), n.writeShort(this.xMax), n.writeShort(this.yMax), n.writeShort(this.macStyle), n.writeShort(this.lowestRecPPEM), n.writeShort(this.fontDirectionHint), n.writeShort(t), n.writeShort(this.glyphDataFormat), n.data;
  }, e;
}(), t5 = function() {
  function r(e, t) {
    var n, i, s, a, o, A, l, u, c, h, f, d, p, v, m, b, w;
    switch (this.platformID = e.readUInt16(), this.encodingID = e.readShort(), this.offset = t + e.readInt(), c = e.pos, e.pos = this.offset, this.format = e.readUInt16(), this.length = e.readUInt16(), this.language = e.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (A = 0; A < 256; ++A) this.codeMap[A] = e.readByte();
        break;
      case 4:
        for (f = e.readUInt16(), h = f / 2, e.pos += 6, s = function() {
          var B, _;
          for (_ = [], A = B = 0; 0 <= h ? B < h : B > h; A = 0 <= h ? ++B : --B) _.push(e.readUInt16());
          return _;
        }(), e.pos += 2, p = function() {
          var B, _;
          for (_ = [], A = B = 0; 0 <= h ? B < h : B > h; A = 0 <= h ? ++B : --B) _.push(e.readUInt16());
          return _;
        }(), l = function() {
          var B, _;
          for (_ = [], A = B = 0; 0 <= h ? B < h : B > h; A = 0 <= h ? ++B : --B) _.push(e.readUInt16());
          return _;
        }(), u = function() {
          var B, _;
          for (_ = [], A = B = 0; 0 <= h ? B < h : B > h; A = 0 <= h ? ++B : --B) _.push(e.readUInt16());
          return _;
        }(), i = (this.length - e.pos + this.offset) / 2, o = function() {
          var B, _;
          for (_ = [], A = B = 0; 0 <= i ? B < i : B > i; A = 0 <= i ? ++B : --B) _.push(e.readUInt16());
          return _;
        }(), A = m = 0, w = s.length; m < w; A = ++m) for (v = s[A], n = b = d = p[A]; d <= v ? b <= v : b >= v; n = d <= v ? ++b : --b) u[A] === 0 ? a = n + l[A] : (a = o[u[A] / 2 + (n - d) - (h - A)] || 0) !== 0 && (a += l[A]), this.codeMap[n] = 65535 & a;
    }
    e.pos = c;
  }
  return r.encode = function(e, t) {
    var n, i, s, a, o, A, l, u, c, h, f, d, p, v, m, b, w, B, _, x, C, F, N, D, T, E, L, S, X, z, R, V, O, J, Z, U, P, H, $, ie, ue, he, ve, Le, de, Ce;
    switch (S = new aA(), a = Object.keys(e).sort(function(Qe, M) {
      return Qe - M;
    }), t) {
      case "macroman":
        for (p = 0, v = function() {
          var Qe = [];
          for (d = 0; d < 256; ++d) Qe.push(0);
          return Qe;
        }(), b = { 0: 0 }, s = {}, X = 0, O = a.length; X < O; X++) b[ve = e[i = a[X]]] == null && (b[ve] = ++p), s[i] = { old: e[i], new: b[e[i]] }, v[i] = b[e[i]];
        return S.writeUInt16(1), S.writeUInt16(0), S.writeUInt32(12), S.writeUInt16(0), S.writeUInt16(262), S.writeUInt16(0), S.write(v), { charMap: s, subtable: S.data, maxGlyphID: p + 1 };
      case "unicode":
        for (E = [], c = [], w = 0, b = {}, n = {}, m = l = null, z = 0, J = a.length; z < J; z++) b[_ = e[i = a[z]]] == null && (b[_] = ++w), n[i] = { old: _, new: b[_] }, o = b[_] - i, m != null && o === l || (m && c.push(m), E.push(i), l = o), m = i;
        for (m && c.push(m), c.push(65535), E.push(65535), D = 2 * (N = E.length), F = 2 * Math.pow(Math.log(N) / Math.LN2, 2), h = Math.log(F / 2) / Math.LN2, C = 2 * N - F, A = [], x = [], f = [], d = R = 0, Z = E.length; R < Z; d = ++R) {
          if (T = E[d], u = c[d], T === 65535) {
            A.push(0), x.push(0);
            break;
          }
          if (T - (L = n[T].new) >= 32768) for (A.push(0), x.push(2 * (f.length + N - d)), i = V = T; T <= u ? V <= u : V >= u; i = T <= u ? ++V : --V) f.push(n[i].new);
          else A.push(L - T), x.push(0);
        }
        for (S.writeUInt16(3), S.writeUInt16(1), S.writeUInt32(12), S.writeUInt16(4), S.writeUInt16(16 + 8 * N + 2 * f.length), S.writeUInt16(0), S.writeUInt16(D), S.writeUInt16(F), S.writeUInt16(h), S.writeUInt16(C), ue = 0, U = c.length; ue < U; ue++) i = c[ue], S.writeUInt16(i);
        for (S.writeUInt16(0), he = 0, P = E.length; he < P; he++) i = E[he], S.writeUInt16(i);
        for (Le = 0, H = A.length; Le < H; Le++) o = A[Le], S.writeUInt16(o);
        for (de = 0, $ = x.length; de < $; de++) B = x[de], S.writeUInt16(B);
        for (Ce = 0, ie = f.length; Ce < ie; Ce++) p = f[Ce], S.writeUInt16(p);
        return { charMap: n, subtable: S.data, maxGlyphID: w + 1 };
    }
  }, r;
}(), V3 = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Oa(e, la), e.prototype.tag = "cmap", e.prototype.parse = function(t) {
    var n, i, s;
    for (t.pos = this.offset, this.version = t.readUInt16(), s = t.readUInt16(), this.tables = [], this.unicode = null, i = 0; 0 <= s ? i < s : i > s; i = 0 <= s ? ++i : --i) n = new t5(t, this.offset), this.tables.push(n), n.isUnicode && this.unicode == null && (this.unicode = n);
    return !0;
  }, e.encode = function(t, n) {
    var i, s;
    return n == null && (n = "macroman"), i = t5.encode(t, n), (s = new aA()).writeUInt16(0), s.writeUInt16(1), i.table = s.data.concat(i.subtable), i;
  }, e;
}(), SP = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Oa(e, la), e.prototype.tag = "hhea", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.ascender = t.readShort(), this.decender = t.readShort(), this.lineGap = t.readShort(), this.advanceWidthMax = t.readShort(), this.minLeftSideBearing = t.readShort(), this.minRightSideBearing = t.readShort(), this.xMaxExtent = t.readShort(), this.caretSlopeRise = t.readShort(), this.caretSlopeRun = t.readShort(), this.caretOffset = t.readShort(), t.pos += 8, this.metricDataFormat = t.readShort(), this.numberOfMetrics = t.readUInt16();
  }, e;
}(), IP = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Oa(e, la), e.prototype.tag = "OS/2", e.prototype.parse = function(t) {
    if (t.pos = this.offset, this.version = t.readUInt16(), this.averageCharWidth = t.readShort(), this.weightClass = t.readUInt16(), this.widthClass = t.readUInt16(), this.type = t.readShort(), this.ySubscriptXSize = t.readShort(), this.ySubscriptYSize = t.readShort(), this.ySubscriptXOffset = t.readShort(), this.ySubscriptYOffset = t.readShort(), this.ySuperscriptXSize = t.readShort(), this.ySuperscriptYSize = t.readShort(), this.ySuperscriptXOffset = t.readShort(), this.ySuperscriptYOffset = t.readShort(), this.yStrikeoutSize = t.readShort(), this.yStrikeoutPosition = t.readShort(), this.familyClass = t.readShort(), this.panose = function() {
      var n, i;
      for (i = [], n = 0; n < 10; ++n) i.push(t.readByte());
      return i;
    }(), this.charRange = function() {
      var n, i;
      for (i = [], n = 0; n < 4; ++n) i.push(t.readInt());
      return i;
    }(), this.vendorID = t.readString(4), this.selection = t.readShort(), this.firstCharIndex = t.readShort(), this.lastCharIndex = t.readShort(), this.version > 0 && (this.ascent = t.readShort(), this.descent = t.readShort(), this.lineGap = t.readShort(), this.winAscent = t.readShort(), this.winDescent = t.readShort(), this.codePageRange = function() {
      var n, i;
      for (i = [], n = 0; n < 2; n = ++n) i.push(t.readInt());
      return i;
    }(), this.version > 1)) return this.xHeight = t.readShort(), this.capHeight = t.readShort(), this.defaultChar = t.readShort(), this.breakChar = t.readShort(), this.maxContext = t.readShort();
  }, e;
}(), FP = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Oa(e, la), e.prototype.tag = "post", e.prototype.parse = function(t) {
    var n, i, s;
    switch (t.pos = this.offset, this.format = t.readInt(), this.italicAngle = t.readInt(), this.underlinePosition = t.readShort(), this.underlineThickness = t.readShort(), this.isFixedPitch = t.readInt(), this.minMemType42 = t.readInt(), this.maxMemType42 = t.readInt(), this.minMemType1 = t.readInt(), this.maxMemType1 = t.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var a;
        for (i = t.readUInt16(), this.glyphNameIndex = [], a = 0; 0 <= i ? a < i : a > i; a = 0 <= i ? ++a : --a) this.glyphNameIndex.push(t.readUInt16());
        for (this.names = [], s = []; t.pos < this.offset + this.length; ) n = t.readByte(), s.push(this.names.push(t.readString(n)));
        return s;
      case 151552:
        return i = t.readUInt16(), this.offsets = t.read(i);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var o, A, l;
          for (l = [], a = o = 0, A = this.file.maxp.numGlyphs; 0 <= A ? o < A : o > A; a = 0 <= A ? ++o : --o) l.push(t.readUInt32());
          return l;
        }).call(this);
    }
  }, e;
}(), TP = function(r, e) {
  this.raw = r, this.length = r.length, this.platformID = e.platformID, this.encodingID = e.encodingID, this.languageID = e.languageID;
}, xP = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Oa(e, la), e.prototype.tag = "name", e.prototype.parse = function(t) {
    var n, i, s, a, o, A, l, u, c, h, f;
    for (t.pos = this.offset, t.readShort(), n = t.readShort(), A = t.readShort(), i = [], a = 0; 0 <= n ? a < n : a > n; a = 0 <= n ? ++a : --a) i.push({ platformID: t.readShort(), encodingID: t.readShort(), languageID: t.readShort(), nameID: t.readShort(), length: t.readShort(), offset: this.offset + A + t.readShort() });
    for (l = {}, a = c = 0, h = i.length; c < h; a = ++c) s = i[a], t.pos = s.offset, u = t.readString(s.length), o = new TP(u, s), l[f = s.nameID] == null && (l[f] = []), l[s.nameID].push(o);
    this.strings = l, this.copyright = l[0], this.fontFamily = l[1], this.fontSubfamily = l[2], this.uniqueSubfamily = l[3], this.fontName = l[4], this.version = l[5];
    try {
      this.postscriptName = l[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = l[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = l[7], this.manufacturer = l[8], this.designer = l[9], this.description = l[10], this.vendorUrl = l[11], this.designerUrl = l[12], this.license = l[13], this.licenseUrl = l[14], this.preferredFamily = l[15], this.preferredSubfamily = l[17], this.compatibleFull = l[18], this.sampleText = l[19];
  }, e;
}(), kP = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Oa(e, la), e.prototype.tag = "maxp", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.numGlyphs = t.readUInt16(), this.maxPoints = t.readUInt16(), this.maxContours = t.readUInt16(), this.maxCompositePoints = t.readUInt16(), this.maxComponentContours = t.readUInt16(), this.maxZones = t.readUInt16(), this.maxTwilightPoints = t.readUInt16(), this.maxStorage = t.readUInt16(), this.maxFunctionDefs = t.readUInt16(), this.maxInstructionDefs = t.readUInt16(), this.maxStackElements = t.readUInt16(), this.maxSizeOfInstructions = t.readUInt16(), this.maxComponentElements = t.readUInt16(), this.maxComponentDepth = t.readUInt16();
  }, e;
}(), LP = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Oa(e, la), e.prototype.tag = "hmtx", e.prototype.parse = function(t) {
    var n, i, s, a, o, A, l;
    for (t.pos = this.offset, this.metrics = [], n = 0, A = this.file.hhea.numberOfMetrics; 0 <= A ? n < A : n > A; n = 0 <= A ? ++n : --n) this.metrics.push({ advance: t.readUInt16(), lsb: t.readInt16() });
    for (s = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var u, c;
      for (c = [], n = u = 0; 0 <= s ? u < s : u > s; n = 0 <= s ? ++u : --u) c.push(t.readInt16());
      return c;
    }(), this.widths = (function() {
      var u, c, h, f;
      for (f = [], u = 0, c = (h = this.metrics).length; u < c; u++) a = h[u], f.push(a.advance);
      return f;
    }).call(this), i = this.widths[this.widths.length - 1], l = [], n = o = 0; 0 <= s ? o < s : o > s; n = 0 <= s ? ++o : --o) l.push(this.widths.push(i));
    return l;
  }, e.prototype.forGlyph = function(t) {
    return t in this.metrics ? this.metrics[t] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t - this.metrics.length] };
  }, e;
}(), z3 = [].slice, UP = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Oa(e, la), e.prototype.tag = "glyf", e.prototype.parse = function() {
    return this.cache = {};
  }, e.prototype.glyphFor = function(t) {
    var n, i, s, a, o, A, l, u, c, h;
    return t in this.cache ? this.cache[t] : (a = this.file.loca, n = this.file.contents, i = a.indexOf(t), (s = a.lengthOf(t)) === 0 ? this.cache[t] = null : (n.pos = this.offset + i, o = (A = new aA(n.read(s))).readShort(), u = A.readShort(), h = A.readShort(), l = A.readShort(), c = A.readShort(), this.cache[t] = o === -1 ? new OP(A, u, h, l, c) : new NP(A, o, u, h, l, c), this.cache[t]));
  }, e.prototype.encode = function(t, n, i) {
    var s, a, o, A, l;
    for (o = [], a = [], A = 0, l = n.length; A < l; A++) s = t[n[A]], a.push(o.length), s && (o = o.concat(s.encode(i)));
    return a.push(o.length), { table: o, offsets: a };
  }, e;
}(), NP = function() {
  function r(e, t, n, i, s, a) {
    this.raw = e, this.numberOfContours = t, this.xMin = n, this.yMin = i, this.xMax = s, this.yMax = a, this.compound = !1;
  }
  return r.prototype.encode = function() {
    return this.raw.data;
  }, r;
}(), OP = function() {
  function r(e, t, n, i, s) {
    var a, o;
    for (this.raw = e, this.xMin = t, this.yMin = n, this.xMax = i, this.yMax = s, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], a = this.raw; o = a.readShort(), this.glyphOffsets.push(a.pos), this.glyphIDs.push(a.readUInt16()), 32 & o; ) a.pos += 1 & o ? 4 : 2, 128 & o ? a.pos += 8 : 64 & o ? a.pos += 4 : 8 & o && (a.pos += 2);
  }
  return r.prototype.encode = function() {
    var e, t, n;
    for (t = new aA(z3.call(this.raw.data)), e = 0, n = this.glyphIDs.length; e < n; ++e) t.pos = this.glyphOffsets[e];
    return t.data;
  }, r;
}(), QP = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return Oa(e, la), e.prototype.tag = "loca", e.prototype.parse = function(t) {
    var n, i;
    return t.pos = this.offset, n = this.file.head.indexToLocFormat, this.offsets = n === 0 ? (function() {
      var s, a;
      for (a = [], i = 0, s = this.length; i < s; i += 2) a.push(2 * t.readUInt16());
      return a;
    }).call(this) : (function() {
      var s, a;
      for (a = [], i = 0, s = this.length; i < s; i += 4) a.push(t.readUInt32());
      return a;
    }).call(this);
  }, e.prototype.indexOf = function(t) {
    return this.offsets[t];
  }, e.prototype.lengthOf = function(t) {
    return this.offsets[t + 1] - this.offsets[t];
  }, e.prototype.encode = function(t, n) {
    for (var i = new Uint32Array(this.offsets.length), s = 0, a = 0, o = 0; o < i.length; ++o) if (i[o] = s, a < n.length && n[a] == o) {
      ++a, i[o] = s;
      var A = this.offsets[o], l = this.offsets[o + 1] - A;
      l > 0 && (s += l);
    }
    for (var u = new Array(4 * i.length), c = 0; c < i.length; ++c) u[4 * c + 3] = 255 & i[c], u[4 * c + 2] = (65280 & i[c]) >> 8, u[4 * c + 1] = (16711680 & i[c]) >> 16, u[4 * c] = (4278190080 & i[c]) >> 24;
    return u;
  }, e;
}(), DP = function() {
  function r(e) {
    this.font = e, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return r.prototype.generateCmap = function() {
    var e, t, n, i, s;
    for (t in i = this.font.cmap.tables[0].codeMap, e = {}, s = this.subset) n = s[t], e[t] = i[n];
    return e;
  }, r.prototype.glyphsFor = function(e) {
    var t, n, i, s, a, o, A;
    for (i = {}, a = 0, o = e.length; a < o; a++) i[s = e[a]] = this.font.glyf.glyphFor(s);
    for (s in t = [], i) (n = i[s]) != null && n.compound && t.push.apply(t, n.glyphIDs);
    if (t.length > 0) for (s in A = this.glyphsFor(t)) n = A[s], i[s] = n;
    return i;
  }, r.prototype.encode = function(e, t) {
    var n, i, s, a, o, A, l, u, c, h, f, d, p, v, m;
    for (i in n = V3.encode(this.generateCmap(), "unicode"), a = this.glyphsFor(e), f = { 0: 0 }, m = n.charMap) f[(A = m[i]).old] = A.new;
    for (d in h = n.maxGlyphID, a) d in f || (f[d] = h++);
    return u = function(b) {
      var w, B;
      for (w in B = {}, b) B[b[w]] = w;
      return B;
    }(f), c = Object.keys(u).sort(function(b, w) {
      return b - w;
    }), p = function() {
      var b, w, B;
      for (B = [], b = 0, w = c.length; b < w; b++) o = c[b], B.push(u[o]);
      return B;
    }(), s = this.font.glyf.encode(a, p, f), l = this.font.loca.encode(s.offsets, p), v = { cmap: this.font.cmap.raw(), glyf: s.table, loca: l, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(t) }, this.font.os2.exists && (v["OS/2"] = this.font.os2.raw()), this.font.directory.encode(v);
  }, r;
}();
Ft.API.PDFObject = function() {
  var r;
  function e() {
  }
  return r = function(t, n) {
    return (Array(n + 1).join("0") + t).slice(-n);
  }, e.convert = function(t) {
    var n, i, s, a;
    if (Array.isArray(t)) return "[" + function() {
      var o, A, l;
      for (l = [], o = 0, A = t.length; o < A; o++) n = t[o], l.push(e.convert(n));
      return l;
    }().join(" ") + "]";
    if (typeof t == "string") return "/" + t;
    if (t != null && t.isString) return "(" + t + ")";
    if (t instanceof Date) return "(D:" + r(t.getUTCFullYear(), 4) + r(t.getUTCMonth(), 2) + r(t.getUTCDate(), 2) + r(t.getUTCHours(), 2) + r(t.getUTCMinutes(), 2) + r(t.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(t) === "[object Object]") {
      for (i in s = ["<<"], t) a = t[i], s.push("/" + i + " " + e.convert(a));
      return s.push(">>"), s.join(`
`);
    }
    return "" + t;
  }, e;
}();
const MP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AcroForm: pP,
  AcroFormAppearance: mt,
  AcroFormButton: Dn,
  AcroFormCheckBox: sf,
  AcroFormChoiceField: ZA,
  AcroFormComboBox: tl,
  AcroFormEditBox: rf,
  AcroFormListBox: el,
  AcroFormPasswordField: af,
  AcroFormPushButton: nf,
  AcroFormRadioButton: rl,
  AcroFormTextField: tA,
  GState: Sf,
  ShadingPattern: Po,
  TilingPattern: $A,
  default: Ft,
  jsPDF: Ft
}, Symbol.toStringTag, { value: "Module" }));
var an = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Rf(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function RP(r) {
  if (r.__esModule) return r;
  var e = r.default;
  if (typeof e == "function") {
    var t = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(r).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(r, n);
    Object.defineProperty(t, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return r[n];
      }
    });
  }), t;
}
var PP = { exports: {} };
const HP = /* @__PURE__ */ RP(MP);
/*!
 * 
 *               jsPDF AutoTable plugin v3.8.4
 *
 *               Copyright (c) 2024 Simon Bengtsson, https://github.com/simonbengtsson/jsPDF-AutoTable
 *               Licensed under the MIT License.
 *               http://opensource.org/licenses/mit-license
 *
 */
(function(r, e) {
  (function(n, i) {
    r.exports = i(function() {
      try {
        return HP;
      } catch {
      }
    }());
  })(typeof globalThis < "u" ? globalThis : typeof an < "u" ? an : typeof window < "u" ? window : typeof self < "u" ? self : an, function(t) {
    return (
      /******/
      function() {
        var n = {
          /***/
          172: (
            /***/
            function(o, A) {
              var l = this && this.__extends || /* @__PURE__ */ function() {
                var h = function(f, d) {
                  return h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(p, v) {
                    p.__proto__ = v;
                  } || function(p, v) {
                    for (var m in v) Object.prototype.hasOwnProperty.call(v, m) && (p[m] = v[m]);
                  }, h(f, d);
                };
                return function(f, d) {
                  if (typeof d != "function" && d !== null)
                    throw new TypeError("Class extends value " + String(d) + " is not a constructor or null");
                  h(f, d);
                  function p() {
                    this.constructor = f;
                  }
                  f.prototype = d === null ? Object.create(d) : (p.prototype = d.prototype, new p());
                };
              }();
              Object.defineProperty(A, "__esModule", { value: !0 }), A.CellHookData = A.HookData = void 0;
              var u = (
                /** @class */
                /* @__PURE__ */ function() {
                  function h(f, d, p) {
                    this.table = d, this.pageNumber = d.pageNumber, this.pageCount = this.pageNumber, this.settings = d.settings, this.cursor = p, this.doc = f.getDocument();
                  }
                  return h;
                }()
              );
              A.HookData = u;
              var c = (
                /** @class */
                function(h) {
                  l(f, h);
                  function f(d, p, v, m, b, w) {
                    var B = h.call(this, d, p, w) || this;
                    return B.cell = v, B.row = m, B.column = b, B.section = m.section, B;
                  }
                  return f;
                }(u)
              );
              A.CellHookData = c;
            }
          ),
          /***/
          340: (
            /***/
            function(o, A, l) {
              Object.defineProperty(A, "__esModule", { value: !0 });
              var u = l(4), c = l(136), h = l(744), f = l(776), d = l(664), p = l(972);
              function v(m) {
                m.API.autoTable = function() {
                  for (var b = [], w = 0; w < arguments.length; w++)
                    b[w] = arguments[w];
                  var B;
                  b.length === 1 ? B = b[0] : (console.error("Use of deprecated autoTable initiation"), B = b[2] || {}, B.columns = b[0], B.body = b[1]);
                  var _ = (0, f.parseInput)(this, B), x = (0, p.createTable)(this, _);
                  return (0, d.drawTable)(this, x), this;
                }, m.API.lastAutoTable = !1, m.API.previousAutoTable = !1, m.API.autoTable.previous = !1, m.API.autoTableText = function(b, w, B, _) {
                  (0, c.default)(b, w, B, _, this);
                }, m.API.autoTableSetDefaults = function(b) {
                  return h.DocHandler.setDefaults(b, this), this;
                }, m.autoTableSetDefaults = function(b, w) {
                  h.DocHandler.setDefaults(b, w);
                }, m.API.autoTableHtmlToJson = function(b, w) {
                  var B;
                  if (w === void 0 && (w = !1), typeof window > "u")
                    return console.error("Cannot run autoTableHtmlToJson in non browser environment"), null;
                  var _ = new h.DocHandler(this), x = (0, u.parseHtml)(_, b, window, w, !1), C = x.head, F = x.body, N = ((B = C[0]) === null || B === void 0 ? void 0 : B.map(function(D) {
                    return D.content;
                  })) || [];
                  return { columns: N, rows: F, data: F };
                }, m.API.autoTableEndPosY = function() {
                  console.error("Use of deprecated function: autoTableEndPosY. Use doc.lastAutoTable.finalY instead.");
                  var b = this.lastAutoTable;
                  return b && b.finalY ? b.finalY : 0;
                }, m.API.autoTableAddPageContent = function(b) {
                  return console.error("Use of deprecated function: autoTableAddPageContent. Use jsPDF.autoTableSetDefaults({didDrawPage: () => {}}) instead."), m.API.autoTable.globalDefaults || (m.API.autoTable.globalDefaults = {}), m.API.autoTable.globalDefaults.addPageContent = b, this;
                }, m.API.autoTableAddPage = function() {
                  return console.error("Use of deprecated function: autoTableAddPage. Use doc.addPage()"), this.addPage(), this;
                };
              }
              A.default = v;
            }
          ),
          /***/
          136: (
            /***/
            function(o, A) {
              Object.defineProperty(A, "__esModule", { value: !0 });
              function l(u, c, h, f, d) {
                f = f || {};
                var p = 1.15, v = d.internal.scaleFactor, m = d.internal.getFontSize() / v, b = d.getLineHeightFactor ? d.getLineHeightFactor() : p, w = m * b, B = /\r\n|\r|\n/g, _ = "", x = 1;
                if ((f.valign === "middle" || f.valign === "bottom" || f.halign === "center" || f.halign === "right") && (_ = typeof u == "string" ? u.split(B) : u, x = _.length || 1), h += m * (2 - p), f.valign === "middle" ? h -= x / 2 * w : f.valign === "bottom" && (h -= x * w), f.halign === "center" || f.halign === "right") {
                  var C = m;
                  if (f.halign === "center" && (C *= 0.5), _ && x >= 1) {
                    for (var F = 0; F < _.length; F++)
                      d.text(_[F], c - d.getStringUnitWidth(_[F]) * C, h), h += w;
                    return d;
                  }
                  c -= d.getStringUnitWidth(u) * C;
                }
                return f.halign === "justify" ? d.text(u, c, h, {
                  maxWidth: f.maxWidth || 100,
                  align: "justify"
                }) : d.text(u, c, h), d;
              }
              A.default = l;
            }
          ),
          /***/
          420: (
            /***/
            function(o, A) {
              Object.defineProperty(A, "__esModule", { value: !0 }), A.getPageAvailableWidth = A.parseSpacing = A.getFillStyle = A.addTableBorder = A.getStringWidth = void 0;
              function l(d, p, v) {
                v.applyStyles(p, !0);
                var m = Array.isArray(d) ? d : [d], b = m.map(function(w) {
                  return v.getTextWidth(w);
                }).reduce(function(w, B) {
                  return Math.max(w, B);
                }, 0);
                return b;
              }
              A.getStringWidth = l;
              function u(d, p, v, m) {
                var b = p.settings.tableLineWidth, w = p.settings.tableLineColor;
                d.applyStyles({ lineWidth: b, lineColor: w });
                var B = c(b, !1);
                B && d.rect(v.x, v.y, p.getWidth(d.pageSize().width), m.y - v.y, B);
              }
              A.addTableBorder = u;
              function c(d, p) {
                var v = d > 0, m = p || p === 0;
                return v && m ? "DF" : v ? "S" : m ? "F" : null;
              }
              A.getFillStyle = c;
              function h(d, p) {
                var v, m, b, w;
                if (d = d || p, Array.isArray(d)) {
                  if (d.length >= 4)
                    return {
                      top: d[0],
                      right: d[1],
                      bottom: d[2],
                      left: d[3]
                    };
                  if (d.length === 3)
                    return {
                      top: d[0],
                      right: d[1],
                      bottom: d[2],
                      left: d[1]
                    };
                  if (d.length === 2)
                    return {
                      top: d[0],
                      right: d[1],
                      bottom: d[0],
                      left: d[1]
                    };
                  d.length === 1 ? d = d[0] : d = p;
                }
                return typeof d == "object" ? (typeof d.vertical == "number" && (d.top = d.vertical, d.bottom = d.vertical), typeof d.horizontal == "number" && (d.right = d.horizontal, d.left = d.horizontal), {
                  left: (v = d.left) !== null && v !== void 0 ? v : p,
                  top: (m = d.top) !== null && m !== void 0 ? m : p,
                  right: (b = d.right) !== null && b !== void 0 ? b : p,
                  bottom: (w = d.bottom) !== null && w !== void 0 ? w : p
                }) : (typeof d != "number" && (d = p), { top: d, right: d, bottom: d, left: d });
              }
              A.parseSpacing = h;
              function f(d, p) {
                var v = h(p.settings.margin, 0);
                return d.pageSize().width - (v.left + v.right);
              }
              A.getPageAvailableWidth = f;
            }
          ),
          /***/
          796: (
            /***/
            function(o, A) {
              var l = this && this.__extends || /* @__PURE__ */ function() {
                var f = function(d, p) {
                  return f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, m) {
                    v.__proto__ = m;
                  } || function(v, m) {
                    for (var b in m) Object.prototype.hasOwnProperty.call(m, b) && (v[b] = m[b]);
                  }, f(d, p);
                };
                return function(d, p) {
                  if (typeof p != "function" && p !== null)
                    throw new TypeError("Class extends value " + String(p) + " is not a constructor or null");
                  f(d, p);
                  function v() {
                    this.constructor = d;
                  }
                  d.prototype = p === null ? Object.create(p) : (v.prototype = p.prototype, new v());
                };
              }();
              Object.defineProperty(A, "__esModule", { value: !0 }), A.getTheme = A.defaultStyles = A.HtmlRowInput = void 0;
              var u = (
                /** @class */
                function(f) {
                  l(d, f);
                  function d(p) {
                    var v = f.call(this) || this;
                    return v._element = p, v;
                  }
                  return d;
                }(Array)
              );
              A.HtmlRowInput = u;
              function c(f) {
                return {
                  font: "helvetica",
                  // helvetica, times, courier
                  fontStyle: "normal",
                  // normal, bold, italic, bolditalic
                  overflow: "linebreak",
                  // linebreak, ellipsize, visible or hidden
                  fillColor: !1,
                  // Either false for transparent, rbg array e.g. [255, 255, 255] or gray level e.g 200
                  textColor: 20,
                  halign: "left",
                  // left, center, right, justify
                  valign: "top",
                  // top, middle, bottom
                  fontSize: 10,
                  cellPadding: 5 / f,
                  // number or {top,left,right,left,vertical,horizontal}
                  lineColor: 200,
                  lineWidth: 0,
                  cellWidth: "auto",
                  // 'auto'|'wrap'|number
                  minCellHeight: 0,
                  minCellWidth: 0
                };
              }
              A.defaultStyles = c;
              function h(f) {
                var d = {
                  striped: {
                    table: { fillColor: 255, textColor: 80, fontStyle: "normal" },
                    head: { textColor: 255, fillColor: [41, 128, 185], fontStyle: "bold" },
                    body: {},
                    foot: { textColor: 255, fillColor: [41, 128, 185], fontStyle: "bold" },
                    alternateRow: { fillColor: 245 }
                  },
                  grid: {
                    table: {
                      fillColor: 255,
                      textColor: 80,
                      fontStyle: "normal",
                      lineWidth: 0.1
                    },
                    head: {
                      textColor: 255,
                      fillColor: [26, 188, 156],
                      fontStyle: "bold",
                      lineWidth: 0
                    },
                    body: {},
                    foot: {
                      textColor: 255,
                      fillColor: [26, 188, 156],
                      fontStyle: "bold",
                      lineWidth: 0
                    },
                    alternateRow: {}
                  },
                  plain: {
                    head: { fontStyle: "bold" },
                    foot: { fontStyle: "bold" }
                  }
                };
                return d[f];
              }
              A.getTheme = h;
            }
          ),
          /***/
          903: (
            /***/
            function(o, A, l) {
              Object.defineProperty(A, "__esModule", { value: !0 }), A.parseCss = void 0;
              var u = l(420);
              function c(v, m, b, w, B) {
                var _ = {}, x = 1.3333333333333333, C = f(m, function(O) {
                  return B.getComputedStyle(O).backgroundColor;
                });
                C != null && (_.fillColor = C);
                var F = f(m, function(O) {
                  return B.getComputedStyle(O).color;
                });
                F != null && (_.textColor = F);
                var N = p(w, b);
                N && (_.cellPadding = N);
                var D = "borderTopColor", T = x * b, E = w.borderTopWidth;
                if (w.borderBottomWidth === E && w.borderRightWidth === E && w.borderLeftWidth === E) {
                  var L = (parseFloat(E) || 0) / T;
                  L && (_.lineWidth = L);
                } else
                  _.lineWidth = {
                    top: (parseFloat(w.borderTopWidth) || 0) / T,
                    right: (parseFloat(w.borderRightWidth) || 0) / T,
                    bottom: (parseFloat(w.borderBottomWidth) || 0) / T,
                    left: (parseFloat(w.borderLeftWidth) || 0) / T
                  }, _.lineWidth.top || (_.lineWidth.right ? D = "borderRightColor" : _.lineWidth.bottom ? D = "borderBottomColor" : _.lineWidth.left && (D = "borderLeftColor"));
                var S = f(m, function(O) {
                  return B.getComputedStyle(O)[D];
                });
                S != null && (_.lineColor = S);
                var X = ["left", "right", "center", "justify"];
                X.indexOf(w.textAlign) !== -1 && (_.halign = w.textAlign), X = ["middle", "bottom", "top"], X.indexOf(w.verticalAlign) !== -1 && (_.valign = w.verticalAlign);
                var z = parseInt(w.fontSize || "");
                isNaN(z) || (_.fontSize = z / x);
                var R = h(w);
                R && (_.fontStyle = R);
                var V = (w.fontFamily || "").toLowerCase();
                return v.indexOf(V) !== -1 && (_.font = V), _;
              }
              A.parseCss = c;
              function h(v) {
                var m = "";
                return (v.fontWeight === "bold" || v.fontWeight === "bolder" || parseInt(v.fontWeight) >= 700) && (m = "bold"), (v.fontStyle === "italic" || v.fontStyle === "oblique") && (m += "italic"), m;
              }
              function f(v, m) {
                var b = d(v, m);
                if (!b)
                  return null;
                var w = b.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d*\.?\d*))?\)$/);
                if (!w || !Array.isArray(w))
                  return null;
                var B = [
                  parseInt(w[1]),
                  parseInt(w[2]),
                  parseInt(w[3])
                ], _ = parseInt(w[4]);
                return _ === 0 || isNaN(B[0]) || isNaN(B[1]) || isNaN(B[2]) ? null : B;
              }
              function d(v, m) {
                var b = m(v);
                return b === "rgba(0, 0, 0, 0)" || b === "transparent" || b === "initial" || b === "inherit" ? v.parentElement == null ? null : d(v.parentElement, m) : b;
              }
              function p(v, m) {
                var b = [
                  v.paddingTop,
                  v.paddingRight,
                  v.paddingBottom,
                  v.paddingLeft
                ], w = 96 / (72 / m), B = (parseInt(v.lineHeight) - parseInt(v.fontSize)) / m / 2, _ = b.map(function(C) {
                  return parseInt(C || "0") / w;
                }), x = (0, u.parseSpacing)(_, 0);
                return B > x.top && (x.top = B), B > x.bottom && (x.bottom = B), x;
              }
            }
          ),
          /***/
          744: (
            /***/
            function(o, A) {
              Object.defineProperty(A, "__esModule", { value: !0 }), A.DocHandler = void 0;
              var l = {}, u = (
                /** @class */
                function() {
                  function c(h) {
                    this.jsPDFDocument = h, this.userStyles = {
                      // Black for versions of jspdf without getTextColor
                      textColor: h.getTextColor ? this.jsPDFDocument.getTextColor() : 0,
                      fontSize: h.internal.getFontSize(),
                      fontStyle: h.internal.getFont().fontStyle,
                      font: h.internal.getFont().fontName,
                      // 0 for versions of jspdf without getLineWidth
                      lineWidth: h.getLineWidth ? this.jsPDFDocument.getLineWidth() : 0,
                      // Black for versions of jspdf without getDrawColor
                      lineColor: h.getDrawColor ? this.jsPDFDocument.getDrawColor() : 0
                    };
                  }
                  return c.setDefaults = function(h, f) {
                    f === void 0 && (f = null), f ? f.__autoTableDocumentDefaults = h : l = h;
                  }, c.unifyColor = function(h) {
                    return Array.isArray(h) ? h : typeof h == "number" ? [h, h, h] : typeof h == "string" ? [h] : null;
                  }, c.prototype.applyStyles = function(h, f) {
                    var d, p, v;
                    f === void 0 && (f = !1), h.fontStyle && this.jsPDFDocument.setFontStyle && this.jsPDFDocument.setFontStyle(h.fontStyle);
                    var m = this.jsPDFDocument.internal.getFont(), b = m.fontStyle, w = m.fontName;
                    if (h.font && (w = h.font), h.fontStyle) {
                      b = h.fontStyle;
                      var B = this.getFontList()[w];
                      B && B.indexOf(b) === -1 && (this.jsPDFDocument.setFontStyle && this.jsPDFDocument.setFontStyle(B[0]), b = B[0]);
                    }
                    if (this.jsPDFDocument.setFont(w, b), h.fontSize && this.jsPDFDocument.setFontSize(h.fontSize), !f) {
                      var _ = c.unifyColor(h.fillColor);
                      _ && (d = this.jsPDFDocument).setFillColor.apply(d, _), _ = c.unifyColor(h.textColor), _ && (p = this.jsPDFDocument).setTextColor.apply(p, _), _ = c.unifyColor(h.lineColor), _ && (v = this.jsPDFDocument).setDrawColor.apply(v, _), typeof h.lineWidth == "number" && this.jsPDFDocument.setLineWidth(h.lineWidth);
                    }
                  }, c.prototype.splitTextToSize = function(h, f, d) {
                    return this.jsPDFDocument.splitTextToSize(h, f, d);
                  }, c.prototype.rect = function(h, f, d, p, v) {
                    return this.jsPDFDocument.rect(h, f, d, p, v);
                  }, c.prototype.getLastAutoTable = function() {
                    return this.jsPDFDocument.lastAutoTable || null;
                  }, c.prototype.getTextWidth = function(h) {
                    return this.jsPDFDocument.getTextWidth(h);
                  }, c.prototype.getDocument = function() {
                    return this.jsPDFDocument;
                  }, c.prototype.setPage = function(h) {
                    this.jsPDFDocument.setPage(h);
                  }, c.prototype.addPage = function() {
                    return this.jsPDFDocument.addPage();
                  }, c.prototype.getFontList = function() {
                    return this.jsPDFDocument.getFontList();
                  }, c.prototype.getGlobalOptions = function() {
                    return l || {};
                  }, c.prototype.getDocumentOptions = function() {
                    return this.jsPDFDocument.__autoTableDocumentDefaults || {};
                  }, c.prototype.pageSize = function() {
                    var h = this.jsPDFDocument.internal.pageSize;
                    return h.width == null && (h = {
                      width: h.getWidth(),
                      height: h.getHeight()
                    }), h;
                  }, c.prototype.scaleFactor = function() {
                    return this.jsPDFDocument.internal.scaleFactor;
                  }, c.prototype.getLineHeightFactor = function() {
                    var h = this.jsPDFDocument;
                    return h.getLineHeightFactor ? h.getLineHeightFactor() : 1.15;
                  }, c.prototype.getLineHeight = function(h) {
                    return h / this.scaleFactor() * this.getLineHeightFactor();
                  }, c.prototype.pageNumber = function() {
                    var h = this.jsPDFDocument.internal.getCurrentPageInfo();
                    return h ? h.pageNumber : this.jsPDFDocument.internal.getNumberOfPages();
                  }, c;
                }()
              );
              A.DocHandler = u;
            }
          ),
          /***/
          4: (
            /***/
            function(o, A, l) {
              Object.defineProperty(A, "__esModule", { value: !0 }), A.parseHtml = void 0;
              var u = l(903), c = l(796);
              function h(p, v, m, b, w) {
                var B, _;
                b === void 0 && (b = !1), w === void 0 && (w = !1);
                var x;
                typeof v == "string" ? x = m.document.querySelector(v) : x = v;
                var C = Object.keys(p.getFontList()), F = p.scaleFactor(), N = [], D = [], T = [];
                if (!x)
                  return console.error("Html table could not be found with input: ", v), { head: N, body: D, foot: T };
                for (var E = 0; E < x.rows.length; E++) {
                  var L = x.rows[E], S = (_ = (B = L == null ? void 0 : L.parentElement) === null || B === void 0 ? void 0 : B.tagName) === null || _ === void 0 ? void 0 : _.toLowerCase(), X = f(C, F, m, L, b, w);
                  X && (S === "thead" ? N.push(X) : S === "tfoot" ? T.push(X) : D.push(X));
                }
                return { head: N, body: D, foot: T };
              }
              A.parseHtml = h;
              function f(p, v, m, b, w, B) {
                for (var _ = new c.HtmlRowInput(b), x = 0; x < b.cells.length; x++) {
                  var C = b.cells[x], F = m.getComputedStyle(C);
                  if (w || F.display !== "none") {
                    var N = void 0;
                    B && (N = (0, u.parseCss)(p, C, v, F, m)), _.push({
                      rowSpan: C.rowSpan,
                      colSpan: C.colSpan,
                      styles: N,
                      _element: C,
                      content: d(C)
                    });
                  }
                }
                var D = m.getComputedStyle(b);
                if (_.length > 0 && (w || D.display !== "none"))
                  return _;
              }
              function d(p) {
                var v = p.cloneNode(!0);
                return v.innerHTML = v.innerHTML.replace(/\n/g, "").replace(/ +/g, " "), v.innerHTML = v.innerHTML.split(/<br.*?>/).map(function(m) {
                  return m.trim();
                }).join(`
`), v.innerText || v.textContent || "";
              }
            }
          ),
          /***/
          776: (
            /***/
            function(o, A, l) {
              Object.defineProperty(A, "__esModule", { value: !0 }), A.parseInput = void 0;
              var u = l(4), c = l(356), h = l(420), f = l(744), d = l(792);
              function p(x, C) {
                var F = new f.DocHandler(x), N = F.getDocumentOptions(), D = F.getGlobalOptions();
                (0, d.default)(F, D, N, C);
                var T = (0, c.assign)({}, D, N, C), E;
                typeof window < "u" && (E = window);
                var L = v(D, N, C), S = m(D, N, C), X = b(F, T), z = B(F, T, E);
                return {
                  id: C.tableId,
                  content: z,
                  hooks: S,
                  styles: L,
                  settings: X
                };
              }
              A.parseInput = p;
              function v(x, C, F) {
                for (var N = {
                  styles: {},
                  headStyles: {},
                  bodyStyles: {},
                  footStyles: {},
                  alternateRowStyles: {},
                  columnStyles: {}
                }, D = function(S) {
                  if (S === "columnStyles") {
                    var X = x[S], z = C[S], R = F[S];
                    N.columnStyles = (0, c.assign)({}, X, z, R);
                  } else {
                    var V = [x, C, F], O = V.map(function(J) {
                      return J[S] || {};
                    });
                    N[S] = (0, c.assign)({}, O[0], O[1], O[2]);
                  }
                }, T = 0, E = Object.keys(N); T < E.length; T++) {
                  var L = E[T];
                  D(L);
                }
                return N;
              }
              function m(x, C, F) {
                for (var N = [x, C, F], D = {
                  didParseCell: [],
                  willDrawCell: [],
                  didDrawCell: [],
                  willDrawPage: [],
                  didDrawPage: []
                }, T = 0, E = N; T < E.length; T++) {
                  var L = E[T];
                  L.didParseCell && D.didParseCell.push(L.didParseCell), L.willDrawCell && D.willDrawCell.push(L.willDrawCell), L.didDrawCell && D.didDrawCell.push(L.didDrawCell), L.willDrawPage && D.willDrawPage.push(L.willDrawPage), L.didDrawPage && D.didDrawPage.push(L.didDrawPage);
                }
                return D;
              }
              function b(x, C) {
                var F, N, D, T, E, L, S, X, z, R, V, O, J = (0, h.parseSpacing)(C.margin, 40 / x.scaleFactor()), Z = (F = w(x, C.startY)) !== null && F !== void 0 ? F : J.top, U;
                C.showFoot === !0 ? U = "everyPage" : C.showFoot === !1 ? U = "never" : U = (N = C.showFoot) !== null && N !== void 0 ? N : "everyPage";
                var P;
                C.showHead === !0 ? P = "everyPage" : C.showHead === !1 ? P = "never" : P = (D = C.showHead) !== null && D !== void 0 ? D : "everyPage";
                var H = (T = C.useCss) !== null && T !== void 0 ? T : !1, $ = C.theme || (H ? "plain" : "striped"), ie = !!C.horizontalPageBreak, ue = (E = C.horizontalPageBreakRepeat) !== null && E !== void 0 ? E : null;
                return {
                  includeHiddenHtml: (L = C.includeHiddenHtml) !== null && L !== void 0 ? L : !1,
                  useCss: H,
                  theme: $,
                  startY: Z,
                  margin: J,
                  pageBreak: (S = C.pageBreak) !== null && S !== void 0 ? S : "auto",
                  rowPageBreak: (X = C.rowPageBreak) !== null && X !== void 0 ? X : "auto",
                  tableWidth: (z = C.tableWidth) !== null && z !== void 0 ? z : "auto",
                  showHead: P,
                  showFoot: U,
                  tableLineWidth: (R = C.tableLineWidth) !== null && R !== void 0 ? R : 0,
                  tableLineColor: (V = C.tableLineColor) !== null && V !== void 0 ? V : 200,
                  horizontalPageBreak: ie,
                  horizontalPageBreakRepeat: ue,
                  horizontalPageBreakBehaviour: (O = C.horizontalPageBreakBehaviour) !== null && O !== void 0 ? O : "afterAllRows"
                };
              }
              function w(x, C) {
                var F = x.getLastAutoTable(), N = x.scaleFactor(), D = x.pageNumber(), T = !1;
                if (F && F.startPageNumber) {
                  var E = F.startPageNumber + F.pageNumber - 1;
                  T = E === D;
                }
                return typeof C == "number" ? C : (C == null || C === !1) && T && (F == null ? void 0 : F.finalY) != null ? F.finalY + 20 / N : null;
              }
              function B(x, C, F) {
                var N = C.head || [], D = C.body || [], T = C.foot || [];
                if (C.html) {
                  var E = C.includeHiddenHtml;
                  if (F) {
                    var L = (0, u.parseHtml)(x, C.html, F, E, C.useCss) || {};
                    N = L.head || N, D = L.body || N, T = L.foot || N;
                  } else
                    console.error("Cannot parse html in non browser environment");
                }
                var S = C.columns || _(N, D, T);
                return {
                  columns: S,
                  head: N,
                  body: D,
                  foot: T
                };
              }
              function _(x, C, F) {
                var N = x[0] || C[0] || F[0] || [], D = [];
                return Object.keys(N).filter(function(T) {
                  return T !== "_element";
                }).forEach(function(T) {
                  var E = 1, L;
                  Array.isArray(N) ? L = N[parseInt(T)] : L = N[T], typeof L == "object" && !Array.isArray(L) && (E = (L == null ? void 0 : L.colSpan) || 1);
                  for (var S = 0; S < E; S++) {
                    var X = void 0;
                    Array.isArray(N) ? X = D.length : X = T + (S > 0 ? "_".concat(S) : "");
                    var z = { dataKey: X };
                    D.push(z);
                  }
                }), D;
              }
            }
          ),
          /***/
          792: (
            /***/
            function(o, A) {
              Object.defineProperty(A, "__esModule", { value: !0 });
              function l(c, h, f, d) {
                for (var p = function(w) {
                  w && typeof w != "object" && console.error("The options parameter should be of type object, is: " + typeof w), typeof w.extendWidth < "u" && (w.tableWidth = w.extendWidth ? "auto" : "wrap", console.error("Use of deprecated option: extendWidth, use tableWidth instead.")), typeof w.margins < "u" && (typeof w.margin > "u" && (w.margin = w.margins), console.error("Use of deprecated option: margins, use margin instead.")), w.startY && typeof w.startY != "number" && (console.error("Invalid value for startY option", w.startY), delete w.startY), !w.didDrawPage && (w.afterPageContent || w.beforePageContent || w.afterPageAdd) && (console.error("The afterPageContent, beforePageContent and afterPageAdd hooks are deprecated. Use didDrawPage instead"), w.didDrawPage = function(T) {
                    c.applyStyles(c.userStyles), w.beforePageContent && w.beforePageContent(T), c.applyStyles(c.userStyles), w.afterPageContent && w.afterPageContent(T), c.applyStyles(c.userStyles), w.afterPageAdd && T.pageNumber > 1 && T.afterPageAdd(T), c.applyStyles(c.userStyles);
                  }), [
                    "createdHeaderCell",
                    "drawHeaderRow",
                    "drawRow",
                    "drawHeaderCell"
                  ].forEach(function(T) {
                    w[T] && console.error('The "'.concat(T, '" hook has changed in version 3.0, check the changelog for how to migrate.'));
                  }), [
                    ["showFoot", "showFooter"],
                    ["showHead", "showHeader"],
                    ["didDrawPage", "addPageContent"],
                    ["didParseCell", "createdCell"],
                    ["headStyles", "headerStyles"]
                  ].forEach(function(T) {
                    var E = T[0], L = T[1];
                    w[L] && (console.error("Use of deprecated option ".concat(L, ". Use ").concat(E, " instead")), w[E] = w[L]);
                  }), [
                    ["padding", "cellPadding"],
                    ["lineHeight", "rowHeight"],
                    "fontSize",
                    "overflow"
                  ].forEach(function(T) {
                    var E = typeof T == "string" ? T : T[0], L = typeof T == "string" ? T : T[1];
                    typeof w[E] < "u" && (typeof w.styles[L] > "u" && (w.styles[L] = w[E]), console.error("Use of deprecated option: " + E + ", use the style " + L + " instead."));
                  });
                  for (var B = 0, _ = [
                    "styles",
                    "bodyStyles",
                    "headStyles",
                    "footStyles"
                  ]; B < _.length; B++) {
                    var x = _[B];
                    u(w[x] || {});
                  }
                  for (var C = w.columnStyles || {}, F = 0, N = Object.keys(C); F < N.length; F++) {
                    var D = N[F];
                    u(C[D] || {});
                  }
                }, v = 0, m = [h, f, d]; v < m.length; v++) {
                  var b = m[v];
                  p(b);
                }
              }
              A.default = l;
              function u(c) {
                c.rowHeight ? (console.error("Use of deprecated style rowHeight. It is renamed to minCellHeight."), c.minCellHeight || (c.minCellHeight = c.rowHeight)) : c.columnWidth && (console.error("Use of deprecated style columnWidth. It is renamed to cellWidth."), c.cellWidth || (c.cellWidth = c.columnWidth));
              }
            }
          ),
          /***/
          260: (
            /***/
            function(o, A, l) {
              Object.defineProperty(A, "__esModule", { value: !0 }), A.Column = A.Cell = A.Row = A.Table = void 0;
              var u = l(796), c = l(172), h = l(420), f = (
                /** @class */
                function() {
                  function m(b, w) {
                    this.pageNumber = 1, this.pageCount = 1, this.id = b.id, this.settings = b.settings, this.styles = b.styles, this.hooks = b.hooks, this.columns = w.columns, this.head = w.head, this.body = w.body, this.foot = w.foot;
                  }
                  return m.prototype.getHeadHeight = function(b) {
                    return this.head.reduce(function(w, B) {
                      return w + B.getMaxCellHeight(b);
                    }, 0);
                  }, m.prototype.getFootHeight = function(b) {
                    return this.foot.reduce(function(w, B) {
                      return w + B.getMaxCellHeight(b);
                    }, 0);
                  }, m.prototype.allRows = function() {
                    return this.head.concat(this.body).concat(this.foot);
                  }, m.prototype.callCellHooks = function(b, w, B, _, x, C) {
                    for (var F = 0, N = w; F < N.length; F++) {
                      var D = N[F], T = new c.CellHookData(b, this, B, _, x, C), E = D(T) === !1;
                      if (B.text = Array.isArray(B.text) ? B.text : [B.text], E)
                        return !1;
                    }
                    return !0;
                  }, m.prototype.callEndPageHooks = function(b, w) {
                    b.applyStyles(b.userStyles);
                    for (var B = 0, _ = this.hooks.didDrawPage; B < _.length; B++) {
                      var x = _[B];
                      x(new c.HookData(b, this, w));
                    }
                  }, m.prototype.callWillDrawPageHooks = function(b, w) {
                    for (var B = 0, _ = this.hooks.willDrawPage; B < _.length; B++) {
                      var x = _[B];
                      x(new c.HookData(b, this, w));
                    }
                  }, m.prototype.getWidth = function(b) {
                    if (typeof this.settings.tableWidth == "number")
                      return this.settings.tableWidth;
                    if (this.settings.tableWidth === "wrap") {
                      var w = this.columns.reduce(function(_, x) {
                        return _ + x.wrappedWidth;
                      }, 0);
                      return w;
                    } else {
                      var B = this.settings.margin;
                      return b - B.left - B.right;
                    }
                  }, m;
                }()
              );
              A.Table = f;
              var d = (
                /** @class */
                function() {
                  function m(b, w, B, _, x) {
                    x === void 0 && (x = !1), this.height = 0, this.raw = b, b instanceof u.HtmlRowInput && (this.raw = b._element, this.element = b._element), this.index = w, this.section = B, this.cells = _, this.spansMultiplePages = x;
                  }
                  return m.prototype.getMaxCellHeight = function(b) {
                    var w = this;
                    return b.reduce(function(B, _) {
                      var x;
                      return Math.max(B, ((x = w.cells[_.index]) === null || x === void 0 ? void 0 : x.height) || 0);
                    }, 0);
                  }, m.prototype.hasRowSpan = function(b) {
                    var w = this;
                    return b.filter(function(B) {
                      var _ = w.cells[B.index];
                      return _ ? _.rowSpan > 1 : !1;
                    }).length > 0;
                  }, m.prototype.canEntireRowFit = function(b, w) {
                    return this.getMaxCellHeight(w) <= b;
                  }, m.prototype.getMinimumRowHeight = function(b, w) {
                    var B = this;
                    return b.reduce(function(_, x) {
                      var C = B.cells[x.index];
                      if (!C)
                        return 0;
                      var F = w.getLineHeight(C.styles.fontSize), N = C.padding("vertical"), D = N + F;
                      return D > _ ? D : _;
                    }, 0);
                  }, m;
                }()
              );
              A.Row = d;
              var p = (
                /** @class */
                function() {
                  function m(b, w, B) {
                    var _, x;
                    this.contentHeight = 0, this.contentWidth = 0, this.wrappedWidth = 0, this.minReadableWidth = 0, this.minWidth = 0, this.width = 0, this.height = 0, this.x = 0, this.y = 0, this.styles = w, this.section = B, this.raw = b;
                    var C = b;
                    b != null && typeof b == "object" && !Array.isArray(b) ? (this.rowSpan = b.rowSpan || 1, this.colSpan = b.colSpan || 1, C = (x = (_ = b.content) !== null && _ !== void 0 ? _ : b.title) !== null && x !== void 0 ? x : b, b._element && (this.raw = b._element)) : (this.rowSpan = 1, this.colSpan = 1);
                    var F = C != null ? "" + C : "", N = /\r\n|\r|\n/g;
                    this.text = F.split(N);
                  }
                  return m.prototype.getTextPos = function() {
                    var b;
                    if (this.styles.valign === "top")
                      b = this.y + this.padding("top");
                    else if (this.styles.valign === "bottom")
                      b = this.y + this.height - this.padding("bottom");
                    else {
                      var w = this.height - this.padding("vertical");
                      b = this.y + w / 2 + this.padding("top");
                    }
                    var B;
                    if (this.styles.halign === "right")
                      B = this.x + this.width - this.padding("right");
                    else if (this.styles.halign === "center") {
                      var _ = this.width - this.padding("horizontal");
                      B = this.x + _ / 2 + this.padding("left");
                    } else
                      B = this.x + this.padding("left");
                    return { x: B, y: b };
                  }, m.prototype.getContentHeight = function(b, w) {
                    w === void 0 && (w = 1.15);
                    var B = Array.isArray(this.text) ? this.text.length : 1, _ = this.styles.fontSize / b * w, x = B * _ + this.padding("vertical");
                    return Math.max(x, this.styles.minCellHeight);
                  }, m.prototype.padding = function(b) {
                    var w = (0, h.parseSpacing)(this.styles.cellPadding, 0);
                    return b === "vertical" ? w.top + w.bottom : b === "horizontal" ? w.left + w.right : w[b];
                  }, m;
                }()
              );
              A.Cell = p;
              var v = (
                /** @class */
                function() {
                  function m(b, w, B) {
                    this.wrappedWidth = 0, this.minReadableWidth = 0, this.minWidth = 0, this.width = 0, this.dataKey = b, this.raw = w, this.index = B;
                  }
                  return m.prototype.getMaxCustomCellWidth = function(b) {
                    for (var w = 0, B = 0, _ = b.allRows(); B < _.length; B++) {
                      var x = _[B], C = x.cells[this.index];
                      C && typeof C.styles.cellWidth == "number" && (w = Math.max(w, C.styles.cellWidth));
                    }
                    return w;
                  }, m;
                }()
              );
              A.Column = v;
            }
          ),
          /***/
          356: (
            /***/
            function(o, A) {
              Object.defineProperty(A, "__esModule", { value: !0 }), A.assign = void 0;
              function l(u, c, h, f, d) {
                if (u == null)
                  throw new TypeError("Cannot convert undefined or null to object");
                for (var p = Object(u), v = 1; v < arguments.length; v++) {
                  var m = arguments[v];
                  if (m != null)
                    for (var b in m)
                      Object.prototype.hasOwnProperty.call(m, b) && (p[b] = m[b]);
                }
                return p;
              }
              A.assign = l;
            }
          ),
          /***/
          972: (
            /***/
            function(o, A, l) {
              Object.defineProperty(A, "__esModule", { value: !0 }), A.createTable = void 0;
              var u = l(744), c = l(260), h = l(324), f = l(796), d = l(356);
              function p(x, C) {
                var F = new u.DocHandler(x), N = v(C, F.scaleFactor()), D = new c.Table(C, N);
                return (0, h.calculateWidths)(F, D), F.applyStyles(F.userStyles), D;
              }
              A.createTable = p;
              function v(x, C) {
                var F = x.content, N = B(F.columns);
                if (F.head.length === 0) {
                  var D = b(N, "head");
                  D && F.head.push(D);
                }
                if (F.foot.length === 0) {
                  var D = b(N, "foot");
                  D && F.foot.push(D);
                }
                var T = x.settings.theme, E = x.styles;
                return {
                  columns: N,
                  head: m("head", F.head, N, E, T, C),
                  body: m("body", F.body, N, E, T, C),
                  foot: m("foot", F.foot, N, E, T, C)
                };
              }
              function m(x, C, F, N, D, T) {
                var E = {}, L = C.map(function(S, X) {
                  for (var z = 0, R = {}, V = 0, O = 0, J = 0, Z = F; J < Z.length; J++) {
                    var U = Z[J];
                    if (E[U.index] == null || E[U.index].left === 0)
                      if (O === 0) {
                        var P = void 0;
                        Array.isArray(S) ? P = S[U.index - V - z] : P = S[U.dataKey];
                        var H = {};
                        typeof P == "object" && !Array.isArray(P) && (H = (P == null ? void 0 : P.styles) || {});
                        var $ = _(x, U, X, D, N, T, H), ie = new c.Cell(P, $, x);
                        R[U.dataKey] = ie, R[U.index] = ie, O = ie.colSpan - 1, E[U.index] = {
                          left: ie.rowSpan - 1,
                          times: O
                        };
                      } else
                        O--, V++;
                    else
                      E[U.index].left--, O = E[U.index].times, z++;
                  }
                  return new c.Row(S, X, x, R);
                });
                return L;
              }
              function b(x, C) {
                var F = {};
                return x.forEach(function(N) {
                  if (N.raw != null) {
                    var D = w(C, N.raw);
                    D != null && (F[N.dataKey] = D);
                  }
                }), Object.keys(F).length > 0 ? F : null;
              }
              function w(x, C) {
                if (x === "head") {
                  if (typeof C == "object")
                    return C.header || C.title || null;
                  if (typeof C == "string" || typeof C == "number")
                    return C;
                } else if (x === "foot" && typeof C == "object")
                  return C.footer;
                return null;
              }
              function B(x) {
                return x.map(function(C, F) {
                  var N, D, T;
                  return typeof C == "object" ? T = (D = (N = C.dataKey) !== null && N !== void 0 ? N : C.key) !== null && D !== void 0 ? D : F : T = F, new c.Column(T, C, F);
                });
              }
              function _(x, C, F, N, D, T, E) {
                var L = (0, f.getTheme)(N), S;
                x === "head" ? S = D.headStyles : x === "body" ? S = D.bodyStyles : x === "foot" && (S = D.footStyles);
                var X = (0, d.assign)({}, L.table, L[x], D.styles, S), z = D.columnStyles[C.dataKey] || D.columnStyles[C.index] || {}, R = x === "body" ? z : {}, V = x === "body" && F % 2 === 0 ? (0, d.assign)({}, L.alternateRow, D.alternateRowStyles) : {}, O = (0, f.defaultStyles)(T), J = (0, d.assign)({}, O, X, V, R);
                return (0, d.assign)(J, E);
              }
            }
          ),
          /***/
          664: (
            /***/
            function(o, A, l) {
              Object.defineProperty(A, "__esModule", { value: !0 }), A.addPage = A.drawTable = void 0;
              var u = l(420), c = l(260), h = l(744), f = l(356), d = l(136), p = l(224);
              function v(z, R) {
                var V = R.settings, O = V.startY, J = V.margin, Z = {
                  x: J.left,
                  y: O
                }, U = R.getHeadHeight(R.columns) + R.getFootHeight(R.columns), P = O + J.bottom + U;
                if (V.pageBreak === "avoid") {
                  var H = R.body, $ = H.reduce(function(he, ve) {
                    return he + ve.height;
                  }, 0);
                  P += $;
                }
                var ie = new h.DocHandler(z);
                (V.pageBreak === "always" || V.startY != null && P > ie.pageSize().height) && (X(ie), Z.y = J.top), R.callWillDrawPageHooks(ie, Z);
                var ue = (0, f.assign)({}, Z);
                R.startPageNumber = ie.pageNumber(), V.horizontalPageBreak ? m(ie, R, ue, Z) : (ie.applyStyles(ie.userStyles), (V.showHead === "firstPage" || V.showHead === "everyPage") && R.head.forEach(function(he) {
                  return D(ie, R, he, Z, R.columns);
                }), ie.applyStyles(ie.userStyles), R.body.forEach(function(he, ve) {
                  var Le = ve === R.body.length - 1;
                  N(ie, R, he, Le, ue, Z, R.columns);
                }), ie.applyStyles(ie.userStyles), (V.showFoot === "lastPage" || V.showFoot === "everyPage") && R.foot.forEach(function(he) {
                  return D(ie, R, he, Z, R.columns);
                })), (0, u.addTableBorder)(ie, R, ue, Z), R.callEndPageHooks(ie, Z), R.finalY = Z.y, z.lastAutoTable = R, z.previousAutoTable = R, z.autoTable && (z.autoTable.previous = R), ie.applyStyles(ie.userStyles);
              }
              A.drawTable = v;
              function m(z, R, V, O) {
                var J = (0, p.calculateAllColumnsCanFitInPage)(z, R), Z = R.settings;
                if (Z.horizontalPageBreakBehaviour === "afterAllRows")
                  J.forEach(function($, ie) {
                    z.applyStyles(z.userStyles), ie > 0 ? S(z, R, V, O, $.columns, !0) : b(z, R, O, $.columns), w(z, R, V, O, $.columns), _(z, R, O, $.columns);
                  });
                else
                  for (var U = -1, P = J[0], H = function() {
                    var $ = U;
                    if (P) {
                      z.applyStyles(z.userStyles);
                      var ie = P.columns;
                      U >= 0 ? S(z, R, V, O, ie, !0) : b(z, R, O, ie), $ = B(z, R, U + 1, O, ie), _(z, R, O, ie);
                    }
                    var ue = $ - U;
                    J.slice(1).forEach(function(he) {
                      z.applyStyles(z.userStyles), S(z, R, V, O, he.columns, !0), B(z, R, U + 1, O, he.columns, ue), _(z, R, O, he.columns);
                    }), U = $;
                  }; U < R.body.length - 1; )
                    H();
              }
              function b(z, R, V, O) {
                var J = R.settings;
                z.applyStyles(z.userStyles), (J.showHead === "firstPage" || J.showHead === "everyPage") && R.head.forEach(function(Z) {
                  return D(z, R, Z, V, O);
                });
              }
              function w(z, R, V, O, J) {
                z.applyStyles(z.userStyles), R.body.forEach(function(Z, U) {
                  var P = U === R.body.length - 1;
                  N(z, R, Z, P, V, O, J);
                });
              }
              function B(z, R, V, O, J, Z) {
                z.applyStyles(z.userStyles), Z = Z ?? R.body.length;
                var U = Math.min(V + Z, R.body.length), P = -1;
                return R.body.slice(V, U).forEach(function(H, $) {
                  var ie = V + $ === R.body.length - 1, ue = L(z, R, ie, O);
                  H.canEntireRowFit(ue, J) && (D(z, R, H, O, J), P = V + $);
                }), P;
              }
              function _(z, R, V, O) {
                var J = R.settings;
                z.applyStyles(z.userStyles), (J.showFoot === "lastPage" || J.showFoot === "everyPage") && R.foot.forEach(function(Z) {
                  return D(z, R, Z, V, O);
                });
              }
              function x(z, R, V) {
                var O = V.getLineHeight(z.styles.fontSize), J = z.padding("vertical"), Z = Math.floor((R - J) / O);
                return Math.max(0, Z);
              }
              function C(z, R, V, O) {
                var J = {};
                z.spansMultiplePages = !0, z.height = 0;
                for (var Z = 0, U = 0, P = V.columns; U < P.length; U++) {
                  var H = P[U], $ = z.cells[H.index];
                  if ($) {
                    Array.isArray($.text) || ($.text = [$.text]);
                    var ie = new c.Cell($.raw, $.styles, $.section);
                    ie = (0, f.assign)(ie, $), ie.text = [];
                    var ue = x($, R, O);
                    $.text.length > ue && (ie.text = $.text.splice(ue, $.text.length));
                    var he = O.scaleFactor(), ve = O.getLineHeightFactor();
                    $.contentHeight = $.getContentHeight(he, ve), $.contentHeight >= R && ($.contentHeight = R, ie.styles.minCellHeight -= R), $.contentHeight > z.height && (z.height = $.contentHeight), ie.contentHeight = ie.getContentHeight(he, ve), ie.contentHeight > Z && (Z = ie.contentHeight), J[H.index] = ie;
                  }
                }
                var Le = new c.Row(z.raw, -1, z.section, J, !0);
                Le.height = Z;
                for (var de = 0, Ce = V.columns; de < Ce.length; de++) {
                  var H = Ce[de], ie = Le.cells[H.index];
                  ie && (ie.height = Le.height);
                  var $ = z.cells[H.index];
                  $ && ($.height = z.height);
                }
                return Le;
              }
              function F(z, R, V, O) {
                var J = z.pageSize().height, Z = O.settings.margin, U = Z.top + Z.bottom, P = J - U;
                R.section === "body" && (P -= O.getHeadHeight(O.columns) + O.getFootHeight(O.columns));
                var H = R.getMinimumRowHeight(O.columns, z), $ = H < V;
                if (H > P)
                  return console.error("Will not be able to print row ".concat(R.index, " correctly since it's minimum height is larger than page height")), !0;
                if (!$)
                  return !1;
                var ie = R.hasRowSpan(O.columns), ue = R.getMaxCellHeight(O.columns) > P;
                return ue ? (ie && console.error("The content of row ".concat(R.index, " will not be drawn correctly since drawing rows with a height larger than the page height and has cells with rowspans is not supported.")), !0) : !(ie || O.settings.rowPageBreak === "avoid");
              }
              function N(z, R, V, O, J, Z, U) {
                var P = L(z, R, O, Z);
                if (V.canEntireRowFit(P, U))
                  D(z, R, V, Z, U);
                else if (F(z, V, P, R)) {
                  var H = C(V, P, R, z);
                  D(z, R, V, Z, U), S(z, R, J, Z, U), N(z, R, H, O, J, Z, U);
                } else
                  S(z, R, J, Z, U), N(z, R, V, O, J, Z, U);
              }
              function D(z, R, V, O, J) {
                O.x = R.settings.margin.left;
                for (var Z = 0, U = J; Z < U.length; Z++) {
                  var P = U[Z], H = V.cells[P.index];
                  if (!H) {
                    O.x += P.width;
                    continue;
                  }
                  z.applyStyles(H.styles), H.x = O.x, H.y = O.y;
                  var $ = R.callCellHooks(z, R.hooks.willDrawCell, H, V, P, O);
                  if ($ === !1) {
                    O.x += P.width;
                    continue;
                  }
                  T(z, H, O);
                  var ie = H.getTextPos();
                  (0, d.default)(H.text, ie.x, ie.y, {
                    halign: H.styles.halign,
                    valign: H.styles.valign,
                    maxWidth: Math.ceil(H.width - H.padding("left") - H.padding("right"))
                  }, z.getDocument()), R.callCellHooks(z, R.hooks.didDrawCell, H, V, P, O), O.x += P.width;
                }
                O.y += V.height;
              }
              function T(z, R, V) {
                var O = R.styles;
                if (z.getDocument().setFillColor(z.getDocument().getFillColor()), typeof O.lineWidth == "number") {
                  var J = (0, u.getFillStyle)(O.lineWidth, O.fillColor);
                  J && z.rect(R.x, V.y, R.width, R.height, J);
                } else typeof O.lineWidth == "object" && (O.fillColor && z.rect(R.x, V.y, R.width, R.height, "F"), E(z, R, V, O.lineWidth));
              }
              function E(z, R, V, O) {
                var J, Z, U, P;
                O.top && (J = V.x, Z = V.y, U = V.x + R.width, P = V.y, O.right && (U += 0.5 * O.right), O.left && (J -= 0.5 * O.left), H(O.top, J, Z, U, P)), O.bottom && (J = V.x, Z = V.y + R.height, U = V.x + R.width, P = V.y + R.height, O.right && (U += 0.5 * O.right), O.left && (J -= 0.5 * O.left), H(O.bottom, J, Z, U, P)), O.left && (J = V.x, Z = V.y, U = V.x, P = V.y + R.height, O.top && (Z -= 0.5 * O.top), O.bottom && (P += 0.5 * O.bottom), H(O.left, J, Z, U, P)), O.right && (J = V.x + R.width, Z = V.y, U = V.x + R.width, P = V.y + R.height, O.top && (Z -= 0.5 * O.top), O.bottom && (P += 0.5 * O.bottom), H(O.right, J, Z, U, P));
                function H($, ie, ue, he, ve) {
                  z.getDocument().setLineWidth($), z.getDocument().line(ie, ue, he, ve, "S");
                }
              }
              function L(z, R, V, O) {
                var J = R.settings.margin.bottom, Z = R.settings.showFoot;
                return (Z === "everyPage" || Z === "lastPage" && V) && (J += R.getFootHeight(R.columns)), z.pageSize().height - O.y - J;
              }
              function S(z, R, V, O, J, Z) {
                J === void 0 && (J = []), Z === void 0 && (Z = !1), z.applyStyles(z.userStyles), R.settings.showFoot === "everyPage" && !Z && R.foot.forEach(function(P) {
                  return D(z, R, P, O, J);
                }), R.callEndPageHooks(z, O);
                var U = R.settings.margin;
                (0, u.addTableBorder)(z, R, V, O), X(z), R.pageNumber++, R.pageCount++, O.x = U.left, O.y = U.top, V.y = U.top, R.callWillDrawPageHooks(z, O), R.settings.showHead === "everyPage" && (R.head.forEach(function(P) {
                  return D(z, R, P, O, J);
                }), z.applyStyles(z.userStyles));
              }
              A.addPage = S;
              function X(z) {
                var R = z.pageNumber();
                z.setPage(R + 1);
                var V = z.pageNumber();
                return V === R ? (z.addPage(), !0) : !1;
              }
            }
          ),
          /***/
          224: (
            /***/
            function(o, A, l) {
              Object.defineProperty(A, "__esModule", { value: !0 }), A.calculateAllColumnsCanFitInPage = void 0;
              var u = l(420);
              function c(f, d, p) {
                var v;
                p === void 0 && (p = {});
                var m = (0, u.getPageAvailableWidth)(f, d), b = /* @__PURE__ */ new Map(), w = [], B = [], _ = [];
                d.settings.horizontalPageBreakRepeat, Array.isArray(d.settings.horizontalPageBreakRepeat) ? _ = d.settings.horizontalPageBreakRepeat : (typeof d.settings.horizontalPageBreakRepeat == "string" || typeof d.settings.horizontalPageBreakRepeat == "number") && (_ = [d.settings.horizontalPageBreakRepeat]), _.forEach(function(N) {
                  var D = d.columns.find(function(T) {
                    return T.dataKey === N || T.index === N;
                  });
                  D && !b.has(D.index) && (b.set(D.index, !0), w.push(D.index), B.push(d.columns[D.index]), m -= D.wrappedWidth);
                });
                for (var x = !0, C = (v = p == null ? void 0 : p.start) !== null && v !== void 0 ? v : 0; C < d.columns.length; ) {
                  if (b.has(C)) {
                    C++;
                    continue;
                  }
                  var F = d.columns[C].wrappedWidth;
                  if (x || m >= F)
                    x = !1, w.push(C), B.push(d.columns[C]), m -= F;
                  else
                    break;
                  C++;
                }
                return { colIndexes: w, columns: B, lastIndex: C - 1 };
              }
              function h(f, d) {
                for (var p = [], v = 0; v < d.columns.length; v++) {
                  var m = c(f, d, { start: v });
                  m.columns.length && (p.push(m), v = m.lastIndex);
                }
                return p;
              }
              A.calculateAllColumnsCanFitInPage = h;
            }
          ),
          /***/
          324: (
            /***/
            function(o, A, l) {
              Object.defineProperty(A, "__esModule", { value: !0 }), A.ellipsize = A.resizeColumns = A.calculateWidths = void 0;
              var u = l(420);
              function c(w, B) {
                h(w, B);
                var _ = [], x = 0;
                B.columns.forEach(function(F) {
                  var N = F.getMaxCustomCellWidth(B);
                  N ? F.width = N : (F.width = F.wrappedWidth, _.push(F)), x += F.width;
                });
                var C = B.getWidth(w.pageSize().width) - x;
                C && (C = f(_, C, function(F) {
                  return Math.max(F.minReadableWidth, F.minWidth);
                })), C && (C = f(_, C, function(F) {
                  return F.minWidth;
                })), C = Math.abs(C), !B.settings.horizontalPageBreak && C > 0.1 / w.scaleFactor() && (C = C < 1 ? C : Math.round(C), console.warn("Of the table content, ".concat(C, " units width could not fit page"))), p(B), v(B, w), d(B);
              }
              A.calculateWidths = c;
              function h(w, B) {
                var _ = w.scaleFactor(), x = B.settings.horizontalPageBreak, C = (0, u.getPageAvailableWidth)(w, B);
                B.allRows().forEach(function(F) {
                  for (var N = 0, D = B.columns; N < D.length; N++) {
                    var T = D[N], E = F.cells[T.index];
                    if (E) {
                      var L = B.hooks.didParseCell;
                      B.callCellHooks(w, L, E, F, T, null);
                      var S = E.padding("horizontal");
                      E.contentWidth = (0, u.getStringWidth)(E.text, E.styles, w) + S;
                      var X = (0, u.getStringWidth)(E.text.join(" ").split(/[^\S\u00A0]+/), E.styles, w);
                      if (E.minReadableWidth = X + E.padding("horizontal"), typeof E.styles.cellWidth == "number")
                        E.minWidth = E.styles.cellWidth, E.wrappedWidth = E.styles.cellWidth;
                      else if (E.styles.cellWidth === "wrap" || x === !0)
                        E.contentWidth > C ? (E.minWidth = C, E.wrappedWidth = C) : (E.minWidth = E.contentWidth, E.wrappedWidth = E.contentWidth);
                      else {
                        var z = 10 / _;
                        E.minWidth = E.styles.minCellWidth || z, E.wrappedWidth = E.contentWidth, E.minWidth > E.wrappedWidth && (E.wrappedWidth = E.minWidth);
                      }
                    }
                  }
                }), B.allRows().forEach(function(F) {
                  for (var N = 0, D = B.columns; N < D.length; N++) {
                    var T = D[N], E = F.cells[T.index];
                    if (E && E.colSpan === 1)
                      T.wrappedWidth = Math.max(T.wrappedWidth, E.wrappedWidth), T.minWidth = Math.max(T.minWidth, E.minWidth), T.minReadableWidth = Math.max(T.minReadableWidth, E.minReadableWidth);
                    else {
                      var L = B.styles.columnStyles[T.dataKey] || B.styles.columnStyles[T.index] || {}, S = L.cellWidth || L.minCellWidth;
                      S && typeof S == "number" && (T.minWidth = S, T.wrappedWidth = S);
                    }
                    E && (E.colSpan > 1 && !T.minWidth && (T.minWidth = E.minWidth), E.colSpan > 1 && !T.wrappedWidth && (T.wrappedWidth = E.minWidth));
                  }
                });
              }
              function f(w, B, _) {
                for (var x = B, C = w.reduce(function(z, R) {
                  return z + R.wrappedWidth;
                }, 0), F = 0; F < w.length; F++) {
                  var N = w[F], D = N.wrappedWidth / C, T = x * D, E = N.width + T, L = _(N), S = E < L ? L : E;
                  B -= S - N.width, N.width = S;
                }
                if (B = Math.round(B * 1e10) / 1e10, B) {
                  var X = w.filter(function(z) {
                    return B < 0 ? z.width > _(z) : !0;
                  });
                  X.length && (B = f(X, B, _));
                }
                return B;
              }
              A.resizeColumns = f;
              function d(w) {
                for (var B = {}, _ = 1, x = w.allRows(), C = 0; C < x.length; C++)
                  for (var F = x[C], N = 0, D = w.columns; N < D.length; N++) {
                    var T = D[N], E = B[T.index];
                    if (_ > 1)
                      _--, delete F.cells[T.index];
                    else if (E)
                      E.cell.height += F.height, _ = E.cell.colSpan, delete F.cells[T.index], E.left--, E.left <= 1 && delete B[T.index];
                    else {
                      var L = F.cells[T.index];
                      if (!L)
                        continue;
                      if (L.height = F.height, L.rowSpan > 1) {
                        var S = x.length - C, X = L.rowSpan > S ? S : L.rowSpan;
                        B[T.index] = { cell: L, left: X, row: F };
                      }
                    }
                  }
              }
              function p(w) {
                for (var B = w.allRows(), _ = 0; _ < B.length; _++)
                  for (var x = B[_], C = null, F = 0, N = 0, D = 0; D < w.columns.length; D++) {
                    var T = w.columns[D];
                    if (N -= 1, N > 1 && w.columns[D + 1])
                      F += T.width, delete x.cells[T.index];
                    else if (C) {
                      var E = C;
                      delete x.cells[T.index], C = null, E.width = T.width + F;
                    } else {
                      var E = x.cells[T.index];
                      if (!E)
                        continue;
                      if (N = E.colSpan, F = 0, E.colSpan > 1) {
                        C = E, F += T.width;
                        continue;
                      }
                      E.width = T.width + F;
                    }
                  }
              }
              function v(w, B) {
                for (var _ = { count: 0, height: 0 }, x = 0, C = w.allRows(); x < C.length; x++) {
                  for (var F = C[x], N = 0, D = w.columns; N < D.length; N++) {
                    var T = D[N], E = F.cells[T.index];
                    if (E) {
                      B.applyStyles(E.styles, !0);
                      var L = E.width - E.padding("horizontal");
                      if (E.styles.overflow === "linebreak")
                        E.text = B.splitTextToSize(E.text, L + 1 / B.scaleFactor(), { fontSize: E.styles.fontSize });
                      else if (E.styles.overflow === "ellipsize")
                        E.text = m(E.text, L, E.styles, B, "...");
                      else if (E.styles.overflow === "hidden")
                        E.text = m(E.text, L, E.styles, B, "");
                      else if (typeof E.styles.overflow == "function") {
                        var S = E.styles.overflow(E.text, L);
                        typeof S == "string" ? E.text = [S] : E.text = S;
                      }
                      E.contentHeight = E.getContentHeight(B.scaleFactor(), B.getLineHeightFactor());
                      var X = E.contentHeight / E.rowSpan;
                      E.rowSpan > 1 && _.count * _.height < X * E.rowSpan ? _ = { height: X, count: E.rowSpan } : _ && _.count > 0 && _.height > X && (X = _.height), X > F.height && (F.height = X);
                    }
                  }
                  _.count--;
                }
              }
              function m(w, B, _, x, C) {
                return w.map(function(F) {
                  return b(F, B, _, x, C);
                });
              }
              A.ellipsize = m;
              function b(w, B, _, x, C) {
                var F = 1e4 * x.scaleFactor();
                if (B = Math.ceil(B * F) / F, B >= (0, u.getStringWidth)(w, _, x))
                  return w;
                for (; B < (0, u.getStringWidth)(w + C, _, x) && !(w.length <= 1); )
                  w = w.substring(0, w.length - 1);
                return w.trim() + C;
              }
            }
          ),
          /***/
          964: (
            /***/
            function(o) {
              if (typeof t > "u") {
                var A = new Error("Cannot find module 'undefined'");
                throw A.code = "MODULE_NOT_FOUND", A;
              }
              o.exports = t;
            }
          )
          /******/
        }, i = {};
        function s(o) {
          var A = i[o];
          if (A !== void 0)
            return A.exports;
          var l = i[o] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          return n[o].call(l.exports, l, l.exports, s), l.exports;
        }
        var a = {};
        return function() {
          var o = a;
          Object.defineProperty(o, "__esModule", { value: !0 }), o.Cell = o.Column = o.Row = o.Table = o.CellHookData = o.__drawTable = o.__createTable = o.applyPlugin = void 0;
          var A = s(340), l = s(776), u = s(664), c = s(972), h = s(260);
          Object.defineProperty(o, "Table", { enumerable: !0, get: function() {
            return h.Table;
          } });
          var f = s(172);
          Object.defineProperty(o, "CellHookData", { enumerable: !0, get: function() {
            return f.CellHookData;
          } });
          var d = s(260);
          Object.defineProperty(o, "Cell", { enumerable: !0, get: function() {
            return d.Cell;
          } }), Object.defineProperty(o, "Column", { enumerable: !0, get: function() {
            return d.Column;
          } }), Object.defineProperty(o, "Row", { enumerable: !0, get: function() {
            return d.Row;
          } });
          function p(B) {
            (0, A.default)(B);
          }
          o.applyPlugin = p;
          function v(B, _) {
            var x = (0, l.parseInput)(B, _), C = (0, c.createTable)(B, x);
            (0, u.drawTable)(B, C);
          }
          function m(B, _) {
            var x = (0, l.parseInput)(B, _);
            return (0, c.createTable)(B, x);
          }
          o.__createTable = m;
          function b(B, _) {
            (0, u.drawTable)(B, _);
          }
          o.__drawTable = b;
          try {
            var w = s(964);
            w.jsPDF && (w = w.jsPDF), p(w);
          } catch {
          }
          o.default = v;
        }(), a;
      }()
    );
  });
})(PP);
var jP = 1 / 0, KP = "[object Symbol]", G3 = /[&<>"'`]/g, $P = RegExp(G3.source), VP = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "`": "&#96;"
}, zP = typeof an == "object" && an && an.Object === Object && an, GP = typeof self == "object" && self && self.Object === Object && self, qP = zP || GP || Function("return this")();
function WP(r) {
  return function(e) {
    return r == null ? void 0 : r[e];
  };
}
var XP = WP(VP), JP = Object.prototype, YP = JP.toString, r5 = qP.Symbol, n5 = r5 ? r5.prototype : void 0, i5 = n5 ? n5.toString : void 0;
function ZP(r) {
  if (typeof r == "string")
    return r;
  if (tH(r))
    return i5 ? i5.call(r) : "";
  var e = r + "";
  return e == "0" && 1 / r == -jP ? "-0" : e;
}
function eH(r) {
  return !!r && typeof r == "object";
}
function tH(r) {
  return typeof r == "symbol" || eH(r) && YP.call(r) == KP;
}
function rH(r) {
  return r == null ? "" : ZP(r);
}
function nH(r) {
  return r = rH(r), r && $P.test(r) ? r.replace(G3, XP) : r;
}
var iH = nH;
const sH = /* @__PURE__ */ Rf(iH);
function od(r) {
  throw new Error('Could not dynamically require "' + r + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var q3 = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(r, e) {
  (function(t) {
    r.exports = t();
  })(function() {
    return function t(n, i, s) {
      function a(l, u) {
        if (!i[l]) {
          if (!n[l]) {
            var c = typeof od == "function" && od;
            if (!u && c) return c(l, !0);
            if (o) return o(l, !0);
            var h = new Error("Cannot find module '" + l + "'");
            throw h.code = "MODULE_NOT_FOUND", h;
          }
          var f = i[l] = { exports: {} };
          n[l][0].call(f.exports, function(d) {
            var p = n[l][1][d];
            return a(p || d);
          }, f, f.exports, t, n, i, s);
        }
        return i[l].exports;
      }
      for (var o = typeof od == "function" && od, A = 0; A < s.length; A++) a(s[A]);
      return a;
    }({ 1: [function(t, n, i) {
      var s = t("./utils"), a = t("./support"), o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      i.encode = function(A) {
        for (var l, u, c, h, f, d, p, v = [], m = 0, b = A.length, w = b, B = s.getTypeOf(A) !== "string"; m < A.length; ) w = b - m, c = B ? (l = A[m++], u = m < b ? A[m++] : 0, m < b ? A[m++] : 0) : (l = A.charCodeAt(m++), u = m < b ? A.charCodeAt(m++) : 0, m < b ? A.charCodeAt(m++) : 0), h = l >> 2, f = (3 & l) << 4 | u >> 4, d = 1 < w ? (15 & u) << 2 | c >> 6 : 64, p = 2 < w ? 63 & c : 64, v.push(o.charAt(h) + o.charAt(f) + o.charAt(d) + o.charAt(p));
        return v.join("");
      }, i.decode = function(A) {
        var l, u, c, h, f, d, p = 0, v = 0, m = "data:";
        if (A.substr(0, m.length) === m) throw new Error("Invalid base64 input, it looks like a data url.");
        var b, w = 3 * (A = A.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (A.charAt(A.length - 1) === o.charAt(64) && w--, A.charAt(A.length - 2) === o.charAt(64) && w--, w % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
        for (b = a.uint8array ? new Uint8Array(0 | w) : new Array(0 | w); p < A.length; ) l = o.indexOf(A.charAt(p++)) << 2 | (h = o.indexOf(A.charAt(p++))) >> 4, u = (15 & h) << 4 | (f = o.indexOf(A.charAt(p++))) >> 2, c = (3 & f) << 6 | (d = o.indexOf(A.charAt(p++))), b[v++] = l, f !== 64 && (b[v++] = u), d !== 64 && (b[v++] = c);
        return b;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(t, n, i) {
      var s = t("./external"), a = t("./stream/DataWorker"), o = t("./stream/Crc32Probe"), A = t("./stream/DataLengthProbe");
      function l(u, c, h, f, d) {
        this.compressedSize = u, this.uncompressedSize = c, this.crc32 = h, this.compression = f, this.compressedContent = d;
      }
      l.prototype = { getContentWorker: function() {
        var u = new a(s.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new A("data_length")), c = this;
        return u.on("end", function() {
          if (this.streamInfo.data_length !== c.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
        }), u;
      }, getCompressedWorker: function() {
        return new a(s.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, l.createWorkerFrom = function(u, c, h) {
        return u.pipe(new o()).pipe(new A("uncompressedSize")).pipe(c.compressWorker(h)).pipe(new A("compressedSize")).withStreamInfo("compression", c);
      }, n.exports = l;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(t, n, i) {
      var s = t("./stream/GenericWorker");
      i.STORE = { magic: "\0\0", compressWorker: function() {
        return new s("STORE compression");
      }, uncompressWorker: function() {
        return new s("STORE decompression");
      } }, i.DEFLATE = t("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(t, n, i) {
      var s = t("./utils"), a = function() {
        for (var o, A = [], l = 0; l < 256; l++) {
          o = l;
          for (var u = 0; u < 8; u++) o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          A[l] = o;
        }
        return A;
      }();
      n.exports = function(o, A) {
        return o !== void 0 && o.length ? s.getTypeOf(o) !== "string" ? function(l, u, c, h) {
          var f = a, d = h + c;
          l ^= -1;
          for (var p = h; p < d; p++) l = l >>> 8 ^ f[255 & (l ^ u[p])];
          return -1 ^ l;
        }(0 | A, o, o.length, 0) : function(l, u, c, h) {
          var f = a, d = h + c;
          l ^= -1;
          for (var p = h; p < d; p++) l = l >>> 8 ^ f[255 & (l ^ u.charCodeAt(p))];
          return -1 ^ l;
        }(0 | A, o, o.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(t, n, i) {
      i.base64 = !1, i.binary = !1, i.dir = !1, i.createFolders = !0, i.date = null, i.compression = null, i.compressionOptions = null, i.comment = null, i.unixPermissions = null, i.dosPermissions = null;
    }, {}], 6: [function(t, n, i) {
      var s = null;
      s = typeof Promise < "u" ? Promise : t("lie"), n.exports = { Promise: s };
    }, { lie: 37 }], 7: [function(t, n, i) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", a = t("pako"), o = t("./utils"), A = t("./stream/GenericWorker"), l = s ? "uint8array" : "array";
      function u(c, h) {
        A.call(this, "FlateWorker/" + c), this._pako = null, this._pakoAction = c, this._pakoOptions = h, this.meta = {};
      }
      i.magic = "\b\0", o.inherits(u, A), u.prototype.processChunk = function(c) {
        this.meta = c.meta, this._pako === null && this._createPako(), this._pako.push(o.transformTo(l, c.data), !1);
      }, u.prototype.flush = function() {
        A.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, u.prototype.cleanUp = function() {
        A.prototype.cleanUp.call(this), this._pako = null;
      }, u.prototype._createPako = function() {
        this._pako = new a[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var c = this;
        this._pako.onData = function(h) {
          c.push({ data: h, meta: c.meta });
        };
      }, i.compressWorker = function(c) {
        return new u("Deflate", c);
      }, i.uncompressWorker = function() {
        return new u("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(t, n, i) {
      function s(f, d) {
        var p, v = "";
        for (p = 0; p < d; p++) v += String.fromCharCode(255 & f), f >>>= 8;
        return v;
      }
      function a(f, d, p, v, m, b) {
        var w, B, _ = f.file, x = f.compression, C = b !== l.utf8encode, F = o.transformTo("string", b(_.name)), N = o.transformTo("string", l.utf8encode(_.name)), D = _.comment, T = o.transformTo("string", b(D)), E = o.transformTo("string", l.utf8encode(D)), L = N.length !== _.name.length, S = E.length !== D.length, X = "", z = "", R = "", V = _.dir, O = _.date, J = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        d && !p || (J.crc32 = f.crc32, J.compressedSize = f.compressedSize, J.uncompressedSize = f.uncompressedSize);
        var Z = 0;
        d && (Z |= 8), C || !L && !S || (Z |= 2048);
        var U = 0, P = 0;
        V && (U |= 16), m === "UNIX" ? (P = 798, U |= function($, ie) {
          var ue = $;
          return $ || (ue = ie ? 16893 : 33204), (65535 & ue) << 16;
        }(_.unixPermissions, V)) : (P = 20, U |= function($) {
          return 63 & ($ || 0);
        }(_.dosPermissions)), w = O.getUTCHours(), w <<= 6, w |= O.getUTCMinutes(), w <<= 5, w |= O.getUTCSeconds() / 2, B = O.getUTCFullYear() - 1980, B <<= 4, B |= O.getUTCMonth() + 1, B <<= 5, B |= O.getUTCDate(), L && (z = s(1, 1) + s(u(F), 4) + N, X += "up" + s(z.length, 2) + z), S && (R = s(1, 1) + s(u(T), 4) + E, X += "uc" + s(R.length, 2) + R);
        var H = "";
        return H += `
\0`, H += s(Z, 2), H += x.magic, H += s(w, 2), H += s(B, 2), H += s(J.crc32, 4), H += s(J.compressedSize, 4), H += s(J.uncompressedSize, 4), H += s(F.length, 2), H += s(X.length, 2), { fileRecord: c.LOCAL_FILE_HEADER + H + F + X, dirRecord: c.CENTRAL_FILE_HEADER + s(P, 2) + H + s(T.length, 2) + "\0\0\0\0" + s(U, 4) + s(v, 4) + F + X + T };
      }
      var o = t("../utils"), A = t("../stream/GenericWorker"), l = t("../utf8"), u = t("../crc32"), c = t("../signature");
      function h(f, d, p, v) {
        A.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = d, this.zipPlatform = p, this.encodeFileName = v, this.streamFiles = f, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      o.inherits(h, A), h.prototype.push = function(f) {
        var d = f.meta.percent || 0, p = this.entriesCount, v = this._sources.length;
        this.accumulate ? this.contentBuffer.push(f) : (this.bytesWritten += f.data.length, A.prototype.push.call(this, { data: f.data, meta: { currentFile: this.currentFile, percent: p ? (d + 100 * (p - v - 1)) / p : 100 } }));
      }, h.prototype.openedSource = function(f) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = f.file.name;
        var d = this.streamFiles && !f.file.dir;
        if (d) {
          var p = a(f, d, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: p.fileRecord, meta: { percent: 0 } });
        } else this.accumulate = !0;
      }, h.prototype.closedSource = function(f) {
        this.accumulate = !1;
        var d = this.streamFiles && !f.file.dir, p = a(f, d, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(p.dirRecord), d) this.push({ data: function(v) {
          return c.DATA_DESCRIPTOR + s(v.crc32, 4) + s(v.compressedSize, 4) + s(v.uncompressedSize, 4);
        }(f), meta: { percent: 100 } });
        else for (this.push({ data: p.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, h.prototype.flush = function() {
        for (var f = this.bytesWritten, d = 0; d < this.dirRecords.length; d++) this.push({ data: this.dirRecords[d], meta: { percent: 100 } });
        var p = this.bytesWritten - f, v = function(m, b, w, B, _) {
          var x = o.transformTo("string", _(B));
          return c.CENTRAL_DIRECTORY_END + "\0\0\0\0" + s(m, 2) + s(m, 2) + s(b, 4) + s(w, 4) + s(x.length, 2) + x;
        }(this.dirRecords.length, p, f, this.zipComment, this.encodeFileName);
        this.push({ data: v, meta: { percent: 100 } });
      }, h.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, h.prototype.registerPrevious = function(f) {
        this._sources.push(f);
        var d = this;
        return f.on("data", function(p) {
          d.processChunk(p);
        }), f.on("end", function() {
          d.closedSource(d.previous.streamInfo), d._sources.length ? d.prepareNextSource() : d.end();
        }), f.on("error", function(p) {
          d.error(p);
        }), this;
      }, h.prototype.resume = function() {
        return !!A.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, h.prototype.error = function(f) {
        var d = this._sources;
        if (!A.prototype.error.call(this, f)) return !1;
        for (var p = 0; p < d.length; p++) try {
          d[p].error(f);
        } catch {
        }
        return !0;
      }, h.prototype.lock = function() {
        A.prototype.lock.call(this);
        for (var f = this._sources, d = 0; d < f.length; d++) f[d].lock();
      }, n.exports = h;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(t, n, i) {
      var s = t("../compressions"), a = t("./ZipFileWorker");
      i.generateWorker = function(o, A, l) {
        var u = new a(A.streamFiles, l, A.platform, A.encodeFileName), c = 0;
        try {
          o.forEach(function(h, f) {
            c++;
            var d = function(b, w) {
              var B = b || w, _ = s[B];
              if (!_) throw new Error(B + " is not a valid compression method !");
              return _;
            }(f.options.compression, A.compression), p = f.options.compressionOptions || A.compressionOptions || {}, v = f.dir, m = f.date;
            f._compressWorker(d, p).withStreamInfo("file", { name: h, dir: v, date: m, comment: f.comment || "", unixPermissions: f.unixPermissions, dosPermissions: f.dosPermissions }).pipe(u);
          }), u.entriesCount = c;
        } catch (h) {
          u.error(h);
        }
        return u;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(t, n, i) {
      function s() {
        if (!(this instanceof s)) return new s();
        if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var a = new s();
          for (var o in this) typeof this[o] != "function" && (a[o] = this[o]);
          return a;
        };
      }
      (s.prototype = t("./object")).loadAsync = t("./load"), s.support = t("./support"), s.defaults = t("./defaults"), s.version = "3.10.1", s.loadAsync = function(a, o) {
        return new s().loadAsync(a, o);
      }, s.external = t("./external"), n.exports = s;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(t, n, i) {
      var s = t("./utils"), a = t("./external"), o = t("./utf8"), A = t("./zipEntries"), l = t("./stream/Crc32Probe"), u = t("./nodejsUtils");
      function c(h) {
        return new a.Promise(function(f, d) {
          var p = h.decompressed.getContentWorker().pipe(new l());
          p.on("error", function(v) {
            d(v);
          }).on("end", function() {
            p.streamInfo.crc32 !== h.decompressed.crc32 ? d(new Error("Corrupted zip : CRC32 mismatch")) : f();
          }).resume();
        });
      }
      n.exports = function(h, f) {
        var d = this;
        return f = s.extend(f || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: o.utf8decode }), u.isNode && u.isStream(h) ? a.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : s.prepareContent("the loaded zip file", h, !0, f.optimizedBinaryString, f.base64).then(function(p) {
          var v = new A(f);
          return v.load(p), v;
        }).then(function(p) {
          var v = [a.Promise.resolve(p)], m = p.files;
          if (f.checkCRC32) for (var b = 0; b < m.length; b++) v.push(c(m[b]));
          return a.Promise.all(v);
        }).then(function(p) {
          for (var v = p.shift(), m = v.files, b = 0; b < m.length; b++) {
            var w = m[b], B = w.fileNameStr, _ = s.resolve(w.fileNameStr);
            d.file(_, w.decompressed, { binary: !0, optimizedBinaryString: !0, date: w.date, dir: w.dir, comment: w.fileCommentStr.length ? w.fileCommentStr : null, unixPermissions: w.unixPermissions, dosPermissions: w.dosPermissions, createFolders: f.createFolders }), w.dir || (d.file(_).unsafeOriginalName = B);
          }
          return v.zipComment.length && (d.comment = v.zipComment), d;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(t, n, i) {
      var s = t("../utils"), a = t("../stream/GenericWorker");
      function o(A, l) {
        a.call(this, "Nodejs stream input adapter for " + A), this._upstreamEnded = !1, this._bindStream(l);
      }
      s.inherits(o, a), o.prototype._bindStream = function(A) {
        var l = this;
        (this._stream = A).pause(), A.on("data", function(u) {
          l.push({ data: u, meta: { percent: 0 } });
        }).on("error", function(u) {
          l.isPaused ? this.generatedError = u : l.error(u);
        }).on("end", function() {
          l.isPaused ? l._upstreamEnded = !0 : l.end();
        });
      }, o.prototype.pause = function() {
        return !!a.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, o.prototype.resume = function() {
        return !!a.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, n.exports = o;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(t, n, i) {
      var s = t("readable-stream").Readable;
      function a(o, A, l) {
        s.call(this, A), this._helper = o;
        var u = this;
        o.on("data", function(c, h) {
          u.push(c) || u._helper.pause(), l && l(h);
        }).on("error", function(c) {
          u.emit("error", c);
        }).on("end", function() {
          u.push(null);
        });
      }
      t("../utils").inherits(a, s), a.prototype._read = function() {
        this._helper.resume();
      }, n.exports = a;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(t, n, i) {
      n.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(s, a) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(s, a);
        if (typeof s == "number") throw new Error('The "data" argument must not be a number');
        return new Buffer(s, a);
      }, allocBuffer: function(s) {
        if (Buffer.alloc) return Buffer.alloc(s);
        var a = new Buffer(s);
        return a.fill(0), a;
      }, isBuffer: function(s) {
        return Buffer.isBuffer(s);
      }, isStream: function(s) {
        return s && typeof s.on == "function" && typeof s.pause == "function" && typeof s.resume == "function";
      } };
    }, {}], 15: [function(t, n, i) {
      function s(_, x, C) {
        var F, N = o.getTypeOf(x), D = o.extend(C || {}, u);
        D.date = D.date || /* @__PURE__ */ new Date(), D.compression !== null && (D.compression = D.compression.toUpperCase()), typeof D.unixPermissions == "string" && (D.unixPermissions = parseInt(D.unixPermissions, 8)), D.unixPermissions && 16384 & D.unixPermissions && (D.dir = !0), D.dosPermissions && 16 & D.dosPermissions && (D.dir = !0), D.dir && (_ = m(_)), D.createFolders && (F = v(_)) && b.call(this, F, !0);
        var T = N === "string" && D.binary === !1 && D.base64 === !1;
        C && C.binary !== void 0 || (D.binary = !T), (x instanceof c && x.uncompressedSize === 0 || D.dir || !x || x.length === 0) && (D.base64 = !1, D.binary = !0, x = "", D.compression = "STORE", N = "string");
        var E = null;
        E = x instanceof c || x instanceof A ? x : d.isNode && d.isStream(x) ? new p(_, x) : o.prepareContent(_, x, D.binary, D.optimizedBinaryString, D.base64);
        var L = new h(_, E, D);
        this.files[_] = L;
      }
      var a = t("./utf8"), o = t("./utils"), A = t("./stream/GenericWorker"), l = t("./stream/StreamHelper"), u = t("./defaults"), c = t("./compressedObject"), h = t("./zipObject"), f = t("./generate"), d = t("./nodejsUtils"), p = t("./nodejs/NodejsStreamInputAdapter"), v = function(_) {
        _.slice(-1) === "/" && (_ = _.substring(0, _.length - 1));
        var x = _.lastIndexOf("/");
        return 0 < x ? _.substring(0, x) : "";
      }, m = function(_) {
        return _.slice(-1) !== "/" && (_ += "/"), _;
      }, b = function(_, x) {
        return x = x !== void 0 ? x : u.createFolders, _ = m(_), this.files[_] || s.call(this, _, null, { dir: !0, createFolders: x }), this.files[_];
      };
      function w(_) {
        return Object.prototype.toString.call(_) === "[object RegExp]";
      }
      var B = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(_) {
        var x, C, F;
        for (x in this.files) F = this.files[x], (C = x.slice(this.root.length, x.length)) && x.slice(0, this.root.length) === this.root && _(C, F);
      }, filter: function(_) {
        var x = [];
        return this.forEach(function(C, F) {
          _(C, F) && x.push(F);
        }), x;
      }, file: function(_, x, C) {
        if (arguments.length !== 1) return _ = this.root + _, s.call(this, _, x, C), this;
        if (w(_)) {
          var F = _;
          return this.filter(function(D, T) {
            return !T.dir && F.test(D);
          });
        }
        var N = this.files[this.root + _];
        return N && !N.dir ? N : null;
      }, folder: function(_) {
        if (!_) return this;
        if (w(_)) return this.filter(function(N, D) {
          return D.dir && _.test(N);
        });
        var x = this.root + _, C = b.call(this, x), F = this.clone();
        return F.root = C.name, F;
      }, remove: function(_) {
        _ = this.root + _;
        var x = this.files[_];
        if (x || (_.slice(-1) !== "/" && (_ += "/"), x = this.files[_]), x && !x.dir) delete this.files[_];
        else for (var C = this.filter(function(N, D) {
          return D.name.slice(0, _.length) === _;
        }), F = 0; F < C.length; F++) delete this.files[C[F].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(_) {
        var x, C = {};
        try {
          if ((C = o.extend(_ || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: a.utf8encode })).type = C.type.toLowerCase(), C.compression = C.compression.toUpperCase(), C.type === "binarystring" && (C.type = "string"), !C.type) throw new Error("No output type specified.");
          o.checkSupport(C.type), C.platform !== "darwin" && C.platform !== "freebsd" && C.platform !== "linux" && C.platform !== "sunos" || (C.platform = "UNIX"), C.platform === "win32" && (C.platform = "DOS");
          var F = C.comment || this.comment || "";
          x = f.generateWorker(this, C, F);
        } catch (N) {
          (x = new A("error")).error(N);
        }
        return new l(x, C.type || "string", C.mimeType);
      }, generateAsync: function(_, x) {
        return this.generateInternalStream(_).accumulate(x);
      }, generateNodeStream: function(_, x) {
        return (_ = _ || {}).type || (_.type = "nodebuffer"), this.generateInternalStream(_).toNodejsStream(x);
      } };
      n.exports = B;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(t, n, i) {
      n.exports = t("stream");
    }, { stream: void 0 }], 17: [function(t, n, i) {
      var s = t("./DataReader");
      function a(o) {
        s.call(this, o);
        for (var A = 0; A < this.data.length; A++) o[A] = 255 & o[A];
      }
      t("../utils").inherits(a, s), a.prototype.byteAt = function(o) {
        return this.data[this.zero + o];
      }, a.prototype.lastIndexOfSignature = function(o) {
        for (var A = o.charCodeAt(0), l = o.charCodeAt(1), u = o.charCodeAt(2), c = o.charCodeAt(3), h = this.length - 4; 0 <= h; --h) if (this.data[h] === A && this.data[h + 1] === l && this.data[h + 2] === u && this.data[h + 3] === c) return h - this.zero;
        return -1;
      }, a.prototype.readAndCheckSignature = function(o) {
        var A = o.charCodeAt(0), l = o.charCodeAt(1), u = o.charCodeAt(2), c = o.charCodeAt(3), h = this.readData(4);
        return A === h[0] && l === h[1] && u === h[2] && c === h[3];
      }, a.prototype.readData = function(o) {
        if (this.checkOffset(o), o === 0) return [];
        var A = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, A;
      }, n.exports = a;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(t, n, i) {
      var s = t("../utils");
      function a(o) {
        this.data = o, this.length = o.length, this.index = 0, this.zero = 0;
      }
      a.prototype = { checkOffset: function(o) {
        this.checkIndex(this.index + o);
      }, checkIndex: function(o) {
        if (this.length < this.zero + o || o < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + o + "). Corrupted zip ?");
      }, setIndex: function(o) {
        this.checkIndex(o), this.index = o;
      }, skip: function(o) {
        this.setIndex(this.index + o);
      }, byteAt: function() {
      }, readInt: function(o) {
        var A, l = 0;
        for (this.checkOffset(o), A = this.index + o - 1; A >= this.index; A--) l = (l << 8) + this.byteAt(A);
        return this.index += o, l;
      }, readString: function(o) {
        return s.transformTo("string", this.readData(o));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var o = this.readInt(4);
        return new Date(Date.UTC(1980 + (o >> 25 & 127), (o >> 21 & 15) - 1, o >> 16 & 31, o >> 11 & 31, o >> 5 & 63, (31 & o) << 1));
      } }, n.exports = a;
    }, { "../utils": 32 }], 19: [function(t, n, i) {
      var s = t("./Uint8ArrayReader");
      function a(o) {
        s.call(this, o);
      }
      t("../utils").inherits(a, s), a.prototype.readData = function(o) {
        this.checkOffset(o);
        var A = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, A;
      }, n.exports = a;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(t, n, i) {
      var s = t("./DataReader");
      function a(o) {
        s.call(this, o);
      }
      t("../utils").inherits(a, s), a.prototype.byteAt = function(o) {
        return this.data.charCodeAt(this.zero + o);
      }, a.prototype.lastIndexOfSignature = function(o) {
        return this.data.lastIndexOf(o) - this.zero;
      }, a.prototype.readAndCheckSignature = function(o) {
        return o === this.readData(4);
      }, a.prototype.readData = function(o) {
        this.checkOffset(o);
        var A = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, A;
      }, n.exports = a;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(t, n, i) {
      var s = t("./ArrayReader");
      function a(o) {
        s.call(this, o);
      }
      t("../utils").inherits(a, s), a.prototype.readData = function(o) {
        if (this.checkOffset(o), o === 0) return new Uint8Array(0);
        var A = this.data.subarray(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, A;
      }, n.exports = a;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(t, n, i) {
      var s = t("../utils"), a = t("../support"), o = t("./ArrayReader"), A = t("./StringReader"), l = t("./NodeBufferReader"), u = t("./Uint8ArrayReader");
      n.exports = function(c) {
        var h = s.getTypeOf(c);
        return s.checkSupport(h), h !== "string" || a.uint8array ? h === "nodebuffer" ? new l(c) : a.uint8array ? new u(s.transformTo("uint8array", c)) : new o(s.transformTo("array", c)) : new A(c);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(t, n, i) {
      i.LOCAL_FILE_HEADER = "PK", i.CENTRAL_FILE_HEADER = "PK", i.CENTRAL_DIRECTORY_END = "PK", i.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", i.ZIP64_CENTRAL_DIRECTORY_END = "PK", i.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(t, n, i) {
      var s = t("./GenericWorker"), a = t("../utils");
      function o(A) {
        s.call(this, "ConvertWorker to " + A), this.destType = A;
      }
      a.inherits(o, s), o.prototype.processChunk = function(A) {
        this.push({ data: a.transformTo(this.destType, A.data), meta: A.meta });
      }, n.exports = o;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(t, n, i) {
      var s = t("./GenericWorker"), a = t("../crc32");
      function o() {
        s.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      t("../utils").inherits(o, s), o.prototype.processChunk = function(A) {
        this.streamInfo.crc32 = a(A.data, this.streamInfo.crc32 || 0), this.push(A);
      }, n.exports = o;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(t, n, i) {
      var s = t("../utils"), a = t("./GenericWorker");
      function o(A) {
        a.call(this, "DataLengthProbe for " + A), this.propName = A, this.withStreamInfo(A, 0);
      }
      s.inherits(o, a), o.prototype.processChunk = function(A) {
        if (A) {
          var l = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = l + A.data.length;
        }
        a.prototype.processChunk.call(this, A);
      }, n.exports = o;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(t, n, i) {
      var s = t("../utils"), a = t("./GenericWorker");
      function o(A) {
        a.call(this, "DataWorker");
        var l = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, A.then(function(u) {
          l.dataIsReady = !0, l.data = u, l.max = u && u.length || 0, l.type = s.getTypeOf(u), l.isPaused || l._tickAndRepeat();
        }, function(u) {
          l.error(u);
        });
      }
      s.inherits(o, a), o.prototype.cleanUp = function() {
        a.prototype.cleanUp.call(this), this.data = null;
      }, o.prototype.resume = function() {
        return !!a.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, s.delay(this._tickAndRepeat, [], this)), !0);
      }, o.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (s.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, o.prototype._tick = function() {
        if (this.isPaused || this.isFinished) return !1;
        var A = null, l = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max) return this.end();
        switch (this.type) {
          case "string":
            A = this.data.substring(this.index, l);
            break;
          case "uint8array":
            A = this.data.subarray(this.index, l);
            break;
          case "array":
          case "nodebuffer":
            A = this.data.slice(this.index, l);
        }
        return this.index = l, this.push({ data: A, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, n.exports = o;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(t, n, i) {
      function s(a) {
        this.name = a || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      s.prototype = { push: function(a) {
        this.emit("data", a);
      }, end: function() {
        if (this.isFinished) return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (a) {
          this.emit("error", a);
        }
        return !0;
      }, error: function(a) {
        return !this.isFinished && (this.isPaused ? this.generatedError = a : (this.isFinished = !0, this.emit("error", a), this.previous && this.previous.error(a), this.cleanUp()), !0);
      }, on: function(a, o) {
        return this._listeners[a].push(o), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(a, o) {
        if (this._listeners[a]) for (var A = 0; A < this._listeners[a].length; A++) this._listeners[a][A].call(this, o);
      }, pipe: function(a) {
        return a.registerPrevious(this);
      }, registerPrevious: function(a) {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = a.streamInfo, this.mergeStreamInfo(), this.previous = a;
        var o = this;
        return a.on("data", function(A) {
          o.processChunk(A);
        }), a.on("end", function() {
          o.end();
        }), a.on("error", function(A) {
          o.error(A);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished) return !1;
        var a = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), a = !0), this.previous && this.previous.resume(), !a;
      }, flush: function() {
      }, processChunk: function(a) {
        this.push(a);
      }, withStreamInfo: function(a, o) {
        return this.extraStreamInfo[a] = o, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var a in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, a) && (this.streamInfo[a] = this.extraStreamInfo[a]);
      }, lock: function() {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var a = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + a : a;
      } }, n.exports = s;
    }, {}], 29: [function(t, n, i) {
      var s = t("../utils"), a = t("./ConvertWorker"), o = t("./GenericWorker"), A = t("../base64"), l = t("../support"), u = t("../external"), c = null;
      if (l.nodestream) try {
        c = t("../nodejs/NodejsStreamOutputAdapter");
      } catch {
      }
      function h(d, p) {
        return new u.Promise(function(v, m) {
          var b = [], w = d._internalType, B = d._outputType, _ = d._mimeType;
          d.on("data", function(x, C) {
            b.push(x), p && p(C);
          }).on("error", function(x) {
            b = [], m(x);
          }).on("end", function() {
            try {
              var x = function(C, F, N) {
                switch (C) {
                  case "blob":
                    return s.newBlob(s.transformTo("arraybuffer", F), N);
                  case "base64":
                    return A.encode(F);
                  default:
                    return s.transformTo(C, F);
                }
              }(B, function(C, F) {
                var N, D = 0, T = null, E = 0;
                for (N = 0; N < F.length; N++) E += F[N].length;
                switch (C) {
                  case "string":
                    return F.join("");
                  case "array":
                    return Array.prototype.concat.apply([], F);
                  case "uint8array":
                    for (T = new Uint8Array(E), N = 0; N < F.length; N++) T.set(F[N], D), D += F[N].length;
                    return T;
                  case "nodebuffer":
                    return Buffer.concat(F);
                  default:
                    throw new Error("concat : unsupported type '" + C + "'");
                }
              }(w, b), _);
              v(x);
            } catch (C) {
              m(C);
            }
            b = [];
          }).resume();
        });
      }
      function f(d, p, v) {
        var m = p;
        switch (p) {
          case "blob":
          case "arraybuffer":
            m = "uint8array";
            break;
          case "base64":
            m = "string";
        }
        try {
          this._internalType = m, this._outputType = p, this._mimeType = v, s.checkSupport(m), this._worker = d.pipe(new a(m)), d.lock();
        } catch (b) {
          this._worker = new o("error"), this._worker.error(b);
        }
      }
      f.prototype = { accumulate: function(d) {
        return h(this, d);
      }, on: function(d, p) {
        var v = this;
        return d === "data" ? this._worker.on(d, function(m) {
          p.call(v, m.data, m.meta);
        }) : this._worker.on(d, function() {
          s.delay(p, arguments, v);
        }), this;
      }, resume: function() {
        return s.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(d) {
        if (s.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
        return new c(this, { objectMode: this._outputType !== "nodebuffer" }, d);
      } }, n.exports = f;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(t, n, i) {
      if (i.base64 = !0, i.array = !0, i.string = !0, i.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", i.nodebuffer = typeof Buffer < "u", i.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") i.blob = !1;
      else {
        var s = new ArrayBuffer(0);
        try {
          i.blob = new Blob([s], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var a = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            a.append(s), i.blob = a.getBlob("application/zip").size === 0;
          } catch {
            i.blob = !1;
          }
        }
      }
      try {
        i.nodestream = !!t("readable-stream").Readable;
      } catch {
        i.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(t, n, i) {
      for (var s = t("./utils"), a = t("./support"), o = t("./nodejsUtils"), A = t("./stream/GenericWorker"), l = new Array(256), u = 0; u < 256; u++) l[u] = 252 <= u ? 6 : 248 <= u ? 5 : 240 <= u ? 4 : 224 <= u ? 3 : 192 <= u ? 2 : 1;
      l[254] = l[254] = 1;
      function c() {
        A.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function h() {
        A.call(this, "utf-8 encode");
      }
      i.utf8encode = function(f) {
        return a.nodebuffer ? o.newBufferFrom(f, "utf-8") : function(d) {
          var p, v, m, b, w, B = d.length, _ = 0;
          for (b = 0; b < B; b++) (64512 & (v = d.charCodeAt(b))) == 55296 && b + 1 < B && (64512 & (m = d.charCodeAt(b + 1))) == 56320 && (v = 65536 + (v - 55296 << 10) + (m - 56320), b++), _ += v < 128 ? 1 : v < 2048 ? 2 : v < 65536 ? 3 : 4;
          for (p = a.uint8array ? new Uint8Array(_) : new Array(_), b = w = 0; w < _; b++) (64512 & (v = d.charCodeAt(b))) == 55296 && b + 1 < B && (64512 & (m = d.charCodeAt(b + 1))) == 56320 && (v = 65536 + (v - 55296 << 10) + (m - 56320), b++), v < 128 ? p[w++] = v : (v < 2048 ? p[w++] = 192 | v >>> 6 : (v < 65536 ? p[w++] = 224 | v >>> 12 : (p[w++] = 240 | v >>> 18, p[w++] = 128 | v >>> 12 & 63), p[w++] = 128 | v >>> 6 & 63), p[w++] = 128 | 63 & v);
          return p;
        }(f);
      }, i.utf8decode = function(f) {
        return a.nodebuffer ? s.transformTo("nodebuffer", f).toString("utf-8") : function(d) {
          var p, v, m, b, w = d.length, B = new Array(2 * w);
          for (p = v = 0; p < w; ) if ((m = d[p++]) < 128) B[v++] = m;
          else if (4 < (b = l[m])) B[v++] = 65533, p += b - 1;
          else {
            for (m &= b === 2 ? 31 : b === 3 ? 15 : 7; 1 < b && p < w; ) m = m << 6 | 63 & d[p++], b--;
            1 < b ? B[v++] = 65533 : m < 65536 ? B[v++] = m : (m -= 65536, B[v++] = 55296 | m >> 10 & 1023, B[v++] = 56320 | 1023 & m);
          }
          return B.length !== v && (B.subarray ? B = B.subarray(0, v) : B.length = v), s.applyFromCharCode(B);
        }(f = s.transformTo(a.uint8array ? "uint8array" : "array", f));
      }, s.inherits(c, A), c.prototype.processChunk = function(f) {
        var d = s.transformTo(a.uint8array ? "uint8array" : "array", f.data);
        if (this.leftOver && this.leftOver.length) {
          if (a.uint8array) {
            var p = d;
            (d = new Uint8Array(p.length + this.leftOver.length)).set(this.leftOver, 0), d.set(p, this.leftOver.length);
          } else d = this.leftOver.concat(d);
          this.leftOver = null;
        }
        var v = function(b, w) {
          var B;
          for ((w = w || b.length) > b.length && (w = b.length), B = w - 1; 0 <= B && (192 & b[B]) == 128; ) B--;
          return B < 0 || B === 0 ? w : B + l[b[B]] > w ? B : w;
        }(d), m = d;
        v !== d.length && (a.uint8array ? (m = d.subarray(0, v), this.leftOver = d.subarray(v, d.length)) : (m = d.slice(0, v), this.leftOver = d.slice(v, d.length))), this.push({ data: i.utf8decode(m), meta: f.meta });
      }, c.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: i.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, i.Utf8DecodeWorker = c, s.inherits(h, A), h.prototype.processChunk = function(f) {
        this.push({ data: i.utf8encode(f.data), meta: f.meta });
      }, i.Utf8EncodeWorker = h;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(t, n, i) {
      var s = t("./support"), a = t("./base64"), o = t("./nodejsUtils"), A = t("./external");
      function l(p) {
        return p;
      }
      function u(p, v) {
        for (var m = 0; m < p.length; ++m) v[m] = 255 & p.charCodeAt(m);
        return v;
      }
      t("setimmediate"), i.newBlob = function(p, v) {
        i.checkSupport("blob");
        try {
          return new Blob([p], { type: v });
        } catch {
          try {
            var m = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return m.append(p), m.getBlob(v);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var c = { stringifyByChunk: function(p, v, m) {
        var b = [], w = 0, B = p.length;
        if (B <= m) return String.fromCharCode.apply(null, p);
        for (; w < B; ) v === "array" || v === "nodebuffer" ? b.push(String.fromCharCode.apply(null, p.slice(w, Math.min(w + m, B)))) : b.push(String.fromCharCode.apply(null, p.subarray(w, Math.min(w + m, B)))), w += m;
        return b.join("");
      }, stringifyByChar: function(p) {
        for (var v = "", m = 0; m < p.length; m++) v += String.fromCharCode(p[m]);
        return v;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return s.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return s.nodebuffer && String.fromCharCode.apply(null, o.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function h(p) {
        var v = 65536, m = i.getTypeOf(p), b = !0;
        if (m === "uint8array" ? b = c.applyCanBeUsed.uint8array : m === "nodebuffer" && (b = c.applyCanBeUsed.nodebuffer), b) for (; 1 < v; ) try {
          return c.stringifyByChunk(p, m, v);
        } catch {
          v = Math.floor(v / 2);
        }
        return c.stringifyByChar(p);
      }
      function f(p, v) {
        for (var m = 0; m < p.length; m++) v[m] = p[m];
        return v;
      }
      i.applyFromCharCode = h;
      var d = {};
      d.string = { string: l, array: function(p) {
        return u(p, new Array(p.length));
      }, arraybuffer: function(p) {
        return d.string.uint8array(p).buffer;
      }, uint8array: function(p) {
        return u(p, new Uint8Array(p.length));
      }, nodebuffer: function(p) {
        return u(p, o.allocBuffer(p.length));
      } }, d.array = { string: h, array: l, arraybuffer: function(p) {
        return new Uint8Array(p).buffer;
      }, uint8array: function(p) {
        return new Uint8Array(p);
      }, nodebuffer: function(p) {
        return o.newBufferFrom(p);
      } }, d.arraybuffer = { string: function(p) {
        return h(new Uint8Array(p));
      }, array: function(p) {
        return f(new Uint8Array(p), new Array(p.byteLength));
      }, arraybuffer: l, uint8array: function(p) {
        return new Uint8Array(p);
      }, nodebuffer: function(p) {
        return o.newBufferFrom(new Uint8Array(p));
      } }, d.uint8array = { string: h, array: function(p) {
        return f(p, new Array(p.length));
      }, arraybuffer: function(p) {
        return p.buffer;
      }, uint8array: l, nodebuffer: function(p) {
        return o.newBufferFrom(p);
      } }, d.nodebuffer = { string: h, array: function(p) {
        return f(p, new Array(p.length));
      }, arraybuffer: function(p) {
        return d.nodebuffer.uint8array(p).buffer;
      }, uint8array: function(p) {
        return f(p, new Uint8Array(p.length));
      }, nodebuffer: l }, i.transformTo = function(p, v) {
        if (v = v || "", !p) return v;
        i.checkSupport(p);
        var m = i.getTypeOf(v);
        return d[m][p](v);
      }, i.resolve = function(p) {
        for (var v = p.split("/"), m = [], b = 0; b < v.length; b++) {
          var w = v[b];
          w === "." || w === "" && b !== 0 && b !== v.length - 1 || (w === ".." ? m.pop() : m.push(w));
        }
        return m.join("/");
      }, i.getTypeOf = function(p) {
        return typeof p == "string" ? "string" : Object.prototype.toString.call(p) === "[object Array]" ? "array" : s.nodebuffer && o.isBuffer(p) ? "nodebuffer" : s.uint8array && p instanceof Uint8Array ? "uint8array" : s.arraybuffer && p instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, i.checkSupport = function(p) {
        if (!s[p.toLowerCase()]) throw new Error(p + " is not supported by this platform");
      }, i.MAX_VALUE_16BITS = 65535, i.MAX_VALUE_32BITS = -1, i.pretty = function(p) {
        var v, m, b = "";
        for (m = 0; m < (p || "").length; m++) b += "\\x" + ((v = p.charCodeAt(m)) < 16 ? "0" : "") + v.toString(16).toUpperCase();
        return b;
      }, i.delay = function(p, v, m) {
        setImmediate(function() {
          p.apply(m || null, v || []);
        });
      }, i.inherits = function(p, v) {
        function m() {
        }
        m.prototype = v.prototype, p.prototype = new m();
      }, i.extend = function() {
        var p, v, m = {};
        for (p = 0; p < arguments.length; p++) for (v in arguments[p]) Object.prototype.hasOwnProperty.call(arguments[p], v) && m[v] === void 0 && (m[v] = arguments[p][v]);
        return m;
      }, i.prepareContent = function(p, v, m, b, w) {
        return A.Promise.resolve(v).then(function(B) {
          return s.blob && (B instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(B)) !== -1) && typeof FileReader < "u" ? new A.Promise(function(_, x) {
            var C = new FileReader();
            C.onload = function(F) {
              _(F.target.result);
            }, C.onerror = function(F) {
              x(F.target.error);
            }, C.readAsArrayBuffer(B);
          }) : B;
        }).then(function(B) {
          var _ = i.getTypeOf(B);
          return _ ? (_ === "arraybuffer" ? B = i.transformTo("uint8array", B) : _ === "string" && (w ? B = a.decode(B) : m && b !== !0 && (B = function(x) {
            return u(x, s.uint8array ? new Uint8Array(x.length) : new Array(x.length));
          }(B))), B) : A.Promise.reject(new Error("Can't read the data of '" + p + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(t, n, i) {
      var s = t("./reader/readerFor"), a = t("./utils"), o = t("./signature"), A = t("./zipEntry"), l = t("./support");
      function u(c) {
        this.files = [], this.loadOptions = c;
      }
      u.prototype = { checkSignature: function(c) {
        if (!this.reader.readAndCheckSignature(c)) {
          this.reader.index -= 4;
          var h = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + a.pretty(h) + ", expected " + a.pretty(c) + ")");
        }
      }, isSignature: function(c, h) {
        var f = this.reader.index;
        this.reader.setIndex(c);
        var d = this.reader.readString(4) === h;
        return this.reader.setIndex(f), d;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var c = this.reader.readData(this.zipCommentLength), h = l.uint8array ? "uint8array" : "array", f = a.transformTo(h, c);
        this.zipComment = this.loadOptions.decodeFileName(f);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var c, h, f, d = this.zip64EndOfCentralSize - 44; 0 < d; ) c = this.reader.readInt(2), h = this.reader.readInt(4), f = this.reader.readData(h), this.zip64ExtensibleData[c] = { id: c, length: h, value: f };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var c, h;
        for (c = 0; c < this.files.length; c++) h = this.files[c], this.reader.setIndex(h.localHeaderOffset), this.checkSignature(o.LOCAL_FILE_HEADER), h.readLocalPart(this.reader), h.handleUTF8(), h.processAttributes();
      }, readCentralDir: function() {
        var c;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(o.CENTRAL_FILE_HEADER); ) (c = new A({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(c);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var c = this.reader.lastIndexOfSignature(o.CENTRAL_DIRECTORY_END);
        if (c < 0) throw this.isSignature(0, o.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(c);
        var h = c;
        if (this.checkSignature(o.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === a.MAX_VALUE_16BITS || this.diskWithCentralDirStart === a.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === a.MAX_VALUE_16BITS || this.centralDirRecords === a.MAX_VALUE_16BITS || this.centralDirSize === a.MAX_VALUE_32BITS || this.centralDirOffset === a.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (c = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(c), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, o.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var f = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (f += 20, f += 12 + this.zip64EndOfCentralSize);
        var d = h - f;
        if (0 < d) this.isSignature(h, o.CENTRAL_FILE_HEADER) || (this.reader.zero = d);
        else if (d < 0) throw new Error("Corrupted zip: missing " + Math.abs(d) + " bytes.");
      }, prepareReader: function(c) {
        this.reader = s(c);
      }, load: function(c) {
        this.prepareReader(c), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, n.exports = u;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(t, n, i) {
      var s = t("./reader/readerFor"), a = t("./utils"), o = t("./compressedObject"), A = t("./crc32"), l = t("./utf8"), u = t("./compressions"), c = t("./support");
      function h(f, d) {
        this.options = f, this.loadOptions = d;
      }
      h.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(f) {
        var d, p;
        if (f.skip(22), this.fileNameLength = f.readInt(2), p = f.readInt(2), this.fileName = f.readData(this.fileNameLength), f.skip(p), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((d = function(v) {
          for (var m in u) if (Object.prototype.hasOwnProperty.call(u, m) && u[m].magic === v) return u[m];
          return null;
        }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + a.pretty(this.compressionMethod) + " unknown (inner file : " + a.transformTo("string", this.fileName) + ")");
        this.decompressed = new o(this.compressedSize, this.uncompressedSize, this.crc32, d, f.readData(this.compressedSize));
      }, readCentralPart: function(f) {
        this.versionMadeBy = f.readInt(2), f.skip(2), this.bitFlag = f.readInt(2), this.compressionMethod = f.readString(2), this.date = f.readDate(), this.crc32 = f.readInt(4), this.compressedSize = f.readInt(4), this.uncompressedSize = f.readInt(4);
        var d = f.readInt(2);
        if (this.extraFieldsLength = f.readInt(2), this.fileCommentLength = f.readInt(2), this.diskNumberStart = f.readInt(2), this.internalFileAttributes = f.readInt(2), this.externalFileAttributes = f.readInt(4), this.localHeaderOffset = f.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
        f.skip(d), this.readExtraFields(f), this.parseZIP64ExtraField(f), this.fileComment = f.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var f = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), f == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), f == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var f = s(this.extraFields[1].value);
          this.uncompressedSize === a.MAX_VALUE_32BITS && (this.uncompressedSize = f.readInt(8)), this.compressedSize === a.MAX_VALUE_32BITS && (this.compressedSize = f.readInt(8)), this.localHeaderOffset === a.MAX_VALUE_32BITS && (this.localHeaderOffset = f.readInt(8)), this.diskNumberStart === a.MAX_VALUE_32BITS && (this.diskNumberStart = f.readInt(4));
        }
      }, readExtraFields: function(f) {
        var d, p, v, m = f.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); f.index + 4 < m; ) d = f.readInt(2), p = f.readInt(2), v = f.readData(p), this.extraFields[d] = { id: d, length: p, value: v };
        f.setIndex(m);
      }, handleUTF8: function() {
        var f = c.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) this.fileNameStr = l.utf8decode(this.fileName), this.fileCommentStr = l.utf8decode(this.fileComment);
        else {
          var d = this.findExtraFieldUnicodePath();
          if (d !== null) this.fileNameStr = d;
          else {
            var p = a.transformTo(f, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(p);
          }
          var v = this.findExtraFieldUnicodeComment();
          if (v !== null) this.fileCommentStr = v;
          else {
            var m = a.transformTo(f, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(m);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var f = this.extraFields[28789];
        if (f) {
          var d = s(f.value);
          return d.readInt(1) !== 1 || A(this.fileName) !== d.readInt(4) ? null : l.utf8decode(d.readData(f.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var f = this.extraFields[25461];
        if (f) {
          var d = s(f.value);
          return d.readInt(1) !== 1 || A(this.fileComment) !== d.readInt(4) ? null : l.utf8decode(d.readData(f.length - 5));
        }
        return null;
      } }, n.exports = h;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(t, n, i) {
      function s(d, p, v) {
        this.name = d, this.dir = v.dir, this.date = v.date, this.comment = v.comment, this.unixPermissions = v.unixPermissions, this.dosPermissions = v.dosPermissions, this._data = p, this._dataBinary = v.binary, this.options = { compression: v.compression, compressionOptions: v.compressionOptions };
      }
      var a = t("./stream/StreamHelper"), o = t("./stream/DataWorker"), A = t("./utf8"), l = t("./compressedObject"), u = t("./stream/GenericWorker");
      s.prototype = { internalStream: function(d) {
        var p = null, v = "string";
        try {
          if (!d) throw new Error("No output type specified.");
          var m = (v = d.toLowerCase()) === "string" || v === "text";
          v !== "binarystring" && v !== "text" || (v = "string"), p = this._decompressWorker();
          var b = !this._dataBinary;
          b && !m && (p = p.pipe(new A.Utf8EncodeWorker())), !b && m && (p = p.pipe(new A.Utf8DecodeWorker()));
        } catch (w) {
          (p = new u("error")).error(w);
        }
        return new a(p, v, "");
      }, async: function(d, p) {
        return this.internalStream(d).accumulate(p);
      }, nodeStream: function(d, p) {
        return this.internalStream(d || "nodebuffer").toNodejsStream(p);
      }, _compressWorker: function(d, p) {
        if (this._data instanceof l && this._data.compression.magic === d.magic) return this._data.getCompressedWorker();
        var v = this._decompressWorker();
        return this._dataBinary || (v = v.pipe(new A.Utf8EncodeWorker())), l.createWorkerFrom(v, d, p);
      }, _decompressWorker: function() {
        return this._data instanceof l ? this._data.getContentWorker() : this._data instanceof u ? this._data : new o(this._data);
      } };
      for (var c = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], h = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, f = 0; f < c.length; f++) s.prototype[c[f]] = h;
      n.exports = s;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(t, n, i) {
      (function(s) {
        var a, o, A = s.MutationObserver || s.WebKitMutationObserver;
        if (A) {
          var l = 0, u = new A(d), c = s.document.createTextNode("");
          u.observe(c, { characterData: !0 }), a = function() {
            c.data = l = ++l % 2;
          };
        } else if (s.setImmediate || s.MessageChannel === void 0) a = "document" in s && "onreadystatechange" in s.document.createElement("script") ? function() {
          var p = s.document.createElement("script");
          p.onreadystatechange = function() {
            d(), p.onreadystatechange = null, p.parentNode.removeChild(p), p = null;
          }, s.document.documentElement.appendChild(p);
        } : function() {
          setTimeout(d, 0);
        };
        else {
          var h = new s.MessageChannel();
          h.port1.onmessage = d, a = function() {
            h.port2.postMessage(0);
          };
        }
        var f = [];
        function d() {
          var p, v;
          o = !0;
          for (var m = f.length; m; ) {
            for (v = f, f = [], p = -1; ++p < m; ) v[p]();
            m = f.length;
          }
          o = !1;
        }
        n.exports = function(p) {
          f.push(p) !== 1 || o || a();
        };
      }).call(this, typeof an < "u" ? an : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(t, n, i) {
      var s = t("immediate");
      function a() {
      }
      var o = {}, A = ["REJECTED"], l = ["FULFILLED"], u = ["PENDING"];
      function c(m) {
        if (typeof m != "function") throw new TypeError("resolver must be a function");
        this.state = u, this.queue = [], this.outcome = void 0, m !== a && p(this, m);
      }
      function h(m, b, w) {
        this.promise = m, typeof b == "function" && (this.onFulfilled = b, this.callFulfilled = this.otherCallFulfilled), typeof w == "function" && (this.onRejected = w, this.callRejected = this.otherCallRejected);
      }
      function f(m, b, w) {
        s(function() {
          var B;
          try {
            B = b(w);
          } catch (_) {
            return o.reject(m, _);
          }
          B === m ? o.reject(m, new TypeError("Cannot resolve promise with itself")) : o.resolve(m, B);
        });
      }
      function d(m) {
        var b = m && m.then;
        if (m && (typeof m == "object" || typeof m == "function") && typeof b == "function") return function() {
          b.apply(m, arguments);
        };
      }
      function p(m, b) {
        var w = !1;
        function B(C) {
          w || (w = !0, o.reject(m, C));
        }
        function _(C) {
          w || (w = !0, o.resolve(m, C));
        }
        var x = v(function() {
          b(_, B);
        });
        x.status === "error" && B(x.value);
      }
      function v(m, b) {
        var w = {};
        try {
          w.value = m(b), w.status = "success";
        } catch (B) {
          w.status = "error", w.value = B;
        }
        return w;
      }
      (n.exports = c).prototype.finally = function(m) {
        if (typeof m != "function") return this;
        var b = this.constructor;
        return this.then(function(w) {
          return b.resolve(m()).then(function() {
            return w;
          });
        }, function(w) {
          return b.resolve(m()).then(function() {
            throw w;
          });
        });
      }, c.prototype.catch = function(m) {
        return this.then(null, m);
      }, c.prototype.then = function(m, b) {
        if (typeof m != "function" && this.state === l || typeof b != "function" && this.state === A) return this;
        var w = new this.constructor(a);
        return this.state !== u ? f(w, this.state === l ? m : b, this.outcome) : this.queue.push(new h(w, m, b)), w;
      }, h.prototype.callFulfilled = function(m) {
        o.resolve(this.promise, m);
      }, h.prototype.otherCallFulfilled = function(m) {
        f(this.promise, this.onFulfilled, m);
      }, h.prototype.callRejected = function(m) {
        o.reject(this.promise, m);
      }, h.prototype.otherCallRejected = function(m) {
        f(this.promise, this.onRejected, m);
      }, o.resolve = function(m, b) {
        var w = v(d, b);
        if (w.status === "error") return o.reject(m, w.value);
        var B = w.value;
        if (B) p(m, B);
        else {
          m.state = l, m.outcome = b;
          for (var _ = -1, x = m.queue.length; ++_ < x; ) m.queue[_].callFulfilled(b);
        }
        return m;
      }, o.reject = function(m, b) {
        m.state = A, m.outcome = b;
        for (var w = -1, B = m.queue.length; ++w < B; ) m.queue[w].callRejected(b);
        return m;
      }, c.resolve = function(m) {
        return m instanceof this ? m : o.resolve(new this(a), m);
      }, c.reject = function(m) {
        var b = new this(a);
        return o.reject(b, m);
      }, c.all = function(m) {
        var b = this;
        if (Object.prototype.toString.call(m) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var w = m.length, B = !1;
        if (!w) return this.resolve([]);
        for (var _ = new Array(w), x = 0, C = -1, F = new this(a); ++C < w; ) N(m[C], C);
        return F;
        function N(D, T) {
          b.resolve(D).then(function(E) {
            _[T] = E, ++x !== w || B || (B = !0, o.resolve(F, _));
          }, function(E) {
            B || (B = !0, o.reject(F, E));
          });
        }
      }, c.race = function(m) {
        var b = this;
        if (Object.prototype.toString.call(m) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var w = m.length, B = !1;
        if (!w) return this.resolve([]);
        for (var _ = -1, x = new this(a); ++_ < w; ) C = m[_], b.resolve(C).then(function(F) {
          B || (B = !0, o.resolve(x, F));
        }, function(F) {
          B || (B = !0, o.reject(x, F));
        });
        var C;
        return x;
      };
    }, { immediate: 36 }], 38: [function(t, n, i) {
      var s = {};
      (0, t("./lib/utils/common").assign)(s, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")), n.exports = s;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(t, n, i) {
      var s = t("./zlib/deflate"), a = t("./utils/common"), o = t("./utils/strings"), A = t("./zlib/messages"), l = t("./zlib/zstream"), u = Object.prototype.toString, c = 0, h = -1, f = 0, d = 8;
      function p(m) {
        if (!(this instanceof p)) return new p(m);
        this.options = a.assign({ level: h, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: f, to: "" }, m || {});
        var b = this.options;
        b.raw && 0 < b.windowBits ? b.windowBits = -b.windowBits : b.gzip && 0 < b.windowBits && b.windowBits < 16 && (b.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new l(), this.strm.avail_out = 0;
        var w = s.deflateInit2(this.strm, b.level, b.method, b.windowBits, b.memLevel, b.strategy);
        if (w !== c) throw new Error(A[w]);
        if (b.header && s.deflateSetHeader(this.strm, b.header), b.dictionary) {
          var B;
          if (B = typeof b.dictionary == "string" ? o.string2buf(b.dictionary) : u.call(b.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(b.dictionary) : b.dictionary, (w = s.deflateSetDictionary(this.strm, B)) !== c) throw new Error(A[w]);
          this._dict_set = !0;
        }
      }
      function v(m, b) {
        var w = new p(b);
        if (w.push(m, !0), w.err) throw w.msg || A[w.err];
        return w.result;
      }
      p.prototype.push = function(m, b) {
        var w, B, _ = this.strm, x = this.options.chunkSize;
        if (this.ended) return !1;
        B = b === ~~b ? b : b === !0 ? 4 : 0, typeof m == "string" ? _.input = o.string2buf(m) : u.call(m) === "[object ArrayBuffer]" ? _.input = new Uint8Array(m) : _.input = m, _.next_in = 0, _.avail_in = _.input.length;
        do {
          if (_.avail_out === 0 && (_.output = new a.Buf8(x), _.next_out = 0, _.avail_out = x), (w = s.deflate(_, B)) !== 1 && w !== c) return this.onEnd(w), !(this.ended = !0);
          _.avail_out !== 0 && (_.avail_in !== 0 || B !== 4 && B !== 2) || (this.options.to === "string" ? this.onData(o.buf2binstring(a.shrinkBuf(_.output, _.next_out))) : this.onData(a.shrinkBuf(_.output, _.next_out)));
        } while ((0 < _.avail_in || _.avail_out === 0) && w !== 1);
        return B === 4 ? (w = s.deflateEnd(this.strm), this.onEnd(w), this.ended = !0, w === c) : B !== 2 || (this.onEnd(c), !(_.avail_out = 0));
      }, p.prototype.onData = function(m) {
        this.chunks.push(m);
      }, p.prototype.onEnd = function(m) {
        m === c && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = a.flattenChunks(this.chunks)), this.chunks = [], this.err = m, this.msg = this.strm.msg;
      }, i.Deflate = p, i.deflate = v, i.deflateRaw = function(m, b) {
        return (b = b || {}).raw = !0, v(m, b);
      }, i.gzip = function(m, b) {
        return (b = b || {}).gzip = !0, v(m, b);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(t, n, i) {
      var s = t("./zlib/inflate"), a = t("./utils/common"), o = t("./utils/strings"), A = t("./zlib/constants"), l = t("./zlib/messages"), u = t("./zlib/zstream"), c = t("./zlib/gzheader"), h = Object.prototype.toString;
      function f(p) {
        if (!(this instanceof f)) return new f(p);
        this.options = a.assign({ chunkSize: 16384, windowBits: 0, to: "" }, p || {});
        var v = this.options;
        v.raw && 0 <= v.windowBits && v.windowBits < 16 && (v.windowBits = -v.windowBits, v.windowBits === 0 && (v.windowBits = -15)), !(0 <= v.windowBits && v.windowBits < 16) || p && p.windowBits || (v.windowBits += 32), 15 < v.windowBits && v.windowBits < 48 && !(15 & v.windowBits) && (v.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new u(), this.strm.avail_out = 0;
        var m = s.inflateInit2(this.strm, v.windowBits);
        if (m !== A.Z_OK) throw new Error(l[m]);
        this.header = new c(), s.inflateGetHeader(this.strm, this.header);
      }
      function d(p, v) {
        var m = new f(v);
        if (m.push(p, !0), m.err) throw m.msg || l[m.err];
        return m.result;
      }
      f.prototype.push = function(p, v) {
        var m, b, w, B, _, x, C = this.strm, F = this.options.chunkSize, N = this.options.dictionary, D = !1;
        if (this.ended) return !1;
        b = v === ~~v ? v : v === !0 ? A.Z_FINISH : A.Z_NO_FLUSH, typeof p == "string" ? C.input = o.binstring2buf(p) : h.call(p) === "[object ArrayBuffer]" ? C.input = new Uint8Array(p) : C.input = p, C.next_in = 0, C.avail_in = C.input.length;
        do {
          if (C.avail_out === 0 && (C.output = new a.Buf8(F), C.next_out = 0, C.avail_out = F), (m = s.inflate(C, A.Z_NO_FLUSH)) === A.Z_NEED_DICT && N && (x = typeof N == "string" ? o.string2buf(N) : h.call(N) === "[object ArrayBuffer]" ? new Uint8Array(N) : N, m = s.inflateSetDictionary(this.strm, x)), m === A.Z_BUF_ERROR && D === !0 && (m = A.Z_OK, D = !1), m !== A.Z_STREAM_END && m !== A.Z_OK) return this.onEnd(m), !(this.ended = !0);
          C.next_out && (C.avail_out !== 0 && m !== A.Z_STREAM_END && (C.avail_in !== 0 || b !== A.Z_FINISH && b !== A.Z_SYNC_FLUSH) || (this.options.to === "string" ? (w = o.utf8border(C.output, C.next_out), B = C.next_out - w, _ = o.buf2string(C.output, w), C.next_out = B, C.avail_out = F - B, B && a.arraySet(C.output, C.output, w, B, 0), this.onData(_)) : this.onData(a.shrinkBuf(C.output, C.next_out)))), C.avail_in === 0 && C.avail_out === 0 && (D = !0);
        } while ((0 < C.avail_in || C.avail_out === 0) && m !== A.Z_STREAM_END);
        return m === A.Z_STREAM_END && (b = A.Z_FINISH), b === A.Z_FINISH ? (m = s.inflateEnd(this.strm), this.onEnd(m), this.ended = !0, m === A.Z_OK) : b !== A.Z_SYNC_FLUSH || (this.onEnd(A.Z_OK), !(C.avail_out = 0));
      }, f.prototype.onData = function(p) {
        this.chunks.push(p);
      }, f.prototype.onEnd = function(p) {
        p === A.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = a.flattenChunks(this.chunks)), this.chunks = [], this.err = p, this.msg = this.strm.msg;
      }, i.Inflate = f, i.inflate = d, i.inflateRaw = function(p, v) {
        return (v = v || {}).raw = !0, d(p, v);
      }, i.ungzip = d;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(t, n, i) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      i.assign = function(A) {
        for (var l = Array.prototype.slice.call(arguments, 1); l.length; ) {
          var u = l.shift();
          if (u) {
            if (typeof u != "object") throw new TypeError(u + "must be non-object");
            for (var c in u) u.hasOwnProperty(c) && (A[c] = u[c]);
          }
        }
        return A;
      }, i.shrinkBuf = function(A, l) {
        return A.length === l ? A : A.subarray ? A.subarray(0, l) : (A.length = l, A);
      };
      var a = { arraySet: function(A, l, u, c, h) {
        if (l.subarray && A.subarray) A.set(l.subarray(u, u + c), h);
        else for (var f = 0; f < c; f++) A[h + f] = l[u + f];
      }, flattenChunks: function(A) {
        var l, u, c, h, f, d;
        for (l = c = 0, u = A.length; l < u; l++) c += A[l].length;
        for (d = new Uint8Array(c), l = h = 0, u = A.length; l < u; l++) f = A[l], d.set(f, h), h += f.length;
        return d;
      } }, o = { arraySet: function(A, l, u, c, h) {
        for (var f = 0; f < c; f++) A[h + f] = l[u + f];
      }, flattenChunks: function(A) {
        return [].concat.apply([], A);
      } };
      i.setTyped = function(A) {
        A ? (i.Buf8 = Uint8Array, i.Buf16 = Uint16Array, i.Buf32 = Int32Array, i.assign(i, a)) : (i.Buf8 = Array, i.Buf16 = Array, i.Buf32 = Array, i.assign(i, o));
      }, i.setTyped(s);
    }, {}], 42: [function(t, n, i) {
      var s = t("./common"), a = !0, o = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        a = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        o = !1;
      }
      for (var A = new s.Buf8(256), l = 0; l < 256; l++) A[l] = 252 <= l ? 6 : 248 <= l ? 5 : 240 <= l ? 4 : 224 <= l ? 3 : 192 <= l ? 2 : 1;
      function u(c, h) {
        if (h < 65537 && (c.subarray && o || !c.subarray && a)) return String.fromCharCode.apply(null, s.shrinkBuf(c, h));
        for (var f = "", d = 0; d < h; d++) f += String.fromCharCode(c[d]);
        return f;
      }
      A[254] = A[254] = 1, i.string2buf = function(c) {
        var h, f, d, p, v, m = c.length, b = 0;
        for (p = 0; p < m; p++) (64512 & (f = c.charCodeAt(p))) == 55296 && p + 1 < m && (64512 & (d = c.charCodeAt(p + 1))) == 56320 && (f = 65536 + (f - 55296 << 10) + (d - 56320), p++), b += f < 128 ? 1 : f < 2048 ? 2 : f < 65536 ? 3 : 4;
        for (h = new s.Buf8(b), p = v = 0; v < b; p++) (64512 & (f = c.charCodeAt(p))) == 55296 && p + 1 < m && (64512 & (d = c.charCodeAt(p + 1))) == 56320 && (f = 65536 + (f - 55296 << 10) + (d - 56320), p++), f < 128 ? h[v++] = f : (f < 2048 ? h[v++] = 192 | f >>> 6 : (f < 65536 ? h[v++] = 224 | f >>> 12 : (h[v++] = 240 | f >>> 18, h[v++] = 128 | f >>> 12 & 63), h[v++] = 128 | f >>> 6 & 63), h[v++] = 128 | 63 & f);
        return h;
      }, i.buf2binstring = function(c) {
        return u(c, c.length);
      }, i.binstring2buf = function(c) {
        for (var h = new s.Buf8(c.length), f = 0, d = h.length; f < d; f++) h[f] = c.charCodeAt(f);
        return h;
      }, i.buf2string = function(c, h) {
        var f, d, p, v, m = h || c.length, b = new Array(2 * m);
        for (f = d = 0; f < m; ) if ((p = c[f++]) < 128) b[d++] = p;
        else if (4 < (v = A[p])) b[d++] = 65533, f += v - 1;
        else {
          for (p &= v === 2 ? 31 : v === 3 ? 15 : 7; 1 < v && f < m; ) p = p << 6 | 63 & c[f++], v--;
          1 < v ? b[d++] = 65533 : p < 65536 ? b[d++] = p : (p -= 65536, b[d++] = 55296 | p >> 10 & 1023, b[d++] = 56320 | 1023 & p);
        }
        return u(b, d);
      }, i.utf8border = function(c, h) {
        var f;
        for ((h = h || c.length) > c.length && (h = c.length), f = h - 1; 0 <= f && (192 & c[f]) == 128; ) f--;
        return f < 0 || f === 0 ? h : f + A[c[f]] > h ? f : h;
      };
    }, { "./common": 41 }], 43: [function(t, n, i) {
      n.exports = function(s, a, o, A) {
        for (var l = 65535 & s | 0, u = s >>> 16 & 65535 | 0, c = 0; o !== 0; ) {
          for (o -= c = 2e3 < o ? 2e3 : o; u = u + (l = l + a[A++] | 0) | 0, --c; ) ;
          l %= 65521, u %= 65521;
        }
        return l | u << 16 | 0;
      };
    }, {}], 44: [function(t, n, i) {
      n.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(t, n, i) {
      var s = function() {
        for (var a, o = [], A = 0; A < 256; A++) {
          a = A;
          for (var l = 0; l < 8; l++) a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
          o[A] = a;
        }
        return o;
      }();
      n.exports = function(a, o, A, l) {
        var u = s, c = l + A;
        a ^= -1;
        for (var h = l; h < c; h++) a = a >>> 8 ^ u[255 & (a ^ o[h])];
        return -1 ^ a;
      };
    }, {}], 46: [function(t, n, i) {
      var s, a = t("../utils/common"), o = t("./trees"), A = t("./adler32"), l = t("./crc32"), u = t("./messages"), c = 0, h = 4, f = 0, d = -2, p = -1, v = 4, m = 2, b = 8, w = 9, B = 286, _ = 30, x = 19, C = 2 * B + 1, F = 15, N = 3, D = 258, T = D + N + 1, E = 42, L = 113, S = 1, X = 2, z = 3, R = 4;
      function V(M, Ae) {
        return M.msg = u[Ae], Ae;
      }
      function O(M) {
        return (M << 1) - (4 < M ? 9 : 0);
      }
      function J(M) {
        for (var Ae = M.length; 0 <= --Ae; ) M[Ae] = 0;
      }
      function Z(M) {
        var Ae = M.state, G = Ae.pending;
        G > M.avail_out && (G = M.avail_out), G !== 0 && (a.arraySet(M.output, Ae.pending_buf, Ae.pending_out, G, M.next_out), M.next_out += G, Ae.pending_out += G, M.total_out += G, M.avail_out -= G, Ae.pending -= G, Ae.pending === 0 && (Ae.pending_out = 0));
      }
      function U(M, Ae) {
        o._tr_flush_block(M, 0 <= M.block_start ? M.block_start : -1, M.strstart - M.block_start, Ae), M.block_start = M.strstart, Z(M.strm);
      }
      function P(M, Ae) {
        M.pending_buf[M.pending++] = Ae;
      }
      function H(M, Ae) {
        M.pending_buf[M.pending++] = Ae >>> 8 & 255, M.pending_buf[M.pending++] = 255 & Ae;
      }
      function $(M, Ae) {
        var G, ne, ee = M.max_chain_length, ae = M.strstart, re = M.prev_length, ce = M.nice_match, le = M.strstart > M.w_size - T ? M.strstart - (M.w_size - T) : 0, Te = M.window, Oe = M.w_mask, Ue = M.prev, Ge = M.strstart + D, at = Te[ae + re - 1], it = Te[ae + re];
        M.prev_length >= M.good_match && (ee >>= 2), ce > M.lookahead && (ce = M.lookahead);
        do
          if (Te[(G = Ae) + re] === it && Te[G + re - 1] === at && Te[G] === Te[ae] && Te[++G] === Te[ae + 1]) {
            ae += 2, G++;
            do
              ;
            while (Te[++ae] === Te[++G] && Te[++ae] === Te[++G] && Te[++ae] === Te[++G] && Te[++ae] === Te[++G] && Te[++ae] === Te[++G] && Te[++ae] === Te[++G] && Te[++ae] === Te[++G] && Te[++ae] === Te[++G] && ae < Ge);
            if (ne = D - (Ge - ae), ae = Ge - D, re < ne) {
              if (M.match_start = Ae, ce <= (re = ne)) break;
              at = Te[ae + re - 1], it = Te[ae + re];
            }
          }
        while ((Ae = Ue[Ae & Oe]) > le && --ee != 0);
        return re <= M.lookahead ? re : M.lookahead;
      }
      function ie(M) {
        var Ae, G, ne, ee, ae, re, ce, le, Te, Oe, Ue = M.w_size;
        do {
          if (ee = M.window_size - M.lookahead - M.strstart, M.strstart >= Ue + (Ue - T)) {
            for (a.arraySet(M.window, M.window, Ue, Ue, 0), M.match_start -= Ue, M.strstart -= Ue, M.block_start -= Ue, Ae = G = M.hash_size; ne = M.head[--Ae], M.head[Ae] = Ue <= ne ? ne - Ue : 0, --G; ) ;
            for (Ae = G = Ue; ne = M.prev[--Ae], M.prev[Ae] = Ue <= ne ? ne - Ue : 0, --G; ) ;
            ee += Ue;
          }
          if (M.strm.avail_in === 0) break;
          if (re = M.strm, ce = M.window, le = M.strstart + M.lookahead, Te = ee, Oe = void 0, Oe = re.avail_in, Te < Oe && (Oe = Te), G = Oe === 0 ? 0 : (re.avail_in -= Oe, a.arraySet(ce, re.input, re.next_in, Oe, le), re.state.wrap === 1 ? re.adler = A(re.adler, ce, Oe, le) : re.state.wrap === 2 && (re.adler = l(re.adler, ce, Oe, le)), re.next_in += Oe, re.total_in += Oe, Oe), M.lookahead += G, M.lookahead + M.insert >= N) for (ae = M.strstart - M.insert, M.ins_h = M.window[ae], M.ins_h = (M.ins_h << M.hash_shift ^ M.window[ae + 1]) & M.hash_mask; M.insert && (M.ins_h = (M.ins_h << M.hash_shift ^ M.window[ae + N - 1]) & M.hash_mask, M.prev[ae & M.w_mask] = M.head[M.ins_h], M.head[M.ins_h] = ae, ae++, M.insert--, !(M.lookahead + M.insert < N)); ) ;
        } while (M.lookahead < T && M.strm.avail_in !== 0);
      }
      function ue(M, Ae) {
        for (var G, ne; ; ) {
          if (M.lookahead < T) {
            if (ie(M), M.lookahead < T && Ae === c) return S;
            if (M.lookahead === 0) break;
          }
          if (G = 0, M.lookahead >= N && (M.ins_h = (M.ins_h << M.hash_shift ^ M.window[M.strstart + N - 1]) & M.hash_mask, G = M.prev[M.strstart & M.w_mask] = M.head[M.ins_h], M.head[M.ins_h] = M.strstart), G !== 0 && M.strstart - G <= M.w_size - T && (M.match_length = $(M, G)), M.match_length >= N) if (ne = o._tr_tally(M, M.strstart - M.match_start, M.match_length - N), M.lookahead -= M.match_length, M.match_length <= M.max_lazy_match && M.lookahead >= N) {
            for (M.match_length--; M.strstart++, M.ins_h = (M.ins_h << M.hash_shift ^ M.window[M.strstart + N - 1]) & M.hash_mask, G = M.prev[M.strstart & M.w_mask] = M.head[M.ins_h], M.head[M.ins_h] = M.strstart, --M.match_length != 0; ) ;
            M.strstart++;
          } else M.strstart += M.match_length, M.match_length = 0, M.ins_h = M.window[M.strstart], M.ins_h = (M.ins_h << M.hash_shift ^ M.window[M.strstart + 1]) & M.hash_mask;
          else ne = o._tr_tally(M, 0, M.window[M.strstart]), M.lookahead--, M.strstart++;
          if (ne && (U(M, !1), M.strm.avail_out === 0)) return S;
        }
        return M.insert = M.strstart < N - 1 ? M.strstart : N - 1, Ae === h ? (U(M, !0), M.strm.avail_out === 0 ? z : R) : M.last_lit && (U(M, !1), M.strm.avail_out === 0) ? S : X;
      }
      function he(M, Ae) {
        for (var G, ne, ee; ; ) {
          if (M.lookahead < T) {
            if (ie(M), M.lookahead < T && Ae === c) return S;
            if (M.lookahead === 0) break;
          }
          if (G = 0, M.lookahead >= N && (M.ins_h = (M.ins_h << M.hash_shift ^ M.window[M.strstart + N - 1]) & M.hash_mask, G = M.prev[M.strstart & M.w_mask] = M.head[M.ins_h], M.head[M.ins_h] = M.strstart), M.prev_length = M.match_length, M.prev_match = M.match_start, M.match_length = N - 1, G !== 0 && M.prev_length < M.max_lazy_match && M.strstart - G <= M.w_size - T && (M.match_length = $(M, G), M.match_length <= 5 && (M.strategy === 1 || M.match_length === N && 4096 < M.strstart - M.match_start) && (M.match_length = N - 1)), M.prev_length >= N && M.match_length <= M.prev_length) {
            for (ee = M.strstart + M.lookahead - N, ne = o._tr_tally(M, M.strstart - 1 - M.prev_match, M.prev_length - N), M.lookahead -= M.prev_length - 1, M.prev_length -= 2; ++M.strstart <= ee && (M.ins_h = (M.ins_h << M.hash_shift ^ M.window[M.strstart + N - 1]) & M.hash_mask, G = M.prev[M.strstart & M.w_mask] = M.head[M.ins_h], M.head[M.ins_h] = M.strstart), --M.prev_length != 0; ) ;
            if (M.match_available = 0, M.match_length = N - 1, M.strstart++, ne && (U(M, !1), M.strm.avail_out === 0)) return S;
          } else if (M.match_available) {
            if ((ne = o._tr_tally(M, 0, M.window[M.strstart - 1])) && U(M, !1), M.strstart++, M.lookahead--, M.strm.avail_out === 0) return S;
          } else M.match_available = 1, M.strstart++, M.lookahead--;
        }
        return M.match_available && (ne = o._tr_tally(M, 0, M.window[M.strstart - 1]), M.match_available = 0), M.insert = M.strstart < N - 1 ? M.strstart : N - 1, Ae === h ? (U(M, !0), M.strm.avail_out === 0 ? z : R) : M.last_lit && (U(M, !1), M.strm.avail_out === 0) ? S : X;
      }
      function ve(M, Ae, G, ne, ee) {
        this.good_length = M, this.max_lazy = Ae, this.nice_length = G, this.max_chain = ne, this.func = ee;
      }
      function Le() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = b, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new a.Buf16(2 * C), this.dyn_dtree = new a.Buf16(2 * (2 * _ + 1)), this.bl_tree = new a.Buf16(2 * (2 * x + 1)), J(this.dyn_ltree), J(this.dyn_dtree), J(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new a.Buf16(F + 1), this.heap = new a.Buf16(2 * B + 1), J(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new a.Buf16(2 * B + 1), J(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function de(M) {
        var Ae;
        return M && M.state ? (M.total_in = M.total_out = 0, M.data_type = m, (Ae = M.state).pending = 0, Ae.pending_out = 0, Ae.wrap < 0 && (Ae.wrap = -Ae.wrap), Ae.status = Ae.wrap ? E : L, M.adler = Ae.wrap === 2 ? 0 : 1, Ae.last_flush = c, o._tr_init(Ae), f) : V(M, d);
      }
      function Ce(M) {
        var Ae = de(M);
        return Ae === f && function(G) {
          G.window_size = 2 * G.w_size, J(G.head), G.max_lazy_match = s[G.level].max_lazy, G.good_match = s[G.level].good_length, G.nice_match = s[G.level].nice_length, G.max_chain_length = s[G.level].max_chain, G.strstart = 0, G.block_start = 0, G.lookahead = 0, G.insert = 0, G.match_length = G.prev_length = N - 1, G.match_available = 0, G.ins_h = 0;
        }(M.state), Ae;
      }
      function Qe(M, Ae, G, ne, ee, ae) {
        if (!M) return d;
        var re = 1;
        if (Ae === p && (Ae = 6), ne < 0 ? (re = 0, ne = -ne) : 15 < ne && (re = 2, ne -= 16), ee < 1 || w < ee || G !== b || ne < 8 || 15 < ne || Ae < 0 || 9 < Ae || ae < 0 || v < ae) return V(M, d);
        ne === 8 && (ne = 9);
        var ce = new Le();
        return (M.state = ce).strm = M, ce.wrap = re, ce.gzhead = null, ce.w_bits = ne, ce.w_size = 1 << ce.w_bits, ce.w_mask = ce.w_size - 1, ce.hash_bits = ee + 7, ce.hash_size = 1 << ce.hash_bits, ce.hash_mask = ce.hash_size - 1, ce.hash_shift = ~~((ce.hash_bits + N - 1) / N), ce.window = new a.Buf8(2 * ce.w_size), ce.head = new a.Buf16(ce.hash_size), ce.prev = new a.Buf16(ce.w_size), ce.lit_bufsize = 1 << ee + 6, ce.pending_buf_size = 4 * ce.lit_bufsize, ce.pending_buf = new a.Buf8(ce.pending_buf_size), ce.d_buf = 1 * ce.lit_bufsize, ce.l_buf = 3 * ce.lit_bufsize, ce.level = Ae, ce.strategy = ae, ce.method = G, Ce(M);
      }
      s = [new ve(0, 0, 0, 0, function(M, Ae) {
        var G = 65535;
        for (G > M.pending_buf_size - 5 && (G = M.pending_buf_size - 5); ; ) {
          if (M.lookahead <= 1) {
            if (ie(M), M.lookahead === 0 && Ae === c) return S;
            if (M.lookahead === 0) break;
          }
          M.strstart += M.lookahead, M.lookahead = 0;
          var ne = M.block_start + G;
          if ((M.strstart === 0 || M.strstart >= ne) && (M.lookahead = M.strstart - ne, M.strstart = ne, U(M, !1), M.strm.avail_out === 0) || M.strstart - M.block_start >= M.w_size - T && (U(M, !1), M.strm.avail_out === 0)) return S;
        }
        return M.insert = 0, Ae === h ? (U(M, !0), M.strm.avail_out === 0 ? z : R) : (M.strstart > M.block_start && (U(M, !1), M.strm.avail_out), S);
      }), new ve(4, 4, 8, 4, ue), new ve(4, 5, 16, 8, ue), new ve(4, 6, 32, 32, ue), new ve(4, 4, 16, 16, he), new ve(8, 16, 32, 32, he), new ve(8, 16, 128, 128, he), new ve(8, 32, 128, 256, he), new ve(32, 128, 258, 1024, he), new ve(32, 258, 258, 4096, he)], i.deflateInit = function(M, Ae) {
        return Qe(M, Ae, b, 15, 8, 0);
      }, i.deflateInit2 = Qe, i.deflateReset = Ce, i.deflateResetKeep = de, i.deflateSetHeader = function(M, Ae) {
        return M && M.state ? M.state.wrap !== 2 ? d : (M.state.gzhead = Ae, f) : d;
      }, i.deflate = function(M, Ae) {
        var G, ne, ee, ae;
        if (!M || !M.state || 5 < Ae || Ae < 0) return M ? V(M, d) : d;
        if (ne = M.state, !M.output || !M.input && M.avail_in !== 0 || ne.status === 666 && Ae !== h) return V(M, M.avail_out === 0 ? -5 : d);
        if (ne.strm = M, G = ne.last_flush, ne.last_flush = Ae, ne.status === E) if (ne.wrap === 2) M.adler = 0, P(ne, 31), P(ne, 139), P(ne, 8), ne.gzhead ? (P(ne, (ne.gzhead.text ? 1 : 0) + (ne.gzhead.hcrc ? 2 : 0) + (ne.gzhead.extra ? 4 : 0) + (ne.gzhead.name ? 8 : 0) + (ne.gzhead.comment ? 16 : 0)), P(ne, 255 & ne.gzhead.time), P(ne, ne.gzhead.time >> 8 & 255), P(ne, ne.gzhead.time >> 16 & 255), P(ne, ne.gzhead.time >> 24 & 255), P(ne, ne.level === 9 ? 2 : 2 <= ne.strategy || ne.level < 2 ? 4 : 0), P(ne, 255 & ne.gzhead.os), ne.gzhead.extra && ne.gzhead.extra.length && (P(ne, 255 & ne.gzhead.extra.length), P(ne, ne.gzhead.extra.length >> 8 & 255)), ne.gzhead.hcrc && (M.adler = l(M.adler, ne.pending_buf, ne.pending, 0)), ne.gzindex = 0, ne.status = 69) : (P(ne, 0), P(ne, 0), P(ne, 0), P(ne, 0), P(ne, 0), P(ne, ne.level === 9 ? 2 : 2 <= ne.strategy || ne.level < 2 ? 4 : 0), P(ne, 3), ne.status = L);
        else {
          var re = b + (ne.w_bits - 8 << 4) << 8;
          re |= (2 <= ne.strategy || ne.level < 2 ? 0 : ne.level < 6 ? 1 : ne.level === 6 ? 2 : 3) << 6, ne.strstart !== 0 && (re |= 32), re += 31 - re % 31, ne.status = L, H(ne, re), ne.strstart !== 0 && (H(ne, M.adler >>> 16), H(ne, 65535 & M.adler)), M.adler = 1;
        }
        if (ne.status === 69) if (ne.gzhead.extra) {
          for (ee = ne.pending; ne.gzindex < (65535 & ne.gzhead.extra.length) && (ne.pending !== ne.pending_buf_size || (ne.gzhead.hcrc && ne.pending > ee && (M.adler = l(M.adler, ne.pending_buf, ne.pending - ee, ee)), Z(M), ee = ne.pending, ne.pending !== ne.pending_buf_size)); ) P(ne, 255 & ne.gzhead.extra[ne.gzindex]), ne.gzindex++;
          ne.gzhead.hcrc && ne.pending > ee && (M.adler = l(M.adler, ne.pending_buf, ne.pending - ee, ee)), ne.gzindex === ne.gzhead.extra.length && (ne.gzindex = 0, ne.status = 73);
        } else ne.status = 73;
        if (ne.status === 73) if (ne.gzhead.name) {
          ee = ne.pending;
          do {
            if (ne.pending === ne.pending_buf_size && (ne.gzhead.hcrc && ne.pending > ee && (M.adler = l(M.adler, ne.pending_buf, ne.pending - ee, ee)), Z(M), ee = ne.pending, ne.pending === ne.pending_buf_size)) {
              ae = 1;
              break;
            }
            ae = ne.gzindex < ne.gzhead.name.length ? 255 & ne.gzhead.name.charCodeAt(ne.gzindex++) : 0, P(ne, ae);
          } while (ae !== 0);
          ne.gzhead.hcrc && ne.pending > ee && (M.adler = l(M.adler, ne.pending_buf, ne.pending - ee, ee)), ae === 0 && (ne.gzindex = 0, ne.status = 91);
        } else ne.status = 91;
        if (ne.status === 91) if (ne.gzhead.comment) {
          ee = ne.pending;
          do {
            if (ne.pending === ne.pending_buf_size && (ne.gzhead.hcrc && ne.pending > ee && (M.adler = l(M.adler, ne.pending_buf, ne.pending - ee, ee)), Z(M), ee = ne.pending, ne.pending === ne.pending_buf_size)) {
              ae = 1;
              break;
            }
            ae = ne.gzindex < ne.gzhead.comment.length ? 255 & ne.gzhead.comment.charCodeAt(ne.gzindex++) : 0, P(ne, ae);
          } while (ae !== 0);
          ne.gzhead.hcrc && ne.pending > ee && (M.adler = l(M.adler, ne.pending_buf, ne.pending - ee, ee)), ae === 0 && (ne.status = 103);
        } else ne.status = 103;
        if (ne.status === 103 && (ne.gzhead.hcrc ? (ne.pending + 2 > ne.pending_buf_size && Z(M), ne.pending + 2 <= ne.pending_buf_size && (P(ne, 255 & M.adler), P(ne, M.adler >> 8 & 255), M.adler = 0, ne.status = L)) : ne.status = L), ne.pending !== 0) {
          if (Z(M), M.avail_out === 0) return ne.last_flush = -1, f;
        } else if (M.avail_in === 0 && O(Ae) <= O(G) && Ae !== h) return V(M, -5);
        if (ne.status === 666 && M.avail_in !== 0) return V(M, -5);
        if (M.avail_in !== 0 || ne.lookahead !== 0 || Ae !== c && ne.status !== 666) {
          var ce = ne.strategy === 2 ? function(le, Te) {
            for (var Oe; ; ) {
              if (le.lookahead === 0 && (ie(le), le.lookahead === 0)) {
                if (Te === c) return S;
                break;
              }
              if (le.match_length = 0, Oe = o._tr_tally(le, 0, le.window[le.strstart]), le.lookahead--, le.strstart++, Oe && (U(le, !1), le.strm.avail_out === 0)) return S;
            }
            return le.insert = 0, Te === h ? (U(le, !0), le.strm.avail_out === 0 ? z : R) : le.last_lit && (U(le, !1), le.strm.avail_out === 0) ? S : X;
          }(ne, Ae) : ne.strategy === 3 ? function(le, Te) {
            for (var Oe, Ue, Ge, at, it = le.window; ; ) {
              if (le.lookahead <= D) {
                if (ie(le), le.lookahead <= D && Te === c) return S;
                if (le.lookahead === 0) break;
              }
              if (le.match_length = 0, le.lookahead >= N && 0 < le.strstart && (Ue = it[Ge = le.strstart - 1]) === it[++Ge] && Ue === it[++Ge] && Ue === it[++Ge]) {
                at = le.strstart + D;
                do
                  ;
                while (Ue === it[++Ge] && Ue === it[++Ge] && Ue === it[++Ge] && Ue === it[++Ge] && Ue === it[++Ge] && Ue === it[++Ge] && Ue === it[++Ge] && Ue === it[++Ge] && Ge < at);
                le.match_length = D - (at - Ge), le.match_length > le.lookahead && (le.match_length = le.lookahead);
              }
              if (le.match_length >= N ? (Oe = o._tr_tally(le, 1, le.match_length - N), le.lookahead -= le.match_length, le.strstart += le.match_length, le.match_length = 0) : (Oe = o._tr_tally(le, 0, le.window[le.strstart]), le.lookahead--, le.strstart++), Oe && (U(le, !1), le.strm.avail_out === 0)) return S;
            }
            return le.insert = 0, Te === h ? (U(le, !0), le.strm.avail_out === 0 ? z : R) : le.last_lit && (U(le, !1), le.strm.avail_out === 0) ? S : X;
          }(ne, Ae) : s[ne.level].func(ne, Ae);
          if (ce !== z && ce !== R || (ne.status = 666), ce === S || ce === z) return M.avail_out === 0 && (ne.last_flush = -1), f;
          if (ce === X && (Ae === 1 ? o._tr_align(ne) : Ae !== 5 && (o._tr_stored_block(ne, 0, 0, !1), Ae === 3 && (J(ne.head), ne.lookahead === 0 && (ne.strstart = 0, ne.block_start = 0, ne.insert = 0))), Z(M), M.avail_out === 0)) return ne.last_flush = -1, f;
        }
        return Ae !== h ? f : ne.wrap <= 0 ? 1 : (ne.wrap === 2 ? (P(ne, 255 & M.adler), P(ne, M.adler >> 8 & 255), P(ne, M.adler >> 16 & 255), P(ne, M.adler >> 24 & 255), P(ne, 255 & M.total_in), P(ne, M.total_in >> 8 & 255), P(ne, M.total_in >> 16 & 255), P(ne, M.total_in >> 24 & 255)) : (H(ne, M.adler >>> 16), H(ne, 65535 & M.adler)), Z(M), 0 < ne.wrap && (ne.wrap = -ne.wrap), ne.pending !== 0 ? f : 1);
      }, i.deflateEnd = function(M) {
        var Ae;
        return M && M.state ? (Ae = M.state.status) !== E && Ae !== 69 && Ae !== 73 && Ae !== 91 && Ae !== 103 && Ae !== L && Ae !== 666 ? V(M, d) : (M.state = null, Ae === L ? V(M, -3) : f) : d;
      }, i.deflateSetDictionary = function(M, Ae) {
        var G, ne, ee, ae, re, ce, le, Te, Oe = Ae.length;
        if (!M || !M.state || (ae = (G = M.state).wrap) === 2 || ae === 1 && G.status !== E || G.lookahead) return d;
        for (ae === 1 && (M.adler = A(M.adler, Ae, Oe, 0)), G.wrap = 0, Oe >= G.w_size && (ae === 0 && (J(G.head), G.strstart = 0, G.block_start = 0, G.insert = 0), Te = new a.Buf8(G.w_size), a.arraySet(Te, Ae, Oe - G.w_size, G.w_size, 0), Ae = Te, Oe = G.w_size), re = M.avail_in, ce = M.next_in, le = M.input, M.avail_in = Oe, M.next_in = 0, M.input = Ae, ie(G); G.lookahead >= N; ) {
          for (ne = G.strstart, ee = G.lookahead - (N - 1); G.ins_h = (G.ins_h << G.hash_shift ^ G.window[ne + N - 1]) & G.hash_mask, G.prev[ne & G.w_mask] = G.head[G.ins_h], G.head[G.ins_h] = ne, ne++, --ee; ) ;
          G.strstart = ne, G.lookahead = N - 1, ie(G);
        }
        return G.strstart += G.lookahead, G.block_start = G.strstart, G.insert = G.lookahead, G.lookahead = 0, G.match_length = G.prev_length = N - 1, G.match_available = 0, M.next_in = ce, M.input = le, M.avail_in = re, G.wrap = ae, f;
      }, i.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(t, n, i) {
      n.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(t, n, i) {
      n.exports = function(s, a) {
        var o, A, l, u, c, h, f, d, p, v, m, b, w, B, _, x, C, F, N, D, T, E, L, S, X;
        o = s.state, A = s.next_in, S = s.input, l = A + (s.avail_in - 5), u = s.next_out, X = s.output, c = u - (a - s.avail_out), h = u + (s.avail_out - 257), f = o.dmax, d = o.wsize, p = o.whave, v = o.wnext, m = o.window, b = o.hold, w = o.bits, B = o.lencode, _ = o.distcode, x = (1 << o.lenbits) - 1, C = (1 << o.distbits) - 1;
        e: do {
          w < 15 && (b += S[A++] << w, w += 8, b += S[A++] << w, w += 8), F = B[b & x];
          t: for (; ; ) {
            if (b >>>= N = F >>> 24, w -= N, (N = F >>> 16 & 255) === 0) X[u++] = 65535 & F;
            else {
              if (!(16 & N)) {
                if (!(64 & N)) {
                  F = B[(65535 & F) + (b & (1 << N) - 1)];
                  continue t;
                }
                if (32 & N) {
                  o.mode = 12;
                  break e;
                }
                s.msg = "invalid literal/length code", o.mode = 30;
                break e;
              }
              D = 65535 & F, (N &= 15) && (w < N && (b += S[A++] << w, w += 8), D += b & (1 << N) - 1, b >>>= N, w -= N), w < 15 && (b += S[A++] << w, w += 8, b += S[A++] << w, w += 8), F = _[b & C];
              r: for (; ; ) {
                if (b >>>= N = F >>> 24, w -= N, !(16 & (N = F >>> 16 & 255))) {
                  if (!(64 & N)) {
                    F = _[(65535 & F) + (b & (1 << N) - 1)];
                    continue r;
                  }
                  s.msg = "invalid distance code", o.mode = 30;
                  break e;
                }
                if (T = 65535 & F, w < (N &= 15) && (b += S[A++] << w, (w += 8) < N && (b += S[A++] << w, w += 8)), f < (T += b & (1 << N) - 1)) {
                  s.msg = "invalid distance too far back", o.mode = 30;
                  break e;
                }
                if (b >>>= N, w -= N, (N = u - c) < T) {
                  if (p < (N = T - N) && o.sane) {
                    s.msg = "invalid distance too far back", o.mode = 30;
                    break e;
                  }
                  if (L = m, (E = 0) === v) {
                    if (E += d - N, N < D) {
                      for (D -= N; X[u++] = m[E++], --N; ) ;
                      E = u - T, L = X;
                    }
                  } else if (v < N) {
                    if (E += d + v - N, (N -= v) < D) {
                      for (D -= N; X[u++] = m[E++], --N; ) ;
                      if (E = 0, v < D) {
                        for (D -= N = v; X[u++] = m[E++], --N; ) ;
                        E = u - T, L = X;
                      }
                    }
                  } else if (E += v - N, N < D) {
                    for (D -= N; X[u++] = m[E++], --N; ) ;
                    E = u - T, L = X;
                  }
                  for (; 2 < D; ) X[u++] = L[E++], X[u++] = L[E++], X[u++] = L[E++], D -= 3;
                  D && (X[u++] = L[E++], 1 < D && (X[u++] = L[E++]));
                } else {
                  for (E = u - T; X[u++] = X[E++], X[u++] = X[E++], X[u++] = X[E++], 2 < (D -= 3); ) ;
                  D && (X[u++] = X[E++], 1 < D && (X[u++] = X[E++]));
                }
                break;
              }
            }
            break;
          }
        } while (A < l && u < h);
        A -= D = w >> 3, b &= (1 << (w -= D << 3)) - 1, s.next_in = A, s.next_out = u, s.avail_in = A < l ? l - A + 5 : 5 - (A - l), s.avail_out = u < h ? h - u + 257 : 257 - (u - h), o.hold = b, o.bits = w;
      };
    }, {}], 49: [function(t, n, i) {
      var s = t("../utils/common"), a = t("./adler32"), o = t("./crc32"), A = t("./inffast"), l = t("./inftrees"), u = 1, c = 2, h = 0, f = -2, d = 1, p = 852, v = 592;
      function m(E) {
        return (E >>> 24 & 255) + (E >>> 8 & 65280) + ((65280 & E) << 8) + ((255 & E) << 24);
      }
      function b() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new s.Buf16(320), this.work = new s.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function w(E) {
        var L;
        return E && E.state ? (L = E.state, E.total_in = E.total_out = L.total = 0, E.msg = "", L.wrap && (E.adler = 1 & L.wrap), L.mode = d, L.last = 0, L.havedict = 0, L.dmax = 32768, L.head = null, L.hold = 0, L.bits = 0, L.lencode = L.lendyn = new s.Buf32(p), L.distcode = L.distdyn = new s.Buf32(v), L.sane = 1, L.back = -1, h) : f;
      }
      function B(E) {
        var L;
        return E && E.state ? ((L = E.state).wsize = 0, L.whave = 0, L.wnext = 0, w(E)) : f;
      }
      function _(E, L) {
        var S, X;
        return E && E.state ? (X = E.state, L < 0 ? (S = 0, L = -L) : (S = 1 + (L >> 4), L < 48 && (L &= 15)), L && (L < 8 || 15 < L) ? f : (X.window !== null && X.wbits !== L && (X.window = null), X.wrap = S, X.wbits = L, B(E))) : f;
      }
      function x(E, L) {
        var S, X;
        return E ? (X = new b(), (E.state = X).window = null, (S = _(E, L)) !== h && (E.state = null), S) : f;
      }
      var C, F, N = !0;
      function D(E) {
        if (N) {
          var L;
          for (C = new s.Buf32(512), F = new s.Buf32(32), L = 0; L < 144; ) E.lens[L++] = 8;
          for (; L < 256; ) E.lens[L++] = 9;
          for (; L < 280; ) E.lens[L++] = 7;
          for (; L < 288; ) E.lens[L++] = 8;
          for (l(u, E.lens, 0, 288, C, 0, E.work, { bits: 9 }), L = 0; L < 32; ) E.lens[L++] = 5;
          l(c, E.lens, 0, 32, F, 0, E.work, { bits: 5 }), N = !1;
        }
        E.lencode = C, E.lenbits = 9, E.distcode = F, E.distbits = 5;
      }
      function T(E, L, S, X) {
        var z, R = E.state;
        return R.window === null && (R.wsize = 1 << R.wbits, R.wnext = 0, R.whave = 0, R.window = new s.Buf8(R.wsize)), X >= R.wsize ? (s.arraySet(R.window, L, S - R.wsize, R.wsize, 0), R.wnext = 0, R.whave = R.wsize) : (X < (z = R.wsize - R.wnext) && (z = X), s.arraySet(R.window, L, S - X, z, R.wnext), (X -= z) ? (s.arraySet(R.window, L, S - X, X, 0), R.wnext = X, R.whave = R.wsize) : (R.wnext += z, R.wnext === R.wsize && (R.wnext = 0), R.whave < R.wsize && (R.whave += z))), 0;
      }
      i.inflateReset = B, i.inflateReset2 = _, i.inflateResetKeep = w, i.inflateInit = function(E) {
        return x(E, 15);
      }, i.inflateInit2 = x, i.inflate = function(E, L) {
        var S, X, z, R, V, O, J, Z, U, P, H, $, ie, ue, he, ve, Le, de, Ce, Qe, M, Ae, G, ne, ee = 0, ae = new s.Buf8(4), re = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!E || !E.state || !E.output || !E.input && E.avail_in !== 0) return f;
        (S = E.state).mode === 12 && (S.mode = 13), V = E.next_out, z = E.output, J = E.avail_out, R = E.next_in, X = E.input, O = E.avail_in, Z = S.hold, U = S.bits, P = O, H = J, Ae = h;
        e: for (; ; ) switch (S.mode) {
          case d:
            if (S.wrap === 0) {
              S.mode = 13;
              break;
            }
            for (; U < 16; ) {
              if (O === 0) break e;
              O--, Z += X[R++] << U, U += 8;
            }
            if (2 & S.wrap && Z === 35615) {
              ae[S.check = 0] = 255 & Z, ae[1] = Z >>> 8 & 255, S.check = o(S.check, ae, 2, 0), U = Z = 0, S.mode = 2;
              break;
            }
            if (S.flags = 0, S.head && (S.head.done = !1), !(1 & S.wrap) || (((255 & Z) << 8) + (Z >> 8)) % 31) {
              E.msg = "incorrect header check", S.mode = 30;
              break;
            }
            if ((15 & Z) != 8) {
              E.msg = "unknown compression method", S.mode = 30;
              break;
            }
            if (U -= 4, M = 8 + (15 & (Z >>>= 4)), S.wbits === 0) S.wbits = M;
            else if (M > S.wbits) {
              E.msg = "invalid window size", S.mode = 30;
              break;
            }
            S.dmax = 1 << M, E.adler = S.check = 1, S.mode = 512 & Z ? 10 : 12, U = Z = 0;
            break;
          case 2:
            for (; U < 16; ) {
              if (O === 0) break e;
              O--, Z += X[R++] << U, U += 8;
            }
            if (S.flags = Z, (255 & S.flags) != 8) {
              E.msg = "unknown compression method", S.mode = 30;
              break;
            }
            if (57344 & S.flags) {
              E.msg = "unknown header flags set", S.mode = 30;
              break;
            }
            S.head && (S.head.text = Z >> 8 & 1), 512 & S.flags && (ae[0] = 255 & Z, ae[1] = Z >>> 8 & 255, S.check = o(S.check, ae, 2, 0)), U = Z = 0, S.mode = 3;
          case 3:
            for (; U < 32; ) {
              if (O === 0) break e;
              O--, Z += X[R++] << U, U += 8;
            }
            S.head && (S.head.time = Z), 512 & S.flags && (ae[0] = 255 & Z, ae[1] = Z >>> 8 & 255, ae[2] = Z >>> 16 & 255, ae[3] = Z >>> 24 & 255, S.check = o(S.check, ae, 4, 0)), U = Z = 0, S.mode = 4;
          case 4:
            for (; U < 16; ) {
              if (O === 0) break e;
              O--, Z += X[R++] << U, U += 8;
            }
            S.head && (S.head.xflags = 255 & Z, S.head.os = Z >> 8), 512 & S.flags && (ae[0] = 255 & Z, ae[1] = Z >>> 8 & 255, S.check = o(S.check, ae, 2, 0)), U = Z = 0, S.mode = 5;
          case 5:
            if (1024 & S.flags) {
              for (; U < 16; ) {
                if (O === 0) break e;
                O--, Z += X[R++] << U, U += 8;
              }
              S.length = Z, S.head && (S.head.extra_len = Z), 512 & S.flags && (ae[0] = 255 & Z, ae[1] = Z >>> 8 & 255, S.check = o(S.check, ae, 2, 0)), U = Z = 0;
            } else S.head && (S.head.extra = null);
            S.mode = 6;
          case 6:
            if (1024 & S.flags && (O < ($ = S.length) && ($ = O), $ && (S.head && (M = S.head.extra_len - S.length, S.head.extra || (S.head.extra = new Array(S.head.extra_len)), s.arraySet(S.head.extra, X, R, $, M)), 512 & S.flags && (S.check = o(S.check, X, $, R)), O -= $, R += $, S.length -= $), S.length)) break e;
            S.length = 0, S.mode = 7;
          case 7:
            if (2048 & S.flags) {
              if (O === 0) break e;
              for ($ = 0; M = X[R + $++], S.head && M && S.length < 65536 && (S.head.name += String.fromCharCode(M)), M && $ < O; ) ;
              if (512 & S.flags && (S.check = o(S.check, X, $, R)), O -= $, R += $, M) break e;
            } else S.head && (S.head.name = null);
            S.length = 0, S.mode = 8;
          case 8:
            if (4096 & S.flags) {
              if (O === 0) break e;
              for ($ = 0; M = X[R + $++], S.head && M && S.length < 65536 && (S.head.comment += String.fromCharCode(M)), M && $ < O; ) ;
              if (512 & S.flags && (S.check = o(S.check, X, $, R)), O -= $, R += $, M) break e;
            } else S.head && (S.head.comment = null);
            S.mode = 9;
          case 9:
            if (512 & S.flags) {
              for (; U < 16; ) {
                if (O === 0) break e;
                O--, Z += X[R++] << U, U += 8;
              }
              if (Z !== (65535 & S.check)) {
                E.msg = "header crc mismatch", S.mode = 30;
                break;
              }
              U = Z = 0;
            }
            S.head && (S.head.hcrc = S.flags >> 9 & 1, S.head.done = !0), E.adler = S.check = 0, S.mode = 12;
            break;
          case 10:
            for (; U < 32; ) {
              if (O === 0) break e;
              O--, Z += X[R++] << U, U += 8;
            }
            E.adler = S.check = m(Z), U = Z = 0, S.mode = 11;
          case 11:
            if (S.havedict === 0) return E.next_out = V, E.avail_out = J, E.next_in = R, E.avail_in = O, S.hold = Z, S.bits = U, 2;
            E.adler = S.check = 1, S.mode = 12;
          case 12:
            if (L === 5 || L === 6) break e;
          case 13:
            if (S.last) {
              Z >>>= 7 & U, U -= 7 & U, S.mode = 27;
              break;
            }
            for (; U < 3; ) {
              if (O === 0) break e;
              O--, Z += X[R++] << U, U += 8;
            }
            switch (S.last = 1 & Z, U -= 1, 3 & (Z >>>= 1)) {
              case 0:
                S.mode = 14;
                break;
              case 1:
                if (D(S), S.mode = 20, L !== 6) break;
                Z >>>= 2, U -= 2;
                break e;
              case 2:
                S.mode = 17;
                break;
              case 3:
                E.msg = "invalid block type", S.mode = 30;
            }
            Z >>>= 2, U -= 2;
            break;
          case 14:
            for (Z >>>= 7 & U, U -= 7 & U; U < 32; ) {
              if (O === 0) break e;
              O--, Z += X[R++] << U, U += 8;
            }
            if ((65535 & Z) != (Z >>> 16 ^ 65535)) {
              E.msg = "invalid stored block lengths", S.mode = 30;
              break;
            }
            if (S.length = 65535 & Z, U = Z = 0, S.mode = 15, L === 6) break e;
          case 15:
            S.mode = 16;
          case 16:
            if ($ = S.length) {
              if (O < $ && ($ = O), J < $ && ($ = J), $ === 0) break e;
              s.arraySet(z, X, R, $, V), O -= $, R += $, J -= $, V += $, S.length -= $;
              break;
            }
            S.mode = 12;
            break;
          case 17:
            for (; U < 14; ) {
              if (O === 0) break e;
              O--, Z += X[R++] << U, U += 8;
            }
            if (S.nlen = 257 + (31 & Z), Z >>>= 5, U -= 5, S.ndist = 1 + (31 & Z), Z >>>= 5, U -= 5, S.ncode = 4 + (15 & Z), Z >>>= 4, U -= 4, 286 < S.nlen || 30 < S.ndist) {
              E.msg = "too many length or distance symbols", S.mode = 30;
              break;
            }
            S.have = 0, S.mode = 18;
          case 18:
            for (; S.have < S.ncode; ) {
              for (; U < 3; ) {
                if (O === 0) break e;
                O--, Z += X[R++] << U, U += 8;
              }
              S.lens[re[S.have++]] = 7 & Z, Z >>>= 3, U -= 3;
            }
            for (; S.have < 19; ) S.lens[re[S.have++]] = 0;
            if (S.lencode = S.lendyn, S.lenbits = 7, G = { bits: S.lenbits }, Ae = l(0, S.lens, 0, 19, S.lencode, 0, S.work, G), S.lenbits = G.bits, Ae) {
              E.msg = "invalid code lengths set", S.mode = 30;
              break;
            }
            S.have = 0, S.mode = 19;
          case 19:
            for (; S.have < S.nlen + S.ndist; ) {
              for (; ve = (ee = S.lencode[Z & (1 << S.lenbits) - 1]) >>> 16 & 255, Le = 65535 & ee, !((he = ee >>> 24) <= U); ) {
                if (O === 0) break e;
                O--, Z += X[R++] << U, U += 8;
              }
              if (Le < 16) Z >>>= he, U -= he, S.lens[S.have++] = Le;
              else {
                if (Le === 16) {
                  for (ne = he + 2; U < ne; ) {
                    if (O === 0) break e;
                    O--, Z += X[R++] << U, U += 8;
                  }
                  if (Z >>>= he, U -= he, S.have === 0) {
                    E.msg = "invalid bit length repeat", S.mode = 30;
                    break;
                  }
                  M = S.lens[S.have - 1], $ = 3 + (3 & Z), Z >>>= 2, U -= 2;
                } else if (Le === 17) {
                  for (ne = he + 3; U < ne; ) {
                    if (O === 0) break e;
                    O--, Z += X[R++] << U, U += 8;
                  }
                  U -= he, M = 0, $ = 3 + (7 & (Z >>>= he)), Z >>>= 3, U -= 3;
                } else {
                  for (ne = he + 7; U < ne; ) {
                    if (O === 0) break e;
                    O--, Z += X[R++] << U, U += 8;
                  }
                  U -= he, M = 0, $ = 11 + (127 & (Z >>>= he)), Z >>>= 7, U -= 7;
                }
                if (S.have + $ > S.nlen + S.ndist) {
                  E.msg = "invalid bit length repeat", S.mode = 30;
                  break;
                }
                for (; $--; ) S.lens[S.have++] = M;
              }
            }
            if (S.mode === 30) break;
            if (S.lens[256] === 0) {
              E.msg = "invalid code -- missing end-of-block", S.mode = 30;
              break;
            }
            if (S.lenbits = 9, G = { bits: S.lenbits }, Ae = l(u, S.lens, 0, S.nlen, S.lencode, 0, S.work, G), S.lenbits = G.bits, Ae) {
              E.msg = "invalid literal/lengths set", S.mode = 30;
              break;
            }
            if (S.distbits = 6, S.distcode = S.distdyn, G = { bits: S.distbits }, Ae = l(c, S.lens, S.nlen, S.ndist, S.distcode, 0, S.work, G), S.distbits = G.bits, Ae) {
              E.msg = "invalid distances set", S.mode = 30;
              break;
            }
            if (S.mode = 20, L === 6) break e;
          case 20:
            S.mode = 21;
          case 21:
            if (6 <= O && 258 <= J) {
              E.next_out = V, E.avail_out = J, E.next_in = R, E.avail_in = O, S.hold = Z, S.bits = U, A(E, H), V = E.next_out, z = E.output, J = E.avail_out, R = E.next_in, X = E.input, O = E.avail_in, Z = S.hold, U = S.bits, S.mode === 12 && (S.back = -1);
              break;
            }
            for (S.back = 0; ve = (ee = S.lencode[Z & (1 << S.lenbits) - 1]) >>> 16 & 255, Le = 65535 & ee, !((he = ee >>> 24) <= U); ) {
              if (O === 0) break e;
              O--, Z += X[R++] << U, U += 8;
            }
            if (ve && !(240 & ve)) {
              for (de = he, Ce = ve, Qe = Le; ve = (ee = S.lencode[Qe + ((Z & (1 << de + Ce) - 1) >> de)]) >>> 16 & 255, Le = 65535 & ee, !(de + (he = ee >>> 24) <= U); ) {
                if (O === 0) break e;
                O--, Z += X[R++] << U, U += 8;
              }
              Z >>>= de, U -= de, S.back += de;
            }
            if (Z >>>= he, U -= he, S.back += he, S.length = Le, ve === 0) {
              S.mode = 26;
              break;
            }
            if (32 & ve) {
              S.back = -1, S.mode = 12;
              break;
            }
            if (64 & ve) {
              E.msg = "invalid literal/length code", S.mode = 30;
              break;
            }
            S.extra = 15 & ve, S.mode = 22;
          case 22:
            if (S.extra) {
              for (ne = S.extra; U < ne; ) {
                if (O === 0) break e;
                O--, Z += X[R++] << U, U += 8;
              }
              S.length += Z & (1 << S.extra) - 1, Z >>>= S.extra, U -= S.extra, S.back += S.extra;
            }
            S.was = S.length, S.mode = 23;
          case 23:
            for (; ve = (ee = S.distcode[Z & (1 << S.distbits) - 1]) >>> 16 & 255, Le = 65535 & ee, !((he = ee >>> 24) <= U); ) {
              if (O === 0) break e;
              O--, Z += X[R++] << U, U += 8;
            }
            if (!(240 & ve)) {
              for (de = he, Ce = ve, Qe = Le; ve = (ee = S.distcode[Qe + ((Z & (1 << de + Ce) - 1) >> de)]) >>> 16 & 255, Le = 65535 & ee, !(de + (he = ee >>> 24) <= U); ) {
                if (O === 0) break e;
                O--, Z += X[R++] << U, U += 8;
              }
              Z >>>= de, U -= de, S.back += de;
            }
            if (Z >>>= he, U -= he, S.back += he, 64 & ve) {
              E.msg = "invalid distance code", S.mode = 30;
              break;
            }
            S.offset = Le, S.extra = 15 & ve, S.mode = 24;
          case 24:
            if (S.extra) {
              for (ne = S.extra; U < ne; ) {
                if (O === 0) break e;
                O--, Z += X[R++] << U, U += 8;
              }
              S.offset += Z & (1 << S.extra) - 1, Z >>>= S.extra, U -= S.extra, S.back += S.extra;
            }
            if (S.offset > S.dmax) {
              E.msg = "invalid distance too far back", S.mode = 30;
              break;
            }
            S.mode = 25;
          case 25:
            if (J === 0) break e;
            if ($ = H - J, S.offset > $) {
              if (($ = S.offset - $) > S.whave && S.sane) {
                E.msg = "invalid distance too far back", S.mode = 30;
                break;
              }
              ie = $ > S.wnext ? ($ -= S.wnext, S.wsize - $) : S.wnext - $, $ > S.length && ($ = S.length), ue = S.window;
            } else ue = z, ie = V - S.offset, $ = S.length;
            for (J < $ && ($ = J), J -= $, S.length -= $; z[V++] = ue[ie++], --$; ) ;
            S.length === 0 && (S.mode = 21);
            break;
          case 26:
            if (J === 0) break e;
            z[V++] = S.length, J--, S.mode = 21;
            break;
          case 27:
            if (S.wrap) {
              for (; U < 32; ) {
                if (O === 0) break e;
                O--, Z |= X[R++] << U, U += 8;
              }
              if (H -= J, E.total_out += H, S.total += H, H && (E.adler = S.check = S.flags ? o(S.check, z, H, V - H) : a(S.check, z, H, V - H)), H = J, (S.flags ? Z : m(Z)) !== S.check) {
                E.msg = "incorrect data check", S.mode = 30;
                break;
              }
              U = Z = 0;
            }
            S.mode = 28;
          case 28:
            if (S.wrap && S.flags) {
              for (; U < 32; ) {
                if (O === 0) break e;
                O--, Z += X[R++] << U, U += 8;
              }
              if (Z !== (4294967295 & S.total)) {
                E.msg = "incorrect length check", S.mode = 30;
                break;
              }
              U = Z = 0;
            }
            S.mode = 29;
          case 29:
            Ae = 1;
            break e;
          case 30:
            Ae = -3;
            break e;
          case 31:
            return -4;
          case 32:
          default:
            return f;
        }
        return E.next_out = V, E.avail_out = J, E.next_in = R, E.avail_in = O, S.hold = Z, S.bits = U, (S.wsize || H !== E.avail_out && S.mode < 30 && (S.mode < 27 || L !== 4)) && T(E, E.output, E.next_out, H - E.avail_out) ? (S.mode = 31, -4) : (P -= E.avail_in, H -= E.avail_out, E.total_in += P, E.total_out += H, S.total += H, S.wrap && H && (E.adler = S.check = S.flags ? o(S.check, z, H, E.next_out - H) : a(S.check, z, H, E.next_out - H)), E.data_type = S.bits + (S.last ? 64 : 0) + (S.mode === 12 ? 128 : 0) + (S.mode === 20 || S.mode === 15 ? 256 : 0), (P == 0 && H === 0 || L === 4) && Ae === h && (Ae = -5), Ae);
      }, i.inflateEnd = function(E) {
        if (!E || !E.state) return f;
        var L = E.state;
        return L.window && (L.window = null), E.state = null, h;
      }, i.inflateGetHeader = function(E, L) {
        var S;
        return E && E.state && 2 & (S = E.state).wrap ? ((S.head = L).done = !1, h) : f;
      }, i.inflateSetDictionary = function(E, L) {
        var S, X = L.length;
        return E && E.state ? (S = E.state).wrap !== 0 && S.mode !== 11 ? f : S.mode === 11 && a(1, L, X, 0) !== S.check ? -3 : T(E, L, X, X) ? (S.mode = 31, -4) : (S.havedict = 1, h) : f;
      }, i.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(t, n, i) {
      var s = t("../utils/common"), a = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], o = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], A = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], l = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      n.exports = function(u, c, h, f, d, p, v, m) {
        var b, w, B, _, x, C, F, N, D, T = m.bits, E = 0, L = 0, S = 0, X = 0, z = 0, R = 0, V = 0, O = 0, J = 0, Z = 0, U = null, P = 0, H = new s.Buf16(16), $ = new s.Buf16(16), ie = null, ue = 0;
        for (E = 0; E <= 15; E++) H[E] = 0;
        for (L = 0; L < f; L++) H[c[h + L]]++;
        for (z = T, X = 15; 1 <= X && H[X] === 0; X--) ;
        if (X < z && (z = X), X === 0) return d[p++] = 20971520, d[p++] = 20971520, m.bits = 1, 0;
        for (S = 1; S < X && H[S] === 0; S++) ;
        for (z < S && (z = S), E = O = 1; E <= 15; E++) if (O <<= 1, (O -= H[E]) < 0) return -1;
        if (0 < O && (u === 0 || X !== 1)) return -1;
        for ($[1] = 0, E = 1; E < 15; E++) $[E + 1] = $[E] + H[E];
        for (L = 0; L < f; L++) c[h + L] !== 0 && (v[$[c[h + L]]++] = L);
        if (C = u === 0 ? (U = ie = v, 19) : u === 1 ? (U = a, P -= 257, ie = o, ue -= 257, 256) : (U = A, ie = l, -1), E = S, x = p, V = L = Z = 0, B = -1, _ = (J = 1 << (R = z)) - 1, u === 1 && 852 < J || u === 2 && 592 < J) return 1;
        for (; ; ) {
          for (F = E - V, D = v[L] < C ? (N = 0, v[L]) : v[L] > C ? (N = ie[ue + v[L]], U[P + v[L]]) : (N = 96, 0), b = 1 << E - V, S = w = 1 << R; d[x + (Z >> V) + (w -= b)] = F << 24 | N << 16 | D | 0, w !== 0; ) ;
          for (b = 1 << E - 1; Z & b; ) b >>= 1;
          if (b !== 0 ? (Z &= b - 1, Z += b) : Z = 0, L++, --H[E] == 0) {
            if (E === X) break;
            E = c[h + v[L]];
          }
          if (z < E && (Z & _) !== B) {
            for (V === 0 && (V = z), x += S, O = 1 << (R = E - V); R + V < X && !((O -= H[R + V]) <= 0); ) R++, O <<= 1;
            if (J += 1 << R, u === 1 && 852 < J || u === 2 && 592 < J) return 1;
            d[B = Z & _] = z << 24 | R << 16 | x - p | 0;
          }
        }
        return Z !== 0 && (d[x + Z] = E - V << 24 | 64 << 16 | 0), m.bits = z, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(t, n, i) {
      n.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(t, n, i) {
      var s = t("../utils/common"), a = 0, o = 1;
      function A(ee) {
        for (var ae = ee.length; 0 <= --ae; ) ee[ae] = 0;
      }
      var l = 0, u = 29, c = 256, h = c + 1 + u, f = 30, d = 19, p = 2 * h + 1, v = 15, m = 16, b = 7, w = 256, B = 16, _ = 17, x = 18, C = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], F = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], N = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], D = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], T = new Array(2 * (h + 2));
      A(T);
      var E = new Array(2 * f);
      A(E);
      var L = new Array(512);
      A(L);
      var S = new Array(256);
      A(S);
      var X = new Array(u);
      A(X);
      var z, R, V, O = new Array(f);
      function J(ee, ae, re, ce, le) {
        this.static_tree = ee, this.extra_bits = ae, this.extra_base = re, this.elems = ce, this.max_length = le, this.has_stree = ee && ee.length;
      }
      function Z(ee, ae) {
        this.dyn_tree = ee, this.max_code = 0, this.stat_desc = ae;
      }
      function U(ee) {
        return ee < 256 ? L[ee] : L[256 + (ee >>> 7)];
      }
      function P(ee, ae) {
        ee.pending_buf[ee.pending++] = 255 & ae, ee.pending_buf[ee.pending++] = ae >>> 8 & 255;
      }
      function H(ee, ae, re) {
        ee.bi_valid > m - re ? (ee.bi_buf |= ae << ee.bi_valid & 65535, P(ee, ee.bi_buf), ee.bi_buf = ae >> m - ee.bi_valid, ee.bi_valid += re - m) : (ee.bi_buf |= ae << ee.bi_valid & 65535, ee.bi_valid += re);
      }
      function $(ee, ae, re) {
        H(ee, re[2 * ae], re[2 * ae + 1]);
      }
      function ie(ee, ae) {
        for (var re = 0; re |= 1 & ee, ee >>>= 1, re <<= 1, 0 < --ae; ) ;
        return re >>> 1;
      }
      function ue(ee, ae, re) {
        var ce, le, Te = new Array(v + 1), Oe = 0;
        for (ce = 1; ce <= v; ce++) Te[ce] = Oe = Oe + re[ce - 1] << 1;
        for (le = 0; le <= ae; le++) {
          var Ue = ee[2 * le + 1];
          Ue !== 0 && (ee[2 * le] = ie(Te[Ue]++, Ue));
        }
      }
      function he(ee) {
        var ae;
        for (ae = 0; ae < h; ae++) ee.dyn_ltree[2 * ae] = 0;
        for (ae = 0; ae < f; ae++) ee.dyn_dtree[2 * ae] = 0;
        for (ae = 0; ae < d; ae++) ee.bl_tree[2 * ae] = 0;
        ee.dyn_ltree[2 * w] = 1, ee.opt_len = ee.static_len = 0, ee.last_lit = ee.matches = 0;
      }
      function ve(ee) {
        8 < ee.bi_valid ? P(ee, ee.bi_buf) : 0 < ee.bi_valid && (ee.pending_buf[ee.pending++] = ee.bi_buf), ee.bi_buf = 0, ee.bi_valid = 0;
      }
      function Le(ee, ae, re, ce) {
        var le = 2 * ae, Te = 2 * re;
        return ee[le] < ee[Te] || ee[le] === ee[Te] && ce[ae] <= ce[re];
      }
      function de(ee, ae, re) {
        for (var ce = ee.heap[re], le = re << 1; le <= ee.heap_len && (le < ee.heap_len && Le(ae, ee.heap[le + 1], ee.heap[le], ee.depth) && le++, !Le(ae, ce, ee.heap[le], ee.depth)); ) ee.heap[re] = ee.heap[le], re = le, le <<= 1;
        ee.heap[re] = ce;
      }
      function Ce(ee, ae, re) {
        var ce, le, Te, Oe, Ue = 0;
        if (ee.last_lit !== 0) for (; ce = ee.pending_buf[ee.d_buf + 2 * Ue] << 8 | ee.pending_buf[ee.d_buf + 2 * Ue + 1], le = ee.pending_buf[ee.l_buf + Ue], Ue++, ce === 0 ? $(ee, le, ae) : ($(ee, (Te = S[le]) + c + 1, ae), (Oe = C[Te]) !== 0 && H(ee, le -= X[Te], Oe), $(ee, Te = U(--ce), re), (Oe = F[Te]) !== 0 && H(ee, ce -= O[Te], Oe)), Ue < ee.last_lit; ) ;
        $(ee, w, ae);
      }
      function Qe(ee, ae) {
        var re, ce, le, Te = ae.dyn_tree, Oe = ae.stat_desc.static_tree, Ue = ae.stat_desc.has_stree, Ge = ae.stat_desc.elems, at = -1;
        for (ee.heap_len = 0, ee.heap_max = p, re = 0; re < Ge; re++) Te[2 * re] !== 0 ? (ee.heap[++ee.heap_len] = at = re, ee.depth[re] = 0) : Te[2 * re + 1] = 0;
        for (; ee.heap_len < 2; ) Te[2 * (le = ee.heap[++ee.heap_len] = at < 2 ? ++at : 0)] = 1, ee.depth[le] = 0, ee.opt_len--, Ue && (ee.static_len -= Oe[2 * le + 1]);
        for (ae.max_code = at, re = ee.heap_len >> 1; 1 <= re; re--) de(ee, Te, re);
        for (le = Ge; re = ee.heap[1], ee.heap[1] = ee.heap[ee.heap_len--], de(ee, Te, 1), ce = ee.heap[1], ee.heap[--ee.heap_max] = re, ee.heap[--ee.heap_max] = ce, Te[2 * le] = Te[2 * re] + Te[2 * ce], ee.depth[le] = (ee.depth[re] >= ee.depth[ce] ? ee.depth[re] : ee.depth[ce]) + 1, Te[2 * re + 1] = Te[2 * ce + 1] = le, ee.heap[1] = le++, de(ee, Te, 1), 2 <= ee.heap_len; ) ;
        ee.heap[--ee.heap_max] = ee.heap[1], function(it, ut) {
          var St, et, gr, bt, Qr, Wt, kt = ut.dyn_tree, Dr = ut.max_code, Xt = ut.stat_desc.static_tree, Cn = ut.stat_desc.has_stree, mr = ut.stat_desc.extra_bits, Ir = ut.stat_desc.extra_base, hr = ut.stat_desc.max_length, wr = 0;
          for (bt = 0; bt <= v; bt++) it.bl_count[bt] = 0;
          for (kt[2 * it.heap[it.heap_max] + 1] = 0, St = it.heap_max + 1; St < p; St++) hr < (bt = kt[2 * kt[2 * (et = it.heap[St]) + 1] + 1] + 1) && (bt = hr, wr++), kt[2 * et + 1] = bt, Dr < et || (it.bl_count[bt]++, Qr = 0, Ir <= et && (Qr = mr[et - Ir]), Wt = kt[2 * et], it.opt_len += Wt * (bt + Qr), Cn && (it.static_len += Wt * (Xt[2 * et + 1] + Qr)));
          if (wr !== 0) {
            do {
              for (bt = hr - 1; it.bl_count[bt] === 0; ) bt--;
              it.bl_count[bt]--, it.bl_count[bt + 1] += 2, it.bl_count[hr]--, wr -= 2;
            } while (0 < wr);
            for (bt = hr; bt !== 0; bt--) for (et = it.bl_count[bt]; et !== 0; ) Dr < (gr = it.heap[--St]) || (kt[2 * gr + 1] !== bt && (it.opt_len += (bt - kt[2 * gr + 1]) * kt[2 * gr], kt[2 * gr + 1] = bt), et--);
          }
        }(ee, ae), ue(Te, at, ee.bl_count);
      }
      function M(ee, ae, re) {
        var ce, le, Te = -1, Oe = ae[1], Ue = 0, Ge = 7, at = 4;
        for (Oe === 0 && (Ge = 138, at = 3), ae[2 * (re + 1) + 1] = 65535, ce = 0; ce <= re; ce++) le = Oe, Oe = ae[2 * (ce + 1) + 1], ++Ue < Ge && le === Oe || (Ue < at ? ee.bl_tree[2 * le] += Ue : le !== 0 ? (le !== Te && ee.bl_tree[2 * le]++, ee.bl_tree[2 * B]++) : Ue <= 10 ? ee.bl_tree[2 * _]++ : ee.bl_tree[2 * x]++, Te = le, at = (Ue = 0) === Oe ? (Ge = 138, 3) : le === Oe ? (Ge = 6, 3) : (Ge = 7, 4));
      }
      function Ae(ee, ae, re) {
        var ce, le, Te = -1, Oe = ae[1], Ue = 0, Ge = 7, at = 4;
        for (Oe === 0 && (Ge = 138, at = 3), ce = 0; ce <= re; ce++) if (le = Oe, Oe = ae[2 * (ce + 1) + 1], !(++Ue < Ge && le === Oe)) {
          if (Ue < at) for (; $(ee, le, ee.bl_tree), --Ue != 0; ) ;
          else le !== 0 ? (le !== Te && ($(ee, le, ee.bl_tree), Ue--), $(ee, B, ee.bl_tree), H(ee, Ue - 3, 2)) : Ue <= 10 ? ($(ee, _, ee.bl_tree), H(ee, Ue - 3, 3)) : ($(ee, x, ee.bl_tree), H(ee, Ue - 11, 7));
          Te = le, at = (Ue = 0) === Oe ? (Ge = 138, 3) : le === Oe ? (Ge = 6, 3) : (Ge = 7, 4);
        }
      }
      A(O);
      var G = !1;
      function ne(ee, ae, re, ce) {
        H(ee, (l << 1) + (ce ? 1 : 0), 3), function(le, Te, Oe, Ue) {
          ve(le), P(le, Oe), P(le, ~Oe), s.arraySet(le.pending_buf, le.window, Te, Oe, le.pending), le.pending += Oe;
        }(ee, ae, re);
      }
      i._tr_init = function(ee) {
        G || (function() {
          var ae, re, ce, le, Te, Oe = new Array(v + 1);
          for (le = ce = 0; le < u - 1; le++) for (X[le] = ce, ae = 0; ae < 1 << C[le]; ae++) S[ce++] = le;
          for (S[ce - 1] = le, le = Te = 0; le < 16; le++) for (O[le] = Te, ae = 0; ae < 1 << F[le]; ae++) L[Te++] = le;
          for (Te >>= 7; le < f; le++) for (O[le] = Te << 7, ae = 0; ae < 1 << F[le] - 7; ae++) L[256 + Te++] = le;
          for (re = 0; re <= v; re++) Oe[re] = 0;
          for (ae = 0; ae <= 143; ) T[2 * ae + 1] = 8, ae++, Oe[8]++;
          for (; ae <= 255; ) T[2 * ae + 1] = 9, ae++, Oe[9]++;
          for (; ae <= 279; ) T[2 * ae + 1] = 7, ae++, Oe[7]++;
          for (; ae <= 287; ) T[2 * ae + 1] = 8, ae++, Oe[8]++;
          for (ue(T, h + 1, Oe), ae = 0; ae < f; ae++) E[2 * ae + 1] = 5, E[2 * ae] = ie(ae, 5);
          z = new J(T, C, c + 1, h, v), R = new J(E, F, 0, f, v), V = new J(new Array(0), N, 0, d, b);
        }(), G = !0), ee.l_desc = new Z(ee.dyn_ltree, z), ee.d_desc = new Z(ee.dyn_dtree, R), ee.bl_desc = new Z(ee.bl_tree, V), ee.bi_buf = 0, ee.bi_valid = 0, he(ee);
      }, i._tr_stored_block = ne, i._tr_flush_block = function(ee, ae, re, ce) {
        var le, Te, Oe = 0;
        0 < ee.level ? (ee.strm.data_type === 2 && (ee.strm.data_type = function(Ue) {
          var Ge, at = 4093624447;
          for (Ge = 0; Ge <= 31; Ge++, at >>>= 1) if (1 & at && Ue.dyn_ltree[2 * Ge] !== 0) return a;
          if (Ue.dyn_ltree[18] !== 0 || Ue.dyn_ltree[20] !== 0 || Ue.dyn_ltree[26] !== 0) return o;
          for (Ge = 32; Ge < c; Ge++) if (Ue.dyn_ltree[2 * Ge] !== 0) return o;
          return a;
        }(ee)), Qe(ee, ee.l_desc), Qe(ee, ee.d_desc), Oe = function(Ue) {
          var Ge;
          for (M(Ue, Ue.dyn_ltree, Ue.l_desc.max_code), M(Ue, Ue.dyn_dtree, Ue.d_desc.max_code), Qe(Ue, Ue.bl_desc), Ge = d - 1; 3 <= Ge && Ue.bl_tree[2 * D[Ge] + 1] === 0; Ge--) ;
          return Ue.opt_len += 3 * (Ge + 1) + 5 + 5 + 4, Ge;
        }(ee), le = ee.opt_len + 3 + 7 >>> 3, (Te = ee.static_len + 3 + 7 >>> 3) <= le && (le = Te)) : le = Te = re + 5, re + 4 <= le && ae !== -1 ? ne(ee, ae, re, ce) : ee.strategy === 4 || Te === le ? (H(ee, 2 + (ce ? 1 : 0), 3), Ce(ee, T, E)) : (H(ee, 4 + (ce ? 1 : 0), 3), function(Ue, Ge, at, it) {
          var ut;
          for (H(Ue, Ge - 257, 5), H(Ue, at - 1, 5), H(Ue, it - 4, 4), ut = 0; ut < it; ut++) H(Ue, Ue.bl_tree[2 * D[ut] + 1], 3);
          Ae(Ue, Ue.dyn_ltree, Ge - 1), Ae(Ue, Ue.dyn_dtree, at - 1);
        }(ee, ee.l_desc.max_code + 1, ee.d_desc.max_code + 1, Oe + 1), Ce(ee, ee.dyn_ltree, ee.dyn_dtree)), he(ee), ce && ve(ee);
      }, i._tr_tally = function(ee, ae, re) {
        return ee.pending_buf[ee.d_buf + 2 * ee.last_lit] = ae >>> 8 & 255, ee.pending_buf[ee.d_buf + 2 * ee.last_lit + 1] = 255 & ae, ee.pending_buf[ee.l_buf + ee.last_lit] = 255 & re, ee.last_lit++, ae === 0 ? ee.dyn_ltree[2 * re]++ : (ee.matches++, ae--, ee.dyn_ltree[2 * (S[re] + c + 1)]++, ee.dyn_dtree[2 * U(ae)]++), ee.last_lit === ee.lit_bufsize - 1;
      }, i._tr_align = function(ee) {
        H(ee, 2, 3), $(ee, w, T), function(ae) {
          ae.bi_valid === 16 ? (P(ae, ae.bi_buf), ae.bi_buf = 0, ae.bi_valid = 0) : 8 <= ae.bi_valid && (ae.pending_buf[ae.pending++] = 255 & ae.bi_buf, ae.bi_buf >>= 8, ae.bi_valid -= 8);
        }(ee);
      };
    }, { "../utils/common": 41 }], 53: [function(t, n, i) {
      n.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(t, n, i) {
      (function(s) {
        (function(a, o) {
          if (!a.setImmediate) {
            var A, l, u, c, h = 1, f = {}, d = !1, p = a.document, v = Object.getPrototypeOf && Object.getPrototypeOf(a);
            v = v && v.setTimeout ? v : a, A = {}.toString.call(a.process) === "[object process]" ? function(B) {
              process.nextTick(function() {
                b(B);
              });
            } : function() {
              if (a.postMessage && !a.importScripts) {
                var B = !0, _ = a.onmessage;
                return a.onmessage = function() {
                  B = !1;
                }, a.postMessage("", "*"), a.onmessage = _, B;
              }
            }() ? (c = "setImmediate$" + Math.random() + "$", a.addEventListener ? a.addEventListener("message", w, !1) : a.attachEvent("onmessage", w), function(B) {
              a.postMessage(c + B, "*");
            }) : a.MessageChannel ? ((u = new MessageChannel()).port1.onmessage = function(B) {
              b(B.data);
            }, function(B) {
              u.port2.postMessage(B);
            }) : p && "onreadystatechange" in p.createElement("script") ? (l = p.documentElement, function(B) {
              var _ = p.createElement("script");
              _.onreadystatechange = function() {
                b(B), _.onreadystatechange = null, l.removeChild(_), _ = null;
              }, l.appendChild(_);
            }) : function(B) {
              setTimeout(b, 0, B);
            }, v.setImmediate = function(B) {
              typeof B != "function" && (B = new Function("" + B));
              for (var _ = new Array(arguments.length - 1), x = 0; x < _.length; x++) _[x] = arguments[x + 1];
              var C = { callback: B, args: _ };
              return f[h] = C, A(h), h++;
            }, v.clearImmediate = m;
          }
          function m(B) {
            delete f[B];
          }
          function b(B) {
            if (d) setTimeout(b, 0, B);
            else {
              var _ = f[B];
              if (_) {
                d = !0;
                try {
                  (function(x) {
                    var C = x.callback, F = x.args;
                    switch (F.length) {
                      case 0:
                        C();
                        break;
                      case 1:
                        C(F[0]);
                        break;
                      case 2:
                        C(F[0], F[1]);
                        break;
                      case 3:
                        C(F[0], F[1], F[2]);
                        break;
                      default:
                        C.apply(o, F);
                    }
                  })(_);
                } finally {
                  m(B), d = !1;
                }
              }
            }
          }
          function w(B) {
            B.source === a && typeof B.data == "string" && B.data.indexOf(c) === 0 && b(+B.data.slice(c.length));
          }
        })(typeof self > "u" ? s === void 0 ? this : s : self);
      }).call(this, typeof an < "u" ? an : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(q3);
var aH = q3.exports;
const oH = /* @__PURE__ */ Rf(aH);
var W3 = { exports: {} };
(function(r, e) {
  (function(t, n) {
    n();
  })(an, function() {
    function t(l, u) {
      return typeof u > "u" ? u = { autoBom: !1 } : typeof u != "object" && (console.warn("Deprecated: Expected third argument to be a object"), u = { autoBom: !u }), u.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(l.type) ? new Blob(["\uFEFF", l], { type: l.type }) : l;
    }
    function n(l, u, c) {
      var h = new XMLHttpRequest();
      h.open("GET", l), h.responseType = "blob", h.onload = function() {
        A(h.response, u, c);
      }, h.onerror = function() {
        console.error("could not download file");
      }, h.send();
    }
    function i(l) {
      var u = new XMLHttpRequest();
      u.open("HEAD", l, !1);
      try {
        u.send();
      } catch {
      }
      return 200 <= u.status && 299 >= u.status;
    }
    function s(l) {
      try {
        l.dispatchEvent(new MouseEvent("click"));
      } catch {
        var u = document.createEvent("MouseEvents");
        u.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), l.dispatchEvent(u);
      }
    }
    var a = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof an == "object" && an.global === an ? an : void 0, o = a.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), A = a.saveAs || (typeof window != "object" || window !== a ? function() {
    } : "download" in HTMLAnchorElement.prototype && !o ? function(l, u, c) {
      var h = a.URL || a.webkitURL, f = document.createElement("a");
      u = u || l.name || "download", f.download = u, f.rel = "noopener", typeof l == "string" ? (f.href = l, f.origin === location.origin ? s(f) : i(f.href) ? n(l, u, c) : s(f, f.target = "_blank")) : (f.href = h.createObjectURL(l), setTimeout(function() {
        h.revokeObjectURL(f.href);
      }, 4e4), setTimeout(function() {
        s(f);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(l, u, c) {
      if (u = u || l.name || "download", typeof l != "string") navigator.msSaveOrOpenBlob(t(l, c), u);
      else if (i(l)) n(l, u, c);
      else {
        var h = document.createElement("a");
        h.href = l, h.target = "_blank", setTimeout(function() {
          s(h);
        });
      }
    } : function(l, u, c, h) {
      if (h = h || open("", "_blank"), h && (h.document.title = h.document.body.innerText = "downloading..."), typeof l == "string") return n(l, u, c);
      var f = l.type === "application/octet-stream", d = /constructor/i.test(a.HTMLElement) || a.safari, p = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((p || f && d || o) && typeof FileReader < "u") {
        var v = new FileReader();
        v.onloadend = function() {
          var w = v.result;
          w = p ? w : w.replace(/^data:[^;]*;/, "data:attachment/file;"), h ? h.location.href = w : location = w, h = null;
        }, v.readAsDataURL(l);
      } else {
        var m = a.URL || a.webkitURL, b = m.createObjectURL(l);
        h ? h.location = b : location.href = b, h = null, setTimeout(function() {
          m.revokeObjectURL(b);
        }, 4e4);
      }
    });
    a.saveAs = A.saveAs = A, r.exports = A;
  });
})(W3);
var AH = W3.exports;
const lH = /* @__PURE__ */ Rf(AH), Ev = "string", uH = "number", cH = [Ev, uH], fH = "Zipclex config missing property filename", hH = "Zipclex filename can only be of type string", dH = "Zipcelx sheet data is not of type array", pH = "Zipclex sheet data childs is not of type array", gH = 'Invalid type supplied in cell config, falling back to "string"', mH = (r) => r.every((e) => Array.isArray(e));
var vH = (r) => r.filename ? typeof r.filename != "string" ? (console.error(hH), !1) : Array.isArray(r.sheet.data) ? mH(r.sheet.data) ? !0 : (console.error(pH), !1) : (console.error(dH), !1) : (console.error(fH), !1);
const X3 = (r) => {
  if (typeof r != "number")
    return "";
  const e = Math.floor(r / 26), t = String.fromCharCode(97 + r % 26).toUpperCase();
  return e === 0 ? t : X3(e - 1) + t;
};
var J3 = (r, e) => `${X3(r)}${e}`, bH = (r, e, t) => `<c r="${J3(r, t)}" t="inlineStr"><is><t>${sH(e)}</t></is></c>`, yH = (r, e, t) => `<c r="${J3(r, t)}"><v>${e}</v></c>`, wH = (r, e, t) => (cH.indexOf(r.type) === -1 && (console.warn(gH), r.type = Ev), r.type === Ev ? bH(e, r.value, t) : yH(e, r.value, t)), BH = (r, e) => {
  const t = e + 1, n = r.map((i, s) => wH(i, s, t)).join("");
  return `<row r="${t}">${n}</row>`;
}, CH = (r) => r.map((e, t) => BH(e, t)).join(""), _H = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mx="http://schemas.microsoft.com/office/mac/excel/2008/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:mv="urn:schemas-microsoft-com:mac:vml" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:xm="http://schemas.microsoft.com/office/excel/2006/main"><workbookPr/><sheets><sheet state="visible" name="Sheet1" sheetId="1" r:id="rId3"/></sheets><definedNames/><calcPr/></workbook>`, EH = `<?xml version="1.0" ?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
<Relationship Id="rId3" Target="worksheets/sheet1.xml" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet"/>
</Relationships>`, SH = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>`, IH = `<?xml version="1.0" ?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
<Default ContentType="application/xml" Extension="xml"/>
<Default ContentType="application/vnd.openxmlformats-package.relationships+xml" Extension="rels"/>
<Override ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" PartName="/xl/worksheets/sheet1.xml"/>
<Override ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" PartName="/xl/workbook.xml"/>
</Types>`, FH = `<?xml version="1.0" ?>
<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:mv="urn:schemas-microsoft-com:mac:vml" xmlns:mx="http://schemas.microsoft.com/office/mac/excel/2008/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:xm="http://schemas.microsoft.com/office/excel/2006/main"><sheetData>{placeholder}</sheetData></worksheet>`;
const TH = (r) => {
  const e = CH(r);
  return FH.replace("{placeholder}", e);
};
var xH = (r) => {
  if (!vH(r))
    throw new Error("Validation failed.");
  const e = new oH(), t = e.folder("xl");
  t.file("workbook.xml", _H), t.file("_rels/workbook.xml.rels", EH), e.file("_rels/.rels", SH), e.file("[Content_Types].xml", IH);
  const n = TH(r.sheet.data);
  return t.file("worksheets/sheet1.xml", n), e.generateAsync({
    type: "blob",
    mimeType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
  }).then((i) => {
    lH.saveAs(i, `${r.filename}.xlsx`);
  });
};
const Y3 = ia(void 0), Z3 = ia();
function kH({
  newXMLDocument: r,
  newPluginHostElement: e
}) {
  Y3.set(r), Z3.set(e);
}
const Pf = {
  //state
  xmlDocument: Y3,
  pluginHostElement: Z3,
  //initialization
  init: kH
}, { pluginHostElement: yg } = Pf;
function LH(r, e) {
  const t = ng({
    new: {
      parent: r,
      element: e
    }
  });
  bn(yg).dispatchEvent(t);
}
function UH(r, e) {
  const t = ng({
    old: {
      parent: r,
      element: e
    }
  });
  bn(yg).dispatchEvent(t);
}
function NH(r, e, t, n) {
  const i = ng({
    old: {
      parent: r,
      element: t
    },
    new: {
      parent: e,
      element: t,
      position: n
    }
  });
  bn(yg).dispatchEvent(i);
}
function OH(r, e) {
  const t = SU(r, e), n = ng(t);
  bn(yg).dispatchEvent(n);
}
const ka = {
  //actions
  createAndDispatchActionEvent: LH,
  updateAndDispatchActionEvent: OH,
  deleteAndDispatchActionEvent: UH,
  moveAndDispatchActionEvent: NH
};
var ni = [];
for (var p0 = 0; p0 < 256; ++p0)
  ni.push((p0 + 256).toString(16).slice(1));
function QH(r, e = 0) {
  return (ni[r[e + 0]] + ni[r[e + 1]] + ni[r[e + 2]] + ni[r[e + 3]] + "-" + ni[r[e + 4]] + ni[r[e + 5]] + "-" + ni[r[e + 6]] + ni[r[e + 7]] + "-" + ni[r[e + 8]] + ni[r[e + 9]] + "-" + ni[r[e + 10]] + ni[r[e + 11]] + ni[r[e + 12]] + ni[r[e + 13]] + ni[r[e + 14]] + ni[r[e + 15]]).toLowerCase();
}
var Ad, DH = new Uint8Array(16);
function MH() {
  if (!Ad && (Ad = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Ad))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Ad(DH);
}
var RH = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const s5 = {
  randomUUID: RH
};
function Np(r, e, t) {
  if (s5.randomUUID && !e && !r)
    return s5.randomUUID();
  r = r || {};
  var n = r.random || (r.rng || MH)();
  return n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, QH(n);
}
const { xmlDocument: wg } = Pf, fl = ia(null);
function PH() {
  const r = bn(wg);
  if (!r)
    throw new Error("XML Document is not defined");
  const e = HH(r);
  fl.set(e);
}
function HH(r) {
  const e = r.documentElement, t = e.querySelector('Private[type="AUTO_DOC"]');
  if (t)
    return t;
  const n = H2(r, "Private", { type: "AUTO_DOC" });
  return e.appendChild(n), ka.createAndDispatchActionEvent(e, n), n;
}
function eI(r, e, t) {
  t >= 0 && t < r.children.length ? r.insertBefore(e, r.children[t]) : r.appendChild(e);
}
function Ru(r) {
  const e = bn(fl);
  return e ? e.querySelector(`DocumentTemplate[id="${r}"]`) : null;
}
function jH() {
  const r = bn(fl);
  return r ? Array.from(r.querySelectorAll("DocumentTemplate")) : [];
}
function KH(r) {
  const e = Ru(r);
  return e ? Array.from(e.querySelectorAll("Block")) : [];
}
function $H(r, e) {
  const t = Ru(r);
  return t ? t.querySelector(`Block[id="${e}"]`) : null;
}
function VH() {
  let r = null;
  const e = bn(wg);
  if (!e)
    throw new Error("XML Document is not defined");
  const t = bn(fl);
  if (t) {
    const n = Np(), i = H2(e, "DocumentTemplate", {
      id: n,
      date: (/* @__PURE__ */ new Date()).toISOString()
    });
    t.appendChild(i), ka.createAndDispatchActionEvent(t, i), r = n;
  }
  return r;
}
function zH(r, e, t) {
  const n = Ru(r);
  if (n) {
    const i = {};
    e && (n.setAttribute("title", e), i.title = e), t && (n.setAttribute("description", t), i.description = t);
    const s = n.getAttribute("id");
    s && (i.id = s);
    const a = n.getAttribute("date");
    a && (i.date = a), Object.keys(i).length > 0 && ka.updateAndDispatchActionEvent(n, i);
  }
}
function GH(r, e, t) {
  const n = Np(), i = bn(wg);
  if (!i)
    throw new Error("XML Document is not defined");
  const s = H2(i, "Block", {
    id: n,
    type: e
  });
  return r.appendChild(s), eI(r, s, t), ka.createAndDispatchActionEvent(r, s), ka.moveAndDispatchActionEvent(r, r, s, t), n;
}
function qH(r, e, t) {
  const n = r.querySelector(`Block[id="${e}"]`);
  if (n) {
    const i = n.getAttribute("id"), s = n.getAttribute("type");
    n.textContent = t, ka.updateAndDispatchActionEvent(n, { id: i, type: s });
  }
}
function WH(r, e, t) {
  const n = r.querySelector(`Block[id="${e}"]`);
  n && (eI(r, n, t), ka.moveAndDispatchActionEvent(r, r, n, t));
}
function XH(r, e) {
  const t = r.querySelector(`Block[id="${e}"]`);
  t && t.parentNode === r && (r.removeChild(t), ka.deleteAndDispatchActionEvent(r, t));
}
function JH(r) {
  const e = bn(fl);
  if (e) {
    const t = Ru(r);
    t && (e.removeChild(t), ka.deleteAndDispatchActionEvent(e, t));
  }
}
function YH(r) {
  if (!bn(wg))
    throw new Error("XML Document is not defined");
  const t = bn(fl);
  if (t) {
    const n = Ru(r);
    if (n) {
      const i = n.getAttribute("title"), s = n.getAttribute("description"), a = n.cloneNode(!0);
      a.setAttribute("id", Np()), a.setAttribute("date", (/* @__PURE__ */ new Date()).toISOString()), a.setAttribute("title", `${i}_Copy`), a.setAttribute("description", `Copied from ${i}'s description: ${s}`);
      const o = a.querySelectorAll("Block");
      for (const A of o)
        A.setAttribute("id", Np());
      t.appendChild(a), ka.createAndDispatchActionEvent(t, a);
    }
  }
}
function ZH() {
  PH();
}
const sa = {
  // state
  privateArea: fl,
  // actions
  init: ZH,
  addDocumentTemplate: VH,
  addBlockToDocumentTemplate: GH,
  getDocumentTemplate: Ru,
  getAllDocumentTemplates: jH,
  getBlockOfDocumentTemplate: $H,
  getAllBlocksOfDocumentTemplate: KH,
  moveBlockInDocumentTemplate: WH,
  editDocumentTemplateTitleAndDescription: zH,
  editBlockContentOfDocumentTemplate: qH,
  deleteDocumentTemplate: JH,
  deleteBlockFromDocumentTemplate: XH,
  duplicateDocumentTemplate: YH
}, { xmlDocument: e7 } = Pf, t7 = (r) => {
  const e = {
    default: "http://www.iec.ch/61850/2003/SCL",
    xsi: "http://www.w3.org/2001/XMLSchema-instance",
    sxy: "http://www.iec.ch/61850/2003/SCLcoordinates"
  };
  return r === null ? null : e[r] || null;
};
function tI(r) {
  const e = bn(e7);
  if (!e)
    throw new Error("XML Document is not defined");
  return r.replace(/{{(.*?)}}/g, (t, n) => {
    try {
      const i = e.evaluate(
        n,
        e,
        t7,
        XPathResult.ANY_TYPE,
        null
      ), s = [];
      let a = i.iterateNext();
      for (; a; )
        s.push(a.textContent || "N/A"), a = i.iterateNext();
      return s.length > 1 ? s.join(", ") : s[0] || "N/A";
    } catch (i) {
      return console.error(`Error evaluating XPath ${n}:`, i), "Error evaluating XPath";
    }
  });
}
function r7(r) {
  const e = r.tableColumns.map((a) => a.columnTitle).join(" | "), t = r.tableColumns.map(() => "---").join(" | "), n = r.tableColumns.map((a) => tI(`{{${a.placeholder}}}`).split(", ")), i = Math.max(...n.map((a) => a.length)), s = Array.from({ length: i }, (a, o) => n.map((A) => A[o] || "").join(" | ")).join(` |
| `);
  return `| ${e} |
| ${t} |
| ${s} |`;
}
const n7 = {
  // actions
  fillPlaceholder: tI,
  fillTableWithPlaceholders: r7
};
var Is = /* @__PURE__ */ ((r) => (r.GOOSE = "GOOSE", r.MMS = "MMS", r.SV = "SV", r.UNKNOWN = "UNKNOWN", r))(Is || {}), rI = /* @__PURE__ */ ((r) => (r.UW = "UW", r.VoltageLevel = "Voltage Level", r.Bay = "Bay", r.M_text = "Meldetext", r.IEDName = "IED Name", r.LogicalDeviceInstance = "Logical Device Instance", r.LogicalNodePrefix = "Logical Node Prefix", r.LogicalNodeClass = "Logical Node Class", r.LogicalNodeInstance = "Logical Node Instance", r.DataObjectName = "Data Object Name", r.DataAttributeName = "Data Attribute Name", r.CommonDataClass = "Common Data Class", r.AttributeType = "AttributeType", r.FunctionalConstraint = "Functional Constraint", r))(rI || {});
const Qn = {
  UW: "UW",
  VoltageLevel: "VoltageLevel",
  Bay: "Bay",
  M_text: "M_text",
  IEDName: "IEDName",
  SignalType: "signalType",
  LogicalNodeInformation: "logicalNodeInformation",
  LogicalDeviceInstance: "LogicalDeviceInstance",
  LogicalNodePrefix: "LogicalNodePrefix",
  LogicalNodeClass: "LogicalNodeClass",
  LogicalNodeInstance: "LogicalNodeInstance",
  LogicalNodeType: "LogicalNodeType",
  LogicalNodeIEDName: "LogicalNodeIEDName",
  DataObjectInformation: "dataObjectInformation",
  DataObjectName: "DataObjectName",
  DataAttributeName: "DataAttributeName",
  CommonDataClass: "CommonDataClass",
  AttributeType: "AttributeType",
  FunctionalConstraint: "FunctionalConstraint"
}, a5 = {
  IEDName: "IEDName",
  ExtRef: "ExtRef"
}, _s = {
  iedName: "iedName",
  serviceType: "serviceType",
  ldInst: "ldInst",
  lnClass: "lnClass",
  lnInst: "lnInst",
  prefix: "prefix",
  doName: "doName",
  daName: "daName",
  srcLDInst: "srcLDInst",
  srcPrefix: "srcPrefix",
  srcLNClass: "srcLNClass",
  srcCBName: "srcCBName"
}, i7 = {
  id: ":id"
}, du = {
  Home: "/",
  Create: "/create",
  Edit: "/edit",
  Not_Found: "*"
}, { xmlDocument: Bg } = Pf, If = ia([]);
function s7() {
  if (!bn(Bg))
    throw new Error("XML Document is not defined");
  const { messagePublishers: e, invaliditiesReports: t } = nI(), { messageSubscribers: n, invaliditiesReports: i } = iI(e);
  return {
    messagePublishers: e,
    messageSubscribers: n,
    invaliditiesReports: [...t, ...i]
  };
}
function nI(r = {}) {
  const e = [], t = [], n = bn(Bg);
  if (!n)
    throw new Error("XML Document is not defined");
  const i = n.querySelector("DataTypeTemplates");
  if (!i)
    throw new Error("DataTypeTemplates Element not found in XML Document");
  const s = n.querySelectorAll("IED");
  for (const o of s)
    a7(o, i, e, t);
  return { messagePublishers: w7(e, r), invaliditiesReports: t };
}
function iI(r, e = {}) {
  const t = bn(Bg);
  if (!t)
    throw new Error("XML Document is not defined");
  const n = [], i = [];
  for (const o of r) {
    const A = Array.from(t.querySelectorAll("IED")).filter((l) => l.getAttribute("name") !== o.IEDName);
    for (const l of A)
      g7(l, o, n);
  }
  const { subscribers: s, matchedRows: a } = C7(n, e);
  return { messageSubscribers: s, invaliditiesReports: i, matchedRows: a };
}
function a7(r, e, t, n) {
  const i = r.querySelectorAll("AccessPoint");
  for (const s of i)
    o7(s, r, e, t, n);
}
function o7(r, e, t, n, i) {
  const s = r.querySelectorAll("LDevice");
  for (const a of s)
    A7(a, e, t, n, i);
}
function A7(r, e, t, n, i) {
  const s = r.querySelector("LN0");
  if (!s) return;
  const a = s.querySelector("GSEControl"), o = s.querySelector("ReportControl");
  if (!a && !o) return;
  const A = a ? Is.GOOSE : o ? Is.MMS : Is.UNKNOWN, l = s.querySelectorAll("DataSet");
  for (const u of l)
    l7(u, r, e, t, A, n, i);
}
function l7(r, e, t, n, i, s, a) {
  const o = r.querySelectorAll("FCDA");
  for (const A of o)
    u7(A, e, t, n, i, s, a);
}
function u7(r, e, t, n, i, s, a) {
  const o = e.getAttribute("inst") || "", A = r.getAttribute("prefix") || "", l = r.getAttribute("lnClass") || "", u = r.getAttribute("lnInst") || "", c = r.getAttribute("doName") || "", h = r.getAttribute("daName") || "", f = r.getAttribute("fc") || "", d = e.querySelectorAll(`LN[inst="${u}"][lnClass="${l}"][prefix="${A}"]`);
  for (const p of d)
    c7(p, o, A, l, u, c, h, f, t, n, i, s, a);
}
function c7(r, e, t, n, i, s, a, o, A, l, u, c, h) {
  const f = bn(Bg);
  if (!f)
    throw new Error("XML Document is not defined");
  const d = f.querySelector("Substation"), p = d && d.getAttribute("name") || "", v = r.querySelectorAll("DOI");
  for (const m of v) {
    const b = m.getAttribute("name") || "";
    if (s !== b) continue;
    const w = m.querySelectorAll("DAI");
    for (const B of w) {
      const _ = B.getAttribute("desc") || "";
      if (_ !== "") {
        const x = A.getAttribute("name") || "", C = {
          [Qn.IEDName]: x,
          [Qn.LogicalDeviceInstance]: e,
          [Qn.LogicalNodePrefix]: t,
          [Qn.LogicalNodeClass]: n,
          [Qn.LogicalNodeInstance]: i,
          [Qn.LogicalNodeType]: r.getAttribute("lnType") || ""
        }, F = f7(C.LogicalNodeType, l, x, C, h);
        if (!F) continue;
        const N = h7(s, F, x, C, h);
        if (!N) continue;
        const D = N.getAttribute("type") || "", T = d7(D, l, x, C, h);
        if (!T) continue;
        const E = B.getAttribute("name") || "", L = T.getAttribute("cdc") || "", S = p7(E, T, x, C, h);
        if (!S) continue;
        const X = S.getAttribute("bType") || "", z = {
          [Qn.DataObjectName]: s,
          [Qn.DataAttributeName]: E,
          [Qn.CommonDataClass]: L,
          [Qn.AttributeType]: X,
          [Qn.FunctionalConstraint]: o
        };
        if (!c.some(
          (V) => V.M_text === _ && V.IEDName === x && V.logicalNodeInformation.LogicalDeviceInstance === e && V.logicalNodeInformation.LogicalNodePrefix === t && V.logicalNodeInformation.LogicalNodeClass === n && V.logicalNodeInformation.LogicalNodeInstance === i && V.logicalNodeInformation.LogicalNodeType === C.LogicalNodeType && V.dataObjectInformation.DataObjectName === s && V.dataObjectInformation.DataAttributeName === E && V.dataObjectInformation.CommonDataClass === L && V.dataObjectInformation.AttributeType === X && V.dataObjectInformation.FunctionalConstraint === o
        )) {
          let V = "", O = "";
          const J = d == null ? void 0 : d.querySelectorAll("VoltageLevel");
          if (J)
            for (const Z of J) {
              const U = Z.querySelectorAll("Bay");
              for (const P of U) {
                const H = P.querySelectorAll("LNode");
                for (const $ of H)
                  $.getAttribute("iedName") === x && (O = P.getAttribute("name") || "", V = Z.getAttribute("name") || "");
              }
            }
          c.push({
            [Qn.UW]: p,
            [Qn.VoltageLevel]: V,
            [Qn.Bay]: O,
            [Qn.M_text]: _,
            [Qn.SignalType]: u,
            [Qn.IEDName]: x,
            [Qn.LogicalNodeInformation]: C,
            [Qn.DataObjectInformation]: z
          });
        }
      }
    }
  }
}
function f7(r, e, t, n, i) {
  const s = e.querySelector(`LNodeType[id="${r}"]`);
  return s || i.push({ IEDName: t, LogicalNodeInformation: n, invalidities: [`LNodeType with id ${r} not found in DataTypeTemplates`] }), s;
}
function h7(r, e, t, n, i) {
  const s = e.querySelector(`DO[name="${r}"]`);
  return s || i.push({ IEDName: t, LogicalNodeInformation: n, invalidities: [`DO with name ${r} not found in LNodeType with id ${n.LogicalNodeType}`] }), s;
}
function d7(r, e, t, n, i) {
  const s = e.querySelector(`DOType[id="${r}"]`);
  return s || i.push({ IEDName: t, LogicalNodeInformation: n, invalidities: [`DOType with id ${r} not found in DataTypeTemplates`] }), s;
}
function p7(r, e, t, n, i) {
  const s = e.querySelector(`DA[name="${r}"]`);
  return s || i.push({ IEDName: t, LogicalNodeInformation: n, invalidities: [`DA with name ${r} not found in DOType with id ${e.getAttribute("id")}`] }), s;
}
function g7(r, e, t, n) {
  const i = r.querySelectorAll("AccessPoint");
  for (const s of i)
    m7(s, r, e, t);
}
function m7(r, e, t, n, i) {
  const s = r.querySelectorAll("LDevice");
  for (const a of s)
    v7(a, e, t, n);
}
function v7(r, e, t, n, i) {
  const s = r.querySelector("LN0");
  if (!s)
    return;
  const a = s.querySelectorAll("Inputs");
  for (const o of a)
    b7(o, e, t, n);
}
function b7(r, e, t, n, i) {
  const s = r.querySelectorAll("ExtRef");
  for (const a of s)
    if (y7(a, t)) {
      const o = {
        [a5.IEDName]: e.getAttribute("name") || "",
        [a5.ExtRef]: {
          [_s.iedName]: a.getAttribute("iedName") || "",
          [_s.serviceType]: Is[a.getAttribute("serviceType")] || Is.UNKNOWN,
          [_s.ldInst]: a.getAttribute("ldInst") || "",
          [_s.lnClass]: a.getAttribute("lnClass") || "",
          [_s.lnInst]: a.getAttribute("lnInst") || "",
          [_s.prefix]: a.getAttribute("prefix") || "",
          [_s.doName]: a.getAttribute("doName") || "",
          [_s.daName]: a.getAttribute("daName") || "",
          [_s.srcLDInst]: a.getAttribute("srcLDInst") || "",
          [_s.srcPrefix]: a.getAttribute("srcPrefix") || "",
          [_s.srcLNClass]: a.getAttribute("srcLNClass") || "",
          [_s.srcCBName]: a.getAttribute("srcCBName") || ""
        }
      };
      n.push(o);
    }
}
function y7(r, e) {
  return r.getAttribute("iedName") === e.IEDName && r.getAttribute("ldInst") === e.logicalNodeInformation.LogicalDeviceInstance && r.getAttribute("lnClass") === e.logicalNodeInformation.LogicalNodeClass && r.getAttribute("lnInst") === e.logicalNodeInformation.LogicalNodeInstance && r.getAttribute("prefix") === e.logicalNodeInformation.LogicalNodePrefix && r.getAttribute("doName") === e.dataObjectInformation.DataObjectName && r.getAttribute("daName") === e.dataObjectInformation.DataAttributeName;
}
function w7(r, e) {
  const t = [], n = [], i = Object.keys(e);
  for (const s of r) {
    const a = [];
    let o = !0;
    for (const A of i) {
      const l = e[A];
      if (l !== void 0) {
        const u = B7(s, A);
        u.toLocaleLowerCase().includes(l.toLocaleLowerCase()) || l.trim() === "" ? a.push(u) : o = !1;
      }
    }
    o && (n.push(s), t.push({ matchedFilteredValuesForPdf: [a], publisher: s, matchedSubscribers: [] }));
  }
  return If.update(() => [...t]), n;
}
function B7(r, e) {
  return ({
    LogicalNodeIEDName: "logicalNodeInformation.IEDName",
    LogicalDeviceInstance: "logicalNodeInformation.LogicalDeviceInstance",
    LogicalNodePrefix: "logicalNodeInformation.LogicalNodePrefix",
    LogicalNodeClass: "logicalNodeInformation.LogicalNodeClass",
    LogicalNodeInstance: "logicalNodeInformation.LogicalNodeInstance",
    LogicalNodeType: "logicalNodeInformation.LogicalNodeType",
    DataObjectName: "dataObjectInformation.DataObjectName",
    DataAttributeName: "dataObjectInformation.DataAttributeName",
    CommonDataClass: "dataObjectInformation.CommonDataClass",
    AttributeType: "dataObjectInformation.AttributeType",
    FunctionalConstraint: "dataObjectInformation.FunctionalConstraint"
  }[e] || e).split(".").reduce((s, a) => s ? s[a] : "", r);
}
function C7(r, e) {
  const t = Object.keys(e), n = [];
  for (const i of r)
    for (const s of t) {
      const a = e[s], o = s && (i.ExtRef.serviceType.toLocaleLowerCase().includes(s.toLocaleLowerCase()) || s.trim() === "");
      (!a || i.IEDName.toLocaleLowerCase().includes(a.toLocaleLowerCase()) || a.trim() === "") && o && (n.push(i), _7(i, bn(If)));
    }
  return { matchedRows: bn(If), subscribers: n };
}
function _7(r, e) {
  for (const t of e)
    E7(t, r) && (S7(t, r.IEDName), I7(t));
  If.update(() => [...e]);
}
function E7(r, e) {
  return r.publisher.IEDName === e.ExtRef.iedName && r.publisher.logicalNodeInformation.LogicalDeviceInstance === e.ExtRef.ldInst && r.publisher.logicalNodeInformation.LogicalNodeClass === e.ExtRef.lnClass && r.publisher.logicalNodeInformation.LogicalNodeInstance === e.ExtRef.lnInst && r.publisher.logicalNodeInformation.LogicalNodePrefix === e.ExtRef.prefix && r.publisher.dataObjectInformation.DataObjectName === e.ExtRef.doName && r.publisher.dataObjectInformation.DataAttributeName === e.ExtRef.daName;
}
function S7(r, e) {
  r.matchedSubscribers.includes(e) || r.matchedSubscribers.push(e);
}
function I7(r) {
  const e = r.matchedSubscribers.join(", "), t = r.matchedFilteredValuesForPdf[0];
  t.length > 0 && r.matchedSubscribers.includes(t[t.length - 1]) ? t[t.length - 1] = e : t.push(e);
}
const o5 = {
  getSignallist: s7,
  getPublishingLogicalDevices: nI,
  getSubscribingLogicalDevices: iI,
  // Store for table pdf
  pdfRowValues: If
};
function F7(r, e) {
  const t = new Ft(), n = 10;
  t.setFontSize(n);
  const i = 10, s = 10;
  let a = i;
  const o = t.internal.pageSize.height, A = t.internal.pageSize, l = A.width ? A.width : A.getWidth(), u = s, c = {
    text: d,
    image: () => {
    },
    signalList: w
  };
  function h(B = 7) {
    a += B;
  }
  function f(B, _, x) {
    return B + 10 > _ - x;
  }
  function d(B) {
    const C = new DOMParser().parseFromString(B.textContent ?? "", "text/html").body.children;
    for (const F of C)
      switch (F.tagName.toLowerCase()) {
        case "h1":
          p(F.textContent ?? "", 20, "bold");
          break;
        case "h2":
          p(F.textContent ?? "", 16, "bold");
          break;
        case "h3":
          p(F.textContent ?? "", 14, "bold");
          break;
        case "p":
          v(F);
          break;
        case "strong":
          p(F.textContent ?? "", n, "bold");
          break;
        case "em":
          p(F.textContent ?? "", n, "italic");
          break;
        case "ul":
        case "ol":
          m(F, 0);
          break;
        default:
          console.error(`Unsupported HTML element: ${F.tagName}`);
      }
  }
  function p(B, _, x, C = 0) {
    t.setFontSize(_), t.setFont("helvetica", x);
    const F = t.splitTextToSize(B ?? "", l - (35 - C));
    for (const N of F)
      f(a, o, u) && (t.addPage(), a = i), t.text(N, 10, a), h();
  }
  function v(B) {
    for (const _ of B.childNodes)
      if (_.nodeType === Node.TEXT_NODE)
        p(_.textContent ?? "", n, "normal");
      else if (_.nodeType === Node.ELEMENT_NODE) {
        const x = _;
        let C = "normal";
        x.tagName.toLowerCase() === "strong" ? C = "bold" : x.tagName.toLowerCase() === "em" && (C = "italic"), p(x.textContent ?? "", n, C);
      }
  }
  function m(B, _ = 0) {
    const x = B.tagName.toLowerCase() === "ol";
    let C = 1;
    Array.from(B.children).forEach((F) => {
      if (F.tagName.toLowerCase() === "li") {
        const N = x ? `${C}. ` : "• ";
        C++;
        const D = F.querySelector("p");
        D ? (p(N + D.textContent, 10, "normal", _), D.remove()) : p(N + (F.textContent ?? ""), 10, "normal", _), Array.from(F.children).forEach((T) => {
          (T.tagName.toLowerCase() === "ul" || T.tagName.toLowerCase() === "ol") && m(T, _ + 10);
        });
      }
    });
  }
  function b(B) {
    f(a, o, u) && (t.addPage(), a = i), t.text(B, 10, a), h();
  }
  function w(B) {
    if (!B.textContent) {
      console.error("No content found in Signal List Block");
      return;
    }
    const _ = B.getAttribute("id"), x = JSON.parse(B.textContent), C = x.selected, N = x.matches.matchedRowsForTablePdf.flatMap((z) => z.matchedFilteredValuesForPdf), D = C.map((z) => ({ value: z.column1, type: "string" })), T = N.map((z) => z.map((R) => ({ value: R, type: "string" }))), E = `SignalList_${_}`, L = `Hint: check ${E}.xlsx`, S = [D, ...T], X = {
      filename: E,
      sheet: {
        data: S
      }
    };
    b(L), xH(X);
  }
  for (const B of e) {
    const _ = B.getAttribute("type");
    _ && c[_] && c[_](B);
  }
  t.save(`${r}.pdf`);
}
function T7(r) {
  const e = sa.getDocumentTemplate(r);
  if (!e) {
    console.error("Template not found");
    return;
  }
  const t = e.getAttribute("title") ?? "N/A", n = e.querySelectorAll("Block"), i = Array.prototype.slice.call(n);
  F7(t, i);
}
const sI = {
  downloadAsPdf: T7
};
function x7(r) {
  Pi(r, "svelte-ayiq1p", "button.is-active.svelte-ayiq1p{background-color:black;color:white}.svelte-ayiq1p:first-child{margin-top:0}");
}
function A5(r) {
  let e, t, n, i, s, a, o, A, l, u, c, h, f, d, p, v, m, b, w, B, _, x, C, F, N, D, T, E, L, S, X, z, R, V, O, J, Z, U, P, H, $, ie, ue, he, ve;
  return {
    c() {
      e = We("div"), t = We("div"), n = We("button"), i = ir("H1"), a = tt(), o = We("button"), A = ir("H2"), u = tt(), c = We("button"), h = ir("H3"), d = tt(), p = We("button"), v = ir("Bold"), w = tt(), B = We("button"), _ = ir("Italic"), F = tt(), N = We("button"), D = ir("Paragraph"), E = tt(), L = We("button"), S = ir("Bullet list"), z = tt(), R = We("button"), V = ir("Ordered list"), J = tt(), Z = We("button"), U = ir("Undo"), H = tt(), $ = We("button"), ie = ir("Redo"), Me(n, "class", s = gi(
        /*editor*/
        r[1].isActive("heading", { level: 1 }) ? "is-active" : ""
      ) + " svelte-ayiq1p"), Me(o, "class", l = gi(
        /*editor*/
        r[1].isActive("heading", { level: 2 }) ? "is-active" : ""
      ) + " svelte-ayiq1p"), Me(c, "class", f = gi(
        /*editor*/
        r[1].isActive("heading", { level: 3 }) ? "is-active" : ""
      ) + " svelte-ayiq1p"), p.disabled = m = !/*editor*/
      r[1].can().chain().focus().toggleBold().run(), Me(p, "class", b = gi(
        /*editor*/
        r[1].isActive("bold") ? "is-active" : ""
      ) + " svelte-ayiq1p"), B.disabled = x = !/*editor*/
      r[1].can().chain().focus().toggleItalic().run(), Me(B, "class", C = gi(
        /*editor*/
        r[1].isActive("italic") ? "is-active" : ""
      ) + " svelte-ayiq1p"), Me(N, "class", T = gi(
        /*editor*/
        r[1].isActive("paragraph") ? "is-active" : ""
      ) + " svelte-ayiq1p"), Me(L, "class", X = gi(
        /*editor*/
        r[1].isActive("bulletList") ? "is-active" : ""
      ) + " svelte-ayiq1p"), Me(R, "class", O = gi(
        /*editor*/
        r[1].isActive("orderedList") ? "is-active" : ""
      ) + " svelte-ayiq1p"), Z.disabled = P = !/*editor*/
      r[1].can().chain().focus().undo().run(), Me(Z, "class", "svelte-ayiq1p"), $.disabled = ue = !/*editor*/
      r[1].can().chain().focus().redo().run(), Me($, "class", "svelte-ayiq1p"), Me(t, "class", "button-group svelte-ayiq1p"), Me(e, "class", "control-group svelte-ayiq1p");
    },
    m(Le, de) {
      ke(Le, e, de), je(e, t), je(t, n), je(n, i), je(t, a), je(t, o), je(o, A), je(t, u), je(t, c), je(c, h), je(t, d), je(t, p), je(p, v), je(t, w), je(t, B), je(B, _), je(t, F), je(t, N), je(N, D), je(t, E), je(t, L), je(L, S), je(t, z), je(t, R), je(R, V), je(t, J), je(t, Z), je(Z, U), je(t, H), je(t, $), je($, ie), he || (ve = [
        pt(
          n,
          "click",
          /*click_handler*/
          r[4]
        ),
        pt(
          o,
          "click",
          /*click_handler_1*/
          r[5]
        ),
        pt(
          c,
          "click",
          /*click_handler_2*/
          r[6]
        ),
        pt(
          p,
          "click",
          /*click_handler_3*/
          r[7]
        ),
        pt(
          B,
          "click",
          /*click_handler_4*/
          r[8]
        ),
        pt(
          N,
          "click",
          /*click_handler_5*/
          r[9]
        ),
        pt(
          L,
          "click",
          /*click_handler_6*/
          r[10]
        ),
        pt(
          R,
          "click",
          /*click_handler_7*/
          r[11]
        ),
        pt(
          Z,
          "click",
          /*click_handler_8*/
          r[12]
        ),
        pt(
          $,
          "click",
          /*click_handler_9*/
          r[13]
        )
      ], he = !0);
    },
    p(Le, de) {
      de & /*editor*/
      2 && s !== (s = gi(
        /*editor*/
        Le[1].isActive("heading", { level: 1 }) ? "is-active" : ""
      ) + " svelte-ayiq1p") && Me(n, "class", s), de & /*editor*/
      2 && l !== (l = gi(
        /*editor*/
        Le[1].isActive("heading", { level: 2 }) ? "is-active" : ""
      ) + " svelte-ayiq1p") && Me(o, "class", l), de & /*editor*/
      2 && f !== (f = gi(
        /*editor*/
        Le[1].isActive("heading", { level: 3 }) ? "is-active" : ""
      ) + " svelte-ayiq1p") && Me(c, "class", f), de & /*editor*/
      2 && m !== (m = !/*editor*/
      Le[1].can().chain().focus().toggleBold().run()) && (p.disabled = m), de & /*editor*/
      2 && b !== (b = gi(
        /*editor*/
        Le[1].isActive("bold") ? "is-active" : ""
      ) + " svelte-ayiq1p") && Me(p, "class", b), de & /*editor*/
      2 && x !== (x = !/*editor*/
      Le[1].can().chain().focus().toggleItalic().run()) && (B.disabled = x), de & /*editor*/
      2 && C !== (C = gi(
        /*editor*/
        Le[1].isActive("italic") ? "is-active" : ""
      ) + " svelte-ayiq1p") && Me(B, "class", C), de & /*editor*/
      2 && T !== (T = gi(
        /*editor*/
        Le[1].isActive("paragraph") ? "is-active" : ""
      ) + " svelte-ayiq1p") && Me(N, "class", T), de & /*editor*/
      2 && X !== (X = gi(
        /*editor*/
        Le[1].isActive("bulletList") ? "is-active" : ""
      ) + " svelte-ayiq1p") && Me(L, "class", X), de & /*editor*/
      2 && O !== (O = gi(
        /*editor*/
        Le[1].isActive("orderedList") ? "is-active" : ""
      ) + " svelte-ayiq1p") && Me(R, "class", O), de & /*editor*/
      2 && P !== (P = !/*editor*/
      Le[1].can().chain().focus().undo().run()) && (Z.disabled = P), de & /*editor*/
      2 && ue !== (ue = !/*editor*/
      Le[1].can().chain().focus().redo().run()) && ($.disabled = ue);
    },
    d(Le) {
      Le && xe(e), he = !1, fr(ve);
    }
  };
}
function k7(r) {
  let e, t, n = (
    /*editor*/
    r[1] && A5(r)
  );
  return {
    c() {
      n && n.c(), e = tt(), t = We("div"), Me(t, "class", "typing-area svelte-ayiq1p");
    },
    m(i, s) {
      n && n.m(i, s), ke(i, e, s), ke(i, t, s), r[14](t);
    },
    p(i, [s]) {
      /*editor*/
      i[1] ? n ? n.p(i, s) : (n = A5(i), n.c(), n.m(e.parentNode, e)) : n && (n.d(1), n = null);
    },
    i: sr,
    o: sr,
    d(i) {
      i && (xe(e), xe(t)), n && n.d(i), r[14](null);
    }
  };
}
const L7 = 1e3;
function U7(r, e, t) {
  let n, i, { content: s = "<p>Hello World! 🌍️ </p>" } = e, { onContentChange: a } = e;
  const o = E3(A, L7);
  function A(B) {
    const _ = n7.fillPlaceholder(B);
    a(_);
  }
  ui(() => {
    t(1, i = new NM({
      element: n,
      extensions: [
        QR.configure({ types: [_3.name] }),
        NR.configure({ heading: { levels: [1, 2, 3] } }),
        DR
      ],
      content: s,
      autofocus: !0,
      onUpdate: ({ editor: B }) => {
        o(B.getHTML());
      },
      onTransaction: () => {
        t(1, i);
      }
    }));
  }), fo(() => {
    i && i.destroy();
  });
  const l = () => i.chain().focus().toggleHeading({ level: 1 }).run(), u = () => i.chain().focus().toggleHeading({ level: 2 }).run(), c = () => i.chain().focus().toggleHeading({ level: 3 }).run(), h = () => i.chain().focus().toggleBold().run(), f = () => i.chain().focus().toggleItalic().run(), d = () => i.chain().focus().setParagraph().run(), p = () => i.chain().focus().toggleBulletList().run(), v = () => i.chain().focus().toggleOrderedList().run(), m = () => i.chain().focus().undo().run(), b = () => i.chain().focus().redo().run();
  function w(B) {
    yt[B ? "unshift" : "push"](() => {
      n = B, t(0, n);
    });
  }
  return r.$$set = (B) => {
    "content" in B && t(2, s = B.content), "onContentChange" in B && t(3, a = B.onContentChange);
  }, [
    n,
    i,
    s,
    a,
    l,
    u,
    c,
    h,
    f,
    d,
    p,
    v,
    m,
    b,
    w
  ];
}
class aI extends jt {
  constructor(e) {
    super(), Pt(this, e, U7, k7, Mt, { content: 2, onContentChange: 3 }, x7);
  }
  get content() {
    return this.$$.ctx[2];
  }
  set content(e) {
    this.$$set({ content: e }), pe();
  }
  get onContentChange() {
    return this.$$.ctx[3];
  }
  set onContentChange(e) {
    this.$$set({ onContentChange: e }), pe();
  }
}
Ht(aI, { content: {}, onContentChange: {} }, [], [], !0);
function N7(r) {
  Pi(r, "svelte-86g6i3", ".image-upload-section.svelte-86g6i3.svelte-86g6i3{display:flex;flex-direction:column;gap:0.5rem}.image-preview.svelte-86g6i3 img.svelte-86g6i3{max-width:150px;max-height:150px}");
}
function l5(r) {
  let e, t, n;
  return {
    c() {
      e = We("div"), t = We("img"), Vy(t.src, n = /*imagePreview*/
      r[0]) || Me(t, "src", n), Me(t, "alt", "Uploaded Image"), Me(t, "class", "svelte-86g6i3"), Me(e, "class", "image-preview svelte-86g6i3");
    },
    m(i, s) {
      ke(i, e, s), je(e, t);
    },
    p(i, s) {
      s & /*imagePreview*/
      1 && !Vy(t.src, n = /*imagePreview*/
      i[0]) && Me(t, "src", n);
    },
    d(i) {
      i && xe(e);
    }
  };
}
function O7(r) {
  let e, t, n, i, s, a, o, A = (
    /*imagePreview*/
    r[0] && l5(r)
  );
  return {
    c() {
      e = We("div"), t = We("label"), t.textContent = "Upload Image:", n = tt(), i = We("input"), s = tt(), A && A.c(), Me(t, "for", "imageUpload"), Me(i, "type", "file"), Me(i, "id", "imageUpload"), Me(i, "accept", "image/*"), Me(e, "class", "image-upload-section svelte-86g6i3");
    },
    m(l, u) {
      ke(l, e, u), je(e, t), je(e, n), je(e, i), je(e, s), A && A.m(e, null), a || (o = pt(
        i,
        "change",
        /*handleImageUpload*/
        r[1]
      ), a = !0);
    },
    p(l, [u]) {
      /*imagePreview*/
      l[0] ? A ? A.p(l, u) : (A = l5(l), A.c(), A.m(e, null)) : A && (A.d(1), A = null);
    },
    i: sr,
    o: sr,
    d(l) {
      l && xe(e), A && A.d(), a = !1, o();
    }
  };
}
function Q7(r, e, t) {
  let { content: n = "" } = e, { onContentChange: i } = e, s = OB.createImageFromBase64(n);
  async function a(o) {
    const A = o.target.files[0];
    if (A && A.type.startsWith("image/")) {
      const l = await OB.convertImageToBase64(A), u = new FileReader();
      u.onload = (c) => {
        var h;
        t(0, s = (h = c.target) == null ? void 0 : h.result);
      }, u.readAsDataURL(A), i(l);
    } else
      alert("Please upload a valid image file");
  }
  return r.$$set = (o) => {
    "content" in o && t(2, n = o.content), "onContentChange" in o && t(3, i = o.onContentChange);
  }, [s, a, n, i];
}
class oI extends jt {
  constructor(e) {
    super(), Pt(this, e, Q7, O7, Mt, { content: 2, onContentChange: 3 }, N7);
  }
  get content() {
    return this.$$.ctx[2];
  }
  set content(e) {
    this.$$set({ content: e }), pe();
  }
  get onContentChange() {
    return this.$$.ctx[3];
  }
  set onContentChange(e) {
    this.$$set({ onContentChange: e }), pe();
  }
}
Ht(oI, { content: {}, onContentChange: {} }, [], [], !0);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var D7 = {
  LABEL_FLOAT_ABOVE: "mdc-floating-label--float-above",
  LABEL_REQUIRED: "mdc-floating-label--required",
  LABEL_SHAKE: "mdc-floating-label--shake",
  ROOT: "mdc-floating-label"
};
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var M7 = (
  /** @class */
  function(r) {
    Zi(e, r);
    function e(t) {
      var n = r.call(this, Jr(Jr({}, e.defaultAdapter), t)) || this;
      return n.shakeAnimationEndHandler = function() {
        n.handleShakeAnimationEnd();
      }, n;
    }
    return Object.defineProperty(e, "cssClasses", {
      get: function() {
        return D7;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "defaultAdapter", {
      /**
       * See {@link MDCFloatingLabelAdapter} for typing information on parameters and return types.
       */
      get: function() {
        return {
          addClass: function() {
          },
          removeClass: function() {
          },
          getWidth: function() {
            return 0;
          },
          registerInteractionHandler: function() {
          },
          deregisterInteractionHandler: function() {
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.init = function() {
      this.adapter.registerInteractionHandler("animationend", this.shakeAnimationEndHandler);
    }, e.prototype.destroy = function() {
      this.adapter.deregisterInteractionHandler("animationend", this.shakeAnimationEndHandler);
    }, e.prototype.getWidth = function() {
      return this.adapter.getWidth();
    }, e.prototype.shake = function(t) {
      var n = e.cssClasses.LABEL_SHAKE;
      t ? this.adapter.addClass(n) : this.adapter.removeClass(n);
    }, e.prototype.float = function(t) {
      var n = e.cssClasses, i = n.LABEL_FLOAT_ABOVE, s = n.LABEL_SHAKE;
      t ? this.adapter.addClass(i) : (this.adapter.removeClass(i), this.adapter.removeClass(s));
    }, e.prototype.setRequired = function(t) {
      var n = e.cssClasses.LABEL_REQUIRED;
      t ? this.adapter.addClass(n) : this.adapter.removeClass(n);
    }, e.prototype.handleShakeAnimationEnd = function() {
      var t = e.cssClasses.LABEL_SHAKE;
      this.adapter.removeClass(t);
    }, e;
  }(La)
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var IA = {
  LINE_RIPPLE_ACTIVE: "mdc-line-ripple--active",
  LINE_RIPPLE_DEACTIVATING: "mdc-line-ripple--deactivating"
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var R7 = (
  /** @class */
  function(r) {
    Zi(e, r);
    function e(t) {
      var n = r.call(this, Jr(Jr({}, e.defaultAdapter), t)) || this;
      return n.transitionEndHandler = function(i) {
        n.handleTransitionEnd(i);
      }, n;
    }
    return Object.defineProperty(e, "cssClasses", {
      get: function() {
        return IA;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "defaultAdapter", {
      /**
       * See {@link MDCLineRippleAdapter} for typing information on parameters and return types.
       */
      get: function() {
        return {
          addClass: function() {
          },
          removeClass: function() {
          },
          hasClass: function() {
            return !1;
          },
          setStyle: function() {
          },
          registerEventHandler: function() {
          },
          deregisterEventHandler: function() {
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.init = function() {
      this.adapter.registerEventHandler("transitionend", this.transitionEndHandler);
    }, e.prototype.destroy = function() {
      this.adapter.deregisterEventHandler("transitionend", this.transitionEndHandler);
    }, e.prototype.activate = function() {
      this.adapter.removeClass(IA.LINE_RIPPLE_DEACTIVATING), this.adapter.addClass(IA.LINE_RIPPLE_ACTIVE);
    }, e.prototype.setRippleCenter = function(t) {
      this.adapter.setStyle("transform-origin", t + "px center");
    }, e.prototype.deactivate = function() {
      this.adapter.addClass(IA.LINE_RIPPLE_DEACTIVATING);
    }, e.prototype.handleTransitionEnd = function(t) {
      var n = this.adapter.hasClass(IA.LINE_RIPPLE_DEACTIVATING);
      t.propertyName === "opacity" && n && (this.adapter.removeClass(IA.LINE_RIPPLE_ACTIVE), this.adapter.removeClass(IA.LINE_RIPPLE_DEACTIVATING));
    }, e;
  }(La)
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var P7 = {
  NOTCH_ELEMENT_SELECTOR: ".mdc-notched-outline__notch"
}, u5 = {
  // This should stay in sync with $mdc-notched-outline-padding * 2.
  NOTCH_ELEMENT_PADDING: 8
}, H7 = {
  NO_LABEL: "mdc-notched-outline--no-label",
  OUTLINE_NOTCHED: "mdc-notched-outline--notched",
  OUTLINE_UPGRADED: "mdc-notched-outline--upgraded"
};
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var j7 = (
  /** @class */
  function(r) {
    Zi(e, r);
    function e(t) {
      return r.call(this, Jr(Jr({}, e.defaultAdapter), t)) || this;
    }
    return Object.defineProperty(e, "strings", {
      get: function() {
        return P7;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "cssClasses", {
      get: function() {
        return H7;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "numbers", {
      get: function() {
        return u5;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "defaultAdapter", {
      /**
       * See {@link MDCNotchedOutlineAdapter} for typing information on parameters and return types.
       */
      get: function() {
        return {
          addClass: function() {
          },
          removeClass: function() {
          },
          setNotchWidthProperty: function() {
          },
          removeNotchWidthProperty: function() {
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.notch = function(t) {
      var n = e.cssClasses.OUTLINE_NOTCHED;
      t > 0 && (t += u5.NOTCH_ELEMENT_PADDING), this.adapter.setNotchWidthProperty(t), this.adapter.addClass(n);
    }, e.prototype.closeNotch = function() {
      var t = e.cssClasses.OUTLINE_NOTCHED;
      this.adapter.removeClass(t), this.adapter.removeNotchWidthProperty();
    }, e;
  }(La)
);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var g0 = {
  ARIA_CONTROLS: "aria-controls",
  ARIA_DESCRIBEDBY: "aria-describedby",
  INPUT_SELECTOR: ".mdc-text-field__input",
  LABEL_SELECTOR: ".mdc-floating-label",
  LEADING_ICON_SELECTOR: ".mdc-text-field__icon--leading",
  LINE_RIPPLE_SELECTOR: ".mdc-line-ripple",
  OUTLINE_SELECTOR: ".mdc-notched-outline",
  PREFIX_SELECTOR: ".mdc-text-field__affix--prefix",
  SUFFIX_SELECTOR: ".mdc-text-field__affix--suffix",
  TRAILING_ICON_SELECTOR: ".mdc-text-field__icon--trailing"
}, K7 = {
  DISABLED: "mdc-text-field--disabled",
  FOCUSED: "mdc-text-field--focused",
  HELPER_LINE: "mdc-text-field-helper-line",
  INVALID: "mdc-text-field--invalid",
  LABEL_FLOATING: "mdc-text-field--label-floating",
  NO_LABEL: "mdc-text-field--no-label",
  OUTLINED: "mdc-text-field--outlined",
  ROOT: "mdc-text-field",
  TEXTAREA: "mdc-text-field--textarea",
  WITH_LEADING_ICON: "mdc-text-field--with-leading-icon",
  WITH_TRAILING_ICON: "mdc-text-field--with-trailing-icon",
  WITH_INTERNAL_COUNTER: "mdc-text-field--with-internal-counter"
}, c5 = {
  LABEL_SCALE: 0.75
}, $7 = [
  "pattern",
  "min",
  "max",
  "required",
  "step",
  "minlength",
  "maxlength"
], V7 = [
  "color",
  "date",
  "datetime-local",
  "month",
  "range",
  "time",
  "week"
];
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var f5 = ["mousedown", "touchstart"], h5 = ["click", "keydown"], z7 = (
  /** @class */
  function(r) {
    Zi(e, r);
    function e(t, n) {
      n === void 0 && (n = {});
      var i = r.call(this, Jr(Jr({}, e.defaultAdapter), t)) || this;
      return i.isFocused = !1, i.receivedUserInput = !1, i.valid = !0, i.useNativeValidation = !0, i.validateOnValueChange = !0, i.helperText = n.helperText, i.characterCounter = n.characterCounter, i.leadingIcon = n.leadingIcon, i.trailingIcon = n.trailingIcon, i.inputFocusHandler = function() {
        i.activateFocus();
      }, i.inputBlurHandler = function() {
        i.deactivateFocus();
      }, i.inputInputHandler = function() {
        i.handleInput();
      }, i.setPointerXOffset = function(s) {
        i.setTransformOrigin(s);
      }, i.textFieldInteractionHandler = function() {
        i.handleTextFieldInteraction();
      }, i.validationAttributeChangeHandler = function(s) {
        i.handleValidationAttributeChange(s);
      }, i;
    }
    return Object.defineProperty(e, "cssClasses", {
      get: function() {
        return K7;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "strings", {
      get: function() {
        return g0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "numbers", {
      get: function() {
        return c5;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "shouldAlwaysFloat", {
      get: function() {
        var t = this.getNativeInput().type;
        return V7.indexOf(t) >= 0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "shouldFloat", {
      get: function() {
        return this.shouldAlwaysFloat || this.isFocused || !!this.getValue() || this.isBadInput();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "shouldShake", {
      get: function() {
        return !this.isFocused && !this.isValid() && !!this.getValue();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "defaultAdapter", {
      /**
       * See {@link MDCTextFieldAdapter} for typing information on parameters and
       * return types.
       */
      get: function() {
        return {
          addClass: function() {
          },
          removeClass: function() {
          },
          hasClass: function() {
            return !0;
          },
          setInputAttr: function() {
          },
          removeInputAttr: function() {
          },
          registerTextFieldInteractionHandler: function() {
          },
          deregisterTextFieldInteractionHandler: function() {
          },
          registerInputInteractionHandler: function() {
          },
          deregisterInputInteractionHandler: function() {
          },
          registerValidationAttributeChangeHandler: function() {
            return new MutationObserver(function() {
            });
          },
          deregisterValidationAttributeChangeHandler: function() {
          },
          getNativeInput: function() {
            return null;
          },
          isFocused: function() {
            return !1;
          },
          activateLineRipple: function() {
          },
          deactivateLineRipple: function() {
          },
          setLineRippleTransformOrigin: function() {
          },
          shakeLabel: function() {
          },
          floatLabel: function() {
          },
          setLabelRequired: function() {
          },
          hasLabel: function() {
            return !1;
          },
          getLabelWidth: function() {
            return 0;
          },
          hasOutline: function() {
            return !1;
          },
          notchOutline: function() {
          },
          closeOutline: function() {
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.init = function() {
      var t, n, i, s;
      this.adapter.hasLabel() && this.getNativeInput().required && this.adapter.setLabelRequired(!0), this.adapter.isFocused() ? this.inputFocusHandler() : this.adapter.hasLabel() && this.shouldFloat && (this.notchOutline(!0), this.adapter.floatLabel(!0), this.styleFloating(!0)), this.adapter.registerInputInteractionHandler("focus", this.inputFocusHandler), this.adapter.registerInputInteractionHandler("blur", this.inputBlurHandler), this.adapter.registerInputInteractionHandler("input", this.inputInputHandler);
      try {
        for (var a = jo(f5), o = a.next(); !o.done; o = a.next()) {
          var A = o.value;
          this.adapter.registerInputInteractionHandler(A, this.setPointerXOffset);
        }
      } catch (c) {
        t = { error: c };
      } finally {
        try {
          o && !o.done && (n = a.return) && n.call(a);
        } finally {
          if (t) throw t.error;
        }
      }
      try {
        for (var l = jo(h5), u = l.next(); !u.done; u = l.next()) {
          var A = u.value;
          this.adapter.registerTextFieldInteractionHandler(A, this.textFieldInteractionHandler);
        }
      } catch (c) {
        i = { error: c };
      } finally {
        try {
          u && !u.done && (s = l.return) && s.call(l);
        } finally {
          if (i) throw i.error;
        }
      }
      this.validationObserver = this.adapter.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler), this.setcharacterCounter(this.getValue().length);
    }, e.prototype.destroy = function() {
      var t, n, i, s;
      this.adapter.deregisterInputInteractionHandler("focus", this.inputFocusHandler), this.adapter.deregisterInputInteractionHandler("blur", this.inputBlurHandler), this.adapter.deregisterInputInteractionHandler("input", this.inputInputHandler);
      try {
        for (var a = jo(f5), o = a.next(); !o.done; o = a.next()) {
          var A = o.value;
          this.adapter.deregisterInputInteractionHandler(A, this.setPointerXOffset);
        }
      } catch (c) {
        t = { error: c };
      } finally {
        try {
          o && !o.done && (n = a.return) && n.call(a);
        } finally {
          if (t) throw t.error;
        }
      }
      try {
        for (var l = jo(h5), u = l.next(); !u.done; u = l.next()) {
          var A = u.value;
          this.adapter.deregisterTextFieldInteractionHandler(A, this.textFieldInteractionHandler);
        }
      } catch (c) {
        i = { error: c };
      } finally {
        try {
          u && !u.done && (s = l.return) && s.call(l);
        } finally {
          if (i) throw i.error;
        }
      }
      this.adapter.deregisterValidationAttributeChangeHandler(this.validationObserver);
    }, e.prototype.handleTextFieldInteraction = function() {
      var t = this.adapter.getNativeInput();
      t && t.disabled || (this.receivedUserInput = !0);
    }, e.prototype.handleValidationAttributeChange = function(t) {
      var n = this;
      t.some(function(i) {
        return $7.indexOf(i) > -1 ? (n.styleValidity(!0), n.adapter.setLabelRequired(n.getNativeInput().required), !0) : !1;
      }), t.indexOf("maxlength") > -1 && this.setcharacterCounter(this.getValue().length);
    }, e.prototype.notchOutline = function(t) {
      if (!(!this.adapter.hasOutline() || !this.adapter.hasLabel()))
        if (t) {
          var n = this.adapter.getLabelWidth() * c5.LABEL_SCALE;
          this.adapter.notchOutline(n);
        } else
          this.adapter.closeOutline();
    }, e.prototype.activateFocus = function() {
      this.isFocused = !0, this.styleFocused(this.isFocused), this.adapter.activateLineRipple(), this.adapter.hasLabel() && (this.notchOutline(this.shouldFloat), this.adapter.floatLabel(this.shouldFloat), this.styleFloating(this.shouldFloat), this.adapter.shakeLabel(this.shouldShake)), this.helperText && (this.helperText.isPersistent() || !this.helperText.isValidation() || !this.valid) && this.helperText.showToScreenReader();
    }, e.prototype.setTransformOrigin = function(t) {
      if (!(this.isDisabled() || this.adapter.hasOutline())) {
        var n = t.touches, i = n ? n[0] : t, s = i.target.getBoundingClientRect(), a = i.clientX - s.left;
        this.adapter.setLineRippleTransformOrigin(a);
      }
    }, e.prototype.handleInput = function() {
      this.autoCompleteFocus(), this.setcharacterCounter(this.getValue().length);
    }, e.prototype.autoCompleteFocus = function() {
      this.receivedUserInput || this.activateFocus();
    }, e.prototype.deactivateFocus = function() {
      this.isFocused = !1, this.adapter.deactivateLineRipple();
      var t = this.isValid();
      this.styleValidity(t), this.styleFocused(this.isFocused), this.adapter.hasLabel() && (this.notchOutline(this.shouldFloat), this.adapter.floatLabel(this.shouldFloat), this.styleFloating(this.shouldFloat), this.adapter.shakeLabel(this.shouldShake)), this.shouldFloat || (this.receivedUserInput = !1);
    }, e.prototype.getValue = function() {
      return this.getNativeInput().value;
    }, e.prototype.setValue = function(t) {
      if (this.getValue() !== t && (this.getNativeInput().value = t), this.setcharacterCounter(t.length), this.validateOnValueChange) {
        var n = this.isValid();
        this.styleValidity(n);
      }
      this.adapter.hasLabel() && (this.notchOutline(this.shouldFloat), this.adapter.floatLabel(this.shouldFloat), this.styleFloating(this.shouldFloat), this.validateOnValueChange && this.adapter.shakeLabel(this.shouldShake));
    }, e.prototype.isValid = function() {
      return this.useNativeValidation ? this.isNativeInputValid() : this.valid;
    }, e.prototype.setValid = function(t) {
      this.valid = t, this.styleValidity(t);
      var n = !t && !this.isFocused && !!this.getValue();
      this.adapter.hasLabel() && this.adapter.shakeLabel(n);
    }, e.prototype.setValidateOnValueChange = function(t) {
      this.validateOnValueChange = t;
    }, e.prototype.getValidateOnValueChange = function() {
      return this.validateOnValueChange;
    }, e.prototype.setUseNativeValidation = function(t) {
      this.useNativeValidation = t;
    }, e.prototype.isDisabled = function() {
      return this.getNativeInput().disabled;
    }, e.prototype.setDisabled = function(t) {
      this.getNativeInput().disabled = t, this.styleDisabled(t);
    }, e.prototype.setHelperTextContent = function(t) {
      this.helperText && this.helperText.setContent(t);
    }, e.prototype.setLeadingIconAriaLabel = function(t) {
      this.leadingIcon && this.leadingIcon.setAriaLabel(t);
    }, e.prototype.setLeadingIconContent = function(t) {
      this.leadingIcon && this.leadingIcon.setContent(t);
    }, e.prototype.setTrailingIconAriaLabel = function(t) {
      this.trailingIcon && this.trailingIcon.setAriaLabel(t);
    }, e.prototype.setTrailingIconContent = function(t) {
      this.trailingIcon && this.trailingIcon.setContent(t);
    }, e.prototype.setcharacterCounter = function(t) {
      if (this.characterCounter) {
        var n = this.getNativeInput().maxLength;
        if (n === -1)
          throw new Error("MDCTextFieldFoundation: Expected maxlength html property on text input or textarea.");
        this.characterCounter.setCounterValue(t, n);
      }
    }, e.prototype.isBadInput = function() {
      return this.getNativeInput().validity.badInput || !1;
    }, e.prototype.isNativeInputValid = function() {
      return this.getNativeInput().validity.valid;
    }, e.prototype.styleValidity = function(t) {
      var n = e.cssClasses.INVALID;
      if (t ? this.adapter.removeClass(n) : this.adapter.addClass(n), this.helperText) {
        this.helperText.setValidity(t);
        var i = this.helperText.isValidation();
        if (!i)
          return;
        var s = this.helperText.isVisible(), a = this.helperText.getId();
        s && a ? this.adapter.setInputAttr(g0.ARIA_DESCRIBEDBY, a) : this.adapter.removeInputAttr(g0.ARIA_DESCRIBEDBY);
      }
    }, e.prototype.styleFocused = function(t) {
      var n = e.cssClasses.FOCUSED;
      t ? this.adapter.addClass(n) : this.adapter.removeClass(n);
    }, e.prototype.styleDisabled = function(t) {
      var n = e.cssClasses, i = n.DISABLED, s = n.INVALID;
      t ? (this.adapter.addClass(i), this.adapter.removeClass(s)) : this.adapter.removeClass(i), this.leadingIcon && this.leadingIcon.setDisabled(t), this.trailingIcon && this.trailingIcon.setDisabled(t);
    }, e.prototype.styleFloating = function(t) {
      var n = e.cssClasses.LABEL_FLOATING;
      t ? this.adapter.addClass(n) : this.adapter.removeClass(n);
    }, e.prototype.getNativeInput = function() {
      var t = this.adapter ? this.adapter.getNativeInput() : null;
      return t || {
        disabled: !1,
        maxLength: -1,
        required: !1,
        type: "input",
        validity: {
          badInput: !1,
          valid: !0
        },
        value: ""
      };
    }, e;
  }(La)
);
function G7(r) {
  let e, t, n, i, s, a, o, A;
  const l = (
    /*#slots*/
    r[22].default
  ), u = Nt(
    l,
    r,
    /*$$scope*/
    r[21],
    null
  );
  let c = [
    {
      class: t = ht({
        [
          /*className*/
          r[3]
        ]: !0,
        "mdc-floating-label": !0,
        "mdc-floating-label--float-above": (
          /*floatAbove*/
          r[0]
        ),
        "mdc-floating-label--required": (
          /*required*/
          r[1]
        ),
        .../*internalClasses*/
        r[8]
      })
    },
    {
      style: n = Object.entries(
        /*internalStyles*/
        r[9]
      ).map(p5).concat([
        /*style*/
        r[4]
      ]).join(" ")
    },
    {
      for: i = /*forId*/
      r[5] || /*inputProps*/
      (r[11] ? (
        /*inputProps*/
        r[11].id
      ) : void 0)
    },
    /*$$restProps*/
    r[12]
  ], h = {};
  for (let f = 0; f < c.length; f += 1)
    h = ze(h, c[f]);
  return {
    c() {
      e = We("label"), u && u.c(), Ut(e, h);
    },
    m(f, d) {
      ke(f, e, d), u && u.m(e, null), r[24](e), a = !0, o || (A = [
        Bt(s = xr.call(
          null,
          e,
          /*use*/
          r[2]
        )),
        Bt(
          /*forwardEvents*/
          r[10].call(null, e)
        )
      ], o = !0);
    },
    p(f, d) {
      u && u.p && (!a || d & /*$$scope*/
      2097152) && Qt(
        u,
        l,
        f,
        /*$$scope*/
        f[21],
        a ? Ot(
          l,
          /*$$scope*/
          f[21],
          d,
          null
        ) : Dt(
          /*$$scope*/
          f[21]
        ),
        null
      ), Ut(e, h = Et(c, [
        (!a || d & /*className, floatAbove, required, internalClasses*/
        267 && t !== (t = ht({
          [
            /*className*/
            f[3]
          ]: !0,
          "mdc-floating-label": !0,
          "mdc-floating-label--float-above": (
            /*floatAbove*/
            f[0]
          ),
          "mdc-floating-label--required": (
            /*required*/
            f[1]
          ),
          .../*internalClasses*/
          f[8]
        }))) && { class: t },
        (!a || d & /*internalStyles, style*/
        528 && n !== (n = Object.entries(
          /*internalStyles*/
          f[9]
        ).map(p5).concat([
          /*style*/
          f[4]
        ]).join(" "))) && { style: n },
        (!a || d & /*forId*/
        32 && i !== (i = /*forId*/
        f[5] || /*inputProps*/
        (f[11] ? (
          /*inputProps*/
          f[11].id
        ) : void 0))) && { for: i },
        d & /*$$restProps*/
        4096 && /*$$restProps*/
        f[12]
      ])), s && ar(s.update) && d & /*use*/
      4 && s.update.call(
        null,
        /*use*/
        f[2]
      );
    },
    i(f) {
      a || (fe(u, f), a = !0);
    },
    o(f) {
      ge(u, f), a = !1;
    },
    d(f) {
      f && xe(e), u && u.d(f), r[24](null), o = !1, fr(A);
    }
  };
}
function q7(r) {
  let e, t, n, i, s, a, o;
  const A = (
    /*#slots*/
    r[22].default
  ), l = Nt(
    A,
    r,
    /*$$scope*/
    r[21],
    null
  );
  let u = [
    {
      class: t = ht({
        [
          /*className*/
          r[3]
        ]: !0,
        "mdc-floating-label": !0,
        "mdc-floating-label--float-above": (
          /*floatAbove*/
          r[0]
        ),
        "mdc-floating-label--required": (
          /*required*/
          r[1]
        ),
        .../*internalClasses*/
        r[8]
      })
    },
    {
      style: n = Object.entries(
        /*internalStyles*/
        r[9]
      ).map(d5).concat([
        /*style*/
        r[4]
      ]).join(" ")
    },
    /*$$restProps*/
    r[12]
  ], c = {};
  for (let h = 0; h < u.length; h += 1)
    c = ze(c, u[h]);
  return {
    c() {
      e = We("span"), l && l.c(), Ut(e, c);
    },
    m(h, f) {
      ke(h, e, f), l && l.m(e, null), r[23](e), s = !0, a || (o = [
        Bt(i = xr.call(
          null,
          e,
          /*use*/
          r[2]
        )),
        Bt(
          /*forwardEvents*/
          r[10].call(null, e)
        )
      ], a = !0);
    },
    p(h, f) {
      l && l.p && (!s || f & /*$$scope*/
      2097152) && Qt(
        l,
        A,
        h,
        /*$$scope*/
        h[21],
        s ? Ot(
          A,
          /*$$scope*/
          h[21],
          f,
          null
        ) : Dt(
          /*$$scope*/
          h[21]
        ),
        null
      ), Ut(e, c = Et(u, [
        (!s || f & /*className, floatAbove, required, internalClasses*/
        267 && t !== (t = ht({
          [
            /*className*/
            h[3]
          ]: !0,
          "mdc-floating-label": !0,
          "mdc-floating-label--float-above": (
            /*floatAbove*/
            h[0]
          ),
          "mdc-floating-label--required": (
            /*required*/
            h[1]
          ),
          .../*internalClasses*/
          h[8]
        }))) && { class: t },
        (!s || f & /*internalStyles, style*/
        528 && n !== (n = Object.entries(
          /*internalStyles*/
          h[9]
        ).map(d5).concat([
          /*style*/
          h[4]
        ]).join(" "))) && { style: n },
        f & /*$$restProps*/
        4096 && /*$$restProps*/
        h[12]
      ])), i && ar(i.update) && f & /*use*/
      4 && i.update.call(
        null,
        /*use*/
        h[2]
      );
    },
    i(h) {
      s || (fe(l, h), s = !0);
    },
    o(h) {
      ge(l, h), s = !1;
    },
    d(h) {
      h && xe(e), l && l.d(h), r[23](null), a = !1, fr(o);
    }
  };
}
function W7(r) {
  let e, t, n, i;
  const s = [q7, G7], a = [];
  function o(A, l) {
    return (
      /*wrapped*/
      A[6] ? 0 : 1
    );
  }
  return e = o(r), t = a[e] = s[e](r), {
    c() {
      t.c(), n = Or();
    },
    m(A, l) {
      a[e].m(A, l), ke(A, n, l), i = !0;
    },
    p(A, [l]) {
      let u = e;
      e = o(A), e === u ? a[e].p(A, l) : (er(), ge(a[u], 1, 1, () => {
        a[u] = null;
      }), tr(), t = a[e], t ? t.p(A, l) : (t = a[e] = s[e](A), t.c()), fe(t, 1), t.m(n.parentNode, n));
    },
    i(A) {
      i || (fe(t), i = !0);
    },
    o(A) {
      ge(t), i = !1;
    },
    d(A) {
      A && xe(n), a[e].d(A);
    }
  };
}
const d5 = ([r, e]) => `${r}: ${e};`, p5 = ([r, e]) => `${r}: ${e};`;
function X7(r, e, t) {
  const n = [
    "use",
    "class",
    "style",
    "for",
    "floatAbove",
    "required",
    "wrapped",
    "shake",
    "float",
    "setRequired",
    "getWidth",
    "getElement"
  ];
  let i = xt(e, n), { $$slots: s = {}, $$scope: a } = e;
  var o;
  const A = Kr(yr());
  let { use: l = [] } = e, { class: u = "" } = e, { style: c = "" } = e, { for: h = void 0 } = e, { floatAbove: f = !1 } = e, { required: d = !1 } = e, { wrapped: p = !1 } = e, v, m, b = {}, w = {}, B = (o = pn("SMUI:generic:input:props")) !== null && o !== void 0 ? o : {}, _ = f, x = d;
  ui(() => {
    t(18, m = new M7({
      addClass: C,
      removeClass: F,
      getWidth: () => {
        var O, J;
        const Z = X(), U = Z.cloneNode(!0);
        (O = Z.parentNode) === null || O === void 0 || O.appendChild(U), U.classList.add("smui-floating-label--remove-transition"), U.classList.add("smui-floating-label--force-size"), U.classList.remove("mdc-floating-label--float-above");
        const P = U.scrollWidth;
        return (J = Z.parentNode) === null || J === void 0 || J.removeChild(U), P;
      },
      registerInteractionHandler: (O, J) => X().addEventListener(O, J),
      deregisterInteractionHandler: (O, J) => X().removeEventListener(O, J)
    }));
    const V = {
      get element() {
        return X();
      },
      addStyle: N,
      removeStyle: D
    };
    return pr(v, "SMUIFloatingLabel:mount", V), m.init(), () => {
      pr(v, "SMUIFloatingLabel:unmount", V), m.destroy();
    };
  });
  function C(V) {
    b[V] || t(8, b[V] = !0, b);
  }
  function F(V) {
    (!(V in b) || b[V]) && t(8, b[V] = !1, b);
  }
  function N(V, O) {
    w[V] != O && (O === "" || O == null ? (delete w[V], t(9, w)) : t(9, w[V] = O, w));
  }
  function D(V) {
    V in w && (delete w[V], t(9, w));
  }
  function T(V) {
    m.shake(V);
  }
  function E(V) {
    t(0, f = V);
  }
  function L(V) {
    t(1, d = V);
  }
  function S() {
    return m.getWidth();
  }
  function X() {
    return v;
  }
  function z(V) {
    yt[V ? "unshift" : "push"](() => {
      v = V, t(7, v);
    });
  }
  function R(V) {
    yt[V ? "unshift" : "push"](() => {
      v = V, t(7, v);
    });
  }
  return r.$$set = (V) => {
    e = ze(ze({}, e), Nr(V)), t(12, i = xt(e, n)), "use" in V && t(2, l = V.use), "class" in V && t(3, u = V.class), "style" in V && t(4, c = V.style), "for" in V && t(5, h = V.for), "floatAbove" in V && t(0, f = V.floatAbove), "required" in V && t(1, d = V.required), "wrapped" in V && t(6, p = V.wrapped), "$$scope" in V && t(21, a = V.$$scope);
  }, r.$$.update = () => {
    r.$$.dirty & /*instance, previousFloatAbove, floatAbove*/
    786433 && m && _ !== f && (t(19, _ = f), m.float(f)), r.$$.dirty & /*instance, previousRequired, required*/
    1310722 && m && x !== d && (t(20, x = d), m.setRequired(d));
  }, [
    f,
    d,
    l,
    u,
    c,
    h,
    p,
    v,
    b,
    w,
    A,
    B,
    i,
    T,
    E,
    L,
    S,
    X,
    m,
    _,
    x,
    a,
    s,
    z,
    R
  ];
}
class mb extends jt {
  constructor(e) {
    super(), Pt(this, e, X7, W7, Mt, {
      use: 2,
      class: 3,
      style: 4,
      for: 5,
      floatAbove: 0,
      required: 1,
      wrapped: 6,
      shake: 13,
      float: 14,
      setRequired: 15,
      getWidth: 16,
      getElement: 17
    });
  }
  get use() {
    return this.$$.ctx[2];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[3];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get style() {
    return this.$$.ctx[4];
  }
  set style(e) {
    this.$$set({ style: e }), pe();
  }
  get for() {
    return this.$$.ctx[5];
  }
  set for(e) {
    this.$$set({ for: e }), pe();
  }
  get floatAbove() {
    return this.$$.ctx[0];
  }
  set floatAbove(e) {
    this.$$set({ floatAbove: e }), pe();
  }
  get required() {
    return this.$$.ctx[1];
  }
  set required(e) {
    this.$$set({ required: e }), pe();
  }
  get wrapped() {
    return this.$$.ctx[6];
  }
  set wrapped(e) {
    this.$$set({ wrapped: e }), pe();
  }
  get shake() {
    return this.$$.ctx[13];
  }
  get float() {
    return this.$$.ctx[14];
  }
  get setRequired() {
    return this.$$.ctx[15];
  }
  get getWidth() {
    return this.$$.ctx[16];
  }
  get getElement() {
    return this.$$.ctx[17];
  }
}
Ht(mb, { use: {}, class: {}, style: {}, for: {}, floatAbove: { type: "Boolean" }, required: { type: "Boolean" }, wrapped: { type: "Boolean" } }, ["default"], ["shake", "float", "setRequired", "getWidth", "getElement"], !0);
function J7(r) {
  let e, t, n, i, s, a, o = [
    {
      class: t = ht({
        [
          /*className*/
          r[1]
        ]: !0,
        "mdc-line-ripple": !0,
        "mdc-line-ripple--active": (
          /*active*/
          r[3]
        ),
        .../*internalClasses*/
        r[5]
      })
    },
    {
      style: n = Object.entries(
        /*internalStyles*/
        r[6]
      ).map(g5).concat([
        /*style*/
        r[2]
      ]).join(" ")
    },
    /*$$restProps*/
    r[8]
  ], A = {};
  for (let l = 0; l < o.length; l += 1)
    A = ze(A, o[l]);
  return {
    c() {
      e = We("div"), Ut(e, A);
    },
    m(l, u) {
      ke(l, e, u), r[13](e), s || (a = [
        Bt(i = xr.call(
          null,
          e,
          /*use*/
          r[0]
        )),
        Bt(
          /*forwardEvents*/
          r[7].call(null, e)
        )
      ], s = !0);
    },
    p(l, [u]) {
      Ut(e, A = Et(o, [
        u & /*className, active, internalClasses*/
        42 && t !== (t = ht({
          [
            /*className*/
            l[1]
          ]: !0,
          "mdc-line-ripple": !0,
          "mdc-line-ripple--active": (
            /*active*/
            l[3]
          ),
          .../*internalClasses*/
          l[5]
        })) && { class: t },
        u & /*internalStyles, style*/
        68 && n !== (n = Object.entries(
          /*internalStyles*/
          l[6]
        ).map(g5).concat([
          /*style*/
          l[2]
        ]).join(" ")) && { style: n },
        u & /*$$restProps*/
        256 && /*$$restProps*/
        l[8]
      ])), i && ar(i.update) && u & /*use*/
      1 && i.update.call(
        null,
        /*use*/
        l[0]
      );
    },
    i: sr,
    o: sr,
    d(l) {
      l && xe(e), r[13](null), s = !1, fr(a);
    }
  };
}
const g5 = ([r, e]) => `${r}: ${e};`;
function Y7(r, e, t) {
  const n = [
    "use",
    "class",
    "style",
    "active",
    "activate",
    "deactivate",
    "setRippleCenter",
    "getElement"
  ];
  let i = xt(e, n);
  const s = Kr(yr());
  let { use: a = [] } = e, { class: o = "" } = e, { style: A = "" } = e, { active: l = !1 } = e, u, c, h = {}, f = {};
  ui(() => (c = new R7({
    addClass: p,
    removeClass: v,
    hasClass: d,
    setStyle: m,
    registerEventHandler: (C, F) => _().addEventListener(C, F),
    deregisterEventHandler: (C, F) => _().removeEventListener(C, F)
  }), c.init(), () => {
    c.destroy();
  }));
  function d(C) {
    return C in h ? h[C] : _().classList.contains(C);
  }
  function p(C) {
    h[C] || t(5, h[C] = !0, h);
  }
  function v(C) {
    (!(C in h) || h[C]) && t(5, h[C] = !1, h);
  }
  function m(C, F) {
    f[C] != F && (F === "" || F == null ? (delete f[C], t(6, f)) : t(6, f[C] = F, f));
  }
  function b() {
    c.activate();
  }
  function w() {
    c.deactivate();
  }
  function B(C) {
    c.setRippleCenter(C);
  }
  function _() {
    return u;
  }
  function x(C) {
    yt[C ? "unshift" : "push"](() => {
      u = C, t(4, u);
    });
  }
  return r.$$set = (C) => {
    e = ze(ze({}, e), Nr(C)), t(8, i = xt(e, n)), "use" in C && t(0, a = C.use), "class" in C && t(1, o = C.class), "style" in C && t(2, A = C.style), "active" in C && t(3, l = C.active);
  }, [
    a,
    o,
    A,
    l,
    u,
    h,
    f,
    s,
    i,
    b,
    w,
    B,
    _,
    x
  ];
}
class AI extends jt {
  constructor(e) {
    super(), Pt(this, e, Y7, J7, Mt, {
      use: 0,
      class: 1,
      style: 2,
      active: 3,
      activate: 9,
      deactivate: 10,
      setRippleCenter: 11,
      getElement: 12
    });
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[1];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get style() {
    return this.$$.ctx[2];
  }
  set style(e) {
    this.$$set({ style: e }), pe();
  }
  get active() {
    return this.$$.ctx[3];
  }
  set active(e) {
    this.$$set({ active: e }), pe();
  }
  get activate() {
    return this.$$.ctx[9];
  }
  get deactivate() {
    return this.$$.ctx[10];
  }
  get setRippleCenter() {
    return this.$$.ctx[11];
  }
  get getElement() {
    return this.$$.ctx[12];
  }
}
Ht(AI, { use: {}, class: {}, style: {}, active: { type: "Boolean" } }, [], ["activate", "deactivate", "setRippleCenter", "getElement"], !0);
function m5(r) {
  let e, t, n;
  const i = (
    /*#slots*/
    r[15].default
  ), s = Nt(
    i,
    r,
    /*$$scope*/
    r[14],
    null
  );
  return {
    c() {
      e = We("div"), s && s.c(), Me(e, "class", "mdc-notched-outline__notch"), Me(e, "style", t = Object.entries(
        /*notchStyles*/
        r[7]
      ).map(v5).join(" "));
    },
    m(a, o) {
      ke(a, e, o), s && s.m(e, null), n = !0;
    },
    p(a, o) {
      s && s.p && (!n || o & /*$$scope*/
      16384) && Qt(
        s,
        i,
        a,
        /*$$scope*/
        a[14],
        n ? Ot(
          i,
          /*$$scope*/
          a[14],
          o,
          null
        ) : Dt(
          /*$$scope*/
          a[14]
        ),
        null
      ), (!n || o & /*notchStyles*/
      128 && t !== (t = Object.entries(
        /*notchStyles*/
        a[7]
      ).map(v5).join(" "))) && Me(e, "style", t);
    },
    i(a) {
      n || (fe(s, a), n = !0);
    },
    o(a) {
      ge(s, a), n = !1;
    },
    d(a) {
      a && xe(e), s && s.d(a);
    }
  };
}
function Z7(r) {
  let e, t, n, i, s, a, o, A, l, u, c = !/*noLabel*/
  r[3] && m5(r), h = [
    {
      class: a = ht({
        [
          /*className*/
          r[1]
        ]: !0,
        "mdc-notched-outline": !0,
        "mdc-notched-outline--notched": (
          /*notched*/
          r[2]
        ),
        "mdc-notched-outline--no-label": (
          /*noLabel*/
          r[3]
        ),
        .../*internalClasses*/
        r[6]
      })
    },
    /*$$restProps*/
    r[10]
  ], f = {};
  for (let d = 0; d < h.length; d += 1)
    f = ze(f, h[d]);
  return {
    c() {
      e = We("div"), t = We("div"), n = tt(), c && c.c(), i = tt(), s = We("div"), Me(t, "class", "mdc-notched-outline__leading"), Me(s, "class", "mdc-notched-outline__trailing"), Ut(e, f);
    },
    m(d, p) {
      ke(d, e, p), je(e, t), je(e, n), c && c.m(e, null), je(e, i), je(e, s), r[16](e), A = !0, l || (u = [
        Bt(o = xr.call(
          null,
          e,
          /*use*/
          r[0]
        )),
        Bt(
          /*forwardEvents*/
          r[8].call(null, e)
        ),
        pt(
          e,
          "SMUIFloatingLabel:mount",
          /*handleFloatingLabelMount*/
          r[9]
        ),
        pt(
          e,
          "SMUIFloatingLabel:unmount",
          /*SMUIFloatingLabel_unmount_handler*/
          r[17]
        )
      ], l = !0);
    },
    p(d, [p]) {
      /*noLabel*/
      d[3] ? c && (er(), ge(c, 1, 1, () => {
        c = null;
      }), tr()) : c ? (c.p(d, p), p & /*noLabel*/
      8 && fe(c, 1)) : (c = m5(d), c.c(), fe(c, 1), c.m(e, i)), Ut(e, f = Et(h, [
        (!A || p & /*className, notched, noLabel, internalClasses*/
        78 && a !== (a = ht({
          [
            /*className*/
            d[1]
          ]: !0,
          "mdc-notched-outline": !0,
          "mdc-notched-outline--notched": (
            /*notched*/
            d[2]
          ),
          "mdc-notched-outline--no-label": (
            /*noLabel*/
            d[3]
          ),
          .../*internalClasses*/
          d[6]
        }))) && { class: a },
        p & /*$$restProps*/
        1024 && /*$$restProps*/
        d[10]
      ])), o && ar(o.update) && p & /*use*/
      1 && o.update.call(
        null,
        /*use*/
        d[0]
      );
    },
    i(d) {
      A || (fe(c), A = !0);
    },
    o(d) {
      ge(c), A = !1;
    },
    d(d) {
      d && xe(e), c && c.d(), r[16](null), l = !1, fr(u);
    }
  };
}
const v5 = ([r, e]) => `${r}: ${e};`;
function e9(r, e, t) {
  const n = ["use", "class", "notched", "noLabel", "notch", "closeNotch", "getElement"];
  let i = xt(e, n), { $$slots: s = {}, $$scope: a } = e;
  const o = Kr(yr());
  let { use: A = [] } = e, { class: l = "" } = e, { notched: u = !1 } = e, { noLabel: c = !1 } = e, h, f, d, p = {}, v = {};
  ui(() => (f = new j7({
    addClass: b,
    removeClass: w,
    setNotchWidthProperty: (T) => B("width", T + "px"),
    removeNotchWidthProperty: () => _("width")
  }), f.init(), () => {
    f.destroy();
  }));
  function m(T) {
    t(4, d = T.detail);
  }
  function b(T) {
    p[T] || t(6, p[T] = !0, p);
  }
  function w(T) {
    (!(T in p) || p[T]) && t(6, p[T] = !1, p);
  }
  function B(T, E) {
    v[T] != E && (E === "" || E == null ? (delete v[T], t(7, v)) : t(7, v[T] = E, v));
  }
  function _(T) {
    T in v && (delete v[T], t(7, v));
  }
  function x(T) {
    f.notch(T);
  }
  function C() {
    f.closeNotch();
  }
  function F() {
    return h;
  }
  function N(T) {
    yt[T ? "unshift" : "push"](() => {
      h = T, t(5, h);
    });
  }
  const D = () => t(4, d = void 0);
  return r.$$set = (T) => {
    e = ze(ze({}, e), Nr(T)), t(10, i = xt(e, n)), "use" in T && t(0, A = T.use), "class" in T && t(1, l = T.class), "notched" in T && t(2, u = T.notched), "noLabel" in T && t(3, c = T.noLabel), "$$scope" in T && t(14, a = T.$$scope);
  }, r.$$.update = () => {
    r.$$.dirty & /*floatingLabel*/
    16 && (d ? (d.addStyle("transition-duration", "0s"), b("mdc-notched-outline--upgraded"), requestAnimationFrame(() => {
      d && d.removeStyle("transition-duration");
    })) : w("mdc-notched-outline--upgraded"));
  }, [
    A,
    l,
    u,
    c,
    d,
    h,
    p,
    v,
    o,
    m,
    i,
    x,
    C,
    F,
    a,
    s,
    N,
    D
  ];
}
class lI extends jt {
  constructor(e) {
    super(), Pt(this, e, e9, Z7, Mt, {
      use: 0,
      class: 1,
      notched: 2,
      noLabel: 3,
      notch: 11,
      closeNotch: 12,
      getElement: 13
    });
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[1];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get notched() {
    return this.$$.ctx[2];
  }
  set notched(e) {
    this.$$set({ notched: e }), pe();
  }
  get noLabel() {
    return this.$$.ctx[3];
  }
  set noLabel(e) {
    this.$$set({ noLabel: e }), pe();
  }
  get notch() {
    return this.$$.ctx[11];
  }
  get closeNotch() {
    return this.$$.ctx[12];
  }
  get getElement() {
    return this.$$.ctx[13];
  }
}
Ht(lI, { use: {}, class: {}, notched: { type: "Boolean" }, noLabel: { type: "Boolean" } }, ["default"], ["notch", "closeNotch", "getElement"], !0);
const t9 = Ua({
  class: "mdc-text-field-helper-line",
  tag: "div"
}), r9 = Ua({
  class: "mdc-text-field__affix mdc-text-field__affix--prefix",
  tag: "span"
}), n9 = Ua({
  class: "mdc-text-field__affix mdc-text-field__affix--suffix",
  tag: "span"
});
function i9(r) {
  let e, t, n, i, s, a = [
    {
      class: t = ht({
        [
          /*className*/
          r[1]
        ]: !0,
        "mdc-text-field__input": !0
      })
    },
    { type: (
      /*type*/
      r[2]
    ) },
    { placeholder: (
      /*placeholder*/
      r[3]
    ) },
    /*valueProp*/
    r[4],
    /*internalAttrs*/
    r[6],
    /*$$restProps*/
    r[10]
  ], o = {};
  for (let A = 0; A < a.length; A += 1)
    o = ze(o, a[A]);
  return {
    c() {
      e = We("input"), Ut(e, o);
    },
    m(A, l) {
      ke(A, e, l), e.autofocus && e.focus(), r[26](e), i || (s = [
        Bt(n = xr.call(
          null,
          e,
          /*use*/
          r[0]
        )),
        Bt(
          /*forwardEvents*/
          r[7].call(null, e)
        ),
        pt(
          e,
          "input",
          /*input_handler*/
          r[27]
        ),
        pt(
          e,
          "change",
          /*changeHandler*/
          r[9]
        ),
        pt(
          e,
          "blur",
          /*blur_handler*/
          r[24]
        ),
        pt(
          e,
          "focus",
          /*focus_handler*/
          r[25]
        )
      ], i = !0);
    },
    p(A, [l]) {
      Ut(e, o = Et(a, [
        l & /*className*/
        2 && t !== (t = ht({
          [
            /*className*/
            A[1]
          ]: !0,
          "mdc-text-field__input": !0
        })) && { class: t },
        l & /*type*/
        4 && { type: (
          /*type*/
          A[2]
        ) },
        l & /*placeholder*/
        8 && { placeholder: (
          /*placeholder*/
          A[3]
        ) },
        l & /*valueProp*/
        16 && /*valueProp*/
        A[4],
        l & /*internalAttrs*/
        64 && /*internalAttrs*/
        A[6],
        l & /*$$restProps*/
        1024 && /*$$restProps*/
        A[10]
      ])), n && ar(n.update) && l & /*use*/
      1 && n.update.call(
        null,
        /*use*/
        A[0]
      );
    },
    i: sr,
    o: sr,
    d(A) {
      A && xe(e), r[26](null), i = !1, fr(s);
    }
  };
}
function s9(r) {
  return r === "" ? Number.NaN : +r;
}
function a9(r, e, t) {
  const n = [
    "use",
    "class",
    "type",
    "placeholder",
    "value",
    "files",
    "dirty",
    "invalid",
    "updateInvalid",
    "emptyValueNull",
    "emptyValueUndefined",
    "getAttr",
    "addAttr",
    "removeAttr",
    "focus",
    "blur",
    "getElement"
  ];
  let i = xt(e, n);
  const s = Kr(yr());
  let a = () => {
  };
  function o(O) {
    return O === a;
  }
  let { use: A = [] } = e, { class: l = "" } = e, { type: u = "text" } = e, { placeholder: c = " " } = e, { value: h = a } = e;
  const f = o(h);
  f && (h = "");
  let { files: d = null } = e, { dirty: p = !1 } = e, { invalid: v = !1 } = e, { updateInvalid: m = !0 } = e, { emptyValueNull: b = h === null } = e;
  f && b && (h = null);
  let { emptyValueUndefined: w = h === void 0 } = e;
  f && w && (h = void 0);
  let B, _ = {}, x = {};
  ui(() => {
    m && t(14, v = B.matches(":invalid"));
  });
  function C(O) {
    if (u === "file") {
      t(12, d = O.currentTarget.files);
      return;
    }
    if (O.currentTarget.value === "" && b) {
      t(11, h = null);
      return;
    }
    if (O.currentTarget.value === "" && w) {
      t(11, h = void 0);
      return;
    }
    switch (u) {
      case "number":
      case "range":
        t(11, h = s9(O.currentTarget.value));
        break;
      default:
        t(11, h = O.currentTarget.value);
        break;
    }
  }
  function F(O) {
    (u === "file" || u === "range") && C(O), t(13, p = !0), m && t(14, v = B.matches(":invalid"));
  }
  function N(O) {
    var J;
    return O in _ ? (J = _[O]) !== null && J !== void 0 ? J : null : S().getAttribute(O);
  }
  function D(O, J) {
    _[O] !== J && t(6, _[O] = J, _);
  }
  function T(O) {
    (!(O in _) || _[O] != null) && t(6, _[O] = void 0, _);
  }
  function E() {
    S().focus();
  }
  function L() {
    S().blur();
  }
  function S() {
    return B;
  }
  function X(O) {
    Sa.call(this, r, O);
  }
  function z(O) {
    Sa.call(this, r, O);
  }
  function R(O) {
    yt[O ? "unshift" : "push"](() => {
      B = O, t(5, B);
    });
  }
  const V = (O) => u !== "file" && C(O);
  return r.$$set = (O) => {
    e = ze(ze({}, e), Nr(O)), t(10, i = xt(e, n)), "use" in O && t(0, A = O.use), "class" in O && t(1, l = O.class), "type" in O && t(2, u = O.type), "placeholder" in O && t(3, c = O.placeholder), "value" in O && t(11, h = O.value), "files" in O && t(12, d = O.files), "dirty" in O && t(13, p = O.dirty), "invalid" in O && t(14, v = O.invalid), "updateInvalid" in O && t(15, m = O.updateInvalid), "emptyValueNull" in O && t(16, b = O.emptyValueNull), "emptyValueUndefined" in O && t(17, w = O.emptyValueUndefined);
  }, r.$$.update = () => {
    r.$$.dirty & /*type, valueProp, value*/
    2068 && (u === "file" ? (delete x.value, t(4, x), t(2, u), t(11, h)) : t(4, x.value = h ?? "", x));
  }, [
    A,
    l,
    u,
    c,
    x,
    B,
    _,
    s,
    C,
    F,
    i,
    h,
    d,
    p,
    v,
    m,
    b,
    w,
    N,
    D,
    T,
    E,
    L,
    S,
    X,
    z,
    R,
    V
  ];
}
class uI extends jt {
  constructor(e) {
    super(), Pt(this, e, a9, i9, Mt, {
      use: 0,
      class: 1,
      type: 2,
      placeholder: 3,
      value: 11,
      files: 12,
      dirty: 13,
      invalid: 14,
      updateInvalid: 15,
      emptyValueNull: 16,
      emptyValueUndefined: 17,
      getAttr: 18,
      addAttr: 19,
      removeAttr: 20,
      focus: 21,
      blur: 22,
      getElement: 23
    });
  }
  get use() {
    return this.$$.ctx[0];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[1];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get type() {
    return this.$$.ctx[2];
  }
  set type(e) {
    this.$$set({ type: e }), pe();
  }
  get placeholder() {
    return this.$$.ctx[3];
  }
  set placeholder(e) {
    this.$$set({ placeholder: e }), pe();
  }
  get value() {
    return this.$$.ctx[11];
  }
  set value(e) {
    this.$$set({ value: e }), pe();
  }
  get files() {
    return this.$$.ctx[12];
  }
  set files(e) {
    this.$$set({ files: e }), pe();
  }
  get dirty() {
    return this.$$.ctx[13];
  }
  set dirty(e) {
    this.$$set({ dirty: e }), pe();
  }
  get invalid() {
    return this.$$.ctx[14];
  }
  set invalid(e) {
    this.$$set({ invalid: e }), pe();
  }
  get updateInvalid() {
    return this.$$.ctx[15];
  }
  set updateInvalid(e) {
    this.$$set({ updateInvalid: e }), pe();
  }
  get emptyValueNull() {
    return this.$$.ctx[16];
  }
  set emptyValueNull(e) {
    this.$$set({ emptyValueNull: e }), pe();
  }
  get emptyValueUndefined() {
    return this.$$.ctx[17];
  }
  set emptyValueUndefined(e) {
    this.$$set({ emptyValueUndefined: e }), pe();
  }
  get getAttr() {
    return this.$$.ctx[18];
  }
  get addAttr() {
    return this.$$.ctx[19];
  }
  get removeAttr() {
    return this.$$.ctx[20];
  }
  get focus() {
    return this.$$.ctx[21];
  }
  get blur() {
    return this.$$.ctx[22];
  }
  get getElement() {
    return this.$$.ctx[23];
  }
}
Ht(uI, { use: {}, class: {}, type: {}, placeholder: {}, value: {}, files: {}, dirty: { type: "Boolean" }, invalid: { type: "Boolean" }, updateInvalid: { type: "Boolean" }, emptyValueNull: {}, emptyValueUndefined: {} }, [], ["getAttr", "addAttr", "removeAttr", "focus", "blur", "getElement"], !0);
function o9(r) {
  let e, t, n, i, s, a, o = [
    {
      class: t = ht({
        [
          /*className*/
          r[2]
        ]: !0,
        "mdc-text-field__input": !0
      })
    },
    {
      style: n = `${/*resizable*/
      r[4] ? "" : "resize: none; "}${/*style*/
      r[3]}`
    },
    /*internalAttrs*/
    r[6],
    /*$$restProps*/
    r[9]
  ], A = {};
  for (let l = 0; l < o.length; l += 1)
    A = ze(A, o[l]);
  return {
    c() {
      e = We("textarea"), Ut(e, A);
    },
    m(l, u) {
      ke(l, e, u), e.autofocus && e.focus(), r[21](e), zy(
        e,
        /*value*/
        r[0]
      ), s || (a = [
        Bt(i = xr.call(
          null,
          e,
          /*use*/
          r[1]
        )),
        Bt(
          /*forwardEvents*/
          r[7].call(null, e)
        ),
        pt(
          e,
          "change",
          /*changeHandler*/
          r[8]
        ),
        pt(
          e,
          "blur",
          /*blur_handler*/
          r[19]
        ),
        pt(
          e,
          "focus",
          /*focus_handler*/
          r[20]
        ),
        pt(
          e,
          "input",
          /*textarea_input_handler*/
          r[22]
        )
      ], s = !0);
    },
    p(l, [u]) {
      Ut(e, A = Et(o, [
        u & /*className*/
        4 && t !== (t = ht({
          [
            /*className*/
            l[2]
          ]: !0,
          "mdc-text-field__input": !0
        })) && { class: t },
        u & /*resizable, style*/
        24 && n !== (n = `${/*resizable*/
        l[4] ? "" : "resize: none; "}${/*style*/
        l[3]}`) && { style: n },
        u & /*internalAttrs*/
        64 && /*internalAttrs*/
        l[6],
        u & /*$$restProps*/
        512 && /*$$restProps*/
        l[9]
      ])), i && ar(i.update) && u & /*use*/
      2 && i.update.call(
        null,
        /*use*/
        l[1]
      ), u & /*value*/
      1 && zy(
        e,
        /*value*/
        l[0]
      );
    },
    i: sr,
    o: sr,
    d(l) {
      l && xe(e), r[21](null), s = !1, fr(a);
    }
  };
}
function A9(r, e, t) {
  const n = [
    "use",
    "class",
    "style",
    "value",
    "dirty",
    "invalid",
    "updateInvalid",
    "resizable",
    "getAttr",
    "addAttr",
    "removeAttr",
    "focus",
    "blur",
    "getElement"
  ];
  let i = xt(e, n);
  const s = Kr(yr());
  let { use: a = [] } = e, { class: o = "" } = e, { style: A = "" } = e, { value: l = "" } = e, { dirty: u = !1 } = e, { invalid: c = !1 } = e, { updateInvalid: h = !0 } = e, { resizable: f = !0 } = e, d, p = {};
  ui(() => {
    h && t(11, c = d.matches(":invalid"));
  });
  function v() {
    t(10, u = !0), h && t(11, c = d.matches(":invalid"));
  }
  function m(T) {
    var E;
    return T in p ? (E = p[T]) !== null && E !== void 0 ? E : null : x().getAttribute(T);
  }
  function b(T, E) {
    p[T] !== E && t(6, p[T] = E, p);
  }
  function w(T) {
    (!(T in p) || p[T] != null) && t(6, p[T] = void 0, p);
  }
  function B() {
    x().focus();
  }
  function _() {
    x().blur();
  }
  function x() {
    return d;
  }
  function C(T) {
    Sa.call(this, r, T);
  }
  function F(T) {
    Sa.call(this, r, T);
  }
  function N(T) {
    yt[T ? "unshift" : "push"](() => {
      d = T, t(5, d);
    });
  }
  function D() {
    l = this.value, t(0, l);
  }
  return r.$$set = (T) => {
    e = ze(ze({}, e), Nr(T)), t(9, i = xt(e, n)), "use" in T && t(1, a = T.use), "class" in T && t(2, o = T.class), "style" in T && t(3, A = T.style), "value" in T && t(0, l = T.value), "dirty" in T && t(10, u = T.dirty), "invalid" in T && t(11, c = T.invalid), "updateInvalid" in T && t(12, h = T.updateInvalid), "resizable" in T && t(4, f = T.resizable);
  }, [
    l,
    a,
    o,
    A,
    f,
    d,
    p,
    s,
    v,
    i,
    u,
    c,
    h,
    m,
    b,
    w,
    B,
    _,
    x,
    C,
    F,
    N,
    D
  ];
}
class cI extends jt {
  constructor(e) {
    super(), Pt(this, e, A9, o9, Mt, {
      use: 1,
      class: 2,
      style: 3,
      value: 0,
      dirty: 10,
      invalid: 11,
      updateInvalid: 12,
      resizable: 4,
      getAttr: 13,
      addAttr: 14,
      removeAttr: 15,
      focus: 16,
      blur: 17,
      getElement: 18
    });
  }
  get use() {
    return this.$$.ctx[1];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[2];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get style() {
    return this.$$.ctx[3];
  }
  set style(e) {
    this.$$set({ style: e }), pe();
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(e) {
    this.$$set({ value: e }), pe();
  }
  get dirty() {
    return this.$$.ctx[10];
  }
  set dirty(e) {
    this.$$set({ dirty: e }), pe();
  }
  get invalid() {
    return this.$$.ctx[11];
  }
  set invalid(e) {
    this.$$set({ invalid: e }), pe();
  }
  get updateInvalid() {
    return this.$$.ctx[12];
  }
  set updateInvalid(e) {
    this.$$set({ updateInvalid: e }), pe();
  }
  get resizable() {
    return this.$$.ctx[4];
  }
  set resizable(e) {
    this.$$set({ resizable: e }), pe();
  }
  get getAttr() {
    return this.$$.ctx[13];
  }
  get addAttr() {
    return this.$$.ctx[14];
  }
  get removeAttr() {
    return this.$$.ctx[15];
  }
  get focus() {
    return this.$$.ctx[16];
  }
  get blur() {
    return this.$$.ctx[17];
  }
  get getElement() {
    return this.$$.ctx[18];
  }
}
Ht(cI, { use: {}, class: {}, style: {}, value: {}, dirty: { type: "Boolean" }, invalid: { type: "Boolean" }, updateInvalid: { type: "Boolean" }, resizable: { type: "Boolean" } }, [], ["getAttr", "addAttr", "removeAttr", "focus", "blur", "getElement"], !0);
const l9 = (r) => ({}), b5 = (r) => ({}), u9 = (r) => ({}), y5 = (r) => ({}), c9 = (r) => ({}), w5 = (r) => ({}), f9 = (r) => ({}), B5 = (r) => ({}), h9 = (r) => ({}), C5 = (r) => ({}), d9 = (r) => ({}), _5 = (r) => ({}), p9 = (r) => ({}), E5 = (r) => ({}), g9 = (r) => ({}), S5 = (r) => ({}), m9 = (r) => ({}), I5 = (r) => ({}), v9 = (r) => ({}), F5 = (r) => ({}), b9 = (r) => ({}), T5 = (r) => ({}), y9 = (r) => ({}), x5 = (r) => ({});
function w9(r) {
  let e, t, n, i, s, a, o, A, l, u, c, h, f, d;
  const p = (
    /*#slots*/
    r[56].label
  ), v = Nt(
    p,
    r,
    /*$$scope*/
    r[87],
    C5
  );
  n = new pf({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: !0,
      $$slots: { default: [C9] },
      $$scope: { ctx: r }
    }
  });
  const m = (
    /*#slots*/
    r[56].default
  ), b = Nt(
    m,
    r,
    /*$$scope*/
    r[87],
    null
  );
  a = new pf({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: !1,
      $$slots: { default: [_9] },
      $$scope: { ctx: r }
    }
  });
  const w = (
    /*#slots*/
    r[56].ripple
  ), B = Nt(
    w,
    r,
    /*$$scope*/
    r[87],
    y5
  );
  let _ = [
    {
      class: A = ht({
        [
          /*className*/
          r[9]
        ]: !0,
        "mdc-text-field": !0,
        "mdc-text-field--disabled": (
          /*disabled*/
          r[12]
        ),
        "mdc-text-field--textarea": (
          /*textarea*/
          r[14]
        ),
        "mdc-text-field--filled": (
          /*variant*/
          r[15] === "filled"
        ),
        "mdc-text-field--outlined": (
          /*variant*/
          r[15] === "outlined"
        ),
        "smui-text-field--standard": (
          /*variant*/
          r[15] === "standard" && !/*textarea*/
          r[14]
        ),
        "mdc-text-field--no-label": (
          /*noLabel*/
          r[16] || !/*$$slots*/
          r[47].label
        ),
        "mdc-text-field--with-leading-icon": (
          /*$$slots*/
          r[47].leadingIcon
        ),
        "mdc-text-field--with-trailing-icon": (
          /*$$slots*/
          r[47].trailingIcon
        ),
        "mdc-text-field--invalid": (
          /*invalid*/
          r[1]
        ),
        .../*internalClasses*/
        r[25]
      })
    },
    {
      style: l = Object.entries(
        /*internalStyles*/
        r[26]
      ).map(H5).concat([
        /*style*/
        r[10]
      ]).join(" ")
    },
    Ia(
      /*$$restProps*/
      r[46],
      ["input$", "label$", "ripple$", "outline$", "helperLine$"]
    )
  ], x = {};
  for (let C = 0; C < _.length; C += 1)
    x = ze(x, _[C]);
  return {
    c() {
      e = We("div"), v && v.c(), t = tt(), Ve(n.$$.fragment), i = tt(), b && b.c(), s = tt(), Ve(a.$$.fragment), o = tt(), B && B.c(), Ut(e, x);
    },
    m(C, F) {
      ke(C, e, F), v && v.m(e, null), je(e, t), Ke(n, e, null), je(e, i), b && b.m(e, null), je(e, s), Ke(a, e, null), je(e, o), B && B.m(e, null), r[82](e), h = !0, f || (d = [
        Bt(u = io.call(null, e, {
          ripple: (
            /*ripple*/
            r[11]
          ),
          unbounded: !1,
          addClass: (
            /*addClass*/
            r[43]
          ),
          removeClass: (
            /*removeClass*/
            r[44]
          ),
          addStyle: (
            /*addStyle*/
            r[45]
          )
        })),
        Bt(c = xr.call(
          null,
          e,
          /*use*/
          r[8]
        )),
        Bt(
          /*forwardEvents*/
          r[34].call(null, e)
        ),
        pt(
          e,
          "SMUITextfieldLeadingIcon:mount",
          /*handleLeadingIconMount*/
          r[38]
        ),
        pt(
          e,
          "SMUITextfieldLeadingIcon:unmount",
          /*SMUITextfieldLeadingIcon_unmount_handler_1*/
          r[83]
        ),
        pt(
          e,
          "SMUITextfieldTrailingIcon:mount",
          /*handleTrailingIconMount*/
          r[39]
        ),
        pt(
          e,
          "SMUITextfieldTrailingIcon:unmount",
          /*SMUITextfieldTrailingIcon_unmount_handler_1*/
          r[84]
        )
      ], f = !0);
    },
    p(C, F) {
      v && v.p && (!h || F[2] & /*$$scope*/
      33554432) && Qt(
        v,
        p,
        C,
        /*$$scope*/
        C[87],
        h ? Ot(
          p,
          /*$$scope*/
          C[87],
          F,
          h9
        ) : Dt(
          /*$$scope*/
          C[87]
        ),
        C5
      );
      const N = {};
      F[2] & /*$$scope*/
      33554432 && (N.$$scope = { dirty: F, ctx: C }), n.$set(N), b && b.p && (!h || F[2] & /*$$scope*/
      33554432) && Qt(
        b,
        m,
        C,
        /*$$scope*/
        C[87],
        h ? Ot(
          m,
          /*$$scope*/
          C[87],
          F,
          null
        ) : Dt(
          /*$$scope*/
          C[87]
        ),
        null
      );
      const D = {};
      F[2] & /*$$scope*/
      33554432 && (D.$$scope = { dirty: F, ctx: C }), a.$set(D), B && B.p && (!h || F[2] & /*$$scope*/
      33554432) && Qt(
        B,
        w,
        C,
        /*$$scope*/
        C[87],
        h ? Ot(
          w,
          /*$$scope*/
          C[87],
          F,
          u9
        ) : Dt(
          /*$$scope*/
          C[87]
        ),
        y5
      ), Ut(e, x = Et(_, [
        (!h || F[0] & /*className, disabled, textarea, variant, noLabel, invalid, internalClasses*/
        33673730 | F[1] & /*$$slots*/
        65536 && A !== (A = ht({
          [
            /*className*/
            C[9]
          ]: !0,
          "mdc-text-field": !0,
          "mdc-text-field--disabled": (
            /*disabled*/
            C[12]
          ),
          "mdc-text-field--textarea": (
            /*textarea*/
            C[14]
          ),
          "mdc-text-field--filled": (
            /*variant*/
            C[15] === "filled"
          ),
          "mdc-text-field--outlined": (
            /*variant*/
            C[15] === "outlined"
          ),
          "smui-text-field--standard": (
            /*variant*/
            C[15] === "standard" && !/*textarea*/
            C[14]
          ),
          "mdc-text-field--no-label": (
            /*noLabel*/
            C[16] || !/*$$slots*/
            C[47].label
          ),
          "mdc-text-field--with-leading-icon": (
            /*$$slots*/
            C[47].leadingIcon
          ),
          "mdc-text-field--with-trailing-icon": (
            /*$$slots*/
            C[47].trailingIcon
          ),
          "mdc-text-field--invalid": (
            /*invalid*/
            C[1]
          ),
          .../*internalClasses*/
          C[25]
        }))) && { class: A },
        (!h || F[0] & /*internalStyles, style*/
        67109888 && l !== (l = Object.entries(
          /*internalStyles*/
          C[26]
        ).map(H5).concat([
          /*style*/
          C[10]
        ]).join(" "))) && { style: l },
        F[1] & /*$$restProps*/
        32768 && Ia(
          /*$$restProps*/
          C[46],
          ["input$", "label$", "ripple$", "outline$", "helperLine$"]
        )
      ])), u && ar(u.update) && F[0] & /*ripple*/
      2048 && u.update.call(null, {
        ripple: (
          /*ripple*/
          C[11]
        ),
        unbounded: !1,
        addClass: (
          /*addClass*/
          C[43]
        ),
        removeClass: (
          /*removeClass*/
          C[44]
        ),
        addStyle: (
          /*addStyle*/
          C[45]
        )
      }), c && ar(c.update) && F[0] & /*use*/
      256 && c.update.call(
        null,
        /*use*/
        C[8]
      );
    },
    i(C) {
      h || (fe(v, C), fe(n.$$.fragment, C), fe(b, C), fe(a.$$.fragment, C), fe(B, C), h = !0);
    },
    o(C) {
      ge(v, C), ge(n.$$.fragment, C), ge(b, C), ge(a.$$.fragment, C), ge(B, C), h = !1;
    },
    d(C) {
      C && xe(e), v && v.d(C), $e(n), b && b.d(C), $e(a), B && B.d(C), r[82](null), f = !1, fr(d);
    }
  };
}
function B9(r) {
  let e, t, n, i, s, a, o, A, l, u, c, h, f, d, p, v, m, b, w = !/*textarea*/
  r[14] && /*variant*/
  r[15] !== "outlined" && k5(r), B = (
    /*textarea*/
    (r[14] || /*variant*/
    r[15] === "outlined") && N5(r)
  );
  i = new pf({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: !0,
      $$slots: { default: [F9] },
      $$scope: { ctx: r }
    }
  });
  const _ = (
    /*#slots*/
    r[56].default
  ), x = Nt(
    _,
    r,
    /*$$scope*/
    r[87],
    null
  ), C = [x9, T9], F = [];
  function N(L, S) {
    return (
      /*textarea*/
      L[14] && typeof /*value*/
      L[0] == "string" ? 0 : 1
    );
  }
  o = N(r), A = F[o] = C[o](r), u = new pf({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: !1,
      $$slots: { default: [U9] },
      $$scope: { ctx: r }
    }
  });
  let D = !/*textarea*/
  r[14] && /*variant*/
  r[15] !== "outlined" && /*ripple*/
  r[11] && M5(r), T = [
    {
      class: h = ht({
        [
          /*className*/
          r[9]
        ]: !0,
        "mdc-text-field": !0,
        "mdc-text-field--disabled": (
          /*disabled*/
          r[12]
        ),
        "mdc-text-field--textarea": (
          /*textarea*/
          r[14]
        ),
        "mdc-text-field--filled": (
          /*variant*/
          r[15] === "filled"
        ),
        "mdc-text-field--outlined": (
          /*variant*/
          r[15] === "outlined"
        ),
        "smui-text-field--standard": (
          /*variant*/
          r[15] === "standard" && !/*textarea*/
          r[14]
        ),
        "mdc-text-field--no-label": (
          /*noLabel*/
          r[16] || /*label*/
          r[17] == null && !/*$$slots*/
          r[47].label
        ),
        "mdc-text-field--label-floating": (
          /*focused*/
          r[28] || /*value*/
          r[0] != null && /*value*/
          r[0] !== ""
        ),
        "mdc-text-field--with-leading-icon": (
          /*isUninitializedValue*/
          r[35](
            /*withLeadingIcon*/
            r[22]
          ) ? (
            /*$$slots*/
            r[47].leadingIcon
          ) : (
            /*withLeadingIcon*/
            r[22]
          )
        ),
        "mdc-text-field--with-trailing-icon": (
          /*isUninitializedValue*/
          r[35](
            /*withTrailingIcon*/
            r[23]
          ) ? (
            /*$$slots*/
            r[47].trailingIcon
          ) : (
            /*withTrailingIcon*/
            r[23]
          )
        ),
        "mdc-text-field--with-internal-counter": (
          /*textarea*/
          r[14] && /*$$slots*/
          r[47].internalCounter
        ),
        "mdc-text-field--invalid": (
          /*invalid*/
          r[1]
        ),
        .../*internalClasses*/
        r[25]
      })
    },
    {
      style: f = Object.entries(
        /*internalStyles*/
        r[26]
      ).map(P5).concat([
        /*style*/
        r[10]
      ]).join(" ")
    },
    {
      for: (
        /* suppress a11y warning, since this is wrapped */
        void 0
      )
    },
    Ia(
      /*$$restProps*/
      r[46],
      ["input$", "label$", "ripple$", "outline$", "helperLine$"]
    )
  ], E = {};
  for (let L = 0; L < T.length; L += 1)
    E = ze(E, T[L]);
  return {
    c() {
      e = We("label"), w && w.c(), t = tt(), B && B.c(), n = tt(), Ve(i.$$.fragment), s = tt(), x && x.c(), a = tt(), A.c(), l = tt(), Ve(u.$$.fragment), c = tt(), D && D.c(), Ut(e, E);
    },
    m(L, S) {
      ke(L, e, S), w && w.m(e, null), je(e, t), B && B.m(e, null), je(e, n), Ke(i, e, null), je(e, s), x && x.m(e, null), je(e, a), F[o].m(e, null), je(e, l), Ke(u, e, null), je(e, c), D && D.m(e, null), r[78](e), v = !0, m || (b = [
        Bt(d = io.call(null, e, {
          ripple: !/*textarea*/
          r[14] && /*variant*/
          r[15] === "filled",
          unbounded: !1,
          addClass: (
            /*addClass*/
            r[43]
          ),
          removeClass: (
            /*removeClass*/
            r[44]
          ),
          addStyle: (
            /*addStyle*/
            r[45]
          ),
          eventTarget: (
            /*inputElement*/
            r[33]
          ),
          activeTarget: (
            /*inputElement*/
            r[33]
          ),
          initPromise: (
            /*initPromise*/
            r[37]
          )
        })),
        Bt(p = xr.call(
          null,
          e,
          /*use*/
          r[8]
        )),
        Bt(
          /*forwardEvents*/
          r[34].call(null, e)
        ),
        pt(
          e,
          "SMUITextfieldLeadingIcon:mount",
          /*handleLeadingIconMount*/
          r[38]
        ),
        pt(
          e,
          "SMUITextfieldLeadingIcon:unmount",
          /*SMUITextfieldLeadingIcon_unmount_handler*/
          r[79]
        ),
        pt(
          e,
          "SMUITextfieldTrailingIcon:mount",
          /*handleTrailingIconMount*/
          r[39]
        ),
        pt(
          e,
          "SMUITextfieldTrailingIcon:unmount",
          /*SMUITextfieldTrailingIcon_unmount_handler*/
          r[80]
        ),
        pt(
          e,
          "SMUITextfieldCharacterCounter:mount",
          /*handleCharacterCounterMount*/
          r[40]
        ),
        pt(
          e,
          "SMUITextfieldCharacterCounter:unmount",
          /*SMUITextfieldCharacterCounter_unmount_handler*/
          r[81]
        )
      ], m = !0);
    },
    p(L, S) {
      !/*textarea*/
      L[14] && /*variant*/
      L[15] !== "outlined" ? w ? (w.p(L, S), S[0] & /*textarea, variant*/
      49152 && fe(w, 1)) : (w = k5(L), w.c(), fe(w, 1), w.m(e, t)) : w && (er(), ge(w, 1, 1, () => {
        w = null;
      }), tr()), /*textarea*/
      L[14] || /*variant*/
      L[15] === "outlined" ? B ? (B.p(L, S), S[0] & /*textarea, variant*/
      49152 && fe(B, 1)) : (B = N5(L), B.c(), fe(B, 1), B.m(e, n)) : B && (er(), ge(B, 1, 1, () => {
        B = null;
      }), tr());
      const X = {};
      S[2] & /*$$scope*/
      33554432 && (X.$$scope = { dirty: S, ctx: L }), i.$set(X), x && x.p && (!v || S[2] & /*$$scope*/
      33554432) && Qt(
        x,
        _,
        L,
        /*$$scope*/
        L[87],
        v ? Ot(
          _,
          /*$$scope*/
          L[87],
          S,
          null
        ) : Dt(
          /*$$scope*/
          L[87]
        ),
        null
      );
      let z = o;
      o = N(L), o === z ? F[o].p(L, S) : (er(), ge(F[z], 1, 1, () => {
        F[z] = null;
      }), tr(), A = F[o], A ? A.p(L, S) : (A = F[o] = C[o](L), A.c()), fe(A, 1), A.m(e, l));
      const R = {};
      S[2] & /*$$scope*/
      33554432 && (R.$$scope = { dirty: S, ctx: L }), u.$set(R), !/*textarea*/
      L[14] && /*variant*/
      L[15] !== "outlined" && /*ripple*/
      L[11] ? D ? (D.p(L, S), S[0] & /*textarea, variant, ripple*/
      51200 && fe(D, 1)) : (D = M5(L), D.c(), fe(D, 1), D.m(e, null)) : D && (er(), ge(D, 1, 1, () => {
        D = null;
      }), tr()), Ut(e, E = Et(T, [
        (!v || S[0] & /*className, disabled, textarea, variant, noLabel, label, focused, value, withLeadingIcon, withTrailingIcon, invalid, internalClasses*/
        314823171 | S[1] & /*$$slots*/
        65536 && h !== (h = ht({
          [
            /*className*/
            L[9]
          ]: !0,
          "mdc-text-field": !0,
          "mdc-text-field--disabled": (
            /*disabled*/
            L[12]
          ),
          "mdc-text-field--textarea": (
            /*textarea*/
            L[14]
          ),
          "mdc-text-field--filled": (
            /*variant*/
            L[15] === "filled"
          ),
          "mdc-text-field--outlined": (
            /*variant*/
            L[15] === "outlined"
          ),
          "smui-text-field--standard": (
            /*variant*/
            L[15] === "standard" && !/*textarea*/
            L[14]
          ),
          "mdc-text-field--no-label": (
            /*noLabel*/
            L[16] || /*label*/
            L[17] == null && !/*$$slots*/
            L[47].label
          ),
          "mdc-text-field--label-floating": (
            /*focused*/
            L[28] || /*value*/
            L[0] != null && /*value*/
            L[0] !== ""
          ),
          "mdc-text-field--with-leading-icon": (
            /*isUninitializedValue*/
            L[35](
              /*withLeadingIcon*/
              L[22]
            ) ? (
              /*$$slots*/
              L[47].leadingIcon
            ) : (
              /*withLeadingIcon*/
              L[22]
            )
          ),
          "mdc-text-field--with-trailing-icon": (
            /*isUninitializedValue*/
            L[35](
              /*withTrailingIcon*/
              L[23]
            ) ? (
              /*$$slots*/
              L[47].trailingIcon
            ) : (
              /*withTrailingIcon*/
              L[23]
            )
          ),
          "mdc-text-field--with-internal-counter": (
            /*textarea*/
            L[14] && /*$$slots*/
            L[47].internalCounter
          ),
          "mdc-text-field--invalid": (
            /*invalid*/
            L[1]
          ),
          .../*internalClasses*/
          L[25]
        }))) && { class: h },
        (!v || S[0] & /*internalStyles, style*/
        67109888 && f !== (f = Object.entries(
          /*internalStyles*/
          L[26]
        ).map(P5).concat([
          /*style*/
          L[10]
        ]).join(" "))) && { style: f },
        {
          for: (
            /* suppress a11y warning, since this is wrapped */
            void 0
          )
        },
        S[1] & /*$$restProps*/
        32768 && Ia(
          /*$$restProps*/
          L[46],
          ["input$", "label$", "ripple$", "outline$", "helperLine$"]
        )
      ])), d && ar(d.update) && S[0] & /*textarea, variant*/
      49152 | S[1] & /*inputElement*/
      4 && d.update.call(null, {
        ripple: !/*textarea*/
        L[14] && /*variant*/
        L[15] === "filled",
        unbounded: !1,
        addClass: (
          /*addClass*/
          L[43]
        ),
        removeClass: (
          /*removeClass*/
          L[44]
        ),
        addStyle: (
          /*addStyle*/
          L[45]
        ),
        eventTarget: (
          /*inputElement*/
          L[33]
        ),
        activeTarget: (
          /*inputElement*/
          L[33]
        ),
        initPromise: (
          /*initPromise*/
          L[37]
        )
      }), p && ar(p.update) && S[0] & /*use*/
      256 && p.update.call(
        null,
        /*use*/
        L[8]
      );
    },
    i(L) {
      v || (fe(w), fe(B), fe(i.$$.fragment, L), fe(x, L), fe(A), fe(u.$$.fragment, L), fe(D), v = !0);
    },
    o(L) {
      ge(w), ge(B), ge(i.$$.fragment, L), ge(x, L), ge(A), ge(u.$$.fragment, L), ge(D), v = !1;
    },
    d(L) {
      L && xe(e), w && w.d(), B && B.d(), $e(i), x && x.d(L), F[o].d(), $e(u), D && D.d(), r[78](null), m = !1, fr(b);
    }
  };
}
function C9(r) {
  let e;
  const t = (
    /*#slots*/
    r[56].leadingIcon
  ), n = Nt(
    t,
    r,
    /*$$scope*/
    r[87],
    B5
  );
  return {
    c() {
      n && n.c();
    },
    m(i, s) {
      n && n.m(i, s), e = !0;
    },
    p(i, s) {
      n && n.p && (!e || s[2] & /*$$scope*/
      33554432) && Qt(
        n,
        t,
        i,
        /*$$scope*/
        i[87],
        e ? Ot(
          t,
          /*$$scope*/
          i[87],
          s,
          f9
        ) : Dt(
          /*$$scope*/
          i[87]
        ),
        B5
      );
    },
    i(i) {
      e || (fe(n, i), e = !0);
    },
    o(i) {
      ge(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function _9(r) {
  let e;
  const t = (
    /*#slots*/
    r[56].trailingIcon
  ), n = Nt(
    t,
    r,
    /*$$scope*/
    r[87],
    w5
  );
  return {
    c() {
      n && n.c();
    },
    m(i, s) {
      n && n.m(i, s), e = !0;
    },
    p(i, s) {
      n && n.p && (!e || s[2] & /*$$scope*/
      33554432) && Qt(
        n,
        t,
        i,
        /*$$scope*/
        i[87],
        e ? Ot(
          t,
          /*$$scope*/
          i[87],
          s,
          c9
        ) : Dt(
          /*$$scope*/
          i[87]
        ),
        w5
      );
    },
    i(i) {
      e || (fe(n, i), e = !0);
    },
    o(i) {
      ge(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function k5(r) {
  let e, t, n, i = (
    /*variant*/
    r[15] === "filled" && L5()
  ), s = !/*noLabel*/
  r[16] && /*label*/
  (r[17] != null || /*$$slots*/
  r[47].label) && U5(r);
  return {
    c() {
      i && i.c(), e = tt(), s && s.c(), t = Or();
    },
    m(a, o) {
      i && i.m(a, o), ke(a, e, o), s && s.m(a, o), ke(a, t, o), n = !0;
    },
    p(a, o) {
      /*variant*/
      a[15] === "filled" ? i || (i = L5(), i.c(), i.m(e.parentNode, e)) : i && (i.d(1), i = null), !/*noLabel*/
      a[16] && /*label*/
      (a[17] != null || /*$$slots*/
      a[47].label) ? s ? (s.p(a, o), o[0] & /*noLabel, label*/
      196608 | o[1] & /*$$slots*/
      65536 && fe(s, 1)) : (s = U5(a), s.c(), fe(s, 1), s.m(t.parentNode, t)) : s && (er(), ge(s, 1, 1, () => {
        s = null;
      }), tr());
    },
    i(a) {
      n || (fe(s), n = !0);
    },
    o(a) {
      ge(s), n = !1;
    },
    d(a) {
      a && (xe(e), xe(t)), i && i.d(a), s && s.d(a);
    }
  };
}
function L5(r) {
  let e;
  return {
    c() {
      e = We("span"), Me(e, "class", "mdc-text-field__ripple");
    },
    m(t, n) {
      ke(t, e, n);
    },
    d(t) {
      t && xe(e);
    }
  };
}
function U5(r) {
  let e, t;
  const n = [
    {
      floatAbove: (
        /*focused*/
        r[28] || /*value*/
        r[0] != null && /*value*/
        r[0] !== "" && (typeof /*value*/
        r[0] != "number" || !isNaN(
          /*value*/
          r[0]
        ))
      )
    },
    { required: (
      /*required*/
      r[13]
    ) },
    { wrapped: !0 },
    on(
      /*$$restProps*/
      r[46],
      "label$"
    )
  ];
  let i = {
    $$slots: { default: [E9] },
    $$scope: { ctx: r }
  };
  for (let s = 0; s < n.length; s += 1)
    i = ze(i, n[s]);
  return e = new mb({ props: i }), r[57](e), {
    c() {
      Ve(e.$$.fragment);
    },
    m(s, a) {
      Ke(e, s, a), t = !0;
    },
    p(s, a) {
      const o = a[0] & /*focused, value, required*/
      268443649 | a[1] & /*$$restProps*/
      32768 ? Et(n, [
        a[0] & /*focused, value*/
        268435457 && {
          floatAbove: (
            /*focused*/
            s[28] || /*value*/
            s[0] != null && /*value*/
            s[0] !== "" && (typeof /*value*/
            s[0] != "number" || !isNaN(
              /*value*/
              s[0]
            ))
          )
        },
        a[0] & /*required*/
        8192 && { required: (
          /*required*/
          s[13]
        ) },
        n[2],
        a[1] & /*$$restProps*/
        32768 && Vt(on(
          /*$$restProps*/
          s[46],
          "label$"
        ))
      ]) : {};
      a[0] & /*label*/
      131072 | a[2] & /*$$scope*/
      33554432 && (o.$$scope = { dirty: a, ctx: s }), e.$set(o);
    },
    i(s) {
      t || (fe(e.$$.fragment, s), t = !0);
    },
    o(s) {
      ge(e.$$.fragment, s), t = !1;
    },
    d(s) {
      r[57](null), $e(e, s);
    }
  };
}
function E9(r) {
  let e = (
    /*label*/
    (r[17] == null ? "" : (
      /*label*/
      r[17]
    )) + ""
  ), t, n;
  const i = (
    /*#slots*/
    r[56].label
  ), s = Nt(
    i,
    r,
    /*$$scope*/
    r[87],
    x5
  );
  return {
    c() {
      t = ir(e), s && s.c();
    },
    m(a, o) {
      ke(a, t, o), s && s.m(a, o), n = !0;
    },
    p(a, o) {
      (!n || o[0] & /*label*/
      131072) && e !== (e = /*label*/
      (a[17] == null ? "" : (
        /*label*/
        a[17]
      )) + "") && Ds(t, e), s && s.p && (!n || o[2] & /*$$scope*/
      33554432) && Qt(
        s,
        i,
        a,
        /*$$scope*/
        a[87],
        n ? Ot(
          i,
          /*$$scope*/
          a[87],
          o,
          y9
        ) : Dt(
          /*$$scope*/
          a[87]
        ),
        x5
      );
    },
    i(a) {
      n || (fe(s, a), n = !0);
    },
    o(a) {
      ge(s, a), n = !1;
    },
    d(a) {
      a && xe(t), s && s.d(a);
    }
  };
}
function N5(r) {
  let e, t;
  const n = [
    {
      noLabel: (
        /*noLabel*/
        r[16] || /*label*/
        r[17] == null && !/*$$slots*/
        r[47].label
      )
    },
    on(
      /*$$restProps*/
      r[46],
      "outline$"
    )
  ];
  let i = {
    $$slots: { default: [I9] },
    $$scope: { ctx: r }
  };
  for (let s = 0; s < n.length; s += 1)
    i = ze(i, n[s]);
  return e = new lI({ props: i }), r[59](e), {
    c() {
      Ve(e.$$.fragment);
    },
    m(s, a) {
      Ke(e, s, a), t = !0;
    },
    p(s, a) {
      const o = a[0] & /*noLabel, label*/
      196608 | a[1] & /*$$slots, $$restProps*/
      98304 ? Et(n, [
        a[0] & /*noLabel, label*/
        196608 | a[1] & /*$$slots*/
        65536 && {
          noLabel: (
            /*noLabel*/
            s[16] || /*label*/
            s[17] == null && !/*$$slots*/
            s[47].label
          )
        },
        a[1] & /*$$restProps*/
        32768 && Vt(on(
          /*$$restProps*/
          s[46],
          "outline$"
        ))
      ]) : {};
      a[0] & /*focused, value, required, floatingLabel, label, noLabel*/
      268640289 | a[1] & /*$$restProps, $$slots*/
      98304 | a[2] & /*$$scope*/
      33554432 && (o.$$scope = { dirty: a, ctx: s }), e.$set(o);
    },
    i(s) {
      t || (fe(e.$$.fragment, s), t = !0);
    },
    o(s) {
      ge(e.$$.fragment, s), t = !1;
    },
    d(s) {
      r[59](null), $e(e, s);
    }
  };
}
function O5(r) {
  let e, t;
  const n = [
    {
      floatAbove: (
        /*focused*/
        r[28] || /*value*/
        r[0] != null && /*value*/
        r[0] !== "" && (typeof /*value*/
        r[0] != "number" || !isNaN(
          /*value*/
          r[0]
        ))
      )
    },
    { required: (
      /*required*/
      r[13]
    ) },
    { wrapped: !0 },
    on(
      /*$$restProps*/
      r[46],
      "label$"
    )
  ];
  let i = {
    $$slots: { default: [S9] },
    $$scope: { ctx: r }
  };
  for (let s = 0; s < n.length; s += 1)
    i = ze(i, n[s]);
  return e = new mb({ props: i }), r[58](e), {
    c() {
      Ve(e.$$.fragment);
    },
    m(s, a) {
      Ke(e, s, a), t = !0;
    },
    p(s, a) {
      const o = a[0] & /*focused, value, required*/
      268443649 | a[1] & /*$$restProps*/
      32768 ? Et(n, [
        a[0] & /*focused, value*/
        268435457 && {
          floatAbove: (
            /*focused*/
            s[28] || /*value*/
            s[0] != null && /*value*/
            s[0] !== "" && (typeof /*value*/
            s[0] != "number" || !isNaN(
              /*value*/
              s[0]
            ))
          )
        },
        a[0] & /*required*/
        8192 && { required: (
          /*required*/
          s[13]
        ) },
        n[2],
        a[1] & /*$$restProps*/
        32768 && Vt(on(
          /*$$restProps*/
          s[46],
          "label$"
        ))
      ]) : {};
      a[0] & /*label*/
      131072 | a[2] & /*$$scope*/
      33554432 && (o.$$scope = { dirty: a, ctx: s }), e.$set(o);
    },
    i(s) {
      t || (fe(e.$$.fragment, s), t = !0);
    },
    o(s) {
      ge(e.$$.fragment, s), t = !1;
    },
    d(s) {
      r[58](null), $e(e, s);
    }
  };
}
function S9(r) {
  let e = (
    /*label*/
    (r[17] == null ? "" : (
      /*label*/
      r[17]
    )) + ""
  ), t, n;
  const i = (
    /*#slots*/
    r[56].label
  ), s = Nt(
    i,
    r,
    /*$$scope*/
    r[87],
    T5
  );
  return {
    c() {
      t = ir(e), s && s.c();
    },
    m(a, o) {
      ke(a, t, o), s && s.m(a, o), n = !0;
    },
    p(a, o) {
      (!n || o[0] & /*label*/
      131072) && e !== (e = /*label*/
      (a[17] == null ? "" : (
        /*label*/
        a[17]
      )) + "") && Ds(t, e), s && s.p && (!n || o[2] & /*$$scope*/
      33554432) && Qt(
        s,
        i,
        a,
        /*$$scope*/
        a[87],
        n ? Ot(
          i,
          /*$$scope*/
          a[87],
          o,
          b9
        ) : Dt(
          /*$$scope*/
          a[87]
        ),
        T5
      );
    },
    i(a) {
      n || (fe(s, a), n = !0);
    },
    o(a) {
      ge(s, a), n = !1;
    },
    d(a) {
      a && xe(t), s && s.d(a);
    }
  };
}
function I9(r) {
  let e, t, n = !/*noLabel*/
  r[16] && /*label*/
  (r[17] != null || /*$$slots*/
  r[47].label) && O5(r);
  return {
    c() {
      n && n.c(), e = Or();
    },
    m(i, s) {
      n && n.m(i, s), ke(i, e, s), t = !0;
    },
    p(i, s) {
      !/*noLabel*/
      i[16] && /*label*/
      (i[17] != null || /*$$slots*/
      i[47].label) ? n ? (n.p(i, s), s[0] & /*noLabel, label*/
      196608 | s[1] & /*$$slots*/
      65536 && fe(n, 1)) : (n = O5(i), n.c(), fe(n, 1), n.m(e.parentNode, e)) : n && (er(), ge(n, 1, 1, () => {
        n = null;
      }), tr());
    },
    i(i) {
      t || (fe(n), t = !0);
    },
    o(i) {
      ge(n), t = !1;
    },
    d(i) {
      i && xe(e), n && n.d(i);
    }
  };
}
function F9(r) {
  let e;
  const t = (
    /*#slots*/
    r[56].leadingIcon
  ), n = Nt(
    t,
    r,
    /*$$scope*/
    r[87],
    F5
  );
  return {
    c() {
      n && n.c();
    },
    m(i, s) {
      n && n.m(i, s), e = !0;
    },
    p(i, s) {
      n && n.p && (!e || s[2] & /*$$scope*/
      33554432) && Qt(
        n,
        t,
        i,
        /*$$scope*/
        i[87],
        e ? Ot(
          t,
          /*$$scope*/
          i[87],
          s,
          v9
        ) : Dt(
          /*$$scope*/
          i[87]
        ),
        F5
      );
    },
    i(i) {
      e || (fe(n, i), e = !0);
    },
    o(i) {
      ge(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function T9(r) {
  let e, t, n, i, s, a, o, A, l, u;
  const c = (
    /*#slots*/
    r[56].prefix
  ), h = Nt(
    c,
    r,
    /*$$scope*/
    r[87],
    S5
  );
  let f = (
    /*prefix*/
    r[20] != null && Q5(r)
  );
  const d = [
    { type: (
      /*type*/
      r[18]
    ) },
    { disabled: (
      /*disabled*/
      r[12]
    ) },
    { required: (
      /*required*/
      r[13]
    ) },
    { updateInvalid: (
      /*updateInvalid*/
      r[19]
    ) },
    { "aria-controls": (
      /*helperId*/
      r[27]
    ) },
    { "aria-describedby": (
      /*helperId*/
      r[27]
    ) },
    /*noLabel*/
    r[16] && /*label*/
    r[17] != null ? { placeholder: (
      /*label*/
      r[17]
    ) } : {},
    on(
      /*$$restProps*/
      r[46],
      "input$"
    )
  ];
  function p(C) {
    r[69](C);
  }
  function v(C) {
    r[70](C);
  }
  function m(C) {
    r[71](C);
  }
  function b(C) {
    r[72](C);
  }
  let w = {};
  for (let C = 0; C < d.length; C += 1)
    w = ze(w, d[C]);
  /*value*/
  r[0] !== void 0 && (w.value = /*value*/
  r[0]), /*files*/
  r[3] !== void 0 && (w.files = /*files*/
  r[3]), /*dirty*/
  r[4] !== void 0 && (w.dirty = /*dirty*/
  r[4]), /*invalid*/
  r[1] !== void 0 && (w.invalid = /*invalid*/
  r[1]), n = new uI({ props: w }), r[68](n), yt.push(() => Gn(n, "value", p)), yt.push(() => Gn(n, "files", v)), yt.push(() => Gn(n, "dirty", m)), yt.push(() => Gn(n, "invalid", b)), n.$on(
    "blur",
    /*blur_handler_2*/
    r[73]
  ), n.$on(
    "focus",
    /*focus_handler_2*/
    r[74]
  ), n.$on(
    "blur",
    /*blur_handler_3*/
    r[75]
  ), n.$on(
    "focus",
    /*focus_handler_3*/
    r[76]
  );
  let B = (
    /*suffix*/
    r[21] != null && D5(r)
  );
  const _ = (
    /*#slots*/
    r[56].suffix
  ), x = Nt(
    _,
    r,
    /*$$scope*/
    r[87],
    E5
  );
  return {
    c() {
      h && h.c(), e = tt(), f && f.c(), t = tt(), Ve(n.$$.fragment), A = tt(), B && B.c(), l = tt(), x && x.c();
    },
    m(C, F) {
      h && h.m(C, F), ke(C, e, F), f && f.m(C, F), ke(C, t, F), Ke(n, C, F), ke(C, A, F), B && B.m(C, F), ke(C, l, F), x && x.m(C, F), u = !0;
    },
    p(C, F) {
      h && h.p && (!u || F[2] & /*$$scope*/
      33554432) && Qt(
        h,
        c,
        C,
        /*$$scope*/
        C[87],
        u ? Ot(
          c,
          /*$$scope*/
          C[87],
          F,
          g9
        ) : Dt(
          /*$$scope*/
          C[87]
        ),
        S5
      ), /*prefix*/
      C[20] != null ? f ? (f.p(C, F), F[0] & /*prefix*/
      1048576 && fe(f, 1)) : (f = Q5(C), f.c(), fe(f, 1), f.m(t.parentNode, t)) : f && (er(), ge(f, 1, 1, () => {
        f = null;
      }), tr());
      const N = F[0] & /*type, disabled, required, updateInvalid, helperId, noLabel, label*/
      135213056 | F[1] & /*$$restProps*/
      32768 ? Et(d, [
        F[0] & /*type*/
        262144 && { type: (
          /*type*/
          C[18]
        ) },
        F[0] & /*disabled*/
        4096 && { disabled: (
          /*disabled*/
          C[12]
        ) },
        F[0] & /*required*/
        8192 && { required: (
          /*required*/
          C[13]
        ) },
        F[0] & /*updateInvalid*/
        524288 && { updateInvalid: (
          /*updateInvalid*/
          C[19]
        ) },
        F[0] & /*helperId*/
        134217728 && { "aria-controls": (
          /*helperId*/
          C[27]
        ) },
        F[0] & /*helperId*/
        134217728 && { "aria-describedby": (
          /*helperId*/
          C[27]
        ) },
        F[0] & /*noLabel, label*/
        196608 && Vt(
          /*noLabel*/
          C[16] && /*label*/
          C[17] != null ? { placeholder: (
            /*label*/
            C[17]
          ) } : {}
        ),
        F[1] & /*$$restProps*/
        32768 && Vt(on(
          /*$$restProps*/
          C[46],
          "input$"
        ))
      ]) : {};
      !i && F[0] & /*value*/
      1 && (i = !0, N.value = /*value*/
      C[0], zn(() => i = !1)), !s && F[0] & /*files*/
      8 && (s = !0, N.files = /*files*/
      C[3], zn(() => s = !1)), !a && F[0] & /*dirty*/
      16 && (a = !0, N.dirty = /*dirty*/
      C[4], zn(() => a = !1)), !o && F[0] & /*invalid*/
      2 && (o = !0, N.invalid = /*invalid*/
      C[1], zn(() => o = !1)), n.$set(N), /*suffix*/
      C[21] != null ? B ? (B.p(C, F), F[0] & /*suffix*/
      2097152 && fe(B, 1)) : (B = D5(C), B.c(), fe(B, 1), B.m(l.parentNode, l)) : B && (er(), ge(B, 1, 1, () => {
        B = null;
      }), tr()), x && x.p && (!u || F[2] & /*$$scope*/
      33554432) && Qt(
        x,
        _,
        C,
        /*$$scope*/
        C[87],
        u ? Ot(
          _,
          /*$$scope*/
          C[87],
          F,
          p9
        ) : Dt(
          /*$$scope*/
          C[87]
        ),
        E5
      );
    },
    i(C) {
      u || (fe(h, C), fe(f), fe(n.$$.fragment, C), fe(B), fe(x, C), u = !0);
    },
    o(C) {
      ge(h, C), ge(f), ge(n.$$.fragment, C), ge(B), ge(x, C), u = !1;
    },
    d(C) {
      C && (xe(e), xe(t), xe(A), xe(l)), h && h.d(C), f && f.d(C), r[68](null), $e(n, C), B && B.d(C), x && x.d(C);
    }
  };
}
function x9(r) {
  let e, t, n, i, s, a, o, A;
  const l = [
    { disabled: (
      /*disabled*/
      r[12]
    ) },
    { required: (
      /*required*/
      r[13]
    ) },
    { updateInvalid: (
      /*updateInvalid*/
      r[19]
    ) },
    { "aria-controls": (
      /*helperId*/
      r[27]
    ) },
    { "aria-describedby": (
      /*helperId*/
      r[27]
    ) },
    on(
      /*$$restProps*/
      r[46],
      "input$"
    )
  ];
  function u(v) {
    r[61](v);
  }
  function c(v) {
    r[62](v);
  }
  function h(v) {
    r[63](v);
  }
  let f = {};
  for (let v = 0; v < l.length; v += 1)
    f = ze(f, l[v]);
  /*value*/
  r[0] !== void 0 && (f.value = /*value*/
  r[0]), /*dirty*/
  r[4] !== void 0 && (f.dirty = /*dirty*/
  r[4]), /*invalid*/
  r[1] !== void 0 && (f.invalid = /*invalid*/
  r[1]), t = new cI({ props: f }), r[60](t), yt.push(() => Gn(t, "value", u)), yt.push(() => Gn(t, "dirty", c)), yt.push(() => Gn(t, "invalid", h)), t.$on(
    "blur",
    /*blur_handler*/
    r[64]
  ), t.$on(
    "focus",
    /*focus_handler*/
    r[65]
  ), t.$on(
    "blur",
    /*blur_handler_1*/
    r[66]
  ), t.$on(
    "focus",
    /*focus_handler_1*/
    r[67]
  );
  const d = (
    /*#slots*/
    r[56].internalCounter
  ), p = Nt(
    d,
    r,
    /*$$scope*/
    r[87],
    I5
  );
  return {
    c() {
      e = We("span"), Ve(t.$$.fragment), a = tt(), p && p.c(), Me(e, "class", o = ht({
        "mdc-text-field__resizer": !("input$resizable" in /*$$restProps*/
        r[46]) || /*$$restProps*/
        r[46].input$resizable
      }));
    },
    m(v, m) {
      ke(v, e, m), Ke(t, e, null), je(e, a), p && p.m(e, null), A = !0;
    },
    p(v, m) {
      const b = m[0] & /*disabled, required, updateInvalid, helperId*/
      134754304 | m[1] & /*$$restProps*/
      32768 ? Et(l, [
        m[0] & /*disabled*/
        4096 && { disabled: (
          /*disabled*/
          v[12]
        ) },
        m[0] & /*required*/
        8192 && { required: (
          /*required*/
          v[13]
        ) },
        m[0] & /*updateInvalid*/
        524288 && { updateInvalid: (
          /*updateInvalid*/
          v[19]
        ) },
        m[0] & /*helperId*/
        134217728 && { "aria-controls": (
          /*helperId*/
          v[27]
        ) },
        m[0] & /*helperId*/
        134217728 && { "aria-describedby": (
          /*helperId*/
          v[27]
        ) },
        m[1] & /*$$restProps*/
        32768 && Vt(on(
          /*$$restProps*/
          v[46],
          "input$"
        ))
      ]) : {};
      !n && m[0] & /*value*/
      1 && (n = !0, b.value = /*value*/
      v[0], zn(() => n = !1)), !i && m[0] & /*dirty*/
      16 && (i = !0, b.dirty = /*dirty*/
      v[4], zn(() => i = !1)), !s && m[0] & /*invalid*/
      2 && (s = !0, b.invalid = /*invalid*/
      v[1], zn(() => s = !1)), t.$set(b), p && p.p && (!A || m[2] & /*$$scope*/
      33554432) && Qt(
        p,
        d,
        v,
        /*$$scope*/
        v[87],
        A ? Ot(
          d,
          /*$$scope*/
          v[87],
          m,
          m9
        ) : Dt(
          /*$$scope*/
          v[87]
        ),
        I5
      ), (!A || m[1] & /*$$restProps*/
      32768 && o !== (o = ht({
        "mdc-text-field__resizer": !("input$resizable" in /*$$restProps*/
        v[46]) || /*$$restProps*/
        v[46].input$resizable
      }))) && Me(e, "class", o);
    },
    i(v) {
      A || (fe(t.$$.fragment, v), fe(p, v), A = !0);
    },
    o(v) {
      ge(t.$$.fragment, v), ge(p, v), A = !1;
    },
    d(v) {
      v && xe(e), r[60](null), $e(t), p && p.d(v);
    }
  };
}
function Q5(r) {
  let e, t;
  return e = new r9({
    props: {
      $$slots: { default: [k9] },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      Ve(e.$$.fragment);
    },
    m(n, i) {
      Ke(e, n, i), t = !0;
    },
    p(n, i) {
      const s = {};
      i[0] & /*prefix*/
      1048576 | i[2] & /*$$scope*/
      33554432 && (s.$$scope = { dirty: i, ctx: n }), e.$set(s);
    },
    i(n) {
      t || (fe(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ge(e.$$.fragment, n), t = !1;
    },
    d(n) {
      $e(e, n);
    }
  };
}
function k9(r) {
  let e;
  return {
    c() {
      e = ir(
        /*prefix*/
        r[20]
      );
    },
    m(t, n) {
      ke(t, e, n);
    },
    p(t, n) {
      n[0] & /*prefix*/
      1048576 && Ds(
        e,
        /*prefix*/
        t[20]
      );
    },
    d(t) {
      t && xe(e);
    }
  };
}
function D5(r) {
  let e, t;
  return e = new n9({
    props: {
      $$slots: { default: [L9] },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      Ve(e.$$.fragment);
    },
    m(n, i) {
      Ke(e, n, i), t = !0;
    },
    p(n, i) {
      const s = {};
      i[0] & /*suffix*/
      2097152 | i[2] & /*$$scope*/
      33554432 && (s.$$scope = { dirty: i, ctx: n }), e.$set(s);
    },
    i(n) {
      t || (fe(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ge(e.$$.fragment, n), t = !1;
    },
    d(n) {
      $e(e, n);
    }
  };
}
function L9(r) {
  let e;
  return {
    c() {
      e = ir(
        /*suffix*/
        r[21]
      );
    },
    m(t, n) {
      ke(t, e, n);
    },
    p(t, n) {
      n[0] & /*suffix*/
      2097152 && Ds(
        e,
        /*suffix*/
        t[21]
      );
    },
    d(t) {
      t && xe(e);
    }
  };
}
function U9(r) {
  let e;
  const t = (
    /*#slots*/
    r[56].trailingIcon
  ), n = Nt(
    t,
    r,
    /*$$scope*/
    r[87],
    _5
  );
  return {
    c() {
      n && n.c();
    },
    m(i, s) {
      n && n.m(i, s), e = !0;
    },
    p(i, s) {
      n && n.p && (!e || s[2] & /*$$scope*/
      33554432) && Qt(
        n,
        t,
        i,
        /*$$scope*/
        i[87],
        e ? Ot(
          t,
          /*$$scope*/
          i[87],
          s,
          d9
        ) : Dt(
          /*$$scope*/
          i[87]
        ),
        _5
      );
    },
    i(i) {
      e || (fe(n, i), e = !0);
    },
    o(i) {
      ge(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function M5(r) {
  let e, t;
  const n = [on(
    /*$$restProps*/
    r[46],
    "ripple$"
  )];
  let i = {};
  for (let s = 0; s < n.length; s += 1)
    i = ze(i, n[s]);
  return e = new AI({ props: i }), r[77](e), {
    c() {
      Ve(e.$$.fragment);
    },
    m(s, a) {
      Ke(e, s, a), t = !0;
    },
    p(s, a) {
      const o = a[1] & /*$$restProps*/
      32768 ? Et(n, [Vt(on(
        /*$$restProps*/
        s[46],
        "ripple$"
      ))]) : {};
      e.$set(o);
    },
    i(s) {
      t || (fe(e.$$.fragment, s), t = !0);
    },
    o(s) {
      ge(e.$$.fragment, s), t = !1;
    },
    d(s) {
      r[77](null), $e(e, s);
    }
  };
}
function R5(r) {
  let e, t;
  const n = [on(
    /*$$restProps*/
    r[46],
    "helperLine$"
  )];
  let i = {
    $$slots: { default: [N9] },
    $$scope: { ctx: r }
  };
  for (let s = 0; s < n.length; s += 1)
    i = ze(i, n[s]);
  return e = new t9({ props: i }), e.$on(
    "SMUITextfieldHelperText:id",
    /*handleHelperTextId*/
    r[41]
  ), e.$on(
    "SMUITextfieldHelperText:mount",
    /*handleHelperTextMount*/
    r[42]
  ), e.$on(
    "SMUITextfieldHelperText:unmount",
    /*SMUITextfieldHelperText_unmount_handler*/
    r[85]
  ), e.$on(
    "SMUITextfieldCharacterCounter:mount",
    /*handleCharacterCounterMount*/
    r[40]
  ), e.$on(
    "SMUITextfieldCharacterCounter:unmount",
    /*SMUITextfieldCharacterCounter_unmount_handler_1*/
    r[86]
  ), {
    c() {
      Ve(e.$$.fragment);
    },
    m(s, a) {
      Ke(e, s, a), t = !0;
    },
    p(s, a) {
      const o = a[1] & /*$$restProps*/
      32768 ? Et(n, [Vt(on(
        /*$$restProps*/
        s[46],
        "helperLine$"
      ))]) : {};
      a[2] & /*$$scope*/
      33554432 && (o.$$scope = { dirty: a, ctx: s }), e.$set(o);
    },
    i(s) {
      t || (fe(e.$$.fragment, s), t = !0);
    },
    o(s) {
      ge(e.$$.fragment, s), t = !1;
    },
    d(s) {
      $e(e, s);
    }
  };
}
function N9(r) {
  let e;
  const t = (
    /*#slots*/
    r[56].helper
  ), n = Nt(
    t,
    r,
    /*$$scope*/
    r[87],
    b5
  );
  return {
    c() {
      n && n.c();
    },
    m(i, s) {
      n && n.m(i, s), e = !0;
    },
    p(i, s) {
      n && n.p && (!e || s[2] & /*$$scope*/
      33554432) && Qt(
        n,
        t,
        i,
        /*$$scope*/
        i[87],
        e ? Ot(
          t,
          /*$$scope*/
          i[87],
          s,
          l9
        ) : Dt(
          /*$$scope*/
          i[87]
        ),
        b5
      );
    },
    i(i) {
      e || (fe(n, i), e = !0);
    },
    o(i) {
      ge(n, i), e = !1;
    },
    d(i) {
      n && n.d(i);
    }
  };
}
function O9(r) {
  let e, t, n, i, s;
  const a = [B9, w9], o = [];
  function A(u, c) {
    return (
      /*valued*/
      u[36] ? 0 : 1
    );
  }
  e = A(r), t = o[e] = a[e](r);
  let l = (
    /*$$slots*/
    r[47].helper && R5(r)
  );
  return {
    c() {
      t.c(), n = tt(), l && l.c(), i = Or();
    },
    m(u, c) {
      o[e].m(u, c), ke(u, n, c), l && l.m(u, c), ke(u, i, c), s = !0;
    },
    p(u, c) {
      t.p(u, c), /*$$slots*/
      u[47].helper ? l ? (l.p(u, c), c[1] & /*$$slots*/
      65536 && fe(l, 1)) : (l = R5(u), l.c(), fe(l, 1), l.m(i.parentNode, i)) : l && (er(), ge(l, 1, 1, () => {
        l = null;
      }), tr());
    },
    i(u) {
      s || (fe(t), fe(l), s = !0);
    },
    o(u) {
      ge(t), ge(l), s = !1;
    },
    d(u) {
      u && (xe(n), xe(i)), o[e].d(u), l && l.d(u);
    }
  };
}
const P5 = ([r, e]) => `${r}: ${e};`, H5 = ([r, e]) => `${r}: ${e};`;
function Q9(r, e, t) {
  let n;
  const i = [
    "use",
    "class",
    "style",
    "ripple",
    "disabled",
    "required",
    "textarea",
    "variant",
    "noLabel",
    "label",
    "type",
    "value",
    "files",
    "invalid",
    "updateInvalid",
    "dirty",
    "prefix",
    "suffix",
    "validateOnValueChange",
    "useNativeValidation",
    "withLeadingIcon",
    "withTrailingIcon",
    "input",
    "floatingLabel",
    "lineRipple",
    "notchedOutline",
    "focus",
    "blur",
    "layout",
    "getElement"
  ];
  let s = xt(e, i), { $$slots: a = {}, $$scope: o } = e;
  const A = D2(a), { applyPassive: l } = CE, u = Kr(yr());
  let c = () => {
  };
  function h(Ee) {
    return Ee === c;
  }
  let { use: f = [] } = e, { class: d = "" } = e, { style: p = "" } = e, { ripple: v = !0 } = e, { disabled: m = !1 } = e, { required: b = !1 } = e, { textarea: w = !1 } = e, { variant: B = w ? "outlined" : "standard" } = e, { noLabel: _ = !1 } = e, { label: x = void 0 } = e, { type: C = "text" } = e, { value: F = s.input$emptyValueUndefined ? void 0 : c } = e, { files: N = c } = e;
  const D = !h(F) || !h(N);
  h(F) && (F = void 0), h(N) && (N = null);
  let { invalid: T = c } = e, { updateInvalid: E = h(T) } = e;
  h(T) && (T = !1);
  let { dirty: L = !1 } = e, { prefix: S = void 0 } = e, { suffix: X = void 0 } = e, { validateOnValueChange: z = E } = e, { useNativeValidation: R = E } = e, { withLeadingIcon: V = c } = e, { withTrailingIcon: O = c } = e, { input: J = void 0 } = e, { floatingLabel: Z = void 0 } = e, { lineRipple: U = void 0 } = e, { notchedOutline: P = void 0 } = e, H, $, ie = {}, ue = {}, he, ve = !1, Le = pn("SMUI:addLayoutListener"), de, Ce, Qe = new Promise((Ee) => Ce = Ee), M, Ae, G, ne, ee = F;
  Le && (de = Le(St)), ui(() => {
    if (t(54, $ = new z7(
      {
        // getRootAdapterMethods_
        addClass: Ue,
        removeClass: Ge,
        hasClass: Oe,
        registerTextFieldInteractionHandler: (Ee, or) => et().addEventListener(Ee, or),
        deregisterTextFieldInteractionHandler: (Ee, or) => et().removeEventListener(Ee, or),
        registerValidationAttributeChangeHandler: (Ee) => {
          const or = (ds) => ds.map((dt) => dt.attributeName).filter((dt) => dt), hi = new MutationObserver((ds) => {
            R && Ee(or(ds));
          }), hs = { attributes: !0 };
          return J && hi.observe(J.getElement(), hs), hi;
        },
        deregisterValidationAttributeChangeHandler: (Ee) => {
          Ee.disconnect();
        },
        // getInputAdapterMethods_
        getNativeInput: () => {
          var Ee;
          return (Ee = J == null ? void 0 : J.getElement()) !== null && Ee !== void 0 ? Ee : null;
        },
        setInputAttr: (Ee, or) => {
          J == null || J.addAttr(Ee, or);
        },
        removeInputAttr: (Ee) => {
          J == null || J.removeAttr(Ee);
        },
        isFocused: () => document.activeElement === (J == null ? void 0 : J.getElement()),
        registerInputInteractionHandler: (Ee, or) => {
          J == null || J.getElement().addEventListener(Ee, or, l());
        },
        deregisterInputInteractionHandler: (Ee, or) => {
          J == null || J.getElement().removeEventListener(Ee, or, l());
        },
        // getLabelAdapterMethods_
        floatLabel: (Ee) => Z && Z.float(Ee),
        getLabelWidth: () => Z ? Z.getWidth() : 0,
        hasLabel: () => !!Z,
        shakeLabel: (Ee) => Z && Z.shake(Ee),
        setLabelRequired: (Ee) => Z && Z.setRequired(Ee),
        // getLineRippleAdapterMethods_
        activateLineRipple: () => U && U.activate(),
        deactivateLineRipple: () => U && U.deactivate(),
        setLineRippleTransformOrigin: (Ee) => U && U.setRippleCenter(Ee),
        // getOutlineAdapterMethods_
        closeOutline: () => P && P.closeNotch(),
        hasOutline: () => !!P,
        notchOutline: (Ee) => P && P.notch(Ee)
      },
      {
        get helperText() {
          return G;
        },
        get characterCounter() {
          return ne;
        },
        get leadingIcon() {
          return M;
        },
        get trailingIcon() {
          return Ae;
        }
      }
    )), D) {
      if (J == null)
        throw new Error("SMUI Textfield must be initialized with either a non-undefined initial value or an Input component.");
      $.init();
    } else
      M2().then(() => {
        if (J == null)
          throw new Error("SMUI Textfield must be initialized with either a non-undefined initial value or an Input component.");
        $.init();
      });
    return Ce(), () => {
      $.destroy();
    };
  }), fo(() => {
    de && de();
  });
  function ae(Ee) {
    t(29, M = Ee.detail);
  }
  function re(Ee) {
    t(30, Ae = Ee.detail);
  }
  function ce(Ee) {
    t(32, ne = Ee.detail);
  }
  function le(Ee) {
    t(27, he = Ee.detail);
  }
  function Te(Ee) {
    t(31, G = Ee.detail);
  }
  function Oe(Ee) {
    var or;
    return Ee in ie ? (or = ie[Ee]) !== null && or !== void 0 ? or : null : et().classList.contains(Ee);
  }
  function Ue(Ee) {
    ie[Ee] || t(25, ie[Ee] = !0, ie);
  }
  function Ge(Ee) {
    (!(Ee in ie) || ie[Ee]) && t(25, ie[Ee] = !1, ie);
  }
  function at(Ee, or) {
    ue[Ee] != or && (or === "" || or == null ? (delete ue[Ee], t(26, ue)) : t(26, ue[Ee] = or, ue));
  }
  function it() {
    J == null || J.focus();
  }
  function ut() {
    J == null || J.blur();
  }
  function St() {
    if ($) {
      const Ee = $.shouldFloat;
      $.notchOutline(Ee);
    }
  }
  function et() {
    return H;
  }
  function gr(Ee) {
    yt[Ee ? "unshift" : "push"](() => {
      Z = Ee, t(5, Z);
    });
  }
  function bt(Ee) {
    yt[Ee ? "unshift" : "push"](() => {
      Z = Ee, t(5, Z);
    });
  }
  function Qr(Ee) {
    yt[Ee ? "unshift" : "push"](() => {
      P = Ee, t(7, P);
    });
  }
  function Wt(Ee) {
    yt[Ee ? "unshift" : "push"](() => {
      J = Ee, t(2, J);
    });
  }
  function kt(Ee) {
    F = Ee, t(0, F);
  }
  function Dr(Ee) {
    L = Ee, t(4, L);
  }
  function Xt(Ee) {
    T = Ee, t(1, T), t(54, $), t(19, E);
  }
  const Cn = () => t(28, ve = !1), mr = () => t(28, ve = !0), Ir = (Ee) => pr(H, "blur", Ee), hr = (Ee) => pr(H, "focus", Ee);
  function wr(Ee) {
    yt[Ee ? "unshift" : "push"](() => {
      J = Ee, t(2, J);
    });
  }
  function gt(Ee) {
    F = Ee, t(0, F);
  }
  function rr(Ee) {
    N = Ee, t(3, N);
  }
  function Rs(Ee) {
    L = Ee, t(4, L);
  }
  function Yr(Ee) {
    T = Ee, t(1, T), t(54, $), t(19, E);
  }
  const fi = () => t(28, ve = !1), Fi = () => t(28, ve = !0), Ct = (Ee) => pr(H, "blur", Ee), Ti = (Ee) => pr(H, "focus", Ee);
  function Yn(Ee) {
    yt[Ee ? "unshift" : "push"](() => {
      U = Ee, t(6, U);
    });
  }
  function _n(Ee) {
    yt[Ee ? "unshift" : "push"](() => {
      H = Ee, t(24, H);
    });
  }
  const Gr = () => t(29, M = void 0), ur = () => t(30, Ae = void 0), En = () => t(32, ne = void 0);
  function Ps(Ee) {
    yt[Ee ? "unshift" : "push"](() => {
      H = Ee, t(24, H);
    });
  }
  const Ki = () => t(29, M = void 0), Zn = () => t(30, Ae = void 0), Nn = () => {
    t(27, he = void 0), t(31, G = void 0);
  }, qr = () => t(32, ne = void 0);
  return r.$$set = (Ee) => {
    e = ze(ze({}, e), Nr(Ee)), t(46, s = xt(e, i)), "use" in Ee && t(8, f = Ee.use), "class" in Ee && t(9, d = Ee.class), "style" in Ee && t(10, p = Ee.style), "ripple" in Ee && t(11, v = Ee.ripple), "disabled" in Ee && t(12, m = Ee.disabled), "required" in Ee && t(13, b = Ee.required), "textarea" in Ee && t(14, w = Ee.textarea), "variant" in Ee && t(15, B = Ee.variant), "noLabel" in Ee && t(16, _ = Ee.noLabel), "label" in Ee && t(17, x = Ee.label), "type" in Ee && t(18, C = Ee.type), "value" in Ee && t(0, F = Ee.value), "files" in Ee && t(3, N = Ee.files), "invalid" in Ee && t(1, T = Ee.invalid), "updateInvalid" in Ee && t(19, E = Ee.updateInvalid), "dirty" in Ee && t(4, L = Ee.dirty), "prefix" in Ee && t(20, S = Ee.prefix), "suffix" in Ee && t(21, X = Ee.suffix), "validateOnValueChange" in Ee && t(48, z = Ee.validateOnValueChange), "useNativeValidation" in Ee && t(49, R = Ee.useNativeValidation), "withLeadingIcon" in Ee && t(22, V = Ee.withLeadingIcon), "withTrailingIcon" in Ee && t(23, O = Ee.withTrailingIcon), "input" in Ee && t(2, J = Ee.input), "floatingLabel" in Ee && t(5, Z = Ee.floatingLabel), "lineRipple" in Ee && t(6, U = Ee.lineRipple), "notchedOutline" in Ee && t(7, P = Ee.notchedOutline), "$$scope" in Ee && t(87, o = Ee.$$scope);
  }, r.$$.update = () => {
    if (r.$$.dirty[0] & /*input*/
    4 && t(33, n = J && J.getElement()), r.$$.dirty[0] & /*invalid, updateInvalid*/
    524290 | r.$$.dirty[1] & /*instance*/
    8388608 && $ && $.isValid() !== !T && (E ? t(1, T = !$.isValid()) : $.setValid(!T)), r.$$.dirty[1] & /*instance, validateOnValueChange*/
    8519680 && $ && $.getValidateOnValueChange() !== z && $.setValidateOnValueChange(h(z) ? !1 : z), r.$$.dirty[1] & /*instance, useNativeValidation*/
    8650752 && $ && $.setUseNativeValidation(h(R) ? !0 : R), r.$$.dirty[0] & /*disabled*/
    4096 | r.$$.dirty[1] & /*instance*/
    8388608 && $ && $.setDisabled(m), r.$$.dirty[0] & /*value*/
    1 | r.$$.dirty[1] & /*instance, previousValue*/
    25165824 && $ && D && ee !== F) {
      t(55, ee = F);
      const Ee = `${F}`;
      $.getValue() !== Ee && $.setValue(Ee);
    }
  }, [
    F,
    T,
    J,
    N,
    L,
    Z,
    U,
    P,
    f,
    d,
    p,
    v,
    m,
    b,
    w,
    B,
    _,
    x,
    C,
    E,
    S,
    X,
    V,
    O,
    H,
    ie,
    ue,
    he,
    ve,
    M,
    Ae,
    G,
    ne,
    n,
    u,
    h,
    D,
    Qe,
    ae,
    re,
    ce,
    le,
    Te,
    Ue,
    Ge,
    at,
    s,
    A,
    z,
    R,
    it,
    ut,
    St,
    et,
    $,
    ee,
    a,
    gr,
    bt,
    Qr,
    Wt,
    kt,
    Dr,
    Xt,
    Cn,
    mr,
    Ir,
    hr,
    wr,
    gt,
    rr,
    Rs,
    Yr,
    fi,
    Fi,
    Ct,
    Ti,
    Yn,
    _n,
    Gr,
    ur,
    En,
    Ps,
    Ki,
    Zn,
    Nn,
    qr,
    o
  ];
}
class Ff extends jt {
  constructor(e) {
    super(), Pt(
      this,
      e,
      Q9,
      O9,
      Mt,
      {
        use: 8,
        class: 9,
        style: 10,
        ripple: 11,
        disabled: 12,
        required: 13,
        textarea: 14,
        variant: 15,
        noLabel: 16,
        label: 17,
        type: 18,
        value: 0,
        files: 3,
        invalid: 1,
        updateInvalid: 19,
        dirty: 4,
        prefix: 20,
        suffix: 21,
        validateOnValueChange: 48,
        useNativeValidation: 49,
        withLeadingIcon: 22,
        withTrailingIcon: 23,
        input: 2,
        floatingLabel: 5,
        lineRipple: 6,
        notchedOutline: 7,
        focus: 50,
        blur: 51,
        layout: 52,
        getElement: 53
      },
      null,
      [-1, -1, -1, -1]
    );
  }
  get use() {
    return this.$$.ctx[8];
  }
  set use(e) {
    this.$$set({ use: e }), pe();
  }
  get class() {
    return this.$$.ctx[9];
  }
  set class(e) {
    this.$$set({ class: e }), pe();
  }
  get style() {
    return this.$$.ctx[10];
  }
  set style(e) {
    this.$$set({ style: e }), pe();
  }
  get ripple() {
    return this.$$.ctx[11];
  }
  set ripple(e) {
    this.$$set({ ripple: e }), pe();
  }
  get disabled() {
    return this.$$.ctx[12];
  }
  set disabled(e) {
    this.$$set({ disabled: e }), pe();
  }
  get required() {
    return this.$$.ctx[13];
  }
  set required(e) {
    this.$$set({ required: e }), pe();
  }
  get textarea() {
    return this.$$.ctx[14];
  }
  set textarea(e) {
    this.$$set({ textarea: e }), pe();
  }
  get variant() {
    return this.$$.ctx[15];
  }
  set variant(e) {
    this.$$set({ variant: e }), pe();
  }
  get noLabel() {
    return this.$$.ctx[16];
  }
  set noLabel(e) {
    this.$$set({ noLabel: e }), pe();
  }
  get label() {
    return this.$$.ctx[17];
  }
  set label(e) {
    this.$$set({ label: e }), pe();
  }
  get type() {
    return this.$$.ctx[18];
  }
  set type(e) {
    this.$$set({ type: e }), pe();
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(e) {
    this.$$set({ value: e }), pe();
  }
  get files() {
    return this.$$.ctx[3];
  }
  set files(e) {
    this.$$set({ files: e }), pe();
  }
  get invalid() {
    return this.$$.ctx[1];
  }
  set invalid(e) {
    this.$$set({ invalid: e }), pe();
  }
  get updateInvalid() {
    return this.$$.ctx[19];
  }
  set updateInvalid(e) {
    this.$$set({ updateInvalid: e }), pe();
  }
  get dirty() {
    return this.$$.ctx[4];
  }
  set dirty(e) {
    this.$$set({ dirty: e }), pe();
  }
  get prefix() {
    return this.$$.ctx[20];
  }
  set prefix(e) {
    this.$$set({ prefix: e }), pe();
  }
  get suffix() {
    return this.$$.ctx[21];
  }
  set suffix(e) {
    this.$$set({ suffix: e }), pe();
  }
  get validateOnValueChange() {
    return this.$$.ctx[48];
  }
  set validateOnValueChange(e) {
    this.$$set({ validateOnValueChange: e }), pe();
  }
  get useNativeValidation() {
    return this.$$.ctx[49];
  }
  set useNativeValidation(e) {
    this.$$set({ useNativeValidation: e }), pe();
  }
  get withLeadingIcon() {
    return this.$$.ctx[22];
  }
  set withLeadingIcon(e) {
    this.$$set({ withLeadingIcon: e }), pe();
  }
  get withTrailingIcon() {
    return this.$$.ctx[23];
  }
  set withTrailingIcon(e) {
    this.$$set({ withTrailingIcon: e }), pe();
  }
  get input() {
    return this.$$.ctx[2];
  }
  set input(e) {
    this.$$set({ input: e }), pe();
  }
  get floatingLabel() {
    return this.$$.ctx[5];
  }
  set floatingLabel(e) {
    this.$$set({ floatingLabel: e }), pe();
  }
  get lineRipple() {
    return this.$$.ctx[6];
  }
  set lineRipple(e) {
    this.$$set({ lineRipple: e }), pe();
  }
  get notchedOutline() {
    return this.$$.ctx[7];
  }
  set notchedOutline(e) {
    this.$$set({ notchedOutline: e }), pe();
  }
  get focus() {
    return this.$$.ctx[50];
  }
  get blur() {
    return this.$$.ctx[51];
  }
  get layout() {
    return this.$$.ctx[52];
  }
  get getElement() {
    return this.$$.ctx[53];
  }
}
Ht(
  Ff,
  { use: {}, class: {}, style: {}, ripple: { type: "Boolean" }, disabled: { type: "Boolean" }, required: { type: "Boolean" }, textarea: { type: "Boolean" }, variant: {}, noLabel: { type: "Boolean" }, label: {}, type: {}, value: {}, files: {}, invalid: {}, updateInvalid: {}, dirty: { type: "Boolean" }, prefix: {}, suffix: {}, validateOnValueChange: {}, useNativeValidation: {}, withLeadingIcon: {}, withTrailingIcon: {}, input: {}, floatingLabel: {}, lineRipple: {}, notchedOutline: {} },
  [
    "label",
    "leadingIcon",
    "default",
    "internalCounter",
    "prefix",
    "suffix",
    "trailingIcon",
    "ripple",
    "helper"
  ],
  ["focus", "blur", "layout", "getElement"],
  !0
);
function D9(r) {
  Pi(r, "svelte-19ufbie", ".signal-row.svelte-19ufbie.svelte-19ufbie{display:grid;grid-template-columns:3% repeat(2, 1fr);grid-gap:1rem;align-items:center;margin-bottom:1rem}.signal-row.svelte-19ufbie .mdc-text-field__input[disabled]{cursor:not-allowed}.signal-row.svelte-19ufbie small.svelte-19ufbie{color:#4d5d63;text-align:center}");
}
function M9(r) {
  let e, t, n, i, s, a, o, A;
  function l(c) {
    r[10](c);
  }
  let u = {};
  return (
    /*areAllCheckboxesSelected*/
    r[4] !== void 0 && (u.checked = /*areAllCheckboxesSelected*/
    r[4]), t = new Of({ props: u }), yt.push(() => Gn(t, "checked", l)), t.$on(
      "click",
      /*toggleAllCheckboxes*/
      r[8]
    ), {
      c() {
        e = We("div"), Ve(t.$$.fragment), i = tt(), s = We("small"), s.textContent = "Choose the columns you want to display and rename if needed", a = tt(), o = We("small"), o.textContent = "Use the filter to limit the content of the columns to certain values", Me(s, "class", "svelte-19ufbie"), Me(o, "class", "svelte-19ufbie");
      },
      m(c, h) {
        ke(c, e, h), Ke(t, e, null), ke(c, i, h), ke(c, s, h), ke(c, a, h), ke(c, o, h), A = !0;
      },
      p(c, h) {
        const f = {};
        !n && h & /*areAllCheckboxesSelected*/
        16 && (n = !0, f.checked = /*areAllCheckboxesSelected*/
        c[4], zn(() => n = !1)), t.$set(f);
      },
      i(c) {
        A || (fe(t.$$.fragment, c), A = !0);
      },
      o(c) {
        ge(t.$$.fragment, c), A = !1;
      },
      d(c) {
        c && (xe(e), xe(i), xe(s), xe(a), xe(o)), $e(t);
      }
    }
  );
}
function R9(r) {
  let e, t = (
    /*isFirstRow*/
    r[6]()
  ), n, i, s, a, o, A, l, u, c, h, f = t && M9(r);
  function d(B) {
    r[11](B);
  }
  let p = {};
  /*isSelected*/
  r[0] !== void 0 && (p.checked = /*isSelected*/
  r[0]), i = new Of({ props: p }), yt.push(() => Gn(i, "checked", d));
  function v(B) {
    r[12](B);
  }
  let m = {
    variant: "outlined",
    label: (
      /*createSuffixForLabelIfNeeded*/
      r[7](
        /*label*/
        r[3].col1Label
      )
    ),
    disabled: !/*isSelected*/
    r[0]
  };
  /*column1*/
  r[1] !== void 0 && (m.value = /*column1*/
  r[1]), o = new Ff({ props: m }), yt.push(() => Gn(o, "value", v)), o.$on(
    "input",
    /*input_handler*/
    r[13]
  );
  function b(B) {
    r[14](B);
  }
  let w = {
    variant: "outlined",
    label: (
      /*createSuffixForLabelIfNeeded*/
      r[7](
        /*label*/
        r[3].col2Label
      )
    ),
    disabled: !/*isSelected*/
    r[0]
  };
  return (
    /*column2*/
    r[2] !== void 0 && (w.value = /*column2*/
    r[2]), u = new Ff({ props: w }), yt.push(() => Gn(u, "value", b)), u.$on(
      "input",
      /*input_handler_1*/
      r[15]
    ), {
      c() {
        e = We("div"), f && f.c(), n = tt(), Ve(i.$$.fragment), a = tt(), Ve(o.$$.fragment), l = tt(), Ve(u.$$.fragment), Me(e, "class", "signal-row svelte-19ufbie");
      },
      m(B, _) {
        ke(B, e, _), f && f.m(e, null), je(e, n), Ke(i, e, null), je(e, a), Ke(o, e, null), je(e, l), Ke(u, e, null), h = !0;
      },
      p(B, [_]) {
        t && f.p(B, _);
        const x = {};
        !s && _ & /*isSelected*/
        1 && (s = !0, x.checked = /*isSelected*/
        B[0], zn(() => s = !1)), i.$set(x);
        const C = {};
        _ & /*label*/
        8 && (C.label = /*createSuffixForLabelIfNeeded*/
        B[7](
          /*label*/
          B[3].col1Label
        )), _ & /*isSelected*/
        1 && (C.disabled = !/*isSelected*/
        B[0]), !A && _ & /*column1*/
        2 && (A = !0, C.value = /*column1*/
        B[1], zn(() => A = !1)), o.$set(C);
        const F = {};
        _ & /*label*/
        8 && (F.label = /*createSuffixForLabelIfNeeded*/
        B[7](
          /*label*/
          B[3].col2Label
        )), _ & /*isSelected*/
        1 && (F.disabled = !/*isSelected*/
        B[0]), !c && _ & /*column2*/
        4 && (c = !0, F.value = /*column2*/
        B[2], zn(() => c = !1)), u.$set(F);
      },
      i(B) {
        h || (fe(f), fe(i.$$.fragment, B), fe(o.$$.fragment, B), fe(u.$$.fragment, B), h = !0);
      },
      o(B) {
        ge(f), ge(i.$$.fragment, B), ge(o.$$.fragment, B), ge(u.$$.fragment, B), h = !1;
      },
      d(B) {
        B && xe(e), f && f.d(), $e(i), $e(o), $e(u);
      }
    }
  );
}
const P9 = 1e3;
function H9(r, e, t) {
  let { idx: n = 1 } = e, { label: i = {
    col1Label: { name: "", hasSuffix: !1 },
    col2Label: { name: "", hasSuffix: !1 }
  } } = e, { isSelected: s = !1 } = e, { column1: a = "" } = e, { column2: o = "" } = e, A = !1;
  const l = E3(c, P9), u = eg();
  function c(_, x) {
    t(1, a = _ === "column1" ? x : a), t(2, o = _ === "column2" ? x : o), u("update", { key: _, value: x });
  }
  function h() {
    return n === 0;
  }
  function f(_) {
    const { name: x, hasSuffix: C } = _;
    return C ? `Column ${n + 1} "${x}"` : x;
  }
  function d() {
    u("toggleAllCheckboxes", { value: A });
  }
  function p(_) {
    A = _, t(4, A);
  }
  function v(_) {
    s = _, t(0, s);
  }
  function m(_) {
    a = _, t(1, a);
  }
  const b = (_) => l("column1", _.target.value);
  function w(_) {
    o = _, t(2, o);
  }
  const B = (_) => l("column2", _.target.value);
  return r.$$set = (_) => {
    "idx" in _ && t(9, n = _.idx), "label" in _ && t(3, i = _.label), "isSelected" in _ && t(0, s = _.isSelected), "column1" in _ && t(1, a = _.column1), "column2" in _ && t(2, o = _.column2);
  }, r.$$.update = () => {
    r.$$.dirty & /*isSelected*/
    1 && (s || !s) && u("update", { key: "isSelected", value: s });
  }, [
    s,
    a,
    o,
    i,
    A,
    l,
    h,
    f,
    d,
    n,
    p,
    v,
    m,
    b,
    w,
    B
  ];
}
class fI extends jt {
  constructor(e) {
    super(), Pt(
      this,
      e,
      H9,
      R9,
      Mt,
      {
        idx: 9,
        label: 3,
        isSelected: 0,
        column1: 1,
        column2: 2
      },
      D9
    );
  }
  get idx() {
    return this.$$.ctx[9];
  }
  set idx(e) {
    this.$$set({ idx: e }), pe();
  }
  get label() {
    return this.$$.ctx[3];
  }
  set label(e) {
    this.$$set({ label: e }), pe();
  }
  get isSelected() {
    return this.$$.ctx[0];
  }
  set isSelected(e) {
    this.$$set({ isSelected: e }), pe();
  }
  get column1() {
    return this.$$.ctx[1];
  }
  set column1(e) {
    this.$$set({ column1: e }), pe();
  }
  get column2() {
    return this.$$.ctx[2];
  }
  set column2(e) {
    this.$$set({ column2: e }), pe();
  }
}
Ht(fI, { idx: {}, label: {}, isSelected: { type: "Boolean" }, column1: {}, column2: {} }, [], [], !0);
function j9(r) {
  Pi(r, "svelte-h3ah26", ".signal-list.svelte-h3ah26{width:99%}");
}
function j5(r, e, t) {
  const n = r.slice();
  return n[21] = e[t], n[22] = e, n[23] = t, n;
}
function K5(r, e) {
  let t, n, i, s, a, o;
  function A(f) {
    e[6](
      f,
      /*row*/
      e[21]
    );
  }
  function l(f) {
    e[7](
      f,
      /*row*/
      e[21]
    );
  }
  function u(f) {
    e[8](
      f,
      /*row*/
      e[21]
    );
  }
  function c(...f) {
    return (
      /*update_handler*/
      e[9](
        /*row*/
        e[21],
        ...f
      )
    );
  }
  let h = {
    idx: (
      /*row*/
      e[21].index
    ),
    label: (
      /*row*/
      e[21].label
    )
  };
  return (
    /*row*/
    e[21].isSelected !== void 0 && (h.isSelected = /*row*/
    e[21].isSelected), /*row*/
    e[21].column1 !== void 0 && (h.column1 = /*row*/
    e[21].column1), /*row*/
    e[21].column2 !== void 0 && (h.column2 = /*row*/
    e[21].column2), n = new fI({ props: h }), yt.push(() => Gn(n, "isSelected", A)), yt.push(() => Gn(n, "column1", l)), yt.push(() => Gn(n, "column2", u)), n.$on("update", c), n.$on(
      "toggleAllCheckboxes",
      /*toggleAllCheckboxes_handler*/
      e[10]
    ), {
      key: r,
      first: null,
      c() {
        t = Or(), Ve(n.$$.fragment), this.first = t;
      },
      m(f, d) {
        ke(f, t, d), Ke(n, f, d), o = !0;
      },
      p(f, d) {
        e = f;
        const p = {};
        d & /*mergedColsAndMessages*/
        1 && (p.idx = /*row*/
        e[21].index), d & /*mergedColsAndMessages*/
        1 && (p.label = /*row*/
        e[21].label), !i && d & /*mergedColsAndMessages*/
        1 && (i = !0, p.isSelected = /*row*/
        e[21].isSelected, zn(() => i = !1)), !s && d & /*mergedColsAndMessages*/
        1 && (s = !0, p.column1 = /*row*/
        e[21].column1, zn(() => s = !1)), !a && d & /*mergedColsAndMessages*/
        1 && (a = !0, p.column2 = /*row*/
        e[21].column2, zn(() => a = !1)), n.$set(p);
      },
      i(f) {
        o || (fe(n.$$.fragment, f), o = !0);
      },
      o(f) {
        ge(n.$$.fragment, f), o = !1;
      },
      d(f) {
        f && xe(t), $e(n, f);
      }
    }
  );
}
function K9(r) {
  let e, t = [], n = /* @__PURE__ */ new Map(), i, s = Iu(
    /*mergedColsAndMessages*/
    r[0]
  );
  const a = (o) => (
    /*row*/
    o[21].index
  );
  for (let o = 0; o < s.length; o += 1) {
    let A = j5(r, s, o), l = a(A);
    n.set(l, t[o] = K5(l, A));
  }
  return {
    c() {
      e = We("article");
      for (let o = 0; o < t.length; o += 1)
        t[o].c();
      Me(e, "class", "signal-list svelte-h3ah26");
    },
    m(o, A) {
      ke(o, e, A);
      for (let l = 0; l < t.length; l += 1)
        t[l] && t[l].m(e, null);
      i = !0;
    },
    p(o, [A]) {
      A & /*mergedColsAndMessages, updateSignalRow, toggleAllCheckboxes*/
      7 && (s = Iu(
        /*mergedColsAndMessages*/
        o[0]
      ), er(), t = wE(t, A, a, 1, o, s, n, e, yE, K5, null, j5), tr());
    },
    i(o) {
      if (!i) {
        for (let A = 0; A < s.length; A += 1)
          fe(t[A]);
        i = !0;
      }
    },
    o(o) {
      for (let A = 0; A < t.length; A += 1)
        ge(t[A]);
      i = !1;
    },
    d(o) {
      o && xe(e);
      for (let A = 0; A < t.length; A += 1)
        t[A].d();
    }
  };
}
function $9() {
  return {
    selected: [],
    matches: { matchedRowsForTablePdf: [] }
  };
}
function V9(r, e, t) {
  let n, i, s, { onContentChange: a } = e, { content: o = "" } = e;
  const l = (h() ? JSON.parse(o) : $9()).selected, u = Object.entries(rI).map(([F, N], D) => {
    const T = v(F);
    return {
      index: D,
      searchKey: F,
      isSelected: (T == null ? void 0 : T.isSelected) ?? !1,
      column1: (T == null ? void 0 : T.column1) ?? N,
      column2: (T == null ? void 0 : T.column2) ?? "",
      label: {
        col1Label: { name: N, hasSuffix: !0 },
        col2Label: {
          name: `Filter by ${N}`,
          hasSuffix: !1
        }
      }
    };
  }), c = Object.entries(Is).map(([F, N], D) => {
    const T = v(F);
    return {
      index: u.length + D,
      searchKey: F,
      isSelected: (T == null ? void 0 : T.isSelected) ?? !1,
      column1: (T == null ? void 0 : T.column1) ?? N,
      column2: (T == null ? void 0 : T.column2) ?? "",
      label: {
        col1Label: { name: N, hasSuffix: !0 },
        col2Label: {
          name: "Filter by IED Name",
          hasSuffix: !1
        }
      }
    };
  });
  function h() {
    return o.trim();
  }
  function f(F, N, D) {
    t(0, n = n.map((T, E) => E === F ? { ...T, [N]: D } : T)), p();
  }
  function d(F) {
    t(0, n = n.map((N) => ({ ...N, isSelected: !F }))), p();
  }
  function p() {
    a(JSON.stringify(s));
  }
  function v(F) {
    return l.find((N) => N.searchKey === F);
  }
  function m() {
    const F = {}, N = {};
    for (const { searchKey: E, column2: L } of i)
      b(E) ? N[E] = L : F[E] = L;
    const { messagePublishers: D } = o5.getPublishingLogicalDevices(F), { matchedRows: T } = o5.getSubscribingLogicalDevices(D, N);
    return { matchedRowsForTablePdf: T };
  }
  function b(F) {
    return [Is.GOOSE, Is.MMS, Is.SV, Is.UNKNOWN].includes(Is[F]);
  }
  function w(F, N) {
    r.$$.not_equal(N.isSelected, F) && (N.isSelected = F, t(0, n));
  }
  function B(F, N) {
    r.$$.not_equal(N.column1, F) && (N.column1 = F, t(0, n));
  }
  function _(F, N) {
    r.$$.not_equal(N.column2, F) && (N.column2 = F, t(0, n));
  }
  const x = (F, N) => f(F.index, N.detail.key, N.detail.value), C = (F) => d(F.detail.value);
  return r.$$set = (F) => {
    "onContentChange" in F && t(3, a = F.onContentChange), "content" in F && t(4, o = F.content);
  }, r.$$.update = () => {
    r.$$.dirty & /*mergedColsAndMessages*/
    1 && t(5, i = n.filter((F) => F.isSelected)), r.$$.dirty & /*selectedRows*/
    32 && (s = {
      selected: i,
      matches: m()
    });
  }, t(0, n = [...u, ...c]), [
    n,
    f,
    d,
    a,
    o,
    i,
    w,
    B,
    _,
    x,
    C
  ];
}
class hI extends jt {
  constructor(e) {
    super(), Pt(this, e, V9, K9, Mt, { onContentChange: 3, content: 4 }, j9);
  }
  get onContentChange() {
    return this.$$.ctx[3];
  }
  set onContentChange(e) {
    this.$$set({ onContentChange: e }), pe();
  }
  get content() {
    return this.$$.ctx[4];
  }
  set content(e) {
    this.$$set({ content: e }), pe();
  }
}
Ht(hI, { onContentChange: {}, content: {} }, [], [], !0);
function z9(r) {
  Pi(r, "svelte-y861mz", ".element-wrapper.svelte-y861mz.svelte-y861mz{border-left:10px solid transparent;padding:0 0 0.5rem 1rem}.element-wrapper.svelte-y861mz.svelte-y861mz:hover{border-color:var(--mdc-theme-secondary);transition:0.25s all ease;background-color:#f5f5f5}.element-wrapper.svelte-y861mz:hover .action-btns.svelte-y861mz{visibility:visible;transition:0.25s all ease}.action-btns.svelte-y861mz.svelte-y861mz{display:flex;justify-content:flex-end;visibility:hidden}");
}
function G9(r) {
  let e, t, n, i, s, a, o, A, l, u, c;
  n = new us({
    props: {
      icon: "content_copy",
      color: "black",
      size: "small"
    }
  }), s = new us({
    props: {
      icon: "delete",
      color: "black",
      size: "small"
    }
  }), s.$on(
    "click",
    /*deleteBlockElement*/
    r[0]
  ), o = new us({
    props: {
      icon: "arrow_upward",
      color: "black",
      size: "small"
    }
  }), l = new us({
    props: {
      icon: "arrow_downward",
      color: "black",
      size: "small"
    }
  });
  const h = (
    /*#slots*/
    r[3].default
  ), f = Nt(
    h,
    r,
    /*$$scope*/
    r[2],
    null
  );
  return {
    c() {
      e = We("div"), t = We("div"), Ve(n.$$.fragment), i = tt(), Ve(s.$$.fragment), a = tt(), Ve(o.$$.fragment), A = tt(), Ve(l.$$.fragment), u = tt(), f && f.c(), Me(t, "class", "action-btns svelte-y861mz"), Me(e, "class", "element-wrapper svelte-y861mz");
    },
    m(d, p) {
      ke(d, e, p), je(e, t), Ke(n, t, null), je(t, i), Ke(s, t, null), je(t, a), Ke(o, t, null), je(t, A), Ke(l, t, null), je(e, u), f && f.m(e, null), c = !0;
    },
    p(d, [p]) {
      f && f.p && (!c || p & /*$$scope*/
      4) && Qt(
        f,
        h,
        d,
        /*$$scope*/
        d[2],
        c ? Ot(
          h,
          /*$$scope*/
          d[2],
          p,
          null
        ) : Dt(
          /*$$scope*/
          d[2]
        ),
        null
      );
    },
    i(d) {
      c || (fe(n.$$.fragment, d), fe(s.$$.fragment, d), fe(o.$$.fragment, d), fe(l.$$.fragment, d), fe(f, d), c = !0);
    },
    o(d) {
      ge(n.$$.fragment, d), ge(s.$$.fragment, d), ge(o.$$.fragment, d), ge(l.$$.fragment, d), ge(f, d), c = !1;
    },
    d(d) {
      d && xe(e), $e(n), $e(s), $e(o), $e(l), f && f.d(d);
    }
  };
}
function q9(r, e, t) {
  let { $$slots: n = {}, $$scope: i } = e, { elementId: s } = e;
  const a = eg();
  function o() {
    a("elementDelete", { elementId: s });
  }
  return r.$$set = (A) => {
    "elementId" in A && t(1, s = A.elementId), "$$scope" in A && t(2, i = A.$$scope);
  }, [o, s, i, n];
}
class dI extends jt {
  constructor(e) {
    super(), Pt(this, e, q9, G9, Mt, { elementId: 1 }, z9);
  }
  get elementId() {
    return this.$$.ctx[1];
  }
  set elementId(e) {
    this.$$set({ elementId: e }), pe();
  }
}
Ht(dI, { elementId: {} }, ["default"], [], !0);
function W9(r) {
  Pi(r, "svelte-1mvq73n", ".template-builder.svelte-1mvq73n{width:70%}.card.svelte-1mvq73n{background-color:white;min-height:50vh;overflow-y:auto;border-radius:.5rem;padding:1.5rem}.elements-list.svelte-1mvq73n{display:flex;flex-direction:column}footer.svelte-1mvq73n{margin-top:2rem}.elements-container.svelte-1mvq73n{margin-top:2rem;display:flex;gap:1.5rem;flex-wrap:wrap}");
}
function $5(r, e, t) {
  const n = r.slice();
  return n[14] = e[t], n;
}
function X9(r) {
  let e, t, n;
  function i(...o) {
    return (
      /*func*/
      r[7](
        /*blockElement*/
        r[14],
        ...o
      )
    );
  }
  var s = (
    /*componentMap*/
    r[2][
      /*blockElement*/
      r[14].type
    ]
  );
  function a(o, A) {
    return {
      props: {
        content: (
          /*blockElement*/
          o[14].content
        ),
        onContentChange: i
      }
    };
  }
  return s && (e = An(s, a(r))), {
    c() {
      e && Ve(e.$$.fragment), t = tt();
    },
    m(o, A) {
      e && Ke(e, o, A), ke(o, t, A), n = !0;
    },
    p(o, A) {
      if (r = o, A & /*blockElements*/
      2 && s !== (s = /*componentMap*/
      r[2][
        /*blockElement*/
        r[14].type
      ])) {
        if (e) {
          er();
          const l = e;
          ge(l.$$.fragment, 1, 0, () => {
            $e(l, 1);
          }), tr();
        }
        s ? (e = An(s, a(r)), Ve(e.$$.fragment), fe(e.$$.fragment, 1), Ke(e, t.parentNode, t)) : e = null;
      } else if (s) {
        const l = {};
        A & /*blockElements*/
        2 && (l.content = /*blockElement*/
        r[14].content), A & /*blockElements*/
        2 && (l.onContentChange = i), e.$set(l);
      }
    },
    i(o) {
      n || (e && fe(e.$$.fragment, o), n = !0);
    },
    o(o) {
      e && ge(e.$$.fragment, o), n = !1;
    },
    d(o) {
      o && xe(t), e && $e(e, o);
    }
  };
}
function V5(r, e) {
  let t, n, i;
  return n = new dI({
    props: {
      elementId: (
        /*blockElement*/
        e[14].id
      ),
      $$slots: { default: [X9] },
      $$scope: { ctx: e }
    }
  }), n.$on(
    "elementDelete",
    /*deleteBlockElement*/
    e[4]
  ), {
    key: r,
    first: null,
    c() {
      t = Or(), Ve(n.$$.fragment), this.first = t;
    },
    m(s, a) {
      ke(s, t, a), Ke(n, s, a), i = !0;
    },
    p(s, a) {
      e = s;
      const o = {};
      a & /*blockElements*/
      2 && (o.elementId = /*blockElement*/
      e[14].id), a & /*$$scope, blockElements*/
      131074 && (o.$$scope = { dirty: a, ctx: e }), n.$set(o);
    },
    i(s) {
      i || (fe(n.$$.fragment, s), i = !0);
    },
    o(s) {
      ge(n.$$.fragment, s), i = !1;
    },
    d(s) {
      s && xe(t), $e(n, s);
    }
  };
}
function J9(r) {
  let e;
  return {
    c() {
      e = ir("add element");
    },
    m(t, n) {
      ke(t, e, n);
    },
    d(t) {
      t && xe(e);
    }
  };
}
function Y9(r) {
  let e, t, n, i;
  return e = new tg({
    props: { icon: "add", fillColor: "#2aa198" }
  }), n = new R2({
    props: {
      $$slots: { default: [J9] },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      Ve(e.$$.fragment), t = tt(), Ve(n.$$.fragment);
    },
    m(s, a) {
      Ke(e, s, a), ke(s, t, a), Ke(n, s, a), i = !0;
    },
    p(s, a) {
      const o = {};
      a & /*$$scope*/
      131072 && (o.$$scope = { dirty: a, ctx: s }), n.$set(o);
    },
    i(s) {
      i || (fe(e.$$.fragment, s), fe(n.$$.fragment, s), i = !0);
    },
    o(s) {
      ge(e.$$.fragment, s), ge(n.$$.fragment, s), i = !1;
    },
    d(s) {
      s && xe(t), $e(e, s), $e(n, s);
    }
  };
}
function z5(r) {
  let e, t, n, i, s, a;
  return e = new Xo({
    props: {
      variant: "outlined",
      $$slots: { default: [Z9] },
      $$scope: { ctx: r }
    }
  }), e.$on(
    "click",
    /*click_handler_1*/
    r[9]
  ), n = new Xo({
    props: {
      variant: "outlined",
      $$slots: { default: [ej] },
      $$scope: { ctx: r }
    }
  }), n.$on(
    "click",
    /*click_handler_2*/
    r[10]
  ), s = new Xo({
    props: {
      variant: "outlined",
      $$slots: { default: [tj] },
      $$scope: { ctx: r }
    }
  }), s.$on(
    "click",
    /*click_handler_3*/
    r[11]
  ), {
    c() {
      Ve(e.$$.fragment), t = tt(), Ve(n.$$.fragment), i = tt(), Ve(s.$$.fragment);
    },
    m(o, A) {
      Ke(e, o, A), ke(o, t, A), Ke(n, o, A), ke(o, i, A), Ke(s, o, A), a = !0;
    },
    p(o, A) {
      const l = {};
      A & /*$$scope*/
      131072 && (l.$$scope = { dirty: A, ctx: o }), e.$set(l);
      const u = {};
      A & /*$$scope*/
      131072 && (u.$$scope = { dirty: A, ctx: o }), n.$set(u);
      const c = {};
      A & /*$$scope*/
      131072 && (c.$$scope = { dirty: A, ctx: o }), s.$set(c);
    },
    i(o) {
      a || (fe(e.$$.fragment, o), fe(n.$$.fragment, o), fe(s.$$.fragment, o), a = !0);
    },
    o(o) {
      ge(e.$$.fragment, o), ge(n.$$.fragment, o), ge(s.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(t), xe(i)), $e(e, o), $e(n, o), $e(s, o);
    }
  };
}
function Z9(r) {
  let e;
  return {
    c() {
      e = ir("Text");
    },
    m(t, n) {
      ke(t, e, n);
    },
    d(t) {
      t && xe(e);
    }
  };
}
function ej(r) {
  let e;
  return {
    c() {
      e = ir("Image");
    },
    m(t, n) {
      ke(t, e, n);
    },
    d(t) {
      t && xe(e);
    }
  };
}
function tj(r) {
  let e;
  return {
    c() {
      e = ir("Signal List");
    },
    m(t, n) {
      ke(t, e, n);
    },
    d(t) {
      t && xe(e);
    }
  };
}
function rj(r) {
  let e, t, n, i = [], s = /* @__PURE__ */ new Map(), a, o, A, l, u, c, h = Iu(
    /*blockElements*/
    r[1]
  );
  const f = (p) => (
    /*blockElement*/
    p[14].id
  );
  for (let p = 0; p < h.length; p += 1) {
    let v = $5(r, h, p), m = f(v);
    s.set(m, i[p] = V5(m, v));
  }
  A = new Xo({
    props: {
      $$slots: { default: [Y9] },
      $$scope: { ctx: r }
    }
  }), A.$on(
    "click",
    /*click_handler*/
    r[8]
  );
  let d = (
    /*isElementsChoiceVisible*/
    r[0] && z5(r)
  );
  return {
    c() {
      e = We("div"), t = We("div"), n = We("div");
      for (let p = 0; p < i.length; p += 1)
        i[p].c();
      a = tt(), o = We("footer"), Ve(A.$$.fragment), l = tt(), u = We("div"), d && d.c(), Me(n, "class", "elements-list svelte-1mvq73n"), Me(u, "class", "elements-container svelte-1mvq73n"), Me(o, "class", "svelte-1mvq73n"), Me(t, "class", "card svelte-1mvq73n"), Me(e, "class", "template-builder svelte-1mvq73n");
    },
    m(p, v) {
      ke(p, e, v), je(e, t), je(t, n);
      for (let m = 0; m < i.length; m += 1)
        i[m] && i[m].m(n, null);
      je(t, a), je(t, o), Ke(A, o, null), je(o, l), je(o, u), d && d.m(u, null), c = !0;
    },
    p(p, [v]) {
      v & /*blockElements, deleteBlockElement, componentMap, handleContentChange*/
      54 && (h = Iu(
        /*blockElements*/
        p[1]
      ), er(), i = wE(i, v, f, 1, p, h, s, n, yE, V5, null, $5), tr());
      const m = {};
      v & /*$$scope*/
      131072 && (m.$$scope = { dirty: v, ctx: p }), A.$set(m), /*isElementsChoiceVisible*/
      p[0] ? d ? (d.p(p, v), v & /*isElementsChoiceVisible*/
      1 && fe(d, 1)) : (d = z5(p), d.c(), fe(d, 1), d.m(u, null)) : d && (er(), ge(d, 1, 1, () => {
        d = null;
      }), tr());
    },
    i(p) {
      if (!c) {
        for (let v = 0; v < h.length; v += 1)
          fe(i[v]);
        fe(A.$$.fragment, p), fe(d), c = !0;
      }
    },
    o(p) {
      for (let v = 0; v < i.length; v += 1)
        ge(i[v]);
      ge(A.$$.fragment, p), ge(d), c = !1;
    },
    d(p) {
      p && xe(e);
      for (let v = 0; v < i.length; v += 1)
        i[v].d();
      $e(A), d && d.d();
    }
  };
}
function nj(r, e, t) {
  let { template: n } = e;
  const s = Array.from(n.querySelectorAll("Block")).map((m) => ({
    id: m.getAttribute("id"),
    type: m.getAttribute("type"),
    content: m.textContent
  }));
  let a = !1, o = s;
  const A = {
    text: aI,
    image: oI,
    signalList: hI
  };
  function l(m) {
    const w = { id: sa.addBlockToDocumentTemplate(n, m, o.length), type: m, content: "" };
    t(1, o = [...o, w]);
  }
  function u(m) {
    const { elementId: b } = m.detail;
    sa.deleteBlockFromDocumentTemplate(n, b), t(1, o = o.filter((w) => w.id !== b));
  }
  function c(m, b) {
    sa.editBlockContentOfDocumentTemplate(n, m, b);
  }
  const h = (m, b) => c(m.id, b), f = () => t(0, a = !a), d = () => {
    l("text");
  }, p = () => {
    l("image");
  }, v = () => {
    l("signalList");
  };
  return r.$$set = (m) => {
    "template" in m && t(6, n = m.template);
  }, [
    a,
    o,
    A,
    l,
    u,
    c,
    n,
    h,
    f,
    d,
    p,
    v
  ];
}
class pI extends jt {
  constructor(e) {
    super(), Pt(this, e, nj, rj, Mt, { template: 6 }, W9);
  }
  get template() {
    return this.$$.ctx[6];
  }
  set template(e) {
    this.$$set({ template: e }), pe();
  }
}
Ht(pI, { template: {} }, [], [], !0);
function ij(r) {
  Pi(r, "svelte-1usfn22", ".template-overview.svelte-1usfn22{padding:2rem}.template-controls.svelte-1usfn22{margin:0 0 1rem 1rem}.template-controls.svelte-1usfn22 .btn-pill{border-radius:2em;cursor:pointer;border-color:var(--mdc-theme-secondary)}.template-controls.svelte-1usfn22 .btn-pill-outlined{color:var(--mdc-theme-secondary)}.template-controls.svelte-1usfn22 .btn-pill-outlined:hover{background-color:var(--mdc-theme-secondary);color:white}.template-controls.svelte-1usfn22 .btn-pill-primary{background-color:var(--mdc-theme-secondary);color:white}.template-controls.svelte-1usfn22 .btn-pill-primary:hover{background-color:rgba(73, 79, 191, 0.8039215686)}");
}
function sj(r) {
  let e;
  return {
    c() {
      e = ir("Add template");
    },
    m(t, n) {
      ke(t, e, n);
    },
    d(t) {
      t && xe(e);
    }
  };
}
function aj(r) {
  let e, t, n, i;
  return e = new tg({ props: { icon: "add" } }), n = new R2({
    props: {
      $$slots: { default: [sj] },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      Ve(e.$$.fragment), t = tt(), Ve(n.$$.fragment);
    },
    m(s, a) {
      Ke(e, s, a), ke(s, t, a), Ke(n, s, a), i = !0;
    },
    p(s, a) {
      const o = {};
      a & /*$$scope*/
      256 && (o.$$scope = { dirty: a, ctx: s }), n.$set(o);
    },
    i(s) {
      i || (fe(e.$$.fragment, s), fe(n.$$.fragment, s), i = !0);
    },
    o(s) {
      ge(e.$$.fragment, s), ge(n.$$.fragment, s), i = !1;
    },
    d(s) {
      s && xe(t), $e(e, s), $e(n, s);
    }
  };
}
function oj(r) {
  let e;
  return {
    c() {
      e = ir("Generate Document");
    },
    m(t, n) {
      ke(t, e, n);
    },
    d(t) {
      t && xe(e);
    }
  };
}
function Aj(r) {
  let e, t, n, i, s, a, o, A, l;
  return n = new Xo({
    props: {
      variant: "raised",
      class: "btn-pill btn-pill-primary",
      $$slots: { default: [aj] },
      $$scope: { ctx: r }
    }
  }), n.$on(
    "click",
    /*navigateToCreateTemplate*/
    r[1]
  ), s = new Xo({
    props: {
      variant: "outlined",
      class: "btn-pill btn-pill-outlined",
      $$slots: { default: [oj] },
      $$scope: { ctx: r }
    }
  }), A = new KE({
    props: {
      allTemplates: (
        /*templatesConvertedToTableRow*/
        r[0]
      )
    }
  }), A.$on(
    "templateDelete",
    /*deleteTemplate*/
    r[2]
  ), A.$on(
    "templateDownload",
    /*downloadTemplateContent*/
    r[3]
  ), A.$on(
    "editTemplate",
    /*navigateToEditTemplate*/
    r[4]
  ), A.$on(
    "duplicateTemplate",
    /*duplicateTemplate*/
    r[5]
  ), {
    c() {
      e = We("div"), t = We("header"), Ve(n.$$.fragment), i = tt(), Ve(s.$$.fragment), a = tt(), o = We("main"), Ve(A.$$.fragment), Me(t, "class", "template-controls svelte-1usfn22"), Me(e, "class", "template-overview svelte-1usfn22");
    },
    m(u, c) {
      ke(u, e, c), je(e, t), Ke(n, t, null), je(t, i), Ke(s, t, null), je(e, a), je(e, o), Ke(A, o, null), l = !0;
    },
    p(u, [c]) {
      const h = {};
      c & /*$$scope*/
      256 && (h.$$scope = { dirty: c, ctx: u }), n.$set(h);
      const f = {};
      c & /*$$scope*/
      256 && (f.$$scope = { dirty: c, ctx: u }), s.$set(f);
      const d = {};
      c & /*templatesConvertedToTableRow*/
      1 && (d.allTemplates = /*templatesConvertedToTableRow*/
      u[0]), A.$set(d);
    },
    i(u) {
      l || (fe(n.$$.fragment, u), fe(s.$$.fragment, u), fe(A.$$.fragment, u), l = !0);
    },
    o(u) {
      ge(n.$$.fragment, u), ge(s.$$.fragment, u), ge(A.$$.fragment, u), l = !1;
    },
    d(u) {
      u && xe(e), $e(n), $e(s), $e(A);
    }
  };
}
const G5 = "N/A";
function lj(r) {
  const e = r.getAttribute("date");
  return {
    id: r.getAttribute("id") ?? "No id",
    name: r.getAttribute("title") ?? G5,
    description: r.getAttribute("description") ?? G5,
    lastEdited: new Date(e)
  };
}
function uj(r, e, t) {
  let n, i = [];
  ui(() => {
    s();
  });
  function s() {
    t(6, i = sa.getAllDocumentTemplates());
  }
  function a() {
    $1(`${du.Create}`);
  }
  function o(c) {
    const { templateId: h } = c.detail;
    sa.deleteDocumentTemplate(h), t(6, i = i.filter((f) => f.getAttribute("id") !== h));
  }
  function A(c) {
    const { templateId: h } = c.detail;
    sI.downloadAsPdf(h);
  }
  function l(c) {
    const { templateId: h } = c.detail;
    $1(`${du.Edit}/${h}`);
  }
  function u(c) {
    const { templateId: h } = c.detail;
    sa.duplicateDocumentTemplate(h), s();
  }
  return r.$$.update = () => {
    r.$$.dirty & /*allTemplates*/
    64 && t(0, n = i.map(lj));
  }, [
    n,
    a,
    o,
    A,
    l,
    u,
    i
  ];
}
class Sv extends jt {
  constructor(e) {
    super(), Pt(this, e, uj, Aj, Mt, {}, ij);
  }
}
Ht(Sv, {}, [], [], !0);
function cj(r, e) {
  function t(n) {
    const i = n.target;
    !r.contains(i) && e();
  }
  return document.body.addEventListener("click", t), {
    destroy() {
      document.body.removeEventListener("click", t);
    }
  };
}
function fj(r) {
  Pi(r, "svelte-1bnudh6", "main.template-builder-container.svelte-1bnudh6.svelte-1bnudh6{margin-top:3rem;display:flex;justify-content:center}.header-container.svelte-1bnudh6.svelte-1bnudh6{border-bottom:1px solid rgba(128, 128, 128, 0.27);padding:0.75rem 0.75rem 0.25rem 0.25rem}.header.svelte-1bnudh6.svelte-1bnudh6{display:flex;width:100%;justify-content:space-between;align-items:center}.template-title.svelte-1bnudh6.svelte-1bnudh6{display:flex;align-items:center;cursor:pointer}.template-title.svelte-1bnudh6 .title.svelte-1bnudh6{min-width:10rem;color:black}.template-metadata.svelte-1bnudh6.svelte-1bnudh6{display:flex;flex-direction:column;width:20%;max-width:25%;gap:1rem;position:absolute;z-index:50;left:2%;border-radius:0.5rem;padding:1.5rem;background-color:white}");
}
function hj(r) {
  let e;
  return {
    c() {
      e = ir("Export");
    },
    m(t, n) {
      ke(t, e, n);
    },
    d(t) {
      t && xe(e);
    }
  };
}
function q5(r) {
  let e, t, n, i, s, a, o, A, l;
  function u(d) {
    r[12](d);
  }
  let c = { variant: "outlined", label: "Title" };
  /*title*/
  r[0] !== void 0 && (c.value = /*title*/
  r[0]), t = new Ff({ props: c }), yt.push(() => Gn(t, "value", u));
  function h(d) {
    r[13](d);
  }
  let f = {
    variant: "outlined",
    label: "Description",
    textarea: !0,
    input$rows: 4,
    input$cols: 30,
    input$resizable: !1
  };
  return (
    /*description*/
    r[1] !== void 0 && (f.value = /*description*/
    r[1]), s = new Ff({ props: f }), yt.push(() => Gn(s, "value", h)), {
      c() {
        e = We("div"), Ve(t.$$.fragment), i = tt(), Ve(s.$$.fragment), Me(e, "class", "template-metadata svelte-1bnudh6"), Me(e, "role", "dialog");
      },
      m(d, p) {
        ke(d, e, p), Ke(t, e, null), je(e, i), Ke(s, e, null), o = !0, A || (l = [
          Bt(cj.call(
            null,
            e,
            /*closeTitleAndDescription*/
            r[7]
          )),
          pt(e, "click", mE(
            /*click_handler*/
            r[10]
          )),
          pt(
            e,
            "keydown",
            /*keydown_handler_1*/
            r[14]
          )
        ], A = !0);
      },
      p(d, p) {
        const v = {};
        !n && p & /*title*/
        1 && (n = !0, v.value = /*title*/
        d[0], zn(() => n = !1)), t.$set(v);
        const m = {};
        !a && p & /*description*/
        2 && (a = !0, m.value = /*description*/
        d[1], zn(() => a = !1)), s.$set(m);
      },
      i(d) {
        o || (fe(t.$$.fragment, d), fe(s.$$.fragment, d), o = !0);
      },
      o(d) {
        ge(t.$$.fragment, d), ge(s.$$.fragment, d), o = !1;
      },
      d(d) {
        d && xe(e), $e(t), $e(s), A = !1, fr(l);
      }
    }
  );
}
function W5(r) {
  let e, t;
  return e = new pI({ props: { template: (
    /*template*/
    r[3]
  ) } }), {
    c() {
      Ve(e.$$.fragment);
    },
    m(n, i) {
      Ke(e, n, i), t = !0;
    },
    p(n, i) {
      const s = {};
      i & /*template*/
      8 && (s.template = /*template*/
      n[3]), e.$set(s);
    },
    i(n) {
      t || (fe(e.$$.fragment, n), t = !0);
    },
    o(n) {
      ge(e.$$.fragment, n), t = !1;
    },
    d(n) {
      $e(e, n);
    }
  };
}
function dj(r) {
  let e, t, n, i, s, a, o, A, l, u, c, h, f, d, p, v;
  s = new us({
    props: { icon: "arrow_back", color: "black" }
  }), s.$on(
    "click",
    /*askForEmptyTitleConfirmation*/
    r[5]
  ), u = new Xo({
    props: {
      variant: "raised",
      $$slots: { default: [hj] },
      $$scope: { ctx: r }
    }
  }), u.$on(
    "click",
    /*downloadTemplateContent*/
    r[8]
  );
  let m = (
    /*isMetadataVisible*/
    r[2] && q5(r)
  ), b = (
    /*template*/
    r[3] && W5(r)
  );
  return {
    c() {
      e = We("div"), t = We("header"), n = We("div"), i = We("div"), Ve(s.$$.fragment), a = tt(), o = We("div"), A = ir(
        /*templateTitle*/
        r[4]
      ), l = tt(), Ve(u.$$.fragment), c = tt(), m && m.c(), h = tt(), f = We("main"), b && b.c(), Me(o, "class", "title svelte-1bnudh6"), Me(o, "role", "button"), Me(o, "tabindex", "0"), Me(i, "class", "template-title svelte-1bnudh6"), Me(n, "class", "header svelte-1bnudh6"), Me(t, "class", "header-container svelte-1bnudh6"), Me(f, "class", "template-builder-container svelte-1bnudh6"), Me(e, "class", "template-creation-container");
    },
    m(w, B) {
      ke(w, e, B), je(e, t), je(t, n), je(n, i), Ke(s, i, null), je(i, a), je(i, o), je(o, A), je(n, l), Ke(u, n, null), je(e, c), m && m.m(e, null), je(e, h), je(e, f), b && b.m(f, null), d = !0, p || (v = [
        pt(o, "click", mE(
          /*displayTitleAndDescription*/
          r[6]
        )),
        pt(
          o,
          "keydown",
          /*keydown_handler*/
          r[11]
        )
      ], p = !0);
    },
    p(w, [B]) {
      (!d || B & /*templateTitle*/
      16) && Ds(
        A,
        /*templateTitle*/
        w[4]
      );
      const _ = {};
      B & /*$$scope*/
      1048576 && (_.$$scope = { dirty: B, ctx: w }), u.$set(_), /*isMetadataVisible*/
      w[2] ? m ? (m.p(w, B), B & /*isMetadataVisible*/
      4 && fe(m, 1)) : (m = q5(w), m.c(), fe(m, 1), m.m(e, h)) : m && (er(), ge(m, 1, 1, () => {
        m = null;
      }), tr()), /*template*/
      w[3] ? b ? (b.p(w, B), B & /*template*/
      8 && fe(b, 1)) : (b = W5(w), b.c(), fe(b, 1), b.m(f, null)) : b && (er(), ge(b, 1, 1, () => {
        b = null;
      }), tr());
    },
    i(w) {
      d || (fe(s.$$.fragment, w), fe(u.$$.fragment, w), fe(m), fe(b), d = !0);
    },
    o(w) {
      ge(s.$$.fragment, w), ge(u.$$.fragment, w), ge(m), ge(b), d = !1;
    },
    d(w) {
      w && xe(e), $e(s), $e(u), m && m.d(), b && b.d(), p = !1, fr(v);
    }
  };
}
const pj = "Untitled Document";
function gj(r, e, t) {
  let n, { params: i = {} } = e, s = "", a = "", o = !1, A, l = null;
  ui(() => {
    if (A = i.id ?? c(), t(3, l = sa.getDocumentTemplate(A)), !l)
      return f();
    u(l);
  });
  function u(C) {
    t(0, s = C.getAttribute("title") || ""), t(1, a = C.getAttribute("description") || "");
  }
  function c() {
    return sa.addDocumentTemplate();
  }
  function h() {
    !s && !confirm("No title has been provided. Do you want to proceed?") || f();
  }
  function f() {
    $1("/");
  }
  function d() {
    t(2, o = !0);
  }
  function p() {
    t(2, o = !1), A ? v() : console.error("Template ID is null. Cannot update title and description.");
  }
  function v() {
    sa.editDocumentTemplateTitleAndDescription(A, s, a);
  }
  function m() {
    A && sI.downloadAsPdf(A);
  }
  function b(C) {
    Sa.call(this, r, C);
  }
  const w = (C) => C.key === "Enter" && d();
  function B(C) {
    s = C, t(0, s);
  }
  function _(C) {
    a = C, t(1, a);
  }
  const x = (C) => C.key === "Escape" && p();
  return r.$$set = (C) => {
    "params" in C && t(9, i = C.params);
  }, r.$$.update = () => {
    r.$$.dirty & /*title*/
    1 && t(4, n = s.length === 0 ? pj : s);
  }, [
    s,
    a,
    o,
    l,
    n,
    h,
    d,
    p,
    m,
    i,
    b,
    w,
    B,
    _,
    x
  ];
}
class gI extends jt {
  constructor(e) {
    super(), Pt(this, e, gj, dj, Mt, { params: 9 }, fj);
  }
  get params() {
    return this.$$.ctx[9];
  }
  set params(e) {
    this.$$set({ params: e }), pe();
  }
}
Ht(gI, { params: {} }, [], [], !0);
const X5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: gI
}, Symbol.toStringTag, { value: "Module" }));
function J5(r) {
  if (!r)
    throw Error("Parameter args is required");
  if (!r.component == !r.asyncComponent)
    throw Error("One and only one of component and asyncComponent is required");
  if (r.component && (r.asyncComponent = () => Promise.resolve(r.component)), typeof r.asyncComponent != "function")
    throw Error("Parameter asyncComponent must be a function");
  if (r.conditions) {
    Array.isArray(r.conditions) || (r.conditions = [r.conditions]);
    for (let t = 0; t < r.conditions.length; t++)
      if (!r.conditions[t] || typeof r.conditions[t] != "function")
        throw Error("Invalid parameter conditions[" + t + "]");
  }
  return r.loadingComponent && (r.asyncComponent.loading = r.loadingComponent, r.asyncComponent.loadingParams = r.loadingParams || void 0), {
    component: r.asyncComponent,
    userData: r.userData,
    conditions: r.conditions && r.conditions.length ? r.conditions : void 0,
    props: r.props && Object.keys(r.props).length ? r.props : {},
    _sveltesparouter: !0
  };
}
const mj = {
  [du.Home]: Sv,
  [`${du.Create}`]: J5({
    asyncComponent: () => Promise.resolve().then(() => X5)
  }),
  [`${du.Edit}/${i7.id}`]: J5({
    asyncComponent: () => Promise.resolve().then(() => X5)
  }),
  [du.Not_Found]: Sv
}, vj = "@oscd-plugins/auto-doc", bj = "1.7.0", yj = "module", wj = {
  dev: "vite --mode STAND_ALONE",
  build: "vite build",
  "_build:watch": "NODE_ENV=development vite build --watch",
  "build:watch": "concurrently 'npm:_build:watch' 'npm:preview'",
  preview: "vite preview --port 55908",
  check: "svelte-check --tsconfig ./tsconfig.json",
  "check:watch": "npm run check -- --watch",
  version: "echo $npm_package_version",
  test: "vitest"
}, Bj = {
  "@oscd-plugins/core": "workspace:^",
  "@oscd-plugins/ui": "workspace:^",
  "@oscd-plugins/uilib": "workspace:^",
  "@smui/button": "7.0.0",
  "@smui/checkbox": "^7.0.0",
  "@smui/data-table": "^7.0.0",
  "@smui/icon-button": "^7.0.0",
  "@smui/textfield": "^7.0.0",
  "@tiptap/core": "^2.11.5",
  "@tiptap/extension-list-item": "^2.11.5",
  "@tiptap/extension-text-style": "^2.11.5",
  "@tiptap/extension-underline": "^2.11.5",
  "@tiptap/pm": "^2.11.5",
  "@tiptap/starter-kit": "^2.11.5",
  jspdf: "^2.5.2",
  "jspdf-autotable": "^3.8.4",
  "svelte-spa-router": "^4.0.1",
  uuid: "^10.0.0",
  zipcelx: "^1.6.2"
}, Cj = {
  "@playwright/test": "^1.28.1",
  "@sveltejs/vite-plugin-svelte": "^3.1.1",
  "@tsconfig/svelte": "^5.0.4",
  "@types/uuid": "^10.0.0",
  concurrently: "^7.6.0",
  playwright: "^1.48.1",
  sass: "^1.61.0",
  svelte: "^4.2.18",
  "svelte-check": "^3.8.5",
  tslib: "^2.6.3",
  typescript: "^5.5.3",
  vite: "^5.4.1",
  "vite-plugin-css-injected-by-js": "^3.1.1",
  vitest: "^2.1.3"
}, Y5 = {
  name: vj,
  private: !0,
  version: bj,
  type: yj,
  scripts: wj,
  dependencies: Bj,
  devDependencies: Cj
};
function _j(r) {
  Pi(r, "svelte-u9zh1g", ".file-missing.svelte-u9zh1g.svelte-u9zh1g{padding-top:20px}.file-missing.svelte-u9zh1g p.svelte-u9zh1g{text-align:center}.banner.svelte-u9zh1g.svelte-u9zh1g{align-items:center;justify-content:space-between;padding:0.25rem 2rem;width:100%;background-color:var(--mdc-theme-error);color:white;position:fixed;top:var(--header-height);box-sizing:border-box;z-index:1}");
}
function Ej(r) {
  let e;
  return {
    c() {
      e = We("div"), e.innerHTML = '<p class="svelte-u9zh1g">No XML file loaded</p>', Me(e, "class", "file-missing svelte-u9zh1g");
    },
    m(t, n) {
      ke(t, e, n);
    },
    p: sr,
    i: sr,
    o: sr,
    d(t) {
      t && xe(e);
    }
  };
}
function Sj(r) {
  let e, t, n, i = (
    /*showBanner*/
    r[2] && !0 && Z5(r)
  );
  return t = new RE({ props: { routes: mj } }), {
    c() {
      i && i.c(), e = tt(), Ve(t.$$.fragment);
    },
    m(s, a) {
      i && i.m(s, a), ke(s, e, a), Ke(t, s, a), n = !0;
    },
    p(s, a) {
      /*showBanner*/
      s[2] ? i ? (i.p(s, a), a & /*showBanner*/
      4 && fe(i, 1)) : (i = Z5(s), i.c(), fe(i, 1), i.m(e.parentNode, e)) : i && (er(), ge(i, 1, 1, () => {
        i = null;
      }), tr());
    },
    i(s) {
      n || (fe(i), fe(t.$$.fragment, s), n = !0);
    },
    o(s) {
      ge(i), ge(t.$$.fragment, s), n = !1;
    },
    d(s) {
      s && xe(e), i && i.d(s), $e(t, s);
    }
  };
}
function Z5(r) {
  let e, t, n, i, s;
  return n = new us({ props: { icon: "close", color: "white" } }), n.$on(
    "click",
    /*click_handler*/
    r[5]
  ), {
    c() {
      e = We("div"), t = ir(`This plugin is in test phase and not suitable for production use.
					`), Ve(n.$$.fragment), Me(e, "class", "banner svelte-u9zh1g"), Me(e, "style", i = /*showBanner*/
      r[2] ? "display:flex;" : "display:none;");
    },
    m(a, o) {
      ke(a, e, o), je(e, t), Ke(n, e, null), s = !0;
    },
    p(a, o) {
      (!s || o & /*showBanner*/
      4 && i !== (i = /*showBanner*/
      a[2] ? "display:flex;" : "display:none;")) && Me(e, "style", i);
    },
    i(a) {
      s || (fe(n.$$.fragment, a), s = !0);
    },
    o(a) {
      ge(n.$$.fragment, a), s = !1;
    },
    d(a) {
      a && xe(e), $e(n);
    }
  };
}
function Ij(r) {
  let e, t, n, i;
  const s = [Sj, Ej], a = [];
  function o(A, l) {
    return (
      /*xmlDocument*/
      A[0] ? 0 : 1
    );
  }
  return t = o(r), n = a[t] = s[t](r), {
    c() {
      e = We("auto-doc"), n.c(), qc(e, "class", "auto-doc");
    },
    m(A, l) {
      ke(A, e, l), a[t].m(e, null), i = !0;
    },
    p(A, l) {
      let u = t;
      t = o(A), t === u ? a[t].p(A, l) : (er(), ge(a[u], 1, 1, () => {
        a[u] = null;
      }), tr(), n = a[t], n ? n.p(A, l) : (n = a[t] = s[t](A), n.c()), fe(n, 1), n.m(e, null));
    },
    i(A) {
      i || (fe(n), i = !0);
    },
    o(A) {
      ge(n), i = !1;
    },
    d(A) {
      A && xe(e), a[t].d();
    }
  };
}
function Fj(r) {
  let e, t, n, i, s, a;
  return s = new ME({
    props: {
      pluginType: (
        /*pluginType*/
        r[1]
      ),
      $$slots: { default: [Ij] },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      e = We("input"), t = tt(), n = We("input"), i = tt(), Ve(s.$$.fragment), Me(e, "type", "hidden"), Me(e, "name", "package-name"), e.value = Y5.name, Me(n, "type", "hidden"), Me(n, "name", "package-version"), n.value = Y5.version;
    },
    m(o, A) {
      ke(o, e, A), ke(o, t, A), ke(o, n, A), ke(o, i, A), Ke(s, o, A), a = !0;
    },
    p(o, [A]) {
      const l = {};
      A & /*pluginType*/
      2 && (l.pluginType = /*pluginType*/
      o[1]), A & /*$$scope, showBanner, xmlDocument*/
      133 && (l.$$scope = { dirty: A, ctx: o }), s.$set(l);
    },
    i(o) {
      a || (fe(s.$$.fragment, o), a = !0);
    },
    o(o) {
      ge(s.$$.fragment, o), a = !1;
    },
    d(o) {
      o && (xe(e), xe(t), xe(n), xe(i)), $e(s, o);
    }
  };
}
function Tj(r, e, t) {
  let { xmlDocument: n = void 0 } = e, { pluginHostElement: i } = e, { pluginType: s = "editor" } = e, { editCount: a } = e, o = !0;
  async function A({ updateTrigger: u, newXMLDocument: c, newPluginHostElement: h }) {
    await Pf.init({ newXMLDocument: c, newPluginHostElement: h }), sa.init();
  }
  const l = () => t(2, o = !o);
  return r.$$set = (u) => {
    "xmlDocument" in u && t(0, n = u.xmlDocument), "pluginHostElement" in u && t(3, i = u.pluginHostElement), "pluginType" in u && t(1, s = u.pluginType), "editCount" in u && t(4, a = u.editCount);
  }, r.$$.update = () => {
    r.$$.dirty & /*editCount, xmlDocument, pluginHostElement*/
    25 && A({
      updateTrigger: a,
      newXMLDocument: n,
      newPluginHostElement: i
    });
  }, [
    n,
    s,
    o,
    i,
    a,
    l
  ];
}
class mI extends jt {
  constructor(e) {
    super(), Pt(
      this,
      e,
      Tj,
      Fj,
      Mt,
      {
        xmlDocument: 0,
        pluginHostElement: 3,
        pluginType: 1,
        editCount: 4
      },
      _j
    );
  }
  get xmlDocument() {
    return this.$$.ctx[0];
  }
  set xmlDocument(e) {
    this.$$set({ xmlDocument: e }), pe();
  }
  get pluginHostElement() {
    return this.$$.ctx[3];
  }
  set pluginHostElement(e) {
    this.$$set({ pluginHostElement: e }), pe();
  }
  get pluginType() {
    return this.$$.ctx[1];
  }
  set pluginType(e) {
    this.$$set({ pluginType: e }), pe();
  }
  get editCount() {
    return this.$$.ctx[4];
  }
  set editCount(e) {
    this.$$set({ editCount: e }), pe();
  }
}
Ht(mI, { xmlDocument: {}, pluginHostElement: {}, pluginType: {}, editCount: {} }, [], [], !0);
const Iae = HU({
  pluginType: "editor",
  isStandAlone: !1,
  pluginComponent: mI
}), xj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Iv = function(r, e) {
  return Iv = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
  }, Iv(r, e);
};
function ua(r, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  Iv(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var Fv = function() {
  return Fv = Object.assign || function(e) {
    for (var t, n = 1, i = arguments.length; n < i; n++) {
      t = arguments[n];
      for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
    }
    return e;
  }, Fv.apply(this, arguments);
};
function Ui(r, e, t, n) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(u) {
      try {
        l(n.next(u));
      } catch (c) {
        a(c);
      }
    }
    function A(u) {
      try {
        l(n.throw(u));
      } catch (c) {
        a(c);
      }
    }
    function l(u) {
      u.done ? s(u.value) : i(u.value).then(o, A);
    }
    l((n = n.apply(r, [])).next());
  });
}
function wi(r, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, a;
  return a = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function o(l) {
    return function(u) {
      return A([l, u]);
    };
  }
  function A(l) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; t; ) try {
      if (n = 1, i && (s = l[0] & 2 ? i.return : l[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, l[1])).done) return s;
      switch (i = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
        case 0:
        case 1:
          s = l;
          break;
        case 4:
          return t.label++, { value: l[1], done: !1 };
        case 5:
          t.label++, i = l[1], l = [0];
          continue;
        case 7:
          l = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            t = 0;
            continue;
          }
          if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
            t.label = l[1];
            break;
          }
          if (l[0] === 6 && t.label < s[1]) {
            t.label = s[1], s = l;
            break;
          }
          if (s && t.label < s[2]) {
            t.label = s[2], t.ops.push(l);
            break;
          }
          s[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      l = e.call(r, t);
    } catch (u) {
      l = [6, u], i = 0;
    } finally {
      n = s = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function ld(r, e, t) {
  if (arguments.length === 2) for (var n = 0, i = e.length, s; n < i; n++)
    (s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
  return r.concat(s || e);
}
var lo = (
  /** @class */
  function() {
    function r(e, t, n, i) {
      this.left = e, this.top = t, this.width = n, this.height = i;
    }
    return r.prototype.add = function(e, t, n, i) {
      return new r(this.left + e, this.top + t, this.width + n, this.height + i);
    }, r.fromClientRect = function(e, t) {
      return new r(t.left + e.windowBounds.left, t.top + e.windowBounds.top, t.width, t.height);
    }, r.fromDOMRectList = function(e, t) {
      var n = Array.from(t).find(function(i) {
        return i.width !== 0;
      });
      return n ? new r(n.left + e.windowBounds.left, n.top + e.windowBounds.top, n.width, n.height) : r.EMPTY;
    }, r.EMPTY = new r(0, 0, 0, 0), r;
  }()
), Cg = function(r, e) {
  return lo.fromClientRect(r, e.getBoundingClientRect());
}, kj = function(r) {
  var e = r.body, t = r.documentElement;
  if (!e || !t)
    throw new Error("Unable to get document size");
  var n = Math.max(Math.max(e.scrollWidth, t.scrollWidth), Math.max(e.offsetWidth, t.offsetWidth), Math.max(e.clientWidth, t.clientWidth)), i = Math.max(Math.max(e.scrollHeight, t.scrollHeight), Math.max(e.offsetHeight, t.offsetHeight), Math.max(e.clientHeight, t.clientHeight));
  return new lo(0, 0, n, i);
}, _g = function(r) {
  for (var e = [], t = 0, n = r.length; t < n; ) {
    var i = r.charCodeAt(t++);
    if (i >= 55296 && i <= 56319 && t < n) {
      var s = r.charCodeAt(t++);
      (s & 64512) === 56320 ? e.push(((i & 1023) << 10) + (s & 1023) + 65536) : (e.push(i), t--);
    } else
      e.push(i);
  }
  return e;
}, dn = function() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  if (String.fromCodePoint)
    return String.fromCodePoint.apply(String, r);
  var t = r.length;
  if (!t)
    return "";
  for (var n = [], i = -1, s = ""; ++i < t; ) {
    var a = r[i];
    a <= 65535 ? n.push(a) : (a -= 65536, n.push((a >> 10) + 55296, a % 1024 + 56320)), (i + 1 === t || n.length > 16384) && (s += String.fromCharCode.apply(String, n), n.length = 0);
  }
  return s;
}, eC = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Lj = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var ud = 0; ud < eC.length; ud++)
  Lj[eC.charCodeAt(ud)] = ud;
var tC = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Mc = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var cd = 0; cd < tC.length; cd++)
  Mc[tC.charCodeAt(cd)] = cd;
var Uj = function(r) {
  var e = r.length * 0.75, t = r.length, n, i = 0, s, a, o, A;
  r[r.length - 1] === "=" && (e--, r[r.length - 2] === "=" && e--);
  var l = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && typeof Uint8Array.prototype.slice < "u" ? new ArrayBuffer(e) : new Array(e), u = Array.isArray(l) ? l : new Uint8Array(l);
  for (n = 0; n < t; n += 4)
    s = Mc[r.charCodeAt(n)], a = Mc[r.charCodeAt(n + 1)], o = Mc[r.charCodeAt(n + 2)], A = Mc[r.charCodeAt(n + 3)], u[i++] = s << 2 | a >> 4, u[i++] = (a & 15) << 4 | o >> 2, u[i++] = (o & 3) << 6 | A & 63;
  return l;
}, Nj = function(r) {
  for (var e = r.length, t = [], n = 0; n < e; n += 2)
    t.push(r[n + 1] << 8 | r[n]);
  return t;
}, Oj = function(r) {
  for (var e = r.length, t = [], n = 0; n < e; n += 4)
    t.push(r[n + 3] << 24 | r[n + 2] << 16 | r[n + 1] << 8 | r[n]);
  return t;
}, nl = 5, vb = 11, m0 = 2, Qj = vb - nl, vI = 65536 >> nl, Dj = 1 << nl, v0 = Dj - 1, Mj = 1024 >> nl, Rj = vI + Mj, Pj = Rj, Hj = 32, jj = Pj + Hj, Kj = 65536 >> vb, $j = 1 << Qj, Vj = $j - 1, rC = function(r, e, t) {
  return r.slice ? r.slice(e, t) : new Uint16Array(Array.prototype.slice.call(r, e, t));
}, zj = function(r, e, t) {
  return r.slice ? r.slice(e, t) : new Uint32Array(Array.prototype.slice.call(r, e, t));
}, Gj = function(r, e) {
  var t = Uj(r), n = Array.isArray(t) ? Oj(t) : new Uint32Array(t), i = Array.isArray(t) ? Nj(t) : new Uint16Array(t), s = 24, a = rC(i, s / 2, n[4] / 2), o = n[5] === 2 ? rC(i, (s + n[4]) / 2) : zj(n, Math.ceil((s + n[4]) / 4));
  return new qj(n[0], n[1], n[2], n[3], a, o);
}, qj = (
  /** @class */
  function() {
    function r(e, t, n, i, s, a) {
      this.initialValue = e, this.errorValue = t, this.highStart = n, this.highValueIndex = i, this.index = s, this.data = a;
    }
    return r.prototype.get = function(e) {
      var t;
      if (e >= 0) {
        if (e < 55296 || e > 56319 && e <= 65535)
          return t = this.index[e >> nl], t = (t << m0) + (e & v0), this.data[t];
        if (e <= 65535)
          return t = this.index[vI + (e - 55296 >> nl)], t = (t << m0) + (e & v0), this.data[t];
        if (e < this.highStart)
          return t = jj - Kj + (e >> vb), t = this.index[t], t += e >> nl & Vj, t = this.index[t], t = (t << m0) + (e & v0), this.data[t];
        if (e <= 1114111)
          return this.data[this.highValueIndex];
      }
      return this.errorValue;
    }, r;
  }()
), nC = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Wj = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var fd = 0; fd < nC.length; fd++)
  Wj[nC.charCodeAt(fd)] = fd;
var Xj = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==", iC = 50, Jj = 1, bI = 2, yI = 3, Yj = 4, Zj = 5, sC = 7, wI = 8, aC = 9, Go = 10, Tv = 11, oC = 12, xv = 13, eK = 14, Rc = 15, kv = 16, hd = 17, _c = 18, tK = 19, AC = 20, Lv = 21, Ec = 22, b0 = 23, Gl = 24, as = 25, Pc = 26, Hc = 27, ql = 28, rK = 29, DA = 30, nK = 31, dd = 32, pd = 33, Uv = 34, Nv = 35, Ov = 36, Tf = 37, Qv = 38, sp = 39, ap = 40, y0 = 41, BI = 42, iK = 43, sK = [9001, 65288], CI = "!", lr = "×", gd = "÷", Dv = Gj(Xj), Ja = [DA, Ov], Mv = [Jj, bI, yI, Zj], _I = [Go, wI], lC = [Hc, Pc], aK = Mv.concat(_I), uC = [Qv, sp, ap, Uv, Nv], oK = [Rc, xv], AK = function(r, e) {
  e === void 0 && (e = "strict");
  var t = [], n = [], i = [];
  return r.forEach(function(s, a) {
    var o = Dv.get(s);
    if (o > iC ? (i.push(!0), o -= iC) : i.push(!1), ["normal", "auto", "loose"].indexOf(e) !== -1 && [8208, 8211, 12316, 12448].indexOf(s) !== -1)
      return n.push(a), t.push(kv);
    if (o === Yj || o === Tv) {
      if (a === 0)
        return n.push(a), t.push(DA);
      var A = t[a - 1];
      return aK.indexOf(A) === -1 ? (n.push(n[a - 1]), t.push(A)) : (n.push(a), t.push(DA));
    }
    if (n.push(a), o === nK)
      return t.push(e === "strict" ? Lv : Tf);
    if (o === BI || o === rK)
      return t.push(DA);
    if (o === iK)
      return s >= 131072 && s <= 196605 || s >= 196608 && s <= 262141 ? t.push(Tf) : t.push(DA);
    t.push(o);
  }), [n, t, i];
}, w0 = function(r, e, t, n) {
  var i = n[t];
  if (Array.isArray(r) ? r.indexOf(i) !== -1 : r === i)
    for (var s = t; s <= n.length; ) {
      s++;
      var a = n[s];
      if (a === e)
        return !0;
      if (a !== Go)
        break;
    }
  if (i === Go)
    for (var s = t; s > 0; ) {
      s--;
      var o = n[s];
      if (Array.isArray(r) ? r.indexOf(o) !== -1 : r === o)
        for (var A = t; A <= n.length; ) {
          A++;
          var a = n[A];
          if (a === e)
            return !0;
          if (a !== Go)
            break;
        }
      if (o !== Go)
        break;
    }
  return !1;
}, cC = function(r, e) {
  for (var t = r; t >= 0; ) {
    var n = e[t];
    if (n === Go)
      t--;
    else
      return n;
  }
  return 0;
}, lK = function(r, e, t, n, i) {
  if (t[n] === 0)
    return lr;
  var s = n - 1;
  if (Array.isArray(i) && i[s] === !0)
    return lr;
  var a = s - 1, o = s + 1, A = e[s], l = a >= 0 ? e[a] : 0, u = e[o];
  if (A === bI && u === yI)
    return lr;
  if (Mv.indexOf(A) !== -1)
    return CI;
  if (Mv.indexOf(u) !== -1 || _I.indexOf(u) !== -1)
    return lr;
  if (cC(s, e) === wI)
    return gd;
  if (Dv.get(r[s]) === Tv || (A === dd || A === pd) && Dv.get(r[o]) === Tv || A === sC || u === sC || A === aC || [Go, xv, Rc].indexOf(A) === -1 && u === aC || [hd, _c, tK, Gl, ql].indexOf(u) !== -1 || cC(s, e) === Ec || w0(b0, Ec, s, e) || w0([hd, _c], Lv, s, e) || w0(oC, oC, s, e))
    return lr;
  if (A === Go)
    return gd;
  if (A === b0 || u === b0)
    return lr;
  if (u === kv || A === kv)
    return gd;
  if ([xv, Rc, Lv].indexOf(u) !== -1 || A === eK || l === Ov && oK.indexOf(A) !== -1 || A === ql && u === Ov || u === AC || Ja.indexOf(u) !== -1 && A === as || Ja.indexOf(A) !== -1 && u === as || A === Hc && [Tf, dd, pd].indexOf(u) !== -1 || [Tf, dd, pd].indexOf(A) !== -1 && u === Pc || Ja.indexOf(A) !== -1 && lC.indexOf(u) !== -1 || lC.indexOf(A) !== -1 && Ja.indexOf(u) !== -1 || // (PR | PO) × ( OP | HY )? NU
  [Hc, Pc].indexOf(A) !== -1 && (u === as || [Ec, Rc].indexOf(u) !== -1 && e[o + 1] === as) || // ( OP | HY ) × NU
  [Ec, Rc].indexOf(A) !== -1 && u === as || // NU ×	(NU | SY | IS)
  A === as && [as, ql, Gl].indexOf(u) !== -1)
    return lr;
  if ([as, ql, Gl, hd, _c].indexOf(u) !== -1)
    for (var c = s; c >= 0; ) {
      var h = e[c];
      if (h === as)
        return lr;
      if ([ql, Gl].indexOf(h) !== -1)
        c--;
      else
        break;
    }
  if ([Hc, Pc].indexOf(u) !== -1)
    for (var c = [hd, _c].indexOf(A) !== -1 ? a : s; c >= 0; ) {
      var h = e[c];
      if (h === as)
        return lr;
      if ([ql, Gl].indexOf(h) !== -1)
        c--;
      else
        break;
    }
  if (Qv === A && [Qv, sp, Uv, Nv].indexOf(u) !== -1 || [sp, Uv].indexOf(A) !== -1 && [sp, ap].indexOf(u) !== -1 || [ap, Nv].indexOf(A) !== -1 && u === ap || uC.indexOf(A) !== -1 && [AC, Pc].indexOf(u) !== -1 || uC.indexOf(u) !== -1 && A === Hc || Ja.indexOf(A) !== -1 && Ja.indexOf(u) !== -1 || A === Gl && Ja.indexOf(u) !== -1 || Ja.concat(as).indexOf(A) !== -1 && u === Ec && sK.indexOf(r[o]) === -1 || Ja.concat(as).indexOf(u) !== -1 && A === _c)
    return lr;
  if (A === y0 && u === y0) {
    for (var f = t[s], d = 1; f > 0 && (f--, e[f] === y0); )
      d++;
    if (d % 2 !== 0)
      return lr;
  }
  return A === dd && u === pd ? lr : gd;
}, uK = function(r, e) {
  e || (e = { lineBreak: "normal", wordBreak: "normal" });
  var t = AK(r, e.lineBreak), n = t[0], i = t[1], s = t[2];
  (e.wordBreak === "break-all" || e.wordBreak === "break-word") && (i = i.map(function(o) {
    return [as, DA, BI].indexOf(o) !== -1 ? Tf : o;
  }));
  var a = e.wordBreak === "keep-all" ? s.map(function(o, A) {
    return o && r[A] >= 19968 && r[A] <= 40959;
  }) : void 0;
  return [n, i, a];
}, cK = (
  /** @class */
  function() {
    function r(e, t, n, i) {
      this.codePoints = e, this.required = t === CI, this.start = n, this.end = i;
    }
    return r.prototype.slice = function() {
      return dn.apply(void 0, this.codePoints.slice(this.start, this.end));
    }, r;
  }()
), fK = function(r, e) {
  var t = _g(r), n = uK(t, e), i = n[0], s = n[1], a = n[2], o = t.length, A = 0, l = 0;
  return {
    next: function() {
      if (l >= o)
        return { done: !0, value: null };
      for (var u = lr; l < o && (u = lK(t, s, i, ++l, a)) === lr; )
        ;
      if (u !== lr || l === o) {
        var c = new cK(t, u, A, l);
        return A = l, { value: c, done: !1 };
      }
      return { done: !0, value: null };
    }
  };
}, hK = 1, dK = 2, Hf = 4, fC = 8, Op = 10, hC = 47, of = 92, pK = 9, gK = 32, md = 34, Sc = 61, mK = 35, vK = 36, bK = 37, vd = 39, bd = 40, Ic = 41, yK = 95, Xi = 45, wK = 33, BK = 60, CK = 62, _K = 64, EK = 91, SK = 93, IK = 61, FK = 123, yd = 63, TK = 125, dC = 124, xK = 126, kK = 128, pC = 65533, B0 = 42, VA = 43, LK = 44, UK = 58, NK = 59, xf = 46, OK = 0, QK = 8, DK = 11, MK = 14, RK = 31, PK = 127, ba = -1, EI = 48, SI = 97, II = 101, HK = 102, jK = 117, KK = 122, FI = 65, TI = 69, xI = 70, $K = 85, VK = 90, Ci = function(r) {
  return r >= EI && r <= 57;
}, zK = function(r) {
  return r >= 55296 && r <= 57343;
}, Wl = function(r) {
  return Ci(r) || r >= FI && r <= xI || r >= SI && r <= HK;
}, GK = function(r) {
  return r >= SI && r <= KK;
}, qK = function(r) {
  return r >= FI && r <= VK;
}, WK = function(r) {
  return GK(r) || qK(r);
}, XK = function(r) {
  return r >= kK;
}, wd = function(r) {
  return r === Op || r === pK || r === gK;
}, Qp = function(r) {
  return WK(r) || XK(r) || r === yK;
}, gC = function(r) {
  return Qp(r) || Ci(r) || r === Xi;
}, JK = function(r) {
  return r >= OK && r <= QK || r === DK || r >= MK && r <= RK || r === PK;
}, Do = function(r, e) {
  return r !== of ? !1 : e !== Op;
}, Bd = function(r, e, t) {
  return r === Xi ? Qp(e) || Do(e, t) : Qp(r) ? !0 : !!(r === of && Do(r, e));
}, C0 = function(r, e, t) {
  return r === VA || r === Xi ? Ci(e) ? !0 : e === xf && Ci(t) : Ci(r === xf ? e : r);
}, YK = function(r) {
  var e = 0, t = 1;
  (r[e] === VA || r[e] === Xi) && (r[e] === Xi && (t = -1), e++);
  for (var n = []; Ci(r[e]); )
    n.push(r[e++]);
  var i = n.length ? parseInt(dn.apply(void 0, n), 10) : 0;
  r[e] === xf && e++;
  for (var s = []; Ci(r[e]); )
    s.push(r[e++]);
  var a = s.length, o = a ? parseInt(dn.apply(void 0, s), 10) : 0;
  (r[e] === TI || r[e] === II) && e++;
  var A = 1;
  (r[e] === VA || r[e] === Xi) && (r[e] === Xi && (A = -1), e++);
  for (var l = []; Ci(r[e]); )
    l.push(r[e++]);
  var u = l.length ? parseInt(dn.apply(void 0, l), 10) : 0;
  return t * (i + o * Math.pow(10, -a)) * Math.pow(10, A * u);
}, ZK = {
  type: 2
  /* LEFT_PARENTHESIS_TOKEN */
}, e$ = {
  type: 3
  /* RIGHT_PARENTHESIS_TOKEN */
}, t$ = {
  type: 4
  /* COMMA_TOKEN */
}, r$ = {
  type: 13
  /* SUFFIX_MATCH_TOKEN */
}, n$ = {
  type: 8
  /* PREFIX_MATCH_TOKEN */
}, i$ = {
  type: 21
  /* COLUMN_TOKEN */
}, s$ = {
  type: 9
  /* DASH_MATCH_TOKEN */
}, a$ = {
  type: 10
  /* INCLUDE_MATCH_TOKEN */
}, o$ = {
  type: 11
  /* LEFT_CURLY_BRACKET_TOKEN */
}, A$ = {
  type: 12
  /* RIGHT_CURLY_BRACKET_TOKEN */
}, l$ = {
  type: 14
  /* SUBSTRING_MATCH_TOKEN */
}, Cd = {
  type: 23
  /* BAD_URL_TOKEN */
}, u$ = {
  type: 1
  /* BAD_STRING_TOKEN */
}, c$ = {
  type: 25
  /* CDO_TOKEN */
}, f$ = {
  type: 24
  /* CDC_TOKEN */
}, h$ = {
  type: 26
  /* COLON_TOKEN */
}, d$ = {
  type: 27
  /* SEMICOLON_TOKEN */
}, p$ = {
  type: 28
  /* LEFT_SQUARE_BRACKET_TOKEN */
}, g$ = {
  type: 29
  /* RIGHT_SQUARE_BRACKET_TOKEN */
}, m$ = {
  type: 31
  /* WHITESPACE_TOKEN */
}, Rv = {
  type: 32
  /* EOF_TOKEN */
}, kI = (
  /** @class */
  function() {
    function r() {
      this._value = [];
    }
    return r.prototype.write = function(e) {
      this._value = this._value.concat(_g(e));
    }, r.prototype.read = function() {
      for (var e = [], t = this.consumeToken(); t !== Rv; )
        e.push(t), t = this.consumeToken();
      return e;
    }, r.prototype.consumeToken = function() {
      var e = this.consumeCodePoint();
      switch (e) {
        case md:
          return this.consumeStringToken(md);
        case mK:
          var t = this.peekCodePoint(0), n = this.peekCodePoint(1), i = this.peekCodePoint(2);
          if (gC(t) || Do(n, i)) {
            var s = Bd(t, n, i) ? dK : hK, a = this.consumeName();
            return { type: 5, value: a, flags: s };
          }
          break;
        case vK:
          if (this.peekCodePoint(0) === Sc)
            return this.consumeCodePoint(), r$;
          break;
        case vd:
          return this.consumeStringToken(vd);
        case bd:
          return ZK;
        case Ic:
          return e$;
        case B0:
          if (this.peekCodePoint(0) === Sc)
            return this.consumeCodePoint(), l$;
          break;
        case VA:
          if (C0(e, this.peekCodePoint(0), this.peekCodePoint(1)))
            return this.reconsumeCodePoint(e), this.consumeNumericToken();
          break;
        case LK:
          return t$;
        case Xi:
          var o = e, A = this.peekCodePoint(0), l = this.peekCodePoint(1);
          if (C0(o, A, l))
            return this.reconsumeCodePoint(e), this.consumeNumericToken();
          if (Bd(o, A, l))
            return this.reconsumeCodePoint(e), this.consumeIdentLikeToken();
          if (A === Xi && l === CK)
            return this.consumeCodePoint(), this.consumeCodePoint(), f$;
          break;
        case xf:
          if (C0(e, this.peekCodePoint(0), this.peekCodePoint(1)))
            return this.reconsumeCodePoint(e), this.consumeNumericToken();
          break;
        case hC:
          if (this.peekCodePoint(0) === B0)
            for (this.consumeCodePoint(); ; ) {
              var u = this.consumeCodePoint();
              if (u === B0 && (u = this.consumeCodePoint(), u === hC))
                return this.consumeToken();
              if (u === ba)
                return this.consumeToken();
            }
          break;
        case UK:
          return h$;
        case NK:
          return d$;
        case BK:
          if (this.peekCodePoint(0) === wK && this.peekCodePoint(1) === Xi && this.peekCodePoint(2) === Xi)
            return this.consumeCodePoint(), this.consumeCodePoint(), c$;
          break;
        case _K:
          var c = this.peekCodePoint(0), h = this.peekCodePoint(1), f = this.peekCodePoint(2);
          if (Bd(c, h, f)) {
            var a = this.consumeName();
            return { type: 7, value: a };
          }
          break;
        case EK:
          return p$;
        case of:
          if (Do(e, this.peekCodePoint(0)))
            return this.reconsumeCodePoint(e), this.consumeIdentLikeToken();
          break;
        case SK:
          return g$;
        case IK:
          if (this.peekCodePoint(0) === Sc)
            return this.consumeCodePoint(), n$;
          break;
        case FK:
          return o$;
        case TK:
          return A$;
        case jK:
        case $K:
          var d = this.peekCodePoint(0), p = this.peekCodePoint(1);
          return d === VA && (Wl(p) || p === yd) && (this.consumeCodePoint(), this.consumeUnicodeRangeToken()), this.reconsumeCodePoint(e), this.consumeIdentLikeToken();
        case dC:
          if (this.peekCodePoint(0) === Sc)
            return this.consumeCodePoint(), s$;
          if (this.peekCodePoint(0) === dC)
            return this.consumeCodePoint(), i$;
          break;
        case xK:
          if (this.peekCodePoint(0) === Sc)
            return this.consumeCodePoint(), a$;
          break;
        case ba:
          return Rv;
      }
      return wd(e) ? (this.consumeWhiteSpace(), m$) : Ci(e) ? (this.reconsumeCodePoint(e), this.consumeNumericToken()) : Qp(e) ? (this.reconsumeCodePoint(e), this.consumeIdentLikeToken()) : { type: 6, value: dn(e) };
    }, r.prototype.consumeCodePoint = function() {
      var e = this._value.shift();
      return typeof e > "u" ? -1 : e;
    }, r.prototype.reconsumeCodePoint = function(e) {
      this._value.unshift(e);
    }, r.prototype.peekCodePoint = function(e) {
      return e >= this._value.length ? -1 : this._value[e];
    }, r.prototype.consumeUnicodeRangeToken = function() {
      for (var e = [], t = this.consumeCodePoint(); Wl(t) && e.length < 6; )
        e.push(t), t = this.consumeCodePoint();
      for (var n = !1; t === yd && e.length < 6; )
        e.push(t), t = this.consumeCodePoint(), n = !0;
      if (n) {
        var i = parseInt(dn.apply(void 0, e.map(function(A) {
          return A === yd ? EI : A;
        })), 16), s = parseInt(dn.apply(void 0, e.map(function(A) {
          return A === yd ? xI : A;
        })), 16);
        return { type: 30, start: i, end: s };
      }
      var a = parseInt(dn.apply(void 0, e), 16);
      if (this.peekCodePoint(0) === Xi && Wl(this.peekCodePoint(1))) {
        this.consumeCodePoint(), t = this.consumeCodePoint();
        for (var o = []; Wl(t) && o.length < 6; )
          o.push(t), t = this.consumeCodePoint();
        var s = parseInt(dn.apply(void 0, o), 16);
        return { type: 30, start: a, end: s };
      } else
        return { type: 30, start: a, end: a };
    }, r.prototype.consumeIdentLikeToken = function() {
      var e = this.consumeName();
      return e.toLowerCase() === "url" && this.peekCodePoint(0) === bd ? (this.consumeCodePoint(), this.consumeUrlToken()) : this.peekCodePoint(0) === bd ? (this.consumeCodePoint(), { type: 19, value: e }) : { type: 20, value: e };
    }, r.prototype.consumeUrlToken = function() {
      var e = [];
      if (this.consumeWhiteSpace(), this.peekCodePoint(0) === ba)
        return { type: 22, value: "" };
      var t = this.peekCodePoint(0);
      if (t === vd || t === md) {
        var n = this.consumeStringToken(this.consumeCodePoint());
        return n.type === 0 && (this.consumeWhiteSpace(), this.peekCodePoint(0) === ba || this.peekCodePoint(0) === Ic) ? (this.consumeCodePoint(), { type: 22, value: n.value }) : (this.consumeBadUrlRemnants(), Cd);
      }
      for (; ; ) {
        var i = this.consumeCodePoint();
        if (i === ba || i === Ic)
          return { type: 22, value: dn.apply(void 0, e) };
        if (wd(i))
          return this.consumeWhiteSpace(), this.peekCodePoint(0) === ba || this.peekCodePoint(0) === Ic ? (this.consumeCodePoint(), { type: 22, value: dn.apply(void 0, e) }) : (this.consumeBadUrlRemnants(), Cd);
        if (i === md || i === vd || i === bd || JK(i))
          return this.consumeBadUrlRemnants(), Cd;
        if (i === of)
          if (Do(i, this.peekCodePoint(0)))
            e.push(this.consumeEscapedCodePoint());
          else
            return this.consumeBadUrlRemnants(), Cd;
        else
          e.push(i);
      }
    }, r.prototype.consumeWhiteSpace = function() {
      for (; wd(this.peekCodePoint(0)); )
        this.consumeCodePoint();
    }, r.prototype.consumeBadUrlRemnants = function() {
      for (; ; ) {
        var e = this.consumeCodePoint();
        if (e === Ic || e === ba)
          return;
        Do(e, this.peekCodePoint(0)) && this.consumeEscapedCodePoint();
      }
    }, r.prototype.consumeStringSlice = function(e) {
      for (var t = 5e4, n = ""; e > 0; ) {
        var i = Math.min(t, e);
        n += dn.apply(void 0, this._value.splice(0, i)), e -= i;
      }
      return this._value.shift(), n;
    }, r.prototype.consumeStringToken = function(e) {
      var t = "", n = 0;
      do {
        var i = this._value[n];
        if (i === ba || i === void 0 || i === e)
          return t += this.consumeStringSlice(n), { type: 0, value: t };
        if (i === Op)
          return this._value.splice(0, n), u$;
        if (i === of) {
          var s = this._value[n + 1];
          s !== ba && s !== void 0 && (s === Op ? (t += this.consumeStringSlice(n), n = -1, this._value.shift()) : Do(i, s) && (t += this.consumeStringSlice(n), t += dn(this.consumeEscapedCodePoint()), n = -1));
        }
        n++;
      } while (!0);
    }, r.prototype.consumeNumber = function() {
      var e = [], t = Hf, n = this.peekCodePoint(0);
      for ((n === VA || n === Xi) && e.push(this.consumeCodePoint()); Ci(this.peekCodePoint(0)); )
        e.push(this.consumeCodePoint());
      n = this.peekCodePoint(0);
      var i = this.peekCodePoint(1);
      if (n === xf && Ci(i))
        for (e.push(this.consumeCodePoint(), this.consumeCodePoint()), t = fC; Ci(this.peekCodePoint(0)); )
          e.push(this.consumeCodePoint());
      n = this.peekCodePoint(0), i = this.peekCodePoint(1);
      var s = this.peekCodePoint(2);
      if ((n === TI || n === II) && ((i === VA || i === Xi) && Ci(s) || Ci(i)))
        for (e.push(this.consumeCodePoint(), this.consumeCodePoint()), t = fC; Ci(this.peekCodePoint(0)); )
          e.push(this.consumeCodePoint());
      return [YK(e), t];
    }, r.prototype.consumeNumericToken = function() {
      var e = this.consumeNumber(), t = e[0], n = e[1], i = this.peekCodePoint(0), s = this.peekCodePoint(1), a = this.peekCodePoint(2);
      if (Bd(i, s, a)) {
        var o = this.consumeName();
        return { type: 15, number: t, flags: n, unit: o };
      }
      return i === bK ? (this.consumeCodePoint(), { type: 16, number: t, flags: n }) : { type: 17, number: t, flags: n };
    }, r.prototype.consumeEscapedCodePoint = function() {
      var e = this.consumeCodePoint();
      if (Wl(e)) {
        for (var t = dn(e); Wl(this.peekCodePoint(0)) && t.length < 6; )
          t += dn(this.consumeCodePoint());
        wd(this.peekCodePoint(0)) && this.consumeCodePoint();
        var n = parseInt(t, 16);
        return n === 0 || zK(n) || n > 1114111 ? pC : n;
      }
      return e === ba ? pC : e;
    }, r.prototype.consumeName = function() {
      for (var e = ""; ; ) {
        var t = this.consumeCodePoint();
        if (gC(t))
          e += dn(t);
        else if (Do(t, this.peekCodePoint(0)))
          e += dn(this.consumeEscapedCodePoint());
        else
          return this.reconsumeCodePoint(t), e;
      }
    }, r;
  }()
), LI = (
  /** @class */
  function() {
    function r(e) {
      this._tokens = e;
    }
    return r.create = function(e) {
      var t = new kI();
      return t.write(e), new r(t.read());
    }, r.parseValue = function(e) {
      return r.create(e).parseComponentValue();
    }, r.parseValues = function(e) {
      return r.create(e).parseComponentValues();
    }, r.prototype.parseComponentValue = function() {
      for (var e = this.consumeToken(); e.type === 31; )
        e = this.consumeToken();
      if (e.type === 32)
        throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
      this.reconsumeToken(e);
      var t = this.consumeComponentValue();
      do
        e = this.consumeToken();
      while (e.type === 31);
      if (e.type === 32)
        return t;
      throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
    }, r.prototype.parseComponentValues = function() {
      for (var e = []; ; ) {
        var t = this.consumeComponentValue();
        if (t.type === 32)
          return e;
        e.push(t), e.push();
      }
    }, r.prototype.consumeComponentValue = function() {
      var e = this.consumeToken();
      switch (e.type) {
        case 11:
        case 28:
        case 2:
          return this.consumeSimpleBlock(e.type);
        case 19:
          return this.consumeFunction(e);
      }
      return e;
    }, r.prototype.consumeSimpleBlock = function(e) {
      for (var t = { type: e, values: [] }, n = this.consumeToken(); ; ) {
        if (n.type === 32 || b$(n, e))
          return t;
        this.reconsumeToken(n), t.values.push(this.consumeComponentValue()), n = this.consumeToken();
      }
    }, r.prototype.consumeFunction = function(e) {
      for (var t = {
        name: e.value,
        values: [],
        type: 18
        /* FUNCTION */
      }; ; ) {
        var n = this.consumeToken();
        if (n.type === 32 || n.type === 3)
          return t;
        this.reconsumeToken(n), t.values.push(this.consumeComponentValue());
      }
    }, r.prototype.consumeToken = function() {
      var e = this._tokens.shift();
      return typeof e > "u" ? Rv : e;
    }, r.prototype.reconsumeToken = function(e) {
      this._tokens.unshift(e);
    }, r;
  }()
), jf = function(r) {
  return r.type === 15;
}, Pu = function(r) {
  return r.type === 17;
}, Tr = function(r) {
  return r.type === 20;
}, v$ = function(r) {
  return r.type === 0;
}, Pv = function(r, e) {
  return Tr(r) && r.value === e;
}, UI = function(r) {
  return r.type !== 31;
}, Nu = function(r) {
  return r.type !== 31 && r.type !== 4;
}, Qa = function(r) {
  var e = [], t = [];
  return r.forEach(function(n) {
    if (n.type === 4) {
      if (t.length === 0)
        throw new Error("Error parsing function args, zero tokens for arg");
      e.push(t), t = [];
      return;
    }
    n.type !== 31 && t.push(n);
  }), t.length && e.push(t), e;
}, b$ = function(r, e) {
  return e === 11 && r.type === 12 || e === 28 && r.type === 29 ? !0 : e === 2 && r.type === 3;
}, oA = function(r) {
  return r.type === 17 || r.type === 15;
}, Ln = function(r) {
  return r.type === 16 || oA(r);
}, NI = function(r) {
  return r.length > 1 ? [r[0], r[1]] : [r[0]];
}, Ai = {
  type: 17,
  number: 0,
  flags: Hf
}, bb = {
  type: 16,
  number: 50,
  flags: Hf
}, qo = {
  type: 16,
  number: 100,
  flags: Hf
}, jc = function(r, e, t) {
  var n = r[0], i = r[1];
  return [Hr(n, e), Hr(typeof i < "u" ? i : n, t)];
}, Hr = function(r, e) {
  if (r.type === 16)
    return r.number / 100 * e;
  if (jf(r))
    switch (r.unit) {
      case "rem":
      case "em":
        return 16 * r.number;
      case "px":
      default:
        return r.number;
    }
  return r.number;
}, OI = "deg", QI = "grad", DI = "rad", MI = "turn", Eg = {
  name: "angle",
  parse: function(r, e) {
    if (e.type === 15)
      switch (e.unit) {
        case OI:
          return Math.PI * e.number / 180;
        case QI:
          return Math.PI / 200 * e.number;
        case DI:
          return e.number;
        case MI:
          return Math.PI * 2 * e.number;
      }
    throw new Error("Unsupported angle type");
  }
}, RI = function(r) {
  return r.type === 15 && (r.unit === OI || r.unit === QI || r.unit === DI || r.unit === MI);
}, PI = function(r) {
  var e = r.filter(Tr).map(function(t) {
    return t.value;
  }).join(" ");
  switch (e) {
    case "to bottom right":
    case "to right bottom":
    case "left top":
    case "top left":
      return [Ai, Ai];
    case "to top":
    case "bottom":
      return ks(0);
    case "to bottom left":
    case "to left bottom":
    case "right top":
    case "top right":
      return [Ai, qo];
    case "to right":
    case "left":
      return ks(90);
    case "to top left":
    case "to left top":
    case "right bottom":
    case "bottom right":
      return [qo, qo];
    case "to bottom":
    case "top":
      return ks(180);
    case "to top right":
    case "to right top":
    case "left bottom":
    case "bottom left":
      return [qo, Ai];
    case "to left":
    case "right":
      return ks(270);
  }
  return 0;
}, ks = function(r) {
  return Math.PI * r / 180;
}, rA = {
  name: "color",
  parse: function(r, e) {
    if (e.type === 18) {
      var t = y$[e.name];
      if (typeof t > "u")
        throw new Error('Attempting to parse an unsupported color function "' + e.name + '"');
      return t(r, e.values);
    }
    if (e.type === 5) {
      if (e.value.length === 3) {
        var n = e.value.substring(0, 1), i = e.value.substring(1, 2), s = e.value.substring(2, 3);
        return Wo(parseInt(n + n, 16), parseInt(i + i, 16), parseInt(s + s, 16), 1);
      }
      if (e.value.length === 4) {
        var n = e.value.substring(0, 1), i = e.value.substring(1, 2), s = e.value.substring(2, 3), a = e.value.substring(3, 4);
        return Wo(parseInt(n + n, 16), parseInt(i + i, 16), parseInt(s + s, 16), parseInt(a + a, 16) / 255);
      }
      if (e.value.length === 6) {
        var n = e.value.substring(0, 2), i = e.value.substring(2, 4), s = e.value.substring(4, 6);
        return Wo(parseInt(n, 16), parseInt(i, 16), parseInt(s, 16), 1);
      }
      if (e.value.length === 8) {
        var n = e.value.substring(0, 2), i = e.value.substring(2, 4), s = e.value.substring(4, 6), a = e.value.substring(6, 8);
        return Wo(parseInt(n, 16), parseInt(i, 16), parseInt(s, 16), parseInt(a, 16) / 255);
      }
    }
    if (e.type === 20) {
      var o = ao[e.value.toUpperCase()];
      if (typeof o < "u")
        return o;
    }
    return ao.TRANSPARENT;
  }
}, nA = function(r) {
  return (255 & r) === 0;
}, $n = function(r) {
  var e = 255 & r, t = 255 & r >> 8, n = 255 & r >> 16, i = 255 & r >> 24;
  return e < 255 ? "rgba(" + i + "," + n + "," + t + "," + e / 255 + ")" : "rgb(" + i + "," + n + "," + t + ")";
}, Wo = function(r, e, t, n) {
  return (r << 24 | e << 16 | t << 8 | Math.round(n * 255) << 0) >>> 0;
}, mC = function(r, e) {
  if (r.type === 17)
    return r.number;
  if (r.type === 16) {
    var t = e === 3 ? 1 : 255;
    return e === 3 ? r.number / 100 * t : Math.round(r.number / 100 * t);
  }
  return 0;
}, vC = function(r, e) {
  var t = e.filter(Nu);
  if (t.length === 3) {
    var n = t.map(mC), i = n[0], s = n[1], a = n[2];
    return Wo(i, s, a, 1);
  }
  if (t.length === 4) {
    var o = t.map(mC), i = o[0], s = o[1], a = o[2], A = o[3];
    return Wo(i, s, a, A);
  }
  return 0;
};
function _0(r, e, t) {
  return t < 0 && (t += 1), t >= 1 && (t -= 1), t < 1 / 6 ? (e - r) * t * 6 + r : t < 1 / 2 ? e : t < 2 / 3 ? (e - r) * 6 * (2 / 3 - t) + r : r;
}
var bC = function(r, e) {
  var t = e.filter(Nu), n = t[0], i = t[1], s = t[2], a = t[3], o = (n.type === 17 ? ks(n.number) : Eg.parse(r, n)) / (Math.PI * 2), A = Ln(i) ? i.number / 100 : 0, l = Ln(s) ? s.number / 100 : 0, u = typeof a < "u" && Ln(a) ? Hr(a, 1) : 1;
  if (A === 0)
    return Wo(l * 255, l * 255, l * 255, 1);
  var c = l <= 0.5 ? l * (A + 1) : l + A - l * A, h = l * 2 - c, f = _0(h, c, o + 1 / 3), d = _0(h, c, o), p = _0(h, c, o - 1 / 3);
  return Wo(f * 255, d * 255, p * 255, u);
}, y$ = {
  hsl: bC,
  hsla: bC,
  rgb: vC,
  rgba: vC
}, Af = function(r, e) {
  return rA.parse(r, LI.create(e).parseComponentValue());
}, ao = {
  ALICEBLUE: 4042850303,
  ANTIQUEWHITE: 4209760255,
  AQUA: 16777215,
  AQUAMARINE: 2147472639,
  AZURE: 4043309055,
  BEIGE: 4126530815,
  BISQUE: 4293182719,
  BLACK: 255,
  BLANCHEDALMOND: 4293643775,
  BLUE: 65535,
  BLUEVIOLET: 2318131967,
  BROWN: 2771004159,
  BURLYWOOD: 3736635391,
  CADETBLUE: 1604231423,
  CHARTREUSE: 2147418367,
  CHOCOLATE: 3530104575,
  CORAL: 4286533887,
  CORNFLOWERBLUE: 1687547391,
  CORNSILK: 4294499583,
  CRIMSON: 3692313855,
  CYAN: 16777215,
  DARKBLUE: 35839,
  DARKCYAN: 9145343,
  DARKGOLDENROD: 3095837695,
  DARKGRAY: 2846468607,
  DARKGREEN: 6553855,
  DARKGREY: 2846468607,
  DARKKHAKI: 3182914559,
  DARKMAGENTA: 2332068863,
  DARKOLIVEGREEN: 1433087999,
  DARKORANGE: 4287365375,
  DARKORCHID: 2570243327,
  DARKRED: 2332033279,
  DARKSALMON: 3918953215,
  DARKSEAGREEN: 2411499519,
  DARKSLATEBLUE: 1211993087,
  DARKSLATEGRAY: 793726975,
  DARKSLATEGREY: 793726975,
  DARKTURQUOISE: 13554175,
  DARKVIOLET: 2483082239,
  DEEPPINK: 4279538687,
  DEEPSKYBLUE: 12582911,
  DIMGRAY: 1768516095,
  DIMGREY: 1768516095,
  DODGERBLUE: 512819199,
  FIREBRICK: 2988581631,
  FLORALWHITE: 4294635775,
  FORESTGREEN: 579543807,
  FUCHSIA: 4278255615,
  GAINSBORO: 3705462015,
  GHOSTWHITE: 4177068031,
  GOLD: 4292280575,
  GOLDENROD: 3668254975,
  GRAY: 2155905279,
  GREEN: 8388863,
  GREENYELLOW: 2919182335,
  GREY: 2155905279,
  HONEYDEW: 4043305215,
  HOTPINK: 4285117695,
  INDIANRED: 3445382399,
  INDIGO: 1258324735,
  IVORY: 4294963455,
  KHAKI: 4041641215,
  LAVENDER: 3873897215,
  LAVENDERBLUSH: 4293981695,
  LAWNGREEN: 2096890111,
  LEMONCHIFFON: 4294626815,
  LIGHTBLUE: 2916673279,
  LIGHTCORAL: 4034953471,
  LIGHTCYAN: 3774873599,
  LIGHTGOLDENRODYELLOW: 4210742015,
  LIGHTGRAY: 3553874943,
  LIGHTGREEN: 2431553791,
  LIGHTGREY: 3553874943,
  LIGHTPINK: 4290167295,
  LIGHTSALMON: 4288707327,
  LIGHTSEAGREEN: 548580095,
  LIGHTSKYBLUE: 2278488831,
  LIGHTSLATEGRAY: 2005441023,
  LIGHTSLATEGREY: 2005441023,
  LIGHTSTEELBLUE: 2965692159,
  LIGHTYELLOW: 4294959359,
  LIME: 16711935,
  LIMEGREEN: 852308735,
  LINEN: 4210091775,
  MAGENTA: 4278255615,
  MAROON: 2147483903,
  MEDIUMAQUAMARINE: 1724754687,
  MEDIUMBLUE: 52735,
  MEDIUMORCHID: 3126187007,
  MEDIUMPURPLE: 2473647103,
  MEDIUMSEAGREEN: 1018393087,
  MEDIUMSLATEBLUE: 2070474495,
  MEDIUMSPRINGGREEN: 16423679,
  MEDIUMTURQUOISE: 1221709055,
  MEDIUMVIOLETRED: 3340076543,
  MIDNIGHTBLUE: 421097727,
  MINTCREAM: 4127193855,
  MISTYROSE: 4293190143,
  MOCCASIN: 4293178879,
  NAVAJOWHITE: 4292783615,
  NAVY: 33023,
  OLDLACE: 4260751103,
  OLIVE: 2155872511,
  OLIVEDRAB: 1804477439,
  ORANGE: 4289003775,
  ORANGERED: 4282712319,
  ORCHID: 3664828159,
  PALEGOLDENROD: 4008225535,
  PALEGREEN: 2566625535,
  PALETURQUOISE: 2951671551,
  PALEVIOLETRED: 3681588223,
  PAPAYAWHIP: 4293907967,
  PEACHPUFF: 4292524543,
  PERU: 3448061951,
  PINK: 4290825215,
  PLUM: 3718307327,
  POWDERBLUE: 2967529215,
  PURPLE: 2147516671,
  REBECCAPURPLE: 1714657791,
  RED: 4278190335,
  ROSYBROWN: 3163525119,
  ROYALBLUE: 1097458175,
  SADDLEBROWN: 2336560127,
  SALMON: 4202722047,
  SANDYBROWN: 4104413439,
  SEAGREEN: 780883967,
  SEASHELL: 4294307583,
  SIENNA: 2689740287,
  SILVER: 3233857791,
  SKYBLUE: 2278484991,
  SLATEBLUE: 1784335871,
  SLATEGRAY: 1887473919,
  SLATEGREY: 1887473919,
  SNOW: 4294638335,
  SPRINGGREEN: 16744447,
  STEELBLUE: 1182971135,
  TAN: 3535047935,
  TEAL: 8421631,
  THISTLE: 3636451583,
  TOMATO: 4284696575,
  TRANSPARENT: 0,
  TURQUOISE: 1088475391,
  VIOLET: 4001558271,
  WHEAT: 4125012991,
  WHITE: 4294967295,
  WHITESMOKE: 4126537215,
  YELLOW: 4294902015,
  YELLOWGREEN: 2597139199
}, w$ = {
  name: "background-clip",
  initialValue: "border-box",
  prefix: !1,
  type: 1,
  parse: function(r, e) {
    return e.map(function(t) {
      if (Tr(t))
        switch (t.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      return 0;
    });
  }
}, B$ = {
  name: "background-color",
  initialValue: "transparent",
  prefix: !1,
  type: 3,
  format: "color"
}, Sg = function(r, e) {
  var t = rA.parse(r, e[0]), n = e[1];
  return n && Ln(n) ? { color: t, stop: n } : { color: t, stop: null };
}, yC = function(r, e) {
  var t = r[0], n = r[r.length - 1];
  t.stop === null && (t.stop = Ai), n.stop === null && (n.stop = qo);
  for (var i = [], s = 0, a = 0; a < r.length; a++) {
    var o = r[a].stop;
    if (o !== null) {
      var A = Hr(o, e);
      A > s ? i.push(A) : i.push(s), s = A;
    } else
      i.push(null);
  }
  for (var l = null, a = 0; a < i.length; a++) {
    var u = i[a];
    if (u === null)
      l === null && (l = a);
    else if (l !== null) {
      for (var c = a - l, h = i[l - 1], f = (u - h) / (c + 1), d = 1; d <= c; d++)
        i[l + d - 1] = f * d;
      l = null;
    }
  }
  return r.map(function(p, v) {
    var m = p.color;
    return { color: m, stop: Math.max(Math.min(1, i[v] / e), 0) };
  });
}, C$ = function(r, e, t) {
  var n = e / 2, i = t / 2, s = Hr(r[0], e) - n, a = i - Hr(r[1], t);
  return (Math.atan2(a, s) + Math.PI * 2) % (Math.PI * 2);
}, _$ = function(r, e, t) {
  var n = typeof r == "number" ? r : C$(r, e, t), i = Math.abs(e * Math.sin(n)) + Math.abs(t * Math.cos(n)), s = e / 2, a = t / 2, o = i / 2, A = Math.sin(n - Math.PI / 2) * o, l = Math.cos(n - Math.PI / 2) * o;
  return [i, s - l, s + l, a - A, a + A];
}, Js = function(r, e) {
  return Math.sqrt(r * r + e * e);
}, wC = function(r, e, t, n, i) {
  var s = [
    [0, 0],
    [0, e],
    [r, 0],
    [r, e]
  ];
  return s.reduce(function(a, o) {
    var A = o[0], l = o[1], u = Js(t - A, n - l);
    return (i ? u < a.optimumDistance : u > a.optimumDistance) ? {
      optimumCorner: o,
      optimumDistance: u
    } : a;
  }, {
    optimumDistance: i ? 1 / 0 : -1 / 0,
    optimumCorner: null
  }).optimumCorner;
}, E$ = function(r, e, t, n, i) {
  var s = 0, a = 0;
  switch (r.size) {
    case 0:
      r.shape === 0 ? s = a = Math.min(Math.abs(e), Math.abs(e - n), Math.abs(t), Math.abs(t - i)) : r.shape === 1 && (s = Math.min(Math.abs(e), Math.abs(e - n)), a = Math.min(Math.abs(t), Math.abs(t - i)));
      break;
    case 2:
      if (r.shape === 0)
        s = a = Math.min(Js(e, t), Js(e, t - i), Js(e - n, t), Js(e - n, t - i));
      else if (r.shape === 1) {
        var o = Math.min(Math.abs(t), Math.abs(t - i)) / Math.min(Math.abs(e), Math.abs(e - n)), A = wC(n, i, e, t, !0), l = A[0], u = A[1];
        s = Js(l - e, (u - t) / o), a = o * s;
      }
      break;
    case 1:
      r.shape === 0 ? s = a = Math.max(Math.abs(e), Math.abs(e - n), Math.abs(t), Math.abs(t - i)) : r.shape === 1 && (s = Math.max(Math.abs(e), Math.abs(e - n)), a = Math.max(Math.abs(t), Math.abs(t - i)));
      break;
    case 3:
      if (r.shape === 0)
        s = a = Math.max(Js(e, t), Js(e, t - i), Js(e - n, t), Js(e - n, t - i));
      else if (r.shape === 1) {
        var o = Math.max(Math.abs(t), Math.abs(t - i)) / Math.max(Math.abs(e), Math.abs(e - n)), c = wC(n, i, e, t, !1), l = c[0], u = c[1];
        s = Js(l - e, (u - t) / o), a = o * s;
      }
      break;
  }
  return Array.isArray(r.size) && (s = Hr(r.size[0], n), a = r.size.length === 2 ? Hr(r.size[1], i) : s), [s, a];
}, S$ = function(r, e) {
  var t = ks(180), n = [];
  return Qa(e).forEach(function(i, s) {
    if (s === 0) {
      var a = i[0];
      if (a.type === 20 && a.value === "to") {
        t = PI(i);
        return;
      } else if (RI(a)) {
        t = Eg.parse(r, a);
        return;
      }
    }
    var o = Sg(r, i);
    n.push(o);
  }), {
    angle: t,
    stops: n,
    type: 1
    /* LINEAR_GRADIENT */
  };
}, _d = function(r, e) {
  var t = ks(180), n = [];
  return Qa(e).forEach(function(i, s) {
    if (s === 0) {
      var a = i[0];
      if (a.type === 20 && ["top", "left", "right", "bottom"].indexOf(a.value) !== -1) {
        t = PI(i);
        return;
      } else if (RI(a)) {
        t = (Eg.parse(r, a) + ks(270)) % ks(360);
        return;
      }
    }
    var o = Sg(r, i);
    n.push(o);
  }), {
    angle: t,
    stops: n,
    type: 1
    /* LINEAR_GRADIENT */
  };
}, I$ = function(r, e) {
  var t = ks(180), n = [], i = 1, s = 0, a = 3, o = [];
  return Qa(e).forEach(function(A, l) {
    var u = A[0];
    if (l === 0) {
      if (Tr(u) && u.value === "linear") {
        i = 1;
        return;
      } else if (Tr(u) && u.value === "radial") {
        i = 2;
        return;
      }
    }
    if (u.type === 18) {
      if (u.name === "from") {
        var c = rA.parse(r, u.values[0]);
        n.push({ stop: Ai, color: c });
      } else if (u.name === "to") {
        var c = rA.parse(r, u.values[0]);
        n.push({ stop: qo, color: c });
      } else if (u.name === "color-stop") {
        var h = u.values.filter(Nu);
        if (h.length === 2) {
          var c = rA.parse(r, h[1]), f = h[0];
          Pu(f) && n.push({
            stop: { type: 16, number: f.number * 100, flags: f.flags },
            color: c
          });
        }
      }
    }
  }), i === 1 ? {
    angle: (t + ks(180)) % ks(360),
    stops: n,
    type: i
  } : { size: a, shape: s, stops: n, position: o, type: i };
}, HI = "closest-side", jI = "farthest-side", KI = "closest-corner", $I = "farthest-corner", VI = "circle", zI = "ellipse", GI = "cover", qI = "contain", F$ = function(r, e) {
  var t = 0, n = 3, i = [], s = [];
  return Qa(e).forEach(function(a, o) {
    var A = !0;
    if (o === 0) {
      var l = !1;
      A = a.reduce(function(c, h) {
        if (l)
          if (Tr(h))
            switch (h.value) {
              case "center":
                return s.push(bb), c;
              case "top":
              case "left":
                return s.push(Ai), c;
              case "right":
              case "bottom":
                return s.push(qo), c;
            }
          else (Ln(h) || oA(h)) && s.push(h);
        else if (Tr(h))
          switch (h.value) {
            case VI:
              return t = 0, !1;
            case zI:
              return t = 1, !1;
            case "at":
              return l = !0, !1;
            case HI:
              return n = 0, !1;
            case GI:
            case jI:
              return n = 1, !1;
            case qI:
            case KI:
              return n = 2, !1;
            case $I:
              return n = 3, !1;
          }
        else if (oA(h) || Ln(h))
          return Array.isArray(n) || (n = []), n.push(h), !1;
        return c;
      }, A);
    }
    if (A) {
      var u = Sg(r, a);
      i.push(u);
    }
  }), {
    size: n,
    shape: t,
    stops: i,
    position: s,
    type: 2
    /* RADIAL_GRADIENT */
  };
}, Ed = function(r, e) {
  var t = 0, n = 3, i = [], s = [];
  return Qa(e).forEach(function(a, o) {
    var A = !0;
    if (o === 0 ? A = a.reduce(function(u, c) {
      if (Tr(c))
        switch (c.value) {
          case "center":
            return s.push(bb), !1;
          case "top":
          case "left":
            return s.push(Ai), !1;
          case "right":
          case "bottom":
            return s.push(qo), !1;
        }
      else if (Ln(c) || oA(c))
        return s.push(c), !1;
      return u;
    }, A) : o === 1 && (A = a.reduce(function(u, c) {
      if (Tr(c))
        switch (c.value) {
          case VI:
            return t = 0, !1;
          case zI:
            return t = 1, !1;
          case qI:
          case HI:
            return n = 0, !1;
          case jI:
            return n = 1, !1;
          case KI:
            return n = 2, !1;
          case GI:
          case $I:
            return n = 3, !1;
        }
      else if (oA(c) || Ln(c))
        return Array.isArray(n) || (n = []), n.push(c), !1;
      return u;
    }, A)), A) {
      var l = Sg(r, a);
      i.push(l);
    }
  }), {
    size: n,
    shape: t,
    stops: i,
    position: s,
    type: 2
    /* RADIAL_GRADIENT */
  };
}, T$ = function(r) {
  return r.type === 1;
}, x$ = function(r) {
  return r.type === 2;
}, yb = {
  name: "image",
  parse: function(r, e) {
    if (e.type === 22) {
      var t = {
        url: e.value,
        type: 0
        /* URL */
      };
      return r.cache.addImage(e.value), t;
    }
    if (e.type === 18) {
      var n = WI[e.name];
      if (typeof n > "u")
        throw new Error('Attempting to parse an unsupported image function "' + e.name + '"');
      return n(r, e.values);
    }
    throw new Error("Unsupported image type " + e.type);
  }
};
function k$(r) {
  return !(r.type === 20 && r.value === "none") && (r.type !== 18 || !!WI[r.name]);
}
var WI = {
  "linear-gradient": S$,
  "-moz-linear-gradient": _d,
  "-ms-linear-gradient": _d,
  "-o-linear-gradient": _d,
  "-webkit-linear-gradient": _d,
  "radial-gradient": F$,
  "-moz-radial-gradient": Ed,
  "-ms-radial-gradient": Ed,
  "-o-radial-gradient": Ed,
  "-webkit-radial-gradient": Ed,
  "-webkit-gradient": I$
}, L$ = {
  name: "background-image",
  initialValue: "none",
  type: 1,
  prefix: !1,
  parse: function(r, e) {
    if (e.length === 0)
      return [];
    var t = e[0];
    return t.type === 20 && t.value === "none" ? [] : e.filter(function(n) {
      return Nu(n) && k$(n);
    }).map(function(n) {
      return yb.parse(r, n);
    });
  }
}, U$ = {
  name: "background-origin",
  initialValue: "border-box",
  prefix: !1,
  type: 1,
  parse: function(r, e) {
    return e.map(function(t) {
      if (Tr(t))
        switch (t.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      return 0;
    });
  }
}, N$ = {
  name: "background-position",
  initialValue: "0% 0%",
  type: 1,
  prefix: !1,
  parse: function(r, e) {
    return Qa(e).map(function(t) {
      return t.filter(Ln);
    }).map(NI);
  }
}, O$ = {
  name: "background-repeat",
  initialValue: "repeat",
  prefix: !1,
  type: 1,
  parse: function(r, e) {
    return Qa(e).map(function(t) {
      return t.filter(Tr).map(function(n) {
        return n.value;
      }).join(" ");
    }).map(Q$);
  }
}, Q$ = function(r) {
  switch (r) {
    case "no-repeat":
      return 1;
    case "repeat-x":
    case "repeat no-repeat":
      return 2;
    case "repeat-y":
    case "no-repeat repeat":
      return 3;
    case "repeat":
    default:
      return 0;
  }
}, _u;
(function(r) {
  r.AUTO = "auto", r.CONTAIN = "contain", r.COVER = "cover";
})(_u || (_u = {}));
var D$ = {
  name: "background-size",
  initialValue: "0",
  prefix: !1,
  type: 1,
  parse: function(r, e) {
    return Qa(e).map(function(t) {
      return t.filter(M$);
    });
  }
}, M$ = function(r) {
  return Tr(r) || Ln(r);
}, Ig = function(r) {
  return {
    name: "border-" + r + "-color",
    initialValue: "transparent",
    prefix: !1,
    type: 3,
    format: "color"
  };
}, R$ = Ig("top"), P$ = Ig("right"), H$ = Ig("bottom"), j$ = Ig("left"), Fg = function(r) {
  return {
    name: "border-radius-" + r,
    initialValue: "0 0",
    prefix: !1,
    type: 1,
    parse: function(e, t) {
      return NI(t.filter(Ln));
    }
  };
}, K$ = Fg("top-left"), $$ = Fg("top-right"), V$ = Fg("bottom-right"), z$ = Fg("bottom-left"), Tg = function(r) {
  return {
    name: "border-" + r + "-style",
    initialValue: "solid",
    prefix: !1,
    type: 2,
    parse: function(e, t) {
      switch (t) {
        case "none":
          return 0;
        case "dashed":
          return 2;
        case "dotted":
          return 3;
        case "double":
          return 4;
      }
      return 1;
    }
  };
}, G$ = Tg("top"), q$ = Tg("right"), W$ = Tg("bottom"), X$ = Tg("left"), xg = function(r) {
  return {
    name: "border-" + r + "-width",
    initialValue: "0",
    type: 0,
    prefix: !1,
    parse: function(e, t) {
      return jf(t) ? t.number : 0;
    }
  };
}, J$ = xg("top"), Y$ = xg("right"), Z$ = xg("bottom"), eV = xg("left"), tV = {
  name: "color",
  initialValue: "transparent",
  prefix: !1,
  type: 3,
  format: "color"
}, rV = {
  name: "direction",
  initialValue: "ltr",
  prefix: !1,
  type: 2,
  parse: function(r, e) {
    switch (e) {
      case "rtl":
        return 1;
      case "ltr":
      default:
        return 0;
    }
  }
}, nV = {
  name: "display",
  initialValue: "inline-block",
  prefix: !1,
  type: 1,
  parse: function(r, e) {
    return e.filter(Tr).reduce(
      function(t, n) {
        return t | iV(n.value);
      },
      0
      /* NONE */
    );
  }
}, iV = function(r) {
  switch (r) {
    case "block":
    case "-webkit-box":
      return 2;
    case "inline":
      return 4;
    case "run-in":
      return 8;
    case "flow":
      return 16;
    case "flow-root":
      return 32;
    case "table":
      return 64;
    case "flex":
    case "-webkit-flex":
      return 128;
    case "grid":
    case "-ms-grid":
      return 256;
    case "ruby":
      return 512;
    case "subgrid":
      return 1024;
    case "list-item":
      return 2048;
    case "table-row-group":
      return 4096;
    case "table-header-group":
      return 8192;
    case "table-footer-group":
      return 16384;
    case "table-row":
      return 32768;
    case "table-cell":
      return 65536;
    case "table-column-group":
      return 131072;
    case "table-column":
      return 262144;
    case "table-caption":
      return 524288;
    case "ruby-base":
      return 1048576;
    case "ruby-text":
      return 2097152;
    case "ruby-base-container":
      return 4194304;
    case "ruby-text-container":
      return 8388608;
    case "contents":
      return 16777216;
    case "inline-block":
      return 33554432;
    case "inline-list-item":
      return 67108864;
    case "inline-table":
      return 134217728;
    case "inline-flex":
      return 268435456;
    case "inline-grid":
      return 536870912;
  }
  return 0;
}, sV = {
  name: "float",
  initialValue: "none",
  prefix: !1,
  type: 2,
  parse: function(r, e) {
    switch (e) {
      case "left":
        return 1;
      case "right":
        return 2;
      case "inline-start":
        return 3;
      case "inline-end":
        return 4;
    }
    return 0;
  }
}, aV = {
  name: "letter-spacing",
  initialValue: "0",
  prefix: !1,
  type: 0,
  parse: function(r, e) {
    return e.type === 20 && e.value === "normal" ? 0 : e.type === 17 || e.type === 15 ? e.number : 0;
  }
}, Dp;
(function(r) {
  r.NORMAL = "normal", r.STRICT = "strict";
})(Dp || (Dp = {}));
var oV = {
  name: "line-break",
  initialValue: "normal",
  prefix: !1,
  type: 2,
  parse: function(r, e) {
    switch (e) {
      case "strict":
        return Dp.STRICT;
      case "normal":
      default:
        return Dp.NORMAL;
    }
  }
}, AV = {
  name: "line-height",
  initialValue: "normal",
  prefix: !1,
  type: 4
  /* TOKEN_VALUE */
}, BC = function(r, e) {
  return Tr(r) && r.value === "normal" ? 1.2 * e : r.type === 17 ? e * r.number : Ln(r) ? Hr(r, e) : e;
}, lV = {
  name: "list-style-image",
  initialValue: "none",
  type: 0,
  prefix: !1,
  parse: function(r, e) {
    return e.type === 20 && e.value === "none" ? null : yb.parse(r, e);
  }
}, uV = {
  name: "list-style-position",
  initialValue: "outside",
  prefix: !1,
  type: 2,
  parse: function(r, e) {
    switch (e) {
      case "inside":
        return 0;
      case "outside":
      default:
        return 1;
    }
  }
}, Hv = {
  name: "list-style-type",
  initialValue: "none",
  prefix: !1,
  type: 2,
  parse: function(r, e) {
    switch (e) {
      case "disc":
        return 0;
      case "circle":
        return 1;
      case "square":
        return 2;
      case "decimal":
        return 3;
      case "cjk-decimal":
        return 4;
      case "decimal-leading-zero":
        return 5;
      case "lower-roman":
        return 6;
      case "upper-roman":
        return 7;
      case "lower-greek":
        return 8;
      case "lower-alpha":
        return 9;
      case "upper-alpha":
        return 10;
      case "arabic-indic":
        return 11;
      case "armenian":
        return 12;
      case "bengali":
        return 13;
      case "cambodian":
        return 14;
      case "cjk-earthly-branch":
        return 15;
      case "cjk-heavenly-stem":
        return 16;
      case "cjk-ideographic":
        return 17;
      case "devanagari":
        return 18;
      case "ethiopic-numeric":
        return 19;
      case "georgian":
        return 20;
      case "gujarati":
        return 21;
      case "gurmukhi":
        return 22;
      case "hebrew":
        return 22;
      case "hiragana":
        return 23;
      case "hiragana-iroha":
        return 24;
      case "japanese-formal":
        return 25;
      case "japanese-informal":
        return 26;
      case "kannada":
        return 27;
      case "katakana":
        return 28;
      case "katakana-iroha":
        return 29;
      case "khmer":
        return 30;
      case "korean-hangul-formal":
        return 31;
      case "korean-hanja-formal":
        return 32;
      case "korean-hanja-informal":
        return 33;
      case "lao":
        return 34;
      case "lower-armenian":
        return 35;
      case "malayalam":
        return 36;
      case "mongolian":
        return 37;
      case "myanmar":
        return 38;
      case "oriya":
        return 39;
      case "persian":
        return 40;
      case "simp-chinese-formal":
        return 41;
      case "simp-chinese-informal":
        return 42;
      case "tamil":
        return 43;
      case "telugu":
        return 44;
      case "thai":
        return 45;
      case "tibetan":
        return 46;
      case "trad-chinese-formal":
        return 47;
      case "trad-chinese-informal":
        return 48;
      case "upper-armenian":
        return 49;
      case "disclosure-open":
        return 50;
      case "disclosure-closed":
        return 51;
      case "none":
      default:
        return -1;
    }
  }
}, kg = function(r) {
  return {
    name: "margin-" + r,
    initialValue: "0",
    prefix: !1,
    type: 4
    /* TOKEN_VALUE */
  };
}, cV = kg("top"), fV = kg("right"), hV = kg("bottom"), dV = kg("left"), pV = {
  name: "overflow",
  initialValue: "visible",
  prefix: !1,
  type: 1,
  parse: function(r, e) {
    return e.filter(Tr).map(function(t) {
      switch (t.value) {
        case "hidden":
          return 1;
        case "scroll":
          return 2;
        case "clip":
          return 3;
        case "auto":
          return 4;
        case "visible":
        default:
          return 0;
      }
    });
  }
}, gV = {
  name: "overflow-wrap",
  initialValue: "normal",
  prefix: !1,
  type: 2,
  parse: function(r, e) {
    switch (e) {
      case "break-word":
        return "break-word";
      case "normal":
      default:
        return "normal";
    }
  }
}, Lg = function(r) {
  return {
    name: "padding-" + r,
    initialValue: "0",
    prefix: !1,
    type: 3,
    format: "length-percentage"
  };
}, mV = Lg("top"), vV = Lg("right"), bV = Lg("bottom"), yV = Lg("left"), wV = {
  name: "text-align",
  initialValue: "left",
  prefix: !1,
  type: 2,
  parse: function(r, e) {
    switch (e) {
      case "right":
        return 2;
      case "center":
      case "justify":
        return 1;
      case "left":
      default:
        return 0;
    }
  }
}, BV = {
  name: "position",
  initialValue: "static",
  prefix: !1,
  type: 2,
  parse: function(r, e) {
    switch (e) {
      case "relative":
        return 1;
      case "absolute":
        return 2;
      case "fixed":
        return 3;
      case "sticky":
        return 4;
    }
    return 0;
  }
}, CV = {
  name: "text-shadow",
  initialValue: "none",
  type: 1,
  prefix: !1,
  parse: function(r, e) {
    return e.length === 1 && Pv(e[0], "none") ? [] : Qa(e).map(function(t) {
      for (var n = {
        color: ao.TRANSPARENT,
        offsetX: Ai,
        offsetY: Ai,
        blur: Ai
      }, i = 0, s = 0; s < t.length; s++) {
        var a = t[s];
        oA(a) ? (i === 0 ? n.offsetX = a : i === 1 ? n.offsetY = a : n.blur = a, i++) : n.color = rA.parse(r, a);
      }
      return n;
    });
  }
}, _V = {
  name: "text-transform",
  initialValue: "none",
  prefix: !1,
  type: 2,
  parse: function(r, e) {
    switch (e) {
      case "uppercase":
        return 2;
      case "lowercase":
        return 1;
      case "capitalize":
        return 3;
    }
    return 0;
  }
}, EV = {
  name: "transform",
  initialValue: "none",
  prefix: !0,
  type: 0,
  parse: function(r, e) {
    if (e.type === 20 && e.value === "none")
      return null;
    if (e.type === 18) {
      var t = FV[e.name];
      if (typeof t > "u")
        throw new Error('Attempting to parse an unsupported transform function "' + e.name + '"');
      return t(e.values);
    }
    return null;
  }
}, SV = function(r) {
  var e = r.filter(function(t) {
    return t.type === 17;
  }).map(function(t) {
    return t.number;
  });
  return e.length === 6 ? e : null;
}, IV = function(r) {
  var e = r.filter(function(A) {
    return A.type === 17;
  }).map(function(A) {
    return A.number;
  }), t = e[0], n = e[1];
  e[2], e[3];
  var i = e[4], s = e[5];
  e[6], e[7], e[8], e[9], e[10], e[11];
  var a = e[12], o = e[13];
  return e[14], e[15], e.length === 16 ? [t, n, i, s, a, o] : null;
}, FV = {
  matrix: SV,
  matrix3d: IV
}, CC = {
  type: 16,
  number: 50,
  flags: Hf
}, TV = [CC, CC], xV = {
  name: "transform-origin",
  initialValue: "50% 50%",
  prefix: !0,
  type: 1,
  parse: function(r, e) {
    var t = e.filter(Ln);
    return t.length !== 2 ? TV : [t[0], t[1]];
  }
}, kV = {
  name: "visible",
  initialValue: "none",
  prefix: !1,
  type: 2,
  parse: function(r, e) {
    switch (e) {
      case "hidden":
        return 1;
      case "collapse":
        return 2;
      case "visible":
      default:
        return 0;
    }
  }
}, lf;
(function(r) {
  r.NORMAL = "normal", r.BREAK_ALL = "break-all", r.KEEP_ALL = "keep-all";
})(lf || (lf = {}));
var LV = {
  name: "word-break",
  initialValue: "normal",
  prefix: !1,
  type: 2,
  parse: function(r, e) {
    switch (e) {
      case "break-all":
        return lf.BREAK_ALL;
      case "keep-all":
        return lf.KEEP_ALL;
      case "normal":
      default:
        return lf.NORMAL;
    }
  }
}, UV = {
  name: "z-index",
  initialValue: "auto",
  prefix: !1,
  type: 0,
  parse: function(r, e) {
    if (e.type === 20)
      return { auto: !0, order: 0 };
    if (Pu(e))
      return { auto: !1, order: e.number };
    throw new Error("Invalid z-index number parsed");
  }
}, XI = {
  name: "time",
  parse: function(r, e) {
    if (e.type === 15)
      switch (e.unit.toLowerCase()) {
        case "s":
          return 1e3 * e.number;
        case "ms":
          return e.number;
      }
    throw new Error("Unsupported time type");
  }
}, NV = {
  name: "opacity",
  initialValue: "1",
  type: 0,
  prefix: !1,
  parse: function(r, e) {
    return Pu(e) ? e.number : 1;
  }
}, OV = {
  name: "text-decoration-color",
  initialValue: "transparent",
  prefix: !1,
  type: 3,
  format: "color"
}, QV = {
  name: "text-decoration-line",
  initialValue: "none",
  prefix: !1,
  type: 1,
  parse: function(r, e) {
    return e.filter(Tr).map(function(t) {
      switch (t.value) {
        case "underline":
          return 1;
        case "overline":
          return 2;
        case "line-through":
          return 3;
        case "none":
          return 4;
      }
      return 0;
    }).filter(function(t) {
      return t !== 0;
    });
  }
}, DV = {
  name: "font-family",
  initialValue: "",
  prefix: !1,
  type: 1,
  parse: function(r, e) {
    var t = [], n = [];
    return e.forEach(function(i) {
      switch (i.type) {
        case 20:
        case 0:
          t.push(i.value);
          break;
        case 17:
          t.push(i.number.toString());
          break;
        case 4:
          n.push(t.join(" ")), t.length = 0;
          break;
      }
    }), t.length && n.push(t.join(" ")), n.map(function(i) {
      return i.indexOf(" ") === -1 ? i : "'" + i + "'";
    });
  }
}, MV = {
  name: "font-size",
  initialValue: "0",
  prefix: !1,
  type: 3,
  format: "length"
}, RV = {
  name: "font-weight",
  initialValue: "normal",
  type: 0,
  prefix: !1,
  parse: function(r, e) {
    if (Pu(e))
      return e.number;
    if (Tr(e))
      switch (e.value) {
        case "bold":
          return 700;
        case "normal":
        default:
          return 400;
      }
    return 400;
  }
}, PV = {
  name: "font-variant",
  initialValue: "none",
  type: 1,
  prefix: !1,
  parse: function(r, e) {
    return e.filter(Tr).map(function(t) {
      return t.value;
    });
  }
}, HV = {
  name: "font-style",
  initialValue: "normal",
  prefix: !1,
  type: 2,
  parse: function(r, e) {
    switch (e) {
      case "oblique":
        return "oblique";
      case "italic":
        return "italic";
      case "normal":
      default:
        return "normal";
    }
  }
}, Rn = function(r, e) {
  return (r & e) !== 0;
}, jV = {
  name: "content",
  initialValue: "none",
  type: 1,
  prefix: !1,
  parse: function(r, e) {
    if (e.length === 0)
      return [];
    var t = e[0];
    return t.type === 20 && t.value === "none" ? [] : e;
  }
}, KV = {
  name: "counter-increment",
  initialValue: "none",
  prefix: !0,
  type: 1,
  parse: function(r, e) {
    if (e.length === 0)
      return null;
    var t = e[0];
    if (t.type === 20 && t.value === "none")
      return null;
    for (var n = [], i = e.filter(UI), s = 0; s < i.length; s++) {
      var a = i[s], o = i[s + 1];
      if (a.type === 20) {
        var A = o && Pu(o) ? o.number : 1;
        n.push({ counter: a.value, increment: A });
      }
    }
    return n;
  }
}, $V = {
  name: "counter-reset",
  initialValue: "none",
  prefix: !0,
  type: 1,
  parse: function(r, e) {
    if (e.length === 0)
      return [];
    for (var t = [], n = e.filter(UI), i = 0; i < n.length; i++) {
      var s = n[i], a = n[i + 1];
      if (Tr(s) && s.value !== "none") {
        var o = a && Pu(a) ? a.number : 0;
        t.push({ counter: s.value, reset: o });
      }
    }
    return t;
  }
}, VV = {
  name: "duration",
  initialValue: "0s",
  prefix: !1,
  type: 1,
  parse: function(r, e) {
    return e.filter(jf).map(function(t) {
      return XI.parse(r, t);
    });
  }
}, zV = {
  name: "quotes",
  initialValue: "none",
  prefix: !0,
  type: 1,
  parse: function(r, e) {
    if (e.length === 0)
      return null;
    var t = e[0];
    if (t.type === 20 && t.value === "none")
      return null;
    var n = [], i = e.filter(v$);
    if (i.length % 2 !== 0)
      return null;
    for (var s = 0; s < i.length; s += 2) {
      var a = i[s].value, o = i[s + 1].value;
      n.push({ open: a, close: o });
    }
    return n;
  }
}, _C = function(r, e, t) {
  if (!r)
    return "";
  var n = r[Math.min(e, r.length - 1)];
  return n ? t ? n.open : n.close : "";
}, GV = {
  name: "box-shadow",
  initialValue: "none",
  type: 1,
  prefix: !1,
  parse: function(r, e) {
    return e.length === 1 && Pv(e[0], "none") ? [] : Qa(e).map(function(t) {
      for (var n = {
        color: 255,
        offsetX: Ai,
        offsetY: Ai,
        blur: Ai,
        spread: Ai,
        inset: !1
      }, i = 0, s = 0; s < t.length; s++) {
        var a = t[s];
        Pv(a, "inset") ? n.inset = !0 : oA(a) ? (i === 0 ? n.offsetX = a : i === 1 ? n.offsetY = a : i === 2 ? n.blur = a : n.spread = a, i++) : n.color = rA.parse(r, a);
      }
      return n;
    });
  }
}, qV = {
  name: "paint-order",
  initialValue: "normal",
  prefix: !1,
  type: 1,
  parse: function(r, e) {
    var t = [
      0,
      1,
      2
      /* MARKERS */
    ], n = [];
    return e.filter(Tr).forEach(function(i) {
      switch (i.value) {
        case "stroke":
          n.push(
            1
            /* STROKE */
          );
          break;
        case "fill":
          n.push(
            0
            /* FILL */
          );
          break;
        case "markers":
          n.push(
            2
            /* MARKERS */
          );
          break;
      }
    }), t.forEach(function(i) {
      n.indexOf(i) === -1 && n.push(i);
    }), n;
  }
}, WV = {
  name: "-webkit-text-stroke-color",
  initialValue: "currentcolor",
  prefix: !1,
  type: 3,
  format: "color"
}, XV = {
  name: "-webkit-text-stroke-width",
  initialValue: "0",
  type: 0,
  prefix: !1,
  parse: function(r, e) {
    return jf(e) ? e.number : 0;
  }
}, JV = (
  /** @class */
  function() {
    function r(e, t) {
      var n, i;
      this.animationDuration = ft(e, VV, t.animationDuration), this.backgroundClip = ft(e, w$, t.backgroundClip), this.backgroundColor = ft(e, B$, t.backgroundColor), this.backgroundImage = ft(e, L$, t.backgroundImage), this.backgroundOrigin = ft(e, U$, t.backgroundOrigin), this.backgroundPosition = ft(e, N$, t.backgroundPosition), this.backgroundRepeat = ft(e, O$, t.backgroundRepeat), this.backgroundSize = ft(e, D$, t.backgroundSize), this.borderTopColor = ft(e, R$, t.borderTopColor), this.borderRightColor = ft(e, P$, t.borderRightColor), this.borderBottomColor = ft(e, H$, t.borderBottomColor), this.borderLeftColor = ft(e, j$, t.borderLeftColor), this.borderTopLeftRadius = ft(e, K$, t.borderTopLeftRadius), this.borderTopRightRadius = ft(e, $$, t.borderTopRightRadius), this.borderBottomRightRadius = ft(e, V$, t.borderBottomRightRadius), this.borderBottomLeftRadius = ft(e, z$, t.borderBottomLeftRadius), this.borderTopStyle = ft(e, G$, t.borderTopStyle), this.borderRightStyle = ft(e, q$, t.borderRightStyle), this.borderBottomStyle = ft(e, W$, t.borderBottomStyle), this.borderLeftStyle = ft(e, X$, t.borderLeftStyle), this.borderTopWidth = ft(e, J$, t.borderTopWidth), this.borderRightWidth = ft(e, Y$, t.borderRightWidth), this.borderBottomWidth = ft(e, Z$, t.borderBottomWidth), this.borderLeftWidth = ft(e, eV, t.borderLeftWidth), this.boxShadow = ft(e, GV, t.boxShadow), this.color = ft(e, tV, t.color), this.direction = ft(e, rV, t.direction), this.display = ft(e, nV, t.display), this.float = ft(e, sV, t.cssFloat), this.fontFamily = ft(e, DV, t.fontFamily), this.fontSize = ft(e, MV, t.fontSize), this.fontStyle = ft(e, HV, t.fontStyle), this.fontVariant = ft(e, PV, t.fontVariant), this.fontWeight = ft(e, RV, t.fontWeight), this.letterSpacing = ft(e, aV, t.letterSpacing), this.lineBreak = ft(e, oV, t.lineBreak), this.lineHeight = ft(e, AV, t.lineHeight), this.listStyleImage = ft(e, lV, t.listStyleImage), this.listStylePosition = ft(e, uV, t.listStylePosition), this.listStyleType = ft(e, Hv, t.listStyleType), this.marginTop = ft(e, cV, t.marginTop), this.marginRight = ft(e, fV, t.marginRight), this.marginBottom = ft(e, hV, t.marginBottom), this.marginLeft = ft(e, dV, t.marginLeft), this.opacity = ft(e, NV, t.opacity);
      var s = ft(e, pV, t.overflow);
      this.overflowX = s[0], this.overflowY = s[s.length > 1 ? 1 : 0], this.overflowWrap = ft(e, gV, t.overflowWrap), this.paddingTop = ft(e, mV, t.paddingTop), this.paddingRight = ft(e, vV, t.paddingRight), this.paddingBottom = ft(e, bV, t.paddingBottom), this.paddingLeft = ft(e, yV, t.paddingLeft), this.paintOrder = ft(e, qV, t.paintOrder), this.position = ft(e, BV, t.position), this.textAlign = ft(e, wV, t.textAlign), this.textDecorationColor = ft(e, OV, (n = t.textDecorationColor) !== null && n !== void 0 ? n : t.color), this.textDecorationLine = ft(e, QV, (i = t.textDecorationLine) !== null && i !== void 0 ? i : t.textDecoration), this.textShadow = ft(e, CV, t.textShadow), this.textTransform = ft(e, _V, t.textTransform), this.transform = ft(e, EV, t.transform), this.transformOrigin = ft(e, xV, t.transformOrigin), this.visibility = ft(e, kV, t.visibility), this.webkitTextStrokeColor = ft(e, WV, t.webkitTextStrokeColor), this.webkitTextStrokeWidth = ft(e, XV, t.webkitTextStrokeWidth), this.wordBreak = ft(e, LV, t.wordBreak), this.zIndex = ft(e, UV, t.zIndex);
    }
    return r.prototype.isVisible = function() {
      return this.display > 0 && this.opacity > 0 && this.visibility === 0;
    }, r.prototype.isTransparent = function() {
      return nA(this.backgroundColor);
    }, r.prototype.isTransformed = function() {
      return this.transform !== null;
    }, r.prototype.isPositioned = function() {
      return this.position !== 0;
    }, r.prototype.isPositionedWithZIndex = function() {
      return this.isPositioned() && !this.zIndex.auto;
    }, r.prototype.isFloating = function() {
      return this.float !== 0;
    }, r.prototype.isInlineLevel = function() {
      return Rn(
        this.display,
        4
        /* INLINE */
      ) || Rn(
        this.display,
        33554432
        /* INLINE_BLOCK */
      ) || Rn(
        this.display,
        268435456
        /* INLINE_FLEX */
      ) || Rn(
        this.display,
        536870912
        /* INLINE_GRID */
      ) || Rn(
        this.display,
        67108864
        /* INLINE_LIST_ITEM */
      ) || Rn(
        this.display,
        134217728
        /* INLINE_TABLE */
      );
    }, r;
  }()
), YV = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e, t) {
      this.content = ft(e, jV, t.content), this.quotes = ft(e, zV, t.quotes);
    }
    return r;
  }()
), EC = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e, t) {
      this.counterIncrement = ft(e, KV, t.counterIncrement), this.counterReset = ft(e, $V, t.counterReset);
    }
    return r;
  }()
), ft = function(r, e, t) {
  var n = new kI(), i = t !== null && typeof t < "u" ? t.toString() : e.initialValue;
  n.write(i);
  var s = new LI(n.read());
  switch (e.type) {
    case 2:
      var a = s.parseComponentValue();
      return e.parse(r, Tr(a) ? a.value : e.initialValue);
    case 0:
      return e.parse(r, s.parseComponentValue());
    case 1:
      return e.parse(r, s.parseComponentValues());
    case 4:
      return s.parseComponentValue();
    case 3:
      switch (e.format) {
        case "angle":
          return Eg.parse(r, s.parseComponentValue());
        case "color":
          return rA.parse(r, s.parseComponentValue());
        case "image":
          return yb.parse(r, s.parseComponentValue());
        case "length":
          var o = s.parseComponentValue();
          return oA(o) ? o : Ai;
        case "length-percentage":
          var A = s.parseComponentValue();
          return Ln(A) ? A : Ai;
        case "time":
          return XI.parse(r, s.parseComponentValue());
      }
      break;
  }
}, ZV = "data-html2canvas-debug", ez = function(r) {
  var e = r.getAttribute(ZV);
  switch (e) {
    case "all":
      return 1;
    case "clone":
      return 2;
    case "parse":
      return 3;
    case "render":
      return 4;
    default:
      return 0;
  }
}, jv = function(r, e) {
  var t = ez(r);
  return t === 1 || e === t;
}, Da = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e, t) {
      if (this.context = e, this.textNodes = [], this.elements = [], this.flags = 0, jv(
        t,
        3
        /* PARSE */
      ))
        debugger;
      this.styles = new JV(e, window.getComputedStyle(t, null)), Vv(t) && (this.styles.animationDuration.some(function(n) {
        return n > 0;
      }) && (t.style.animationDuration = "0s"), this.styles.transform !== null && (t.style.transform = "none")), this.bounds = Cg(this.context, t), jv(
        t,
        4
        /* RENDER */
      ) && (this.flags |= 16);
    }
    return r;
  }()
), tz = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=", SC = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Kc = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var Sd = 0; Sd < SC.length; Sd++)
  Kc[SC.charCodeAt(Sd)] = Sd;
var rz = function(r) {
  var e = r.length * 0.75, t = r.length, n, i = 0, s, a, o, A;
  r[r.length - 1] === "=" && (e--, r[r.length - 2] === "=" && e--);
  var l = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && typeof Uint8Array.prototype.slice < "u" ? new ArrayBuffer(e) : new Array(e), u = Array.isArray(l) ? l : new Uint8Array(l);
  for (n = 0; n < t; n += 4)
    s = Kc[r.charCodeAt(n)], a = Kc[r.charCodeAt(n + 1)], o = Kc[r.charCodeAt(n + 2)], A = Kc[r.charCodeAt(n + 3)], u[i++] = s << 2 | a >> 4, u[i++] = (a & 15) << 4 | o >> 2, u[i++] = (o & 3) << 6 | A & 63;
  return l;
}, nz = function(r) {
  for (var e = r.length, t = [], n = 0; n < e; n += 2)
    t.push(r[n + 1] << 8 | r[n]);
  return t;
}, iz = function(r) {
  for (var e = r.length, t = [], n = 0; n < e; n += 4)
    t.push(r[n + 3] << 24 | r[n + 2] << 16 | r[n + 1] << 8 | r[n]);
  return t;
}, il = 5, wb = 11, E0 = 2, sz = wb - il, JI = 65536 >> il, az = 1 << il, S0 = az - 1, oz = 1024 >> il, Az = JI + oz, lz = Az, uz = 32, cz = lz + uz, fz = 65536 >> wb, hz = 1 << sz, dz = hz - 1, IC = function(r, e, t) {
  return r.slice ? r.slice(e, t) : new Uint16Array(Array.prototype.slice.call(r, e, t));
}, pz = function(r, e, t) {
  return r.slice ? r.slice(e, t) : new Uint32Array(Array.prototype.slice.call(r, e, t));
}, gz = function(r, e) {
  var t = rz(r), n = Array.isArray(t) ? iz(t) : new Uint32Array(t), i = Array.isArray(t) ? nz(t) : new Uint16Array(t), s = 24, a = IC(i, s / 2, n[4] / 2), o = n[5] === 2 ? IC(i, (s + n[4]) / 2) : pz(n, Math.ceil((s + n[4]) / 4));
  return new mz(n[0], n[1], n[2], n[3], a, o);
}, mz = (
  /** @class */
  function() {
    function r(e, t, n, i, s, a) {
      this.initialValue = e, this.errorValue = t, this.highStart = n, this.highValueIndex = i, this.index = s, this.data = a;
    }
    return r.prototype.get = function(e) {
      var t;
      if (e >= 0) {
        if (e < 55296 || e > 56319 && e <= 65535)
          return t = this.index[e >> il], t = (t << E0) + (e & S0), this.data[t];
        if (e <= 65535)
          return t = this.index[JI + (e - 55296 >> il)], t = (t << E0) + (e & S0), this.data[t];
        if (e < this.highStart)
          return t = cz - fz + (e >> wb), t = this.index[t], t += e >> il & dz, t = this.index[t], t = (t << E0) + (e & S0), this.data[t];
        if (e <= 1114111)
          return this.data[this.highValueIndex];
      }
      return this.errorValue;
    }, r;
  }()
), FC = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", vz = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var Id = 0; Id < FC.length; Id++)
  vz[FC.charCodeAt(Id)] = Id;
var bz = 1, I0 = 2, F0 = 3, TC = 4, xC = 5, yz = 7, kC = 8, T0 = 9, x0 = 10, LC = 11, UC = 12, NC = 13, OC = 14, k0 = 15, wz = function(r) {
  for (var e = [], t = 0, n = r.length; t < n; ) {
    var i = r.charCodeAt(t++);
    if (i >= 55296 && i <= 56319 && t < n) {
      var s = r.charCodeAt(t++);
      (s & 64512) === 56320 ? e.push(((i & 1023) << 10) + (s & 1023) + 65536) : (e.push(i), t--);
    } else
      e.push(i);
  }
  return e;
}, Bz = function() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  if (String.fromCodePoint)
    return String.fromCodePoint.apply(String, r);
  var t = r.length;
  if (!t)
    return "";
  for (var n = [], i = -1, s = ""; ++i < t; ) {
    var a = r[i];
    a <= 65535 ? n.push(a) : (a -= 65536, n.push((a >> 10) + 55296, a % 1024 + 56320)), (i + 1 === t || n.length > 16384) && (s += String.fromCharCode.apply(String, n), n.length = 0);
  }
  return s;
}, Cz = gz(tz), Es = "×", L0 = "÷", _z = function(r) {
  return Cz.get(r);
}, Ez = function(r, e, t) {
  var n = t - 2, i = e[n], s = e[t - 1], a = e[t];
  if (s === I0 && a === F0)
    return Es;
  if (s === I0 || s === F0 || s === TC || a === I0 || a === F0 || a === TC)
    return L0;
  if (s === kC && [kC, T0, LC, UC].indexOf(a) !== -1 || (s === LC || s === T0) && (a === T0 || a === x0) || (s === UC || s === x0) && a === x0 || a === NC || a === xC || a === yz || s === bz)
    return Es;
  if (s === NC && a === OC) {
    for (; i === xC; )
      i = e[--n];
    if (i === OC)
      return Es;
  }
  if (s === k0 && a === k0) {
    for (var o = 0; i === k0; )
      o++, i = e[--n];
    if (o % 2 === 0)
      return Es;
  }
  return L0;
}, Sz = function(r) {
  var e = wz(r), t = e.length, n = 0, i = 0, s = e.map(_z);
  return {
    next: function() {
      if (n >= t)
        return { done: !0, value: null };
      for (var a = Es; n < t && (a = Ez(e, s, ++n)) === Es; )
        ;
      if (a !== Es || n === t) {
        var o = Bz.apply(null, e.slice(i, n));
        return i = n, { value: o, done: !1 };
      }
      return { done: !0, value: null };
    }
  };
}, Iz = function(r) {
  for (var e = Sz(r), t = [], n; !(n = e.next()).done; )
    n.value && t.push(n.value.slice());
  return t;
}, Fz = function(r) {
  var e = 123;
  if (r.createRange) {
    var t = r.createRange();
    if (t.getBoundingClientRect) {
      var n = r.createElement("boundtest");
      n.style.height = e + "px", n.style.display = "block", r.body.appendChild(n), t.selectNode(n);
      var i = t.getBoundingClientRect(), s = Math.round(i.height);
      if (r.body.removeChild(n), s === e)
        return !0;
    }
  }
  return !1;
}, Tz = function(r) {
  var e = r.createElement("boundtest");
  e.style.width = "50px", e.style.display = "block", e.style.fontSize = "12px", e.style.letterSpacing = "0px", e.style.wordSpacing = "0px", r.body.appendChild(e);
  var t = r.createRange();
  e.innerHTML = typeof "".repeat == "function" ? "&#128104;".repeat(10) : "";
  var n = e.firstChild, i = _g(n.data).map(function(A) {
    return dn(A);
  }), s = 0, a = {}, o = i.every(function(A, l) {
    t.setStart(n, s), t.setEnd(n, s + A.length);
    var u = t.getBoundingClientRect();
    s += A.length;
    var c = u.x > a.x || u.y > a.y;
    return a = u, l === 0 ? !0 : c;
  });
  return r.body.removeChild(e), o;
}, xz = function() {
  return typeof new Image().crossOrigin < "u";
}, kz = function() {
  return typeof new XMLHttpRequest().responseType == "string";
}, Lz = function(r) {
  var e = new Image(), t = r.createElement("canvas"), n = t.getContext("2d");
  if (!n)
    return !1;
  e.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
  try {
    n.drawImage(e, 0, 0), t.toDataURL();
  } catch {
    return !1;
  }
  return !0;
}, QC = function(r) {
  return r[0] === 0 && r[1] === 255 && r[2] === 0 && r[3] === 255;
}, Uz = function(r) {
  var e = r.createElement("canvas"), t = 100;
  e.width = t, e.height = t;
  var n = e.getContext("2d");
  if (!n)
    return Promise.reject(!1);
  n.fillStyle = "rgb(0, 255, 0)", n.fillRect(0, 0, t, t);
  var i = new Image(), s = e.toDataURL();
  i.src = s;
  var a = Kv(t, t, 0, 0, i);
  return n.fillStyle = "red", n.fillRect(0, 0, t, t), DC(a).then(function(o) {
    n.drawImage(o, 0, 0);
    var A = n.getImageData(0, 0, t, t).data;
    n.fillStyle = "red", n.fillRect(0, 0, t, t);
    var l = r.createElement("div");
    return l.style.backgroundImage = "url(" + s + ")", l.style.height = t + "px", QC(A) ? DC(Kv(t, t, 0, 0, l)) : Promise.reject(!1);
  }).then(function(o) {
    return n.drawImage(o, 0, 0), QC(n.getImageData(0, 0, t, t).data);
  }).catch(function() {
    return !1;
  });
}, Kv = function(r, e, t, n, i) {
  var s = "http://www.w3.org/2000/svg", a = document.createElementNS(s, "svg"), o = document.createElementNS(s, "foreignObject");
  return a.setAttributeNS(null, "width", r.toString()), a.setAttributeNS(null, "height", e.toString()), o.setAttributeNS(null, "width", "100%"), o.setAttributeNS(null, "height", "100%"), o.setAttributeNS(null, "x", t.toString()), o.setAttributeNS(null, "y", n.toString()), o.setAttributeNS(null, "externalResourcesRequired", "true"), a.appendChild(o), o.appendChild(i), a;
}, DC = function(r) {
  return new Promise(function(e, t) {
    var n = new Image();
    n.onload = function() {
      return e(n);
    }, n.onerror = t, n.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(r));
  });
}, si = {
  get SUPPORT_RANGE_BOUNDS() {
    var r = Fz(document);
    return Object.defineProperty(si, "SUPPORT_RANGE_BOUNDS", { value: r }), r;
  },
  get SUPPORT_WORD_BREAKING() {
    var r = si.SUPPORT_RANGE_BOUNDS && Tz(document);
    return Object.defineProperty(si, "SUPPORT_WORD_BREAKING", { value: r }), r;
  },
  get SUPPORT_SVG_DRAWING() {
    var r = Lz(document);
    return Object.defineProperty(si, "SUPPORT_SVG_DRAWING", { value: r }), r;
  },
  get SUPPORT_FOREIGNOBJECT_DRAWING() {
    var r = typeof Array.from == "function" && typeof window.fetch == "function" ? Uz(document) : Promise.resolve(!1);
    return Object.defineProperty(si, "SUPPORT_FOREIGNOBJECT_DRAWING", { value: r }), r;
  },
  get SUPPORT_CORS_IMAGES() {
    var r = xz();
    return Object.defineProperty(si, "SUPPORT_CORS_IMAGES", { value: r }), r;
  },
  get SUPPORT_RESPONSE_TYPE() {
    var r = kz();
    return Object.defineProperty(si, "SUPPORT_RESPONSE_TYPE", { value: r }), r;
  },
  get SUPPORT_CORS_XHR() {
    var r = "withCredentials" in new XMLHttpRequest();
    return Object.defineProperty(si, "SUPPORT_CORS_XHR", { value: r }), r;
  },
  get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
    var r = !!(typeof Intl < "u" && Intl.Segmenter);
    return Object.defineProperty(si, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value: r }), r;
  }
}, uf = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e, t) {
      this.text = e, this.bounds = t;
    }
    return r;
  }()
), Nz = function(r, e, t, n) {
  var i = Dz(e, t), s = [], a = 0;
  return i.forEach(function(o) {
    if (t.textDecorationLine.length || o.trim().length > 0)
      if (si.SUPPORT_RANGE_BOUNDS) {
        var A = MC(n, a, o.length).getClientRects();
        if (A.length > 1) {
          var l = Bb(o), u = 0;
          l.forEach(function(h) {
            s.push(new uf(h, lo.fromDOMRectList(r, MC(n, u + a, h.length).getClientRects()))), u += h.length;
          });
        } else
          s.push(new uf(o, lo.fromDOMRectList(r, A)));
      } else {
        var c = n.splitText(o.length);
        s.push(new uf(o, Oz(r, n))), n = c;
      }
    else si.SUPPORT_RANGE_BOUNDS || (n = n.splitText(o.length));
    a += o.length;
  }), s;
}, Oz = function(r, e) {
  var t = e.ownerDocument;
  if (t) {
    var n = t.createElement("html2canvaswrapper");
    n.appendChild(e.cloneNode(!0));
    var i = e.parentNode;
    if (i) {
      i.replaceChild(n, e);
      var s = Cg(r, n);
      return n.firstChild && i.replaceChild(n.firstChild, n), s;
    }
  }
  return lo.EMPTY;
}, MC = function(r, e, t) {
  var n = r.ownerDocument;
  if (!n)
    throw new Error("Node has no owner document");
  var i = n.createRange();
  return i.setStart(r, e), i.setEnd(r, e + t), i;
}, Bb = function(r) {
  if (si.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var e = new Intl.Segmenter(void 0, { granularity: "grapheme" });
    return Array.from(e.segment(r)).map(function(t) {
      return t.segment;
    });
  }
  return Iz(r);
}, Qz = function(r, e) {
  if (si.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var t = new Intl.Segmenter(void 0, {
      granularity: "word"
    });
    return Array.from(t.segment(r)).map(function(n) {
      return n.segment;
    });
  }
  return Rz(r, e);
}, Dz = function(r, e) {
  return e.letterSpacing !== 0 ? Bb(r) : Qz(r, e);
}, Mz = [32, 160, 4961, 65792, 65793, 4153, 4241], Rz = function(r, e) {
  for (var t = fK(r, {
    lineBreak: e.lineBreak,
    wordBreak: e.overflowWrap === "break-word" ? "break-word" : e.wordBreak
  }), n = [], i, s = function() {
    if (i.value) {
      var a = i.value.slice(), o = _g(a), A = "";
      o.forEach(function(l) {
        Mz.indexOf(l) === -1 ? A += dn(l) : (A.length && n.push(A), n.push(dn(l)), A = "");
      }), A.length && n.push(A);
    }
  }; !(i = t.next()).done; )
    s();
  return n;
}, Pz = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e, t, n) {
      this.text = Hz(t.data, n.textTransform), this.textBounds = Nz(e, this.text, n, t);
    }
    return r;
  }()
), Hz = function(r, e) {
  switch (e) {
    case 1:
      return r.toLowerCase();
    case 3:
      return r.replace(jz, Kz);
    case 2:
      return r.toUpperCase();
    default:
      return r;
  }
}, jz = /(^|\s|:|-|\(|\))([a-z])/g, Kz = function(r, e, t) {
  return r.length > 0 ? e + t.toUpperCase() : r;
}, YI = (
  /** @class */
  function(r) {
    ua(e, r);
    function e(t, n) {
      var i = r.call(this, t, n) || this;
      return i.src = n.currentSrc || n.src, i.intrinsicWidth = n.naturalWidth, i.intrinsicHeight = n.naturalHeight, i.context.cache.addImage(i.src), i;
    }
    return e;
  }(Da)
), ZI = (
  /** @class */
  function(r) {
    ua(e, r);
    function e(t, n) {
      var i = r.call(this, t, n) || this;
      return i.canvas = n, i.intrinsicWidth = n.width, i.intrinsicHeight = n.height, i;
    }
    return e;
  }(Da)
), eF = (
  /** @class */
  function(r) {
    ua(e, r);
    function e(t, n) {
      var i = r.call(this, t, n) || this, s = new XMLSerializer(), a = Cg(t, n);
      return n.setAttribute("width", a.width + "px"), n.setAttribute("height", a.height + "px"), i.svg = "data:image/svg+xml," + encodeURIComponent(s.serializeToString(n)), i.intrinsicWidth = n.width.baseVal.value, i.intrinsicHeight = n.height.baseVal.value, i.context.cache.addImage(i.svg), i;
    }
    return e;
  }(Da)
), tF = (
  /** @class */
  function(r) {
    ua(e, r);
    function e(t, n) {
      var i = r.call(this, t, n) || this;
      return i.value = n.value, i;
    }
    return e;
  }(Da)
), $v = (
  /** @class */
  function(r) {
    ua(e, r);
    function e(t, n) {
      var i = r.call(this, t, n) || this;
      return i.start = n.start, i.reversed = typeof n.reversed == "boolean" && n.reversed === !0, i;
    }
    return e;
  }(Da)
), $z = [
  {
    type: 15,
    flags: 0,
    unit: "px",
    number: 3
  }
], Vz = [
  {
    type: 16,
    flags: 0,
    number: 50
  }
], zz = function(r) {
  return r.width > r.height ? new lo(r.left + (r.width - r.height) / 2, r.top, r.height, r.height) : r.width < r.height ? new lo(r.left, r.top + (r.height - r.width) / 2, r.width, r.width) : r;
}, Gz = function(r) {
  var e = r.type === qz ? new Array(r.value.length + 1).join("•") : r.value;
  return e.length === 0 ? r.placeholder || "" : e;
}, Mp = "checkbox", Rp = "radio", qz = "password", RC = 707406591, Cb = (
  /** @class */
  function(r) {
    ua(e, r);
    function e(t, n) {
      var i = r.call(this, t, n) || this;
      switch (i.type = n.type.toLowerCase(), i.checked = n.checked, i.value = Gz(n), (i.type === Mp || i.type === Rp) && (i.styles.backgroundColor = 3739148031, i.styles.borderTopColor = i.styles.borderRightColor = i.styles.borderBottomColor = i.styles.borderLeftColor = 2779096575, i.styles.borderTopWidth = i.styles.borderRightWidth = i.styles.borderBottomWidth = i.styles.borderLeftWidth = 1, i.styles.borderTopStyle = i.styles.borderRightStyle = i.styles.borderBottomStyle = i.styles.borderLeftStyle = 1, i.styles.backgroundClip = [
        0
        /* BORDER_BOX */
      ], i.styles.backgroundOrigin = [
        0
        /* BORDER_BOX */
      ], i.bounds = zz(i.bounds)), i.type) {
        case Mp:
          i.styles.borderTopRightRadius = i.styles.borderTopLeftRadius = i.styles.borderBottomRightRadius = i.styles.borderBottomLeftRadius = $z;
          break;
        case Rp:
          i.styles.borderTopRightRadius = i.styles.borderTopLeftRadius = i.styles.borderBottomRightRadius = i.styles.borderBottomLeftRadius = Vz;
          break;
      }
      return i;
    }
    return e;
  }(Da)
), rF = (
  /** @class */
  function(r) {
    ua(e, r);
    function e(t, n) {
      var i = r.call(this, t, n) || this, s = n.options[n.selectedIndex || 0];
      return i.value = s && s.text || "", i;
    }
    return e;
  }(Da)
), nF = (
  /** @class */
  function(r) {
    ua(e, r);
    function e(t, n) {
      var i = r.call(this, t, n) || this;
      return i.value = n.value, i;
    }
    return e;
  }(Da)
), iF = (
  /** @class */
  function(r) {
    ua(e, r);
    function e(t, n) {
      var i = r.call(this, t, n) || this;
      i.src = n.src, i.width = parseInt(n.width, 10) || 0, i.height = parseInt(n.height, 10) || 0, i.backgroundColor = i.styles.backgroundColor;
      try {
        if (n.contentWindow && n.contentWindow.document && n.contentWindow.document.documentElement) {
          i.tree = aF(t, n.contentWindow.document.documentElement);
          var s = n.contentWindow.document.documentElement ? Af(t, getComputedStyle(n.contentWindow.document.documentElement).backgroundColor) : ao.TRANSPARENT, a = n.contentWindow.document.body ? Af(t, getComputedStyle(n.contentWindow.document.body).backgroundColor) : ao.TRANSPARENT;
          i.backgroundColor = nA(s) ? nA(a) ? i.styles.backgroundColor : a : s;
        }
      } catch {
      }
      return i;
    }
    return e;
  }(Da)
), Wz = ["OL", "UL", "MENU"], op = function(r, e, t, n) {
  for (var i = e.firstChild, s = void 0; i; i = s)
    if (s = i.nextSibling, oF(i) && i.data.trim().length > 0)
      t.textNodes.push(new Pz(r, i, t.styles));
    else if (pu(i))
      if (cF(i) && i.assignedNodes)
        i.assignedNodes().forEach(function(o) {
          return op(r, o, t, n);
        });
      else {
        var a = sF(r, i);
        a.styles.isVisible() && (Xz(i, a, n) ? a.flags |= 4 : Jz(a.styles) && (a.flags |= 2), Wz.indexOf(i.tagName) !== -1 && (a.flags |= 8), t.elements.push(a), i.slot, i.shadowRoot ? op(r, i.shadowRoot, a, n) : !Pp(i) && !AF(i) && !Hp(i) && op(r, i, a, n));
      }
}, sF = function(r, e) {
  return zv(e) ? new YI(r, e) : lF(e) ? new ZI(r, e) : AF(e) ? new eF(r, e) : Yz(e) ? new tF(r, e) : Zz(e) ? new $v(r, e) : eG(e) ? new Cb(r, e) : Hp(e) ? new rF(r, e) : Pp(e) ? new nF(r, e) : uF(e) ? new iF(r, e) : new Da(r, e);
}, aF = function(r, e) {
  var t = sF(r, e);
  return t.flags |= 4, op(r, e, t, t), t;
}, Xz = function(r, e, t) {
  return e.styles.isPositionedWithZIndex() || e.styles.opacity < 1 || e.styles.isTransformed() || _b(r) && t.styles.isTransparent();
}, Jz = function(r) {
  return r.isPositioned() || r.isFloating();
}, oF = function(r) {
  return r.nodeType === Node.TEXT_NODE;
}, pu = function(r) {
  return r.nodeType === Node.ELEMENT_NODE;
}, Vv = function(r) {
  return pu(r) && typeof r.style < "u" && !Ap(r);
}, Ap = function(r) {
  return typeof r.className == "object";
}, Yz = function(r) {
  return r.tagName === "LI";
}, Zz = function(r) {
  return r.tagName === "OL";
}, eG = function(r) {
  return r.tagName === "INPUT";
}, tG = function(r) {
  return r.tagName === "HTML";
}, AF = function(r) {
  return r.tagName === "svg";
}, _b = function(r) {
  return r.tagName === "BODY";
}, lF = function(r) {
  return r.tagName === "CANVAS";
}, PC = function(r) {
  return r.tagName === "VIDEO";
}, zv = function(r) {
  return r.tagName === "IMG";
}, uF = function(r) {
  return r.tagName === "IFRAME";
}, HC = function(r) {
  return r.tagName === "STYLE";
}, rG = function(r) {
  return r.tagName === "SCRIPT";
}, Pp = function(r) {
  return r.tagName === "TEXTAREA";
}, Hp = function(r) {
  return r.tagName === "SELECT";
}, cF = function(r) {
  return r.tagName === "SLOT";
}, jC = function(r) {
  return r.tagName.indexOf("-") > 0;
}, nG = (
  /** @class */
  function() {
    function r() {
      this.counters = {};
    }
    return r.prototype.getCounterValue = function(e) {
      var t = this.counters[e];
      return t && t.length ? t[t.length - 1] : 1;
    }, r.prototype.getCounterValues = function(e) {
      var t = this.counters[e];
      return t || [];
    }, r.prototype.pop = function(e) {
      var t = this;
      e.forEach(function(n) {
        return t.counters[n].pop();
      });
    }, r.prototype.parse = function(e) {
      var t = this, n = e.counterIncrement, i = e.counterReset, s = !0;
      n !== null && n.forEach(function(o) {
        var A = t.counters[o.counter];
        A && o.increment !== 0 && (s = !1, A.length || A.push(1), A[Math.max(0, A.length - 1)] += o.increment);
      });
      var a = [];
      return s && i.forEach(function(o) {
        var A = t.counters[o.counter];
        a.push(o.counter), A || (A = t.counters[o.counter] = []), A.push(o.reset);
      }), a;
    }, r;
  }()
), KC = {
  integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
  values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
}, $C = {
  integers: [
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "Ք",
    "Փ",
    "Ւ",
    "Ց",
    "Ր",
    "Տ",
    "Վ",
    "Ս",
    "Ռ",
    "Ջ",
    "Պ",
    "Չ",
    "Ո",
    "Շ",
    "Ն",
    "Յ",
    "Մ",
    "Ճ",
    "Ղ",
    "Ձ",
    "Հ",
    "Կ",
    "Ծ",
    "Խ",
    "Լ",
    "Ի",
    "Ժ",
    "Թ",
    "Ը",
    "Է",
    "Զ",
    "Ե",
    "Դ",
    "Գ",
    "Բ",
    "Ա"
  ]
}, iG = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    19,
    18,
    17,
    16,
    15,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "י׳",
    "ט׳",
    "ח׳",
    "ז׳",
    "ו׳",
    "ה׳",
    "ד׳",
    "ג׳",
    "ב׳",
    "א׳",
    "ת",
    "ש",
    "ר",
    "ק",
    "צ",
    "פ",
    "ע",
    "ס",
    "נ",
    "מ",
    "ל",
    "כ",
    "יט",
    "יח",
    "יז",
    "טז",
    "טו",
    "י",
    "ט",
    "ח",
    "ז",
    "ו",
    "ה",
    "ד",
    "ג",
    "ב",
    "א"
  ]
}, sG = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "ჵ",
    "ჰ",
    "ჯ",
    "ჴ",
    "ხ",
    "ჭ",
    "წ",
    "ძ",
    "ც",
    "ჩ",
    "შ",
    "ყ",
    "ღ",
    "ქ",
    "ფ",
    "ჳ",
    "ტ",
    "ს",
    "რ",
    "ჟ",
    "პ",
    "ო",
    "ჲ",
    "ნ",
    "მ",
    "ლ",
    "კ",
    "ი",
    "თ",
    "ჱ",
    "ზ",
    "ვ",
    "ე",
    "დ",
    "გ",
    "ბ",
    "ა"
  ]
}, Xl = function(r, e, t, n, i, s) {
  return r < e || r > t ? kf(r, i, s.length > 0) : n.integers.reduce(function(a, o, A) {
    for (; r >= o; )
      r -= o, a += n.values[A];
    return a;
  }, "") + s;
}, fF = function(r, e, t, n) {
  var i = "";
  do
    t || r--, i = n(r) + i, r /= e;
  while (r * e >= e);
  return i;
}, hn = function(r, e, t, n, i) {
  var s = t - e + 1;
  return (r < 0 ? "-" : "") + (fF(Math.abs(r), s, n, function(a) {
    return dn(Math.floor(a % s) + e);
  }) + i);
}, FA = function(r, e, t) {
  t === void 0 && (t = ". ");
  var n = e.length;
  return fF(Math.abs(r), n, !1, function(i) {
    return e[Math.floor(i % n)];
  }) + t;
}, Au = 1, Uo = 2, No = 4, $c = 8, Ya = function(r, e, t, n, i, s) {
  if (r < -9999 || r > 9999)
    return kf(r, 4, i.length > 0);
  var a = Math.abs(r), o = i;
  if (a === 0)
    return e[0] + o;
  for (var A = 0; a > 0 && A <= 4; A++) {
    var l = a % 10;
    l === 0 && Rn(s, Au) && o !== "" ? o = e[l] + o : l > 1 || l === 1 && A === 0 || l === 1 && A === 1 && Rn(s, Uo) || l === 1 && A === 1 && Rn(s, No) && r > 100 || l === 1 && A > 1 && Rn(s, $c) ? o = e[l] + (A > 0 ? t[A - 1] : "") + o : l === 1 && A > 0 && (o = t[A - 1] + o), a = Math.floor(a / 10);
  }
  return (r < 0 ? n : "") + o;
}, VC = "十百千萬", zC = "拾佰仟萬", GC = "マイナス", U0 = "마이너스", kf = function(r, e, t) {
  var n = t ? ". " : "", i = t ? "、" : "", s = t ? ", " : "", a = t ? " " : "";
  switch (e) {
    case 0:
      return "•" + a;
    case 1:
      return "◦" + a;
    case 2:
      return "◾" + a;
    case 5:
      var o = hn(r, 48, 57, !0, n);
      return o.length < 4 ? "0" + o : o;
    case 4:
      return FA(r, "〇一二三四五六七八九", i);
    case 6:
      return Xl(r, 1, 3999, KC, 3, n).toLowerCase();
    case 7:
      return Xl(r, 1, 3999, KC, 3, n);
    case 8:
      return hn(r, 945, 969, !1, n);
    case 9:
      return hn(r, 97, 122, !1, n);
    case 10:
      return hn(r, 65, 90, !1, n);
    case 11:
      return hn(r, 1632, 1641, !0, n);
    case 12:
    case 49:
      return Xl(r, 1, 9999, $C, 3, n);
    case 35:
      return Xl(r, 1, 9999, $C, 3, n).toLowerCase();
    case 13:
      return hn(r, 2534, 2543, !0, n);
    case 14:
    case 30:
      return hn(r, 6112, 6121, !0, n);
    case 15:
      return FA(r, "子丑寅卯辰巳午未申酉戌亥", i);
    case 16:
      return FA(r, "甲乙丙丁戊己庚辛壬癸", i);
    case 17:
    case 48:
      return Ya(r, "零一二三四五六七八九", VC, "負", i, Uo | No | $c);
    case 47:
      return Ya(r, "零壹貳參肆伍陸柒捌玖", zC, "負", i, Au | Uo | No | $c);
    case 42:
      return Ya(r, "零一二三四五六七八九", VC, "负", i, Uo | No | $c);
    case 41:
      return Ya(r, "零壹贰叁肆伍陆柒捌玖", zC, "负", i, Au | Uo | No | $c);
    case 26:
      return Ya(r, "〇一二三四五六七八九", "十百千万", GC, i, 0);
    case 25:
      return Ya(r, "零壱弐参四伍六七八九", "拾百千万", GC, i, Au | Uo | No);
    case 31:
      return Ya(r, "영일이삼사오육칠팔구", "십백천만", U0, s, Au | Uo | No);
    case 33:
      return Ya(r, "零一二三四五六七八九", "十百千萬", U0, s, 0);
    case 32:
      return Ya(r, "零壹貳參四五六七八九", "拾百千", U0, s, Au | Uo | No);
    case 18:
      return hn(r, 2406, 2415, !0, n);
    case 20:
      return Xl(r, 1, 19999, sG, 3, n);
    case 21:
      return hn(r, 2790, 2799, !0, n);
    case 22:
      return hn(r, 2662, 2671, !0, n);
    case 22:
      return Xl(r, 1, 10999, iG, 3, n);
    case 23:
      return FA(r, "あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをん");
    case 24:
      return FA(r, "いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす");
    case 27:
      return hn(r, 3302, 3311, !0, n);
    case 28:
      return FA(r, "アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲン", i);
    case 29:
      return FA(r, "イロハニホヘトチリヌルヲワカヨタレソツネナラムウヰノオクヤマケフコエテアサキユメミシヱヒモセス", i);
    case 34:
      return hn(r, 3792, 3801, !0, n);
    case 37:
      return hn(r, 6160, 6169, !0, n);
    case 38:
      return hn(r, 4160, 4169, !0, n);
    case 39:
      return hn(r, 2918, 2927, !0, n);
    case 40:
      return hn(r, 1776, 1785, !0, n);
    case 43:
      return hn(r, 3046, 3055, !0, n);
    case 44:
      return hn(r, 3174, 3183, !0, n);
    case 45:
      return hn(r, 3664, 3673, !0, n);
    case 46:
      return hn(r, 3872, 3881, !0, n);
    case 3:
    default:
      return hn(r, 48, 57, !0, n);
  }
}, hF = "data-html2canvas-ignore", qC = (
  /** @class */
  function() {
    function r(e, t, n) {
      if (this.context = e, this.options = n, this.scrolledElements = [], this.referenceElement = t, this.counters = new nG(), this.quoteDepth = 0, !t.ownerDocument)
        throw new Error("Cloned element does not have an owner document");
      this.documentElement = this.cloneNode(t.ownerDocument.documentElement, !1);
    }
    return r.prototype.toIFrame = function(e, t) {
      var n = this, i = aG(e, t);
      if (!i.contentWindow)
        return Promise.reject("Unable to find iframe window");
      var s = e.defaultView.pageXOffset, a = e.defaultView.pageYOffset, o = i.contentWindow, A = o.document, l = lG(i).then(function() {
        return Ui(n, void 0, void 0, function() {
          var u, c;
          return wi(this, function(h) {
            switch (h.label) {
              case 0:
                return this.scrolledElements.forEach(hG), o && (o.scrollTo(t.left, t.top), /(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (o.scrollY !== t.top || o.scrollX !== t.left) && (this.context.logger.warn("Unable to restore scroll position for cloned document"), this.context.windowBounds = this.context.windowBounds.add(o.scrollX - t.left, o.scrollY - t.top, 0, 0))), u = this.options.onclone, c = this.clonedReferenceElement, typeof c > "u" ? [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")] : A.fonts && A.fonts.ready ? [4, A.fonts.ready] : [3, 2];
              case 1:
                h.sent(), h.label = 2;
              case 2:
                return /(AppleWebKit)/g.test(navigator.userAgent) ? [4, AG(A)] : [3, 4];
              case 3:
                h.sent(), h.label = 4;
              case 4:
                return typeof u == "function" ? [2, Promise.resolve().then(function() {
                  return u(A, c);
                }).then(function() {
                  return i;
                })] : [2, i];
            }
          });
        });
      });
      return A.open(), A.write(cG(document.doctype) + "<html></html>"), fG(this.referenceElement.ownerDocument, s, a), A.replaceChild(A.adoptNode(this.documentElement), A.documentElement), A.close(), l;
    }, r.prototype.createElementClone = function(e) {
      if (jv(
        e,
        2
        /* CLONE */
      ))
        debugger;
      if (lF(e))
        return this.createCanvasClone(e);
      if (PC(e))
        return this.createVideoClone(e);
      if (HC(e))
        return this.createStyleClone(e);
      var t = e.cloneNode(!1);
      return zv(t) && (zv(e) && e.currentSrc && e.currentSrc !== e.src && (t.src = e.currentSrc, t.srcset = ""), t.loading === "lazy" && (t.loading = "eager")), jC(t) ? this.createCustomElementClone(t) : t;
    }, r.prototype.createCustomElementClone = function(e) {
      var t = document.createElement("html2canvascustomelement");
      return N0(e.style, t), t;
    }, r.prototype.createStyleClone = function(e) {
      try {
        var t = e.sheet;
        if (t && t.cssRules) {
          var n = [].slice.call(t.cssRules, 0).reduce(function(s, a) {
            return a && typeof a.cssText == "string" ? s + a.cssText : s;
          }, ""), i = e.cloneNode(!1);
          return i.textContent = n, i;
        }
      } catch (s) {
        if (this.context.logger.error("Unable to access cssRules property", s), s.name !== "SecurityError")
          throw s;
      }
      return e.cloneNode(!1);
    }, r.prototype.createCanvasClone = function(e) {
      var t;
      if (this.options.inlineImages && e.ownerDocument) {
        var n = e.ownerDocument.createElement("img");
        try {
          return n.src = e.toDataURL(), n;
        } catch {
          this.context.logger.info("Unable to inline canvas contents, canvas is tainted", e);
        }
      }
      var i = e.cloneNode(!1);
      try {
        i.width = e.width, i.height = e.height;
        var s = e.getContext("2d"), a = i.getContext("2d");
        if (a)
          if (!this.options.allowTaint && s)
            a.putImageData(s.getImageData(0, 0, e.width, e.height), 0, 0);
          else {
            var o = (t = e.getContext("webgl2")) !== null && t !== void 0 ? t : e.getContext("webgl");
            if (o) {
              var A = o.getContextAttributes();
              (A == null ? void 0 : A.preserveDrawingBuffer) === !1 && this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", e);
            }
            a.drawImage(e, 0, 0);
          }
        return i;
      } catch {
        this.context.logger.info("Unable to clone canvas as it is tainted", e);
      }
      return i;
    }, r.prototype.createVideoClone = function(e) {
      var t = e.ownerDocument.createElement("canvas");
      t.width = e.offsetWidth, t.height = e.offsetHeight;
      var n = t.getContext("2d");
      try {
        return n && (n.drawImage(e, 0, 0, t.width, t.height), this.options.allowTaint || n.getImageData(0, 0, t.width, t.height)), t;
      } catch {
        this.context.logger.info("Unable to clone video as it is tainted", e);
      }
      var i = e.ownerDocument.createElement("canvas");
      return i.width = e.offsetWidth, i.height = e.offsetHeight, i;
    }, r.prototype.appendChildNode = function(e, t, n) {
      (!pu(t) || !rG(t) && !t.hasAttribute(hF) && (typeof this.options.ignoreElements != "function" || !this.options.ignoreElements(t))) && (!this.options.copyStyles || !pu(t) || !HC(t)) && e.appendChild(this.cloneNode(t, n));
    }, r.prototype.cloneChildNodes = function(e, t, n) {
      for (var i = this, s = e.shadowRoot ? e.shadowRoot.firstChild : e.firstChild; s; s = s.nextSibling)
        if (pu(s) && cF(s) && typeof s.assignedNodes == "function") {
          var a = s.assignedNodes();
          a.length && a.forEach(function(o) {
            return i.appendChildNode(t, o, n);
          });
        } else
          this.appendChildNode(t, s, n);
    }, r.prototype.cloneNode = function(e, t) {
      if (oF(e))
        return document.createTextNode(e.data);
      if (!e.ownerDocument)
        return e.cloneNode(!1);
      var n = e.ownerDocument.defaultView;
      if (n && pu(e) && (Vv(e) || Ap(e))) {
        var i = this.createElementClone(e);
        i.style.transitionProperty = "none";
        var s = n.getComputedStyle(e), a = n.getComputedStyle(e, ":before"), o = n.getComputedStyle(e, ":after");
        this.referenceElement === e && Vv(i) && (this.clonedReferenceElement = i), _b(i) && gG(i);
        var A = this.counters.parse(new EC(this.context, s)), l = this.resolvePseudoContent(e, i, a, cf.BEFORE);
        jC(e) && (t = !0), PC(e) || this.cloneChildNodes(e, i, t), l && i.insertBefore(l, i.firstChild);
        var u = this.resolvePseudoContent(e, i, o, cf.AFTER);
        return u && i.appendChild(u), this.counters.pop(A), (s && (this.options.copyStyles || Ap(e)) && !uF(e) || t) && N0(s, i), (e.scrollTop !== 0 || e.scrollLeft !== 0) && this.scrolledElements.push([i, e.scrollLeft, e.scrollTop]), (Pp(e) || Hp(e)) && (Pp(i) || Hp(i)) && (i.value = e.value), i;
      }
      return e.cloneNode(!1);
    }, r.prototype.resolvePseudoContent = function(e, t, n, i) {
      var s = this;
      if (n) {
        var a = n.content, o = t.ownerDocument;
        if (!(!o || !a || a === "none" || a === "-moz-alt-content" || n.display === "none")) {
          this.counters.parse(new EC(this.context, n));
          var A = new YV(this.context, n), l = o.createElement("html2canvaspseudoelement");
          N0(n, l), A.content.forEach(function(c) {
            if (c.type === 0)
              l.appendChild(o.createTextNode(c.value));
            else if (c.type === 22) {
              var h = o.createElement("img");
              h.src = c.value, h.style.opacity = "1", l.appendChild(h);
            } else if (c.type === 18) {
              if (c.name === "attr") {
                var f = c.values.filter(Tr);
                f.length && l.appendChild(o.createTextNode(e.getAttribute(f[0].value) || ""));
              } else if (c.name === "counter") {
                var d = c.values.filter(Nu), p = d[0], v = d[1];
                if (p && Tr(p)) {
                  var m = s.counters.getCounterValue(p.value), b = v && Tr(v) ? Hv.parse(s.context, v.value) : 3;
                  l.appendChild(o.createTextNode(kf(m, b, !1)));
                }
              } else if (c.name === "counters") {
                var w = c.values.filter(Nu), p = w[0], B = w[1], v = w[2];
                if (p && Tr(p)) {
                  var _ = s.counters.getCounterValues(p.value), x = v && Tr(v) ? Hv.parse(s.context, v.value) : 3, C = B && B.type === 0 ? B.value : "", F = _.map(function(T) {
                    return kf(T, x, !1);
                  }).join(C);
                  l.appendChild(o.createTextNode(F));
                }
              }
            } else if (c.type === 20)
              switch (c.value) {
                case "open-quote":
                  l.appendChild(o.createTextNode(_C(A.quotes, s.quoteDepth++, !0)));
                  break;
                case "close-quote":
                  l.appendChild(o.createTextNode(_C(A.quotes, --s.quoteDepth, !1)));
                  break;
                default:
                  l.appendChild(o.createTextNode(c.value));
              }
          }), l.className = Gv + " " + qv;
          var u = i === cf.BEFORE ? " " + Gv : " " + qv;
          return Ap(t) ? t.className.baseValue += u : t.className += u, l;
        }
      }
    }, r.destroy = function(e) {
      return e.parentNode ? (e.parentNode.removeChild(e), !0) : !1;
    }, r;
  }()
), cf;
(function(r) {
  r[r.BEFORE = 0] = "BEFORE", r[r.AFTER = 1] = "AFTER";
})(cf || (cf = {}));
var aG = function(r, e) {
  var t = r.createElement("iframe");
  return t.className = "html2canvas-container", t.style.visibility = "hidden", t.style.position = "fixed", t.style.left = "-10000px", t.style.top = "0px", t.style.border = "0", t.width = e.width.toString(), t.height = e.height.toString(), t.scrolling = "no", t.setAttribute(hF, "true"), r.body.appendChild(t), t;
}, oG = function(r) {
  return new Promise(function(e) {
    if (r.complete) {
      e();
      return;
    }
    if (!r.src) {
      e();
      return;
    }
    r.onload = e, r.onerror = e;
  });
}, AG = function(r) {
  return Promise.all([].slice.call(r.images, 0).map(oG));
}, lG = function(r) {
  return new Promise(function(e, t) {
    var n = r.contentWindow;
    if (!n)
      return t("No window assigned for iframe");
    var i = n.document;
    n.onload = r.onload = function() {
      n.onload = r.onload = null;
      var s = setInterval(function() {
        i.body.childNodes.length > 0 && i.readyState === "complete" && (clearInterval(s), e(r));
      }, 50);
    };
  });
}, uG = [
  "all",
  "d",
  "content"
  // Safari shows pseudoelements if content is set
], N0 = function(r, e) {
  for (var t = r.length - 1; t >= 0; t--) {
    var n = r.item(t);
    uG.indexOf(n) === -1 && e.style.setProperty(n, r.getPropertyValue(n));
  }
  return e;
}, cG = function(r) {
  var e = "";
  return r && (e += "<!DOCTYPE ", r.name && (e += r.name), r.internalSubset && (e += r.internalSubset), r.publicId && (e += '"' + r.publicId + '"'), r.systemId && (e += '"' + r.systemId + '"'), e += ">"), e;
}, fG = function(r, e, t) {
  r && r.defaultView && (e !== r.defaultView.pageXOffset || t !== r.defaultView.pageYOffset) && r.defaultView.scrollTo(e, t);
}, hG = function(r) {
  var e = r[0], t = r[1], n = r[2];
  e.scrollLeft = t, e.scrollTop = n;
}, dG = ":before", pG = ":after", Gv = "___html2canvas___pseudoelement_before", qv = "___html2canvas___pseudoelement_after", WC = `{
    content: "" !important;
    display: none !important;
}`, gG = function(r) {
  mG(r, "." + Gv + dG + WC + `
         .` + qv + pG + WC);
}, mG = function(r, e) {
  var t = r.ownerDocument;
  if (t) {
    var n = t.createElement("style");
    n.textContent = e, r.appendChild(n);
  }
}, dF = (
  /** @class */
  function() {
    function r() {
    }
    return r.getOrigin = function(e) {
      var t = r._link;
      return t ? (t.href = e, t.href = t.href, t.protocol + t.hostname + t.port) : "about:blank";
    }, r.isSameOrigin = function(e) {
      return r.getOrigin(e) === r._origin;
    }, r.setContext = function(e) {
      r._link = e.document.createElement("a"), r._origin = r.getOrigin(e.location.href);
    }, r._origin = "about:blank", r;
  }()
), vG = (
  /** @class */
  function() {
    function r(e, t) {
      this.context = e, this._options = t, this._cache = {};
    }
    return r.prototype.addImage = function(e) {
      var t = Promise.resolve();
      return this.has(e) || (Q0(e) || BG(e)) && (this._cache[e] = this.loadImage(e)).catch(function() {
      }), t;
    }, r.prototype.match = function(e) {
      return this._cache[e];
    }, r.prototype.loadImage = function(e) {
      return Ui(this, void 0, void 0, function() {
        var t, n, i, s, a = this;
        return wi(this, function(o) {
          switch (o.label) {
            case 0:
              return t = dF.isSameOrigin(e), n = !O0(e) && this._options.useCORS === !0 && si.SUPPORT_CORS_IMAGES && !t, i = !O0(e) && !t && !Q0(e) && typeof this._options.proxy == "string" && si.SUPPORT_CORS_XHR && !n, !t && this._options.allowTaint === !1 && !O0(e) && !Q0(e) && !i && !n ? [
                2
                /*return*/
              ] : (s = e, i ? [4, this.proxy(s)] : [3, 2]);
            case 1:
              s = o.sent(), o.label = 2;
            case 2:
              return this.context.logger.debug("Added image " + e.substring(0, 256)), [4, new Promise(function(A, l) {
                var u = new Image();
                u.onload = function() {
                  return A(u);
                }, u.onerror = l, (CG(s) || n) && (u.crossOrigin = "anonymous"), u.src = s, u.complete === !0 && setTimeout(function() {
                  return A(u);
                }, 500), a._options.imageTimeout > 0 && setTimeout(function() {
                  return l("Timed out (" + a._options.imageTimeout + "ms) loading image");
                }, a._options.imageTimeout);
              })];
            case 3:
              return [2, o.sent()];
          }
        });
      });
    }, r.prototype.has = function(e) {
      return typeof this._cache[e] < "u";
    }, r.prototype.keys = function() {
      return Promise.resolve(Object.keys(this._cache));
    }, r.prototype.proxy = function(e) {
      var t = this, n = this._options.proxy;
      if (!n)
        throw new Error("No proxy defined");
      var i = e.substring(0, 256);
      return new Promise(function(s, a) {
        var o = si.SUPPORT_RESPONSE_TYPE ? "blob" : "text", A = new XMLHttpRequest();
        A.onload = function() {
          if (A.status === 200)
            if (o === "text")
              s(A.response);
            else {
              var c = new FileReader();
              c.addEventListener("load", function() {
                return s(c.result);
              }, !1), c.addEventListener("error", function(h) {
                return a(h);
              }, !1), c.readAsDataURL(A.response);
            }
          else
            a("Failed to proxy resource " + i + " with status code " + A.status);
        }, A.onerror = a;
        var l = n.indexOf("?") > -1 ? "&" : "?";
        if (A.open("GET", "" + n + l + "url=" + encodeURIComponent(e) + "&responseType=" + o), o !== "text" && A instanceof XMLHttpRequest && (A.responseType = o), t._options.imageTimeout) {
          var u = t._options.imageTimeout;
          A.timeout = u, A.ontimeout = function() {
            return a("Timed out (" + u + "ms) proxying " + i);
          };
        }
        A.send();
      });
    }, r;
  }()
), bG = /^data:image\/svg\+xml/i, yG = /^data:image\/.*;base64,/i, wG = /^data:image\/.*/i, BG = function(r) {
  return si.SUPPORT_SVG_DRAWING || !_G(r);
}, O0 = function(r) {
  return wG.test(r);
}, CG = function(r) {
  return yG.test(r);
}, Q0 = function(r) {
  return r.substr(0, 4) === "blob";
}, _G = function(r) {
  return r.substr(-3).toLowerCase() === "svg" || bG.test(r);
}, ot = (
  /** @class */
  function() {
    function r(e, t) {
      this.type = 0, this.x = e, this.y = t;
    }
    return r.prototype.add = function(e, t) {
      return new r(this.x + e, this.y + t);
    }, r;
  }()
), Jl = function(r, e, t) {
  return new ot(r.x + (e.x - r.x) * t, r.y + (e.y - r.y) * t);
}, Fd = (
  /** @class */
  function() {
    function r(e, t, n, i) {
      this.type = 1, this.start = e, this.startControl = t, this.endControl = n, this.end = i;
    }
    return r.prototype.subdivide = function(e, t) {
      var n = Jl(this.start, this.startControl, e), i = Jl(this.startControl, this.endControl, e), s = Jl(this.endControl, this.end, e), a = Jl(n, i, e), o = Jl(i, s, e), A = Jl(a, o, e);
      return t ? new r(this.start, n, a, A) : new r(A, o, s, this.end);
    }, r.prototype.add = function(e, t) {
      return new r(this.start.add(e, t), this.startControl.add(e, t), this.endControl.add(e, t), this.end.add(e, t));
    }, r.prototype.reverse = function() {
      return new r(this.end, this.endControl, this.startControl, this.start);
    }, r;
  }()
), Fs = function(r) {
  return r.type === 1;
}, EG = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e) {
      var t = e.styles, n = e.bounds, i = jc(t.borderTopLeftRadius, n.width, n.height), s = i[0], a = i[1], o = jc(t.borderTopRightRadius, n.width, n.height), A = o[0], l = o[1], u = jc(t.borderBottomRightRadius, n.width, n.height), c = u[0], h = u[1], f = jc(t.borderBottomLeftRadius, n.width, n.height), d = f[0], p = f[1], v = [];
      v.push((s + A) / n.width), v.push((d + c) / n.width), v.push((a + p) / n.height), v.push((l + h) / n.height);
      var m = Math.max.apply(Math, v);
      m > 1 && (s /= m, a /= m, A /= m, l /= m, c /= m, h /= m, d /= m, p /= m);
      var b = n.width - A, w = n.height - h, B = n.width - c, _ = n.height - p, x = t.borderTopWidth, C = t.borderRightWidth, F = t.borderBottomWidth, N = t.borderLeftWidth, D = Hr(t.paddingTop, e.bounds.width), T = Hr(t.paddingRight, e.bounds.width), E = Hr(t.paddingBottom, e.bounds.width), L = Hr(t.paddingLeft, e.bounds.width);
      this.topLeftBorderDoubleOuterBox = s > 0 || a > 0 ? zr(n.left + N / 3, n.top + x / 3, s - N / 3, a - x / 3, Cr.TOP_LEFT) : new ot(n.left + N / 3, n.top + x / 3), this.topRightBorderDoubleOuterBox = s > 0 || a > 0 ? zr(n.left + b, n.top + x / 3, A - C / 3, l - x / 3, Cr.TOP_RIGHT) : new ot(n.left + n.width - C / 3, n.top + x / 3), this.bottomRightBorderDoubleOuterBox = c > 0 || h > 0 ? zr(n.left + B, n.top + w, c - C / 3, h - F / 3, Cr.BOTTOM_RIGHT) : new ot(n.left + n.width - C / 3, n.top + n.height - F / 3), this.bottomLeftBorderDoubleOuterBox = d > 0 || p > 0 ? zr(n.left + N / 3, n.top + _, d - N / 3, p - F / 3, Cr.BOTTOM_LEFT) : new ot(n.left + N / 3, n.top + n.height - F / 3), this.topLeftBorderDoubleInnerBox = s > 0 || a > 0 ? zr(n.left + N * 2 / 3, n.top + x * 2 / 3, s - N * 2 / 3, a - x * 2 / 3, Cr.TOP_LEFT) : new ot(n.left + N * 2 / 3, n.top + x * 2 / 3), this.topRightBorderDoubleInnerBox = s > 0 || a > 0 ? zr(n.left + b, n.top + x * 2 / 3, A - C * 2 / 3, l - x * 2 / 3, Cr.TOP_RIGHT) : new ot(n.left + n.width - C * 2 / 3, n.top + x * 2 / 3), this.bottomRightBorderDoubleInnerBox = c > 0 || h > 0 ? zr(n.left + B, n.top + w, c - C * 2 / 3, h - F * 2 / 3, Cr.BOTTOM_RIGHT) : new ot(n.left + n.width - C * 2 / 3, n.top + n.height - F * 2 / 3), this.bottomLeftBorderDoubleInnerBox = d > 0 || p > 0 ? zr(n.left + N * 2 / 3, n.top + _, d - N * 2 / 3, p - F * 2 / 3, Cr.BOTTOM_LEFT) : new ot(n.left + N * 2 / 3, n.top + n.height - F * 2 / 3), this.topLeftBorderStroke = s > 0 || a > 0 ? zr(n.left + N / 2, n.top + x / 2, s - N / 2, a - x / 2, Cr.TOP_LEFT) : new ot(n.left + N / 2, n.top + x / 2), this.topRightBorderStroke = s > 0 || a > 0 ? zr(n.left + b, n.top + x / 2, A - C / 2, l - x / 2, Cr.TOP_RIGHT) : new ot(n.left + n.width - C / 2, n.top + x / 2), this.bottomRightBorderStroke = c > 0 || h > 0 ? zr(n.left + B, n.top + w, c - C / 2, h - F / 2, Cr.BOTTOM_RIGHT) : new ot(n.left + n.width - C / 2, n.top + n.height - F / 2), this.bottomLeftBorderStroke = d > 0 || p > 0 ? zr(n.left + N / 2, n.top + _, d - N / 2, p - F / 2, Cr.BOTTOM_LEFT) : new ot(n.left + N / 2, n.top + n.height - F / 2), this.topLeftBorderBox = s > 0 || a > 0 ? zr(n.left, n.top, s, a, Cr.TOP_LEFT) : new ot(n.left, n.top), this.topRightBorderBox = A > 0 || l > 0 ? zr(n.left + b, n.top, A, l, Cr.TOP_RIGHT) : new ot(n.left + n.width, n.top), this.bottomRightBorderBox = c > 0 || h > 0 ? zr(n.left + B, n.top + w, c, h, Cr.BOTTOM_RIGHT) : new ot(n.left + n.width, n.top + n.height), this.bottomLeftBorderBox = d > 0 || p > 0 ? zr(n.left, n.top + _, d, p, Cr.BOTTOM_LEFT) : new ot(n.left, n.top + n.height), this.topLeftPaddingBox = s > 0 || a > 0 ? zr(n.left + N, n.top + x, Math.max(0, s - N), Math.max(0, a - x), Cr.TOP_LEFT) : new ot(n.left + N, n.top + x), this.topRightPaddingBox = A > 0 || l > 0 ? zr(n.left + Math.min(b, n.width - C), n.top + x, b > n.width + C ? 0 : Math.max(0, A - C), Math.max(0, l - x), Cr.TOP_RIGHT) : new ot(n.left + n.width - C, n.top + x), this.bottomRightPaddingBox = c > 0 || h > 0 ? zr(n.left + Math.min(B, n.width - N), n.top + Math.min(w, n.height - F), Math.max(0, c - C), Math.max(0, h - F), Cr.BOTTOM_RIGHT) : new ot(n.left + n.width - C, n.top + n.height - F), this.bottomLeftPaddingBox = d > 0 || p > 0 ? zr(n.left + N, n.top + Math.min(_, n.height - F), Math.max(0, d - N), Math.max(0, p - F), Cr.BOTTOM_LEFT) : new ot(n.left + N, n.top + n.height - F), this.topLeftContentBox = s > 0 || a > 0 ? zr(n.left + N + L, n.top + x + D, Math.max(0, s - (N + L)), Math.max(0, a - (x + D)), Cr.TOP_LEFT) : new ot(n.left + N + L, n.top + x + D), this.topRightContentBox = A > 0 || l > 0 ? zr(n.left + Math.min(b, n.width + N + L), n.top + x + D, b > n.width + N + L ? 0 : A - N + L, l - (x + D), Cr.TOP_RIGHT) : new ot(n.left + n.width - (C + T), n.top + x + D), this.bottomRightContentBox = c > 0 || h > 0 ? zr(n.left + Math.min(B, n.width - (N + L)), n.top + Math.min(w, n.height + x + D), Math.max(0, c - (C + T)), h - (F + E), Cr.BOTTOM_RIGHT) : new ot(n.left + n.width - (C + T), n.top + n.height - (F + E)), this.bottomLeftContentBox = d > 0 || p > 0 ? zr(n.left + N + L, n.top + _, Math.max(0, d - (N + L)), p - (F + E), Cr.BOTTOM_LEFT) : new ot(n.left + N + L, n.top + n.height - (F + E));
    }
    return r;
  }()
), Cr;
(function(r) {
  r[r.TOP_LEFT = 0] = "TOP_LEFT", r[r.TOP_RIGHT = 1] = "TOP_RIGHT", r[r.BOTTOM_RIGHT = 2] = "BOTTOM_RIGHT", r[r.BOTTOM_LEFT = 3] = "BOTTOM_LEFT";
})(Cr || (Cr = {}));
var zr = function(r, e, t, n, i) {
  var s = 4 * ((Math.sqrt(2) - 1) / 3), a = t * s, o = n * s, A = r + t, l = e + n;
  switch (i) {
    case Cr.TOP_LEFT:
      return new Fd(new ot(r, l), new ot(r, l - o), new ot(A - a, e), new ot(A, e));
    case Cr.TOP_RIGHT:
      return new Fd(new ot(r, e), new ot(r + a, e), new ot(A, l - o), new ot(A, l));
    case Cr.BOTTOM_RIGHT:
      return new Fd(new ot(A, e), new ot(A, e + o), new ot(r + a, l), new ot(r, l));
    case Cr.BOTTOM_LEFT:
    default:
      return new Fd(new ot(A, l), new ot(A - a, l), new ot(r, e + o), new ot(r, e));
  }
}, jp = function(r) {
  return [r.topLeftBorderBox, r.topRightBorderBox, r.bottomRightBorderBox, r.bottomLeftBorderBox];
}, SG = function(r) {
  return [
    r.topLeftContentBox,
    r.topRightContentBox,
    r.bottomRightContentBox,
    r.bottomLeftContentBox
  ];
}, Kp = function(r) {
  return [
    r.topLeftPaddingBox,
    r.topRightPaddingBox,
    r.bottomRightPaddingBox,
    r.bottomLeftPaddingBox
  ];
}, IG = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e, t, n) {
      this.offsetX = e, this.offsetY = t, this.matrix = n, this.type = 0, this.target = 6;
    }
    return r;
  }()
), Td = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e, t) {
      this.path = e, this.target = t, this.type = 1;
    }
    return r;
  }()
), FG = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e) {
      this.opacity = e, this.type = 2, this.target = 6;
    }
    return r;
  }()
), TG = function(r) {
  return r.type === 0;
}, pF = function(r) {
  return r.type === 1;
}, xG = function(r) {
  return r.type === 2;
}, XC = function(r, e) {
  return r.length === e.length ? r.some(function(t, n) {
    return t === e[n];
  }) : !1;
}, kG = function(r, e, t, n, i) {
  return r.map(function(s, a) {
    switch (a) {
      case 0:
        return s.add(e, t);
      case 1:
        return s.add(e + n, t);
      case 2:
        return s.add(e + n, t + i);
      case 3:
        return s.add(e, t + i);
    }
    return s;
  });
}, gF = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e) {
      this.element = e, this.inlineLevel = [], this.nonInlineLevel = [], this.negativeZIndex = [], this.zeroOrAutoZIndexOrTransformedOrOpacity = [], this.positiveZIndex = [], this.nonPositionedFloats = [], this.nonPositionedInlineLevel = [];
    }
    return r;
  }()
), mF = (
  /** @class */
  function() {
    function r(e, t) {
      if (this.container = e, this.parent = t, this.effects = [], this.curves = new EG(this.container), this.container.styles.opacity < 1 && this.effects.push(new FG(this.container.styles.opacity)), this.container.styles.transform !== null) {
        var n = this.container.bounds.left + this.container.styles.transformOrigin[0].number, i = this.container.bounds.top + this.container.styles.transformOrigin[1].number, s = this.container.styles.transform;
        this.effects.push(new IG(n, i, s));
      }
      if (this.container.styles.overflowX !== 0) {
        var a = jp(this.curves), o = Kp(this.curves);
        XC(a, o) ? this.effects.push(new Td(
          a,
          6
          /* CONTENT */
        )) : (this.effects.push(new Td(
          a,
          2
          /* BACKGROUND_BORDERS */
        )), this.effects.push(new Td(
          o,
          4
          /* CONTENT */
        )));
      }
    }
    return r.prototype.getEffects = function(e) {
      for (var t = [
        2,
        3
        /* FIXED */
      ].indexOf(this.container.styles.position) === -1, n = this.parent, i = this.effects.slice(0); n; ) {
        var s = n.effects.filter(function(A) {
          return !pF(A);
        });
        if (t || n.container.styles.position !== 0 || !n.parent) {
          if (i.unshift.apply(i, s), t = [
            2,
            3
            /* FIXED */
          ].indexOf(n.container.styles.position) === -1, n.container.styles.overflowX !== 0) {
            var a = jp(n.curves), o = Kp(n.curves);
            XC(a, o) || i.unshift(new Td(
              o,
              6
              /* CONTENT */
            ));
          }
        } else
          i.unshift.apply(i, s);
        n = n.parent;
      }
      return i.filter(function(A) {
        return Rn(A.target, e);
      });
    }, r;
  }()
), Wv = function(r, e, t, n) {
  r.container.elements.forEach(function(i) {
    var s = Rn(
      i.flags,
      4
      /* CREATES_REAL_STACKING_CONTEXT */
    ), a = Rn(
      i.flags,
      2
      /* CREATES_STACKING_CONTEXT */
    ), o = new mF(i, r);
    Rn(
      i.styles.display,
      2048
      /* LIST_ITEM */
    ) && n.push(o);
    var A = Rn(
      i.flags,
      8
      /* IS_LIST_OWNER */
    ) ? [] : n;
    if (s || a) {
      var l = s || i.styles.isPositioned() ? t : e, u = new gF(o);
      if (i.styles.isPositioned() || i.styles.opacity < 1 || i.styles.isTransformed()) {
        var c = i.styles.zIndex.order;
        if (c < 0) {
          var h = 0;
          l.negativeZIndex.some(function(d, p) {
            return c > d.element.container.styles.zIndex.order ? (h = p, !1) : h > 0;
          }), l.negativeZIndex.splice(h, 0, u);
        } else if (c > 0) {
          var f = 0;
          l.positiveZIndex.some(function(d, p) {
            return c >= d.element.container.styles.zIndex.order ? (f = p + 1, !1) : f > 0;
          }), l.positiveZIndex.splice(f, 0, u);
        } else
          l.zeroOrAutoZIndexOrTransformedOrOpacity.push(u);
      } else
        i.styles.isFloating() ? l.nonPositionedFloats.push(u) : l.nonPositionedInlineLevel.push(u);
      Wv(o, u, s ? u : t, A);
    } else
      i.styles.isInlineLevel() ? e.inlineLevel.push(o) : e.nonInlineLevel.push(o), Wv(o, e, t, A);
    Rn(
      i.flags,
      8
      /* IS_LIST_OWNER */
    ) && vF(i, A);
  });
}, vF = function(r, e) {
  for (var t = r instanceof $v ? r.start : 1, n = r instanceof $v ? r.reversed : !1, i = 0; i < e.length; i++) {
    var s = e[i];
    s.container instanceof tF && typeof s.container.value == "number" && s.container.value !== 0 && (t = s.container.value), s.listValue = kf(t, s.container.styles.listStyleType, !0), t += n ? -1 : 1;
  }
}, LG = function(r) {
  var e = new mF(r, null), t = new gF(e), n = [];
  return Wv(e, t, t, n), vF(e.container, n), t;
}, JC = function(r, e) {
  switch (e) {
    case 0:
      return Ls(r.topLeftBorderBox, r.topLeftPaddingBox, r.topRightBorderBox, r.topRightPaddingBox);
    case 1:
      return Ls(r.topRightBorderBox, r.topRightPaddingBox, r.bottomRightBorderBox, r.bottomRightPaddingBox);
    case 2:
      return Ls(r.bottomRightBorderBox, r.bottomRightPaddingBox, r.bottomLeftBorderBox, r.bottomLeftPaddingBox);
    case 3:
    default:
      return Ls(r.bottomLeftBorderBox, r.bottomLeftPaddingBox, r.topLeftBorderBox, r.topLeftPaddingBox);
  }
}, UG = function(r, e) {
  switch (e) {
    case 0:
      return Ls(r.topLeftBorderBox, r.topLeftBorderDoubleOuterBox, r.topRightBorderBox, r.topRightBorderDoubleOuterBox);
    case 1:
      return Ls(r.topRightBorderBox, r.topRightBorderDoubleOuterBox, r.bottomRightBorderBox, r.bottomRightBorderDoubleOuterBox);
    case 2:
      return Ls(r.bottomRightBorderBox, r.bottomRightBorderDoubleOuterBox, r.bottomLeftBorderBox, r.bottomLeftBorderDoubleOuterBox);
    case 3:
    default:
      return Ls(r.bottomLeftBorderBox, r.bottomLeftBorderDoubleOuterBox, r.topLeftBorderBox, r.topLeftBorderDoubleOuterBox);
  }
}, NG = function(r, e) {
  switch (e) {
    case 0:
      return Ls(r.topLeftBorderDoubleInnerBox, r.topLeftPaddingBox, r.topRightBorderDoubleInnerBox, r.topRightPaddingBox);
    case 1:
      return Ls(r.topRightBorderDoubleInnerBox, r.topRightPaddingBox, r.bottomRightBorderDoubleInnerBox, r.bottomRightPaddingBox);
    case 2:
      return Ls(r.bottomRightBorderDoubleInnerBox, r.bottomRightPaddingBox, r.bottomLeftBorderDoubleInnerBox, r.bottomLeftPaddingBox);
    case 3:
    default:
      return Ls(r.bottomLeftBorderDoubleInnerBox, r.bottomLeftPaddingBox, r.topLeftBorderDoubleInnerBox, r.topLeftPaddingBox);
  }
}, OG = function(r, e) {
  switch (e) {
    case 0:
      return xd(r.topLeftBorderStroke, r.topRightBorderStroke);
    case 1:
      return xd(r.topRightBorderStroke, r.bottomRightBorderStroke);
    case 2:
      return xd(r.bottomRightBorderStroke, r.bottomLeftBorderStroke);
    case 3:
    default:
      return xd(r.bottomLeftBorderStroke, r.topLeftBorderStroke);
  }
}, xd = function(r, e) {
  var t = [];
  return Fs(r) ? t.push(r.subdivide(0.5, !1)) : t.push(r), Fs(e) ? t.push(e.subdivide(0.5, !0)) : t.push(e), t;
}, Ls = function(r, e, t, n) {
  var i = [];
  return Fs(r) ? i.push(r.subdivide(0.5, !1)) : i.push(r), Fs(t) ? i.push(t.subdivide(0.5, !0)) : i.push(t), Fs(n) ? i.push(n.subdivide(0.5, !0).reverse()) : i.push(n), Fs(e) ? i.push(e.subdivide(0.5, !1).reverse()) : i.push(e), i;
}, bF = function(r) {
  var e = r.bounds, t = r.styles;
  return e.add(t.borderLeftWidth, t.borderTopWidth, -(t.borderRightWidth + t.borderLeftWidth), -(t.borderTopWidth + t.borderBottomWidth));
}, $p = function(r) {
  var e = r.styles, t = r.bounds, n = Hr(e.paddingLeft, t.width), i = Hr(e.paddingRight, t.width), s = Hr(e.paddingTop, t.width), a = Hr(e.paddingBottom, t.width);
  return t.add(n + e.borderLeftWidth, s + e.borderTopWidth, -(e.borderRightWidth + e.borderLeftWidth + n + i), -(e.borderTopWidth + e.borderBottomWidth + s + a));
}, QG = function(r, e) {
  return r === 0 ? e.bounds : r === 2 ? $p(e) : bF(e);
}, DG = function(r, e) {
  return r === 0 ? e.bounds : r === 2 ? $p(e) : bF(e);
}, D0 = function(r, e, t) {
  var n = QG(lu(r.styles.backgroundOrigin, e), r), i = DG(lu(r.styles.backgroundClip, e), r), s = MG(lu(r.styles.backgroundSize, e), t, n), a = s[0], o = s[1], A = jc(lu(r.styles.backgroundPosition, e), n.width - a, n.height - o), l = RG(lu(r.styles.backgroundRepeat, e), A, s, n, i), u = Math.round(n.left + A[0]), c = Math.round(n.top + A[1]);
  return [l, u, c, a, o];
}, Yl = function(r) {
  return Tr(r) && r.value === _u.AUTO;
}, kd = function(r) {
  return typeof r == "number";
}, MG = function(r, e, t) {
  var n = e[0], i = e[1], s = e[2], a = r[0], o = r[1];
  if (!a)
    return [0, 0];
  if (Ln(a) && o && Ln(o))
    return [Hr(a, t.width), Hr(o, t.height)];
  var A = kd(s);
  if (Tr(a) && (a.value === _u.CONTAIN || a.value === _u.COVER)) {
    if (kd(s)) {
      var l = t.width / t.height;
      return l < s != (a.value === _u.COVER) ? [t.width, t.width / s] : [t.height * s, t.height];
    }
    return [t.width, t.height];
  }
  var u = kd(n), c = kd(i), h = u || c;
  if (Yl(a) && (!o || Yl(o))) {
    if (u && c)
      return [n, i];
    if (!A && !h)
      return [t.width, t.height];
    if (h && A) {
      var f = u ? n : i * s, d = c ? i : n / s;
      return [f, d];
    }
    var p = u ? n : t.width, v = c ? i : t.height;
    return [p, v];
  }
  if (A) {
    var m = 0, b = 0;
    return Ln(a) ? m = Hr(a, t.width) : Ln(o) && (b = Hr(o, t.height)), Yl(a) ? m = b * s : (!o || Yl(o)) && (b = m / s), [m, b];
  }
  var w = null, B = null;
  if (Ln(a) ? w = Hr(a, t.width) : o && Ln(o) && (B = Hr(o, t.height)), w !== null && (!o || Yl(o)) && (B = u && c ? w / n * i : t.height), B !== null && Yl(a) && (w = u && c ? B / i * n : t.width), w !== null && B !== null)
    return [w, B];
  throw new Error("Unable to calculate background-size for element");
}, lu = function(r, e) {
  var t = r[e];
  return typeof t > "u" ? r[0] : t;
}, RG = function(r, e, t, n, i) {
  var s = e[0], a = e[1], o = t[0], A = t[1];
  switch (r) {
    case 2:
      return [
        new ot(Math.round(n.left), Math.round(n.top + a)),
        new ot(Math.round(n.left + n.width), Math.round(n.top + a)),
        new ot(Math.round(n.left + n.width), Math.round(A + n.top + a)),
        new ot(Math.round(n.left), Math.round(A + n.top + a))
      ];
    case 3:
      return [
        new ot(Math.round(n.left + s), Math.round(n.top)),
        new ot(Math.round(n.left + s + o), Math.round(n.top)),
        new ot(Math.round(n.left + s + o), Math.round(n.height + n.top)),
        new ot(Math.round(n.left + s), Math.round(n.height + n.top))
      ];
    case 1:
      return [
        new ot(Math.round(n.left + s), Math.round(n.top + a)),
        new ot(Math.round(n.left + s + o), Math.round(n.top + a)),
        new ot(Math.round(n.left + s + o), Math.round(n.top + a + A)),
        new ot(Math.round(n.left + s), Math.round(n.top + a + A))
      ];
    default:
      return [
        new ot(Math.round(i.left), Math.round(i.top)),
        new ot(Math.round(i.left + i.width), Math.round(i.top)),
        new ot(Math.round(i.left + i.width), Math.round(i.height + i.top)),
        new ot(Math.round(i.left), Math.round(i.height + i.top))
      ];
  }
}, PG = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", YC = "Hidden Text", HG = (
  /** @class */
  function() {
    function r(e) {
      this._data = {}, this._document = e;
    }
    return r.prototype.parseMetrics = function(e, t) {
      var n = this._document.createElement("div"), i = this._document.createElement("img"), s = this._document.createElement("span"), a = this._document.body;
      n.style.visibility = "hidden", n.style.fontFamily = e, n.style.fontSize = t, n.style.margin = "0", n.style.padding = "0", n.style.whiteSpace = "nowrap", a.appendChild(n), i.src = PG, i.width = 1, i.height = 1, i.style.margin = "0", i.style.padding = "0", i.style.verticalAlign = "baseline", s.style.fontFamily = e, s.style.fontSize = t, s.style.margin = "0", s.style.padding = "0", s.appendChild(this._document.createTextNode(YC)), n.appendChild(s), n.appendChild(i);
      var o = i.offsetTop - s.offsetTop + 2;
      n.removeChild(s), n.appendChild(this._document.createTextNode(YC)), n.style.lineHeight = "normal", i.style.verticalAlign = "super";
      var A = i.offsetTop - n.offsetTop + 2;
      return a.removeChild(n), { baseline: o, middle: A };
    }, r.prototype.getMetrics = function(e, t) {
      var n = e + " " + t;
      return typeof this._data[n] > "u" && (this._data[n] = this.parseMetrics(e, t)), this._data[n];
    }, r;
  }()
), yF = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e, t) {
      this.context = e, this.options = t;
    }
    return r;
  }()
), jG = 1e4, KG = (
  /** @class */
  function(r) {
    ua(e, r);
    function e(t, n) {
      var i = r.call(this, t, n) || this;
      return i._activeEffects = [], i.canvas = n.canvas ? n.canvas : document.createElement("canvas"), i.ctx = i.canvas.getContext("2d"), n.canvas || (i.canvas.width = Math.floor(n.width * n.scale), i.canvas.height = Math.floor(n.height * n.scale), i.canvas.style.width = n.width + "px", i.canvas.style.height = n.height + "px"), i.fontMetrics = new HG(document), i.ctx.scale(i.options.scale, i.options.scale), i.ctx.translate(-n.x, -n.y), i.ctx.textBaseline = "bottom", i._activeEffects = [], i.context.logger.debug("Canvas renderer initialized (" + n.width + "x" + n.height + ") with scale " + n.scale), i;
    }
    return e.prototype.applyEffects = function(t) {
      for (var n = this; this._activeEffects.length; )
        this.popEffect();
      t.forEach(function(i) {
        return n.applyEffect(i);
      });
    }, e.prototype.applyEffect = function(t) {
      this.ctx.save(), xG(t) && (this.ctx.globalAlpha = t.opacity), TG(t) && (this.ctx.translate(t.offsetX, t.offsetY), this.ctx.transform(t.matrix[0], t.matrix[1], t.matrix[2], t.matrix[3], t.matrix[4], t.matrix[5]), this.ctx.translate(-t.offsetX, -t.offsetY)), pF(t) && (this.path(t.path), this.ctx.clip()), this._activeEffects.push(t);
    }, e.prototype.popEffect = function() {
      this._activeEffects.pop(), this.ctx.restore();
    }, e.prototype.renderStack = function(t) {
      return Ui(this, void 0, void 0, function() {
        var n;
        return wi(this, function(i) {
          switch (i.label) {
            case 0:
              return n = t.element.container.styles, n.isVisible() ? [4, this.renderStackContent(t)] : [3, 2];
            case 1:
              i.sent(), i.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.renderNode = function(t) {
      return Ui(this, void 0, void 0, function() {
        return wi(this, function(n) {
          switch (n.label) {
            case 0:
              if (Rn(
                t.container.flags,
                16
                /* DEBUG_RENDER */
              ))
                debugger;
              return t.container.styles.isVisible() ? [4, this.renderNodeBackgroundAndBorders(t)] : [3, 3];
            case 1:
              return n.sent(), [4, this.renderNodeContent(t)];
            case 2:
              n.sent(), n.label = 3;
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.renderTextWithLetterSpacing = function(t, n, i) {
      var s = this;
      if (n === 0)
        this.ctx.fillText(t.text, t.bounds.left, t.bounds.top + i);
      else {
        var a = Bb(t.text);
        a.reduce(function(o, A) {
          return s.ctx.fillText(A, o, t.bounds.top + i), o + s.ctx.measureText(A).width;
        }, t.bounds.left);
      }
    }, e.prototype.createFontStyle = function(t) {
      var n = t.fontVariant.filter(function(a) {
        return a === "normal" || a === "small-caps";
      }).join(""), i = qG(t.fontFamily).join(", "), s = jf(t.fontSize) ? "" + t.fontSize.number + t.fontSize.unit : t.fontSize.number + "px";
      return [
        [t.fontStyle, n, t.fontWeight, s, i].join(" "),
        i,
        s
      ];
    }, e.prototype.renderTextNode = function(t, n) {
      return Ui(this, void 0, void 0, function() {
        var i, s, a, o, A, l, u, c, h = this;
        return wi(this, function(f) {
          return i = this.createFontStyle(n), s = i[0], a = i[1], o = i[2], this.ctx.font = s, this.ctx.direction = n.direction === 1 ? "rtl" : "ltr", this.ctx.textAlign = "left", this.ctx.textBaseline = "alphabetic", A = this.fontMetrics.getMetrics(a, o), l = A.baseline, u = A.middle, c = n.paintOrder, t.textBounds.forEach(function(d) {
            c.forEach(function(p) {
              switch (p) {
                case 0:
                  h.ctx.fillStyle = $n(n.color), h.renderTextWithLetterSpacing(d, n.letterSpacing, l);
                  var v = n.textShadow;
                  v.length && d.text.trim().length && (v.slice(0).reverse().forEach(function(m) {
                    h.ctx.shadowColor = $n(m.color), h.ctx.shadowOffsetX = m.offsetX.number * h.options.scale, h.ctx.shadowOffsetY = m.offsetY.number * h.options.scale, h.ctx.shadowBlur = m.blur.number, h.renderTextWithLetterSpacing(d, n.letterSpacing, l);
                  }), h.ctx.shadowColor = "", h.ctx.shadowOffsetX = 0, h.ctx.shadowOffsetY = 0, h.ctx.shadowBlur = 0), n.textDecorationLine.length && (h.ctx.fillStyle = $n(n.textDecorationColor || n.color), n.textDecorationLine.forEach(function(m) {
                    switch (m) {
                      case 1:
                        h.ctx.fillRect(d.bounds.left, Math.round(d.bounds.top + l), d.bounds.width, 1);
                        break;
                      case 2:
                        h.ctx.fillRect(d.bounds.left, Math.round(d.bounds.top), d.bounds.width, 1);
                        break;
                      case 3:
                        h.ctx.fillRect(d.bounds.left, Math.ceil(d.bounds.top + u), d.bounds.width, 1);
                        break;
                    }
                  }));
                  break;
                case 1:
                  n.webkitTextStrokeWidth && d.text.trim().length && (h.ctx.strokeStyle = $n(n.webkitTextStrokeColor), h.ctx.lineWidth = n.webkitTextStrokeWidth, h.ctx.lineJoin = window.chrome ? "miter" : "round", h.ctx.strokeText(d.text, d.bounds.left, d.bounds.top + l)), h.ctx.strokeStyle = "", h.ctx.lineWidth = 0, h.ctx.lineJoin = "miter";
                  break;
              }
            });
          }), [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.renderReplacedElement = function(t, n, i) {
      if (i && t.intrinsicWidth > 0 && t.intrinsicHeight > 0) {
        var s = $p(t), a = Kp(n);
        this.path(a), this.ctx.save(), this.ctx.clip(), this.ctx.drawImage(i, 0, 0, t.intrinsicWidth, t.intrinsicHeight, s.left, s.top, s.width, s.height), this.ctx.restore();
      }
    }, e.prototype.renderNodeContent = function(t) {
      return Ui(this, void 0, void 0, function() {
        var n, i, s, a, o, A, b, b, l, u, c, h, B, f, d, _, p, v, m, b, w, B, _;
        return wi(this, function(x) {
          switch (x.label) {
            case 0:
              this.applyEffects(t.getEffects(
                4
                /* CONTENT */
              )), n = t.container, i = t.curves, s = n.styles, a = 0, o = n.textNodes, x.label = 1;
            case 1:
              return a < o.length ? (A = o[a], [4, this.renderTextNode(A, s)]) : [3, 4];
            case 2:
              x.sent(), x.label = 3;
            case 3:
              return a++, [3, 1];
            case 4:
              if (!(n instanceof YI)) return [3, 8];
              x.label = 5;
            case 5:
              return x.trys.push([5, 7, , 8]), [4, this.context.cache.match(n.src)];
            case 6:
              return b = x.sent(), this.renderReplacedElement(n, i, b), [3, 8];
            case 7:
              return x.sent(), this.context.logger.error("Error loading image " + n.src), [3, 8];
            case 8:
              if (n instanceof ZI && this.renderReplacedElement(n, i, n.canvas), !(n instanceof eF)) return [3, 12];
              x.label = 9;
            case 9:
              return x.trys.push([9, 11, , 12]), [4, this.context.cache.match(n.svg)];
            case 10:
              return b = x.sent(), this.renderReplacedElement(n, i, b), [3, 12];
            case 11:
              return x.sent(), this.context.logger.error("Error loading svg " + n.svg.substring(0, 255)), [3, 12];
            case 12:
              return n instanceof iF && n.tree ? (l = new e(this.context, {
                scale: this.options.scale,
                backgroundColor: n.backgroundColor,
                x: 0,
                y: 0,
                width: n.width,
                height: n.height
              }), [4, l.render(n.tree)]) : [3, 14];
            case 13:
              u = x.sent(), n.width && n.height && this.ctx.drawImage(u, 0, 0, n.width, n.height, n.bounds.left, n.bounds.top, n.bounds.width, n.bounds.height), x.label = 14;
            case 14:
              if (n instanceof Cb && (c = Math.min(n.bounds.width, n.bounds.height), n.type === Mp ? n.checked && (this.ctx.save(), this.path([
                new ot(n.bounds.left + c * 0.39363, n.bounds.top + c * 0.79),
                new ot(n.bounds.left + c * 0.16, n.bounds.top + c * 0.5549),
                new ot(n.bounds.left + c * 0.27347, n.bounds.top + c * 0.44071),
                new ot(n.bounds.left + c * 0.39694, n.bounds.top + c * 0.5649),
                new ot(n.bounds.left + c * 0.72983, n.bounds.top + c * 0.23),
                new ot(n.bounds.left + c * 0.84, n.bounds.top + c * 0.34085),
                new ot(n.bounds.left + c * 0.39363, n.bounds.top + c * 0.79)
              ]), this.ctx.fillStyle = $n(RC), this.ctx.fill(), this.ctx.restore()) : n.type === Rp && n.checked && (this.ctx.save(), this.ctx.beginPath(), this.ctx.arc(n.bounds.left + c / 2, n.bounds.top + c / 2, c / 4, 0, Math.PI * 2, !0), this.ctx.fillStyle = $n(RC), this.ctx.fill(), this.ctx.restore())), $G(n) && n.value.length) {
                switch (h = this.createFontStyle(s), B = h[0], f = h[1], d = this.fontMetrics.getMetrics(B, f).baseline, this.ctx.font = B, this.ctx.fillStyle = $n(s.color), this.ctx.textBaseline = "alphabetic", this.ctx.textAlign = zG(n.styles.textAlign), _ = $p(n), p = 0, n.styles.textAlign) {
                  case 1:
                    p += _.width / 2;
                    break;
                  case 2:
                    p += _.width;
                    break;
                }
                v = _.add(p, 0, 0, -_.height / 2 + 1), this.ctx.save(), this.path([
                  new ot(_.left, _.top),
                  new ot(_.left + _.width, _.top),
                  new ot(_.left + _.width, _.top + _.height),
                  new ot(_.left, _.top + _.height)
                ]), this.ctx.clip(), this.renderTextWithLetterSpacing(new uf(n.value, v), s.letterSpacing, d), this.ctx.restore(), this.ctx.textBaseline = "alphabetic", this.ctx.textAlign = "left";
              }
              if (!Rn(
                n.styles.display,
                2048
                /* LIST_ITEM */
              )) return [3, 20];
              if (n.styles.listStyleImage === null) return [3, 19];
              if (m = n.styles.listStyleImage, m.type !== 0) return [3, 18];
              b = void 0, w = m.url, x.label = 15;
            case 15:
              return x.trys.push([15, 17, , 18]), [4, this.context.cache.match(w)];
            case 16:
              return b = x.sent(), this.ctx.drawImage(b, n.bounds.left - (b.width + 10), n.bounds.top), [3, 18];
            case 17:
              return x.sent(), this.context.logger.error("Error loading list-style-image " + w), [3, 18];
            case 18:
              return [3, 20];
            case 19:
              t.listValue && n.styles.listStyleType !== -1 && (B = this.createFontStyle(s)[0], this.ctx.font = B, this.ctx.fillStyle = $n(s.color), this.ctx.textBaseline = "middle", this.ctx.textAlign = "right", _ = new lo(n.bounds.left, n.bounds.top + Hr(n.styles.paddingTop, n.bounds.width), n.bounds.width, BC(s.lineHeight, s.fontSize.number) / 2 + 1), this.renderTextWithLetterSpacing(new uf(t.listValue, _), s.letterSpacing, BC(s.lineHeight, s.fontSize.number) / 2 + 2), this.ctx.textBaseline = "bottom", this.ctx.textAlign = "left"), x.label = 20;
            case 20:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.renderStackContent = function(t) {
      return Ui(this, void 0, void 0, function() {
        var n, i, m, s, a, m, o, A, m, l, u, m, c, h, m, f, d, m, p, v, m;
        return wi(this, function(b) {
          switch (b.label) {
            case 0:
              if (Rn(
                t.element.container.flags,
                16
                /* DEBUG_RENDER */
              ))
                debugger;
              return [4, this.renderNodeBackgroundAndBorders(t.element)];
            case 1:
              b.sent(), n = 0, i = t.negativeZIndex, b.label = 2;
            case 2:
              return n < i.length ? (m = i[n], [4, this.renderStack(m)]) : [3, 5];
            case 3:
              b.sent(), b.label = 4;
            case 4:
              return n++, [3, 2];
            case 5:
              return [4, this.renderNodeContent(t.element)];
            case 6:
              b.sent(), s = 0, a = t.nonInlineLevel, b.label = 7;
            case 7:
              return s < a.length ? (m = a[s], [4, this.renderNode(m)]) : [3, 10];
            case 8:
              b.sent(), b.label = 9;
            case 9:
              return s++, [3, 7];
            case 10:
              o = 0, A = t.nonPositionedFloats, b.label = 11;
            case 11:
              return o < A.length ? (m = A[o], [4, this.renderStack(m)]) : [3, 14];
            case 12:
              b.sent(), b.label = 13;
            case 13:
              return o++, [3, 11];
            case 14:
              l = 0, u = t.nonPositionedInlineLevel, b.label = 15;
            case 15:
              return l < u.length ? (m = u[l], [4, this.renderStack(m)]) : [3, 18];
            case 16:
              b.sent(), b.label = 17;
            case 17:
              return l++, [3, 15];
            case 18:
              c = 0, h = t.inlineLevel, b.label = 19;
            case 19:
              return c < h.length ? (m = h[c], [4, this.renderNode(m)]) : [3, 22];
            case 20:
              b.sent(), b.label = 21;
            case 21:
              return c++, [3, 19];
            case 22:
              f = 0, d = t.zeroOrAutoZIndexOrTransformedOrOpacity, b.label = 23;
            case 23:
              return f < d.length ? (m = d[f], [4, this.renderStack(m)]) : [3, 26];
            case 24:
              b.sent(), b.label = 25;
            case 25:
              return f++, [3, 23];
            case 26:
              p = 0, v = t.positiveZIndex, b.label = 27;
            case 27:
              return p < v.length ? (m = v[p], [4, this.renderStack(m)]) : [3, 30];
            case 28:
              b.sent(), b.label = 29;
            case 29:
              return p++, [3, 27];
            case 30:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.mask = function(t) {
      this.ctx.beginPath(), this.ctx.moveTo(0, 0), this.ctx.lineTo(this.canvas.width, 0), this.ctx.lineTo(this.canvas.width, this.canvas.height), this.ctx.lineTo(0, this.canvas.height), this.ctx.lineTo(0, 0), this.formatPath(t.slice(0).reverse()), this.ctx.closePath();
    }, e.prototype.path = function(t) {
      this.ctx.beginPath(), this.formatPath(t), this.ctx.closePath();
    }, e.prototype.formatPath = function(t) {
      var n = this;
      t.forEach(function(i, s) {
        var a = Fs(i) ? i.start : i;
        s === 0 ? n.ctx.moveTo(a.x, a.y) : n.ctx.lineTo(a.x, a.y), Fs(i) && n.ctx.bezierCurveTo(i.startControl.x, i.startControl.y, i.endControl.x, i.endControl.y, i.end.x, i.end.y);
      });
    }, e.prototype.renderRepeat = function(t, n, i, s) {
      this.path(t), this.ctx.fillStyle = n, this.ctx.translate(i, s), this.ctx.fill(), this.ctx.translate(-i, -s);
    }, e.prototype.resizeImage = function(t, n, i) {
      var s;
      if (t.width === n && t.height === i)
        return t;
      var a = (s = this.canvas.ownerDocument) !== null && s !== void 0 ? s : document, o = a.createElement("canvas");
      o.width = Math.max(1, n), o.height = Math.max(1, i);
      var A = o.getContext("2d");
      return A.drawImage(t, 0, 0, t.width, t.height, 0, 0, n, i), o;
    }, e.prototype.renderBackgroundImage = function(t) {
      return Ui(this, void 0, void 0, function() {
        var n, i, s, a, o, A;
        return wi(this, function(l) {
          switch (l.label) {
            case 0:
              n = t.styles.backgroundImage.length - 1, i = function(u) {
                var c, h, f, D, z, R, L, S, F, d, D, z, R, L, S, p, v, m, b, w, B, _, x, C, F, N, D, T, E, L, S, X, z, R, V, O, J, Z, U, P, H, $;
                return wi(this, function(ie) {
                  switch (ie.label) {
                    case 0:
                      if (u.type !== 0) return [3, 5];
                      c = void 0, h = u.url, ie.label = 1;
                    case 1:
                      return ie.trys.push([1, 3, , 4]), [4, s.context.cache.match(h)];
                    case 2:
                      return c = ie.sent(), [3, 4];
                    case 3:
                      return ie.sent(), s.context.logger.error("Error loading background-image " + h), [3, 4];
                    case 4:
                      return c && (f = D0(t, n, [
                        c.width,
                        c.height,
                        c.width / c.height
                      ]), D = f[0], z = f[1], R = f[2], L = f[3], S = f[4], F = s.ctx.createPattern(s.resizeImage(c, L, S), "repeat"), s.renderRepeat(D, F, z, R)), [3, 6];
                    case 5:
                      T$(u) ? (d = D0(t, n, [null, null, null]), D = d[0], z = d[1], R = d[2], L = d[3], S = d[4], p = _$(u.angle, L, S), v = p[0], m = p[1], b = p[2], w = p[3], B = p[4], _ = document.createElement("canvas"), _.width = L, _.height = S, x = _.getContext("2d"), C = x.createLinearGradient(m, w, b, B), yC(u.stops, v).forEach(function(ue) {
                        return C.addColorStop(ue.stop, $n(ue.color));
                      }), x.fillStyle = C, x.fillRect(0, 0, L, S), L > 0 && S > 0 && (F = s.ctx.createPattern(_, "repeat"), s.renderRepeat(D, F, z, R))) : x$(u) && (N = D0(t, n, [
                        null,
                        null,
                        null
                      ]), D = N[0], T = N[1], E = N[2], L = N[3], S = N[4], X = u.position.length === 0 ? [bb] : u.position, z = Hr(X[0], L), R = Hr(X[X.length - 1], S), V = E$(u, z, R, L, S), O = V[0], J = V[1], O > 0 && J > 0 && (Z = s.ctx.createRadialGradient(T + z, E + R, 0, T + z, E + R, O), yC(u.stops, O * 2).forEach(function(ue) {
                        return Z.addColorStop(ue.stop, $n(ue.color));
                      }), s.path(D), s.ctx.fillStyle = Z, O !== J ? (U = t.bounds.left + 0.5 * t.bounds.width, P = t.bounds.top + 0.5 * t.bounds.height, H = J / O, $ = 1 / H, s.ctx.save(), s.ctx.translate(U, P), s.ctx.transform(1, 0, 0, H, 0, 0), s.ctx.translate(-U, -P), s.ctx.fillRect(T, $ * (E - P) + P, L, S * $), s.ctx.restore()) : s.ctx.fill())), ie.label = 6;
                    case 6:
                      return n--, [
                        2
                        /*return*/
                      ];
                  }
                });
              }, s = this, a = 0, o = t.styles.backgroundImage.slice(0).reverse(), l.label = 1;
            case 1:
              return a < o.length ? (A = o[a], [5, i(A)]) : [3, 4];
            case 2:
              l.sent(), l.label = 3;
            case 3:
              return a++, [3, 1];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.renderSolidBorder = function(t, n, i) {
      return Ui(this, void 0, void 0, function() {
        return wi(this, function(s) {
          return this.path(JC(i, n)), this.ctx.fillStyle = $n(t), this.ctx.fill(), [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.renderDoubleBorder = function(t, n, i, s) {
      return Ui(this, void 0, void 0, function() {
        var a, o;
        return wi(this, function(A) {
          switch (A.label) {
            case 0:
              return n < 3 ? [4, this.renderSolidBorder(t, i, s)] : [3, 2];
            case 1:
              return A.sent(), [
                2
                /*return*/
              ];
            case 2:
              return a = UG(s, i), this.path(a), this.ctx.fillStyle = $n(t), this.ctx.fill(), o = NG(s, i), this.path(o), this.ctx.fill(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.renderNodeBackgroundAndBorders = function(t) {
      return Ui(this, void 0, void 0, function() {
        var n, i, s, a, o, A, l, u, c = this;
        return wi(this, function(h) {
          switch (h.label) {
            case 0:
              return this.applyEffects(t.getEffects(
                2
                /* BACKGROUND_BORDERS */
              )), n = t.container.styles, i = !nA(n.backgroundColor) || n.backgroundImage.length, s = [
                { style: n.borderTopStyle, color: n.borderTopColor, width: n.borderTopWidth },
                { style: n.borderRightStyle, color: n.borderRightColor, width: n.borderRightWidth },
                { style: n.borderBottomStyle, color: n.borderBottomColor, width: n.borderBottomWidth },
                { style: n.borderLeftStyle, color: n.borderLeftColor, width: n.borderLeftWidth }
              ], a = VG(lu(n.backgroundClip, 0), t.curves), i || n.boxShadow.length ? (this.ctx.save(), this.path(a), this.ctx.clip(), nA(n.backgroundColor) || (this.ctx.fillStyle = $n(n.backgroundColor), this.ctx.fill()), [4, this.renderBackgroundImage(t.container)]) : [3, 2];
            case 1:
              h.sent(), this.ctx.restore(), n.boxShadow.slice(0).reverse().forEach(function(f) {
                c.ctx.save();
                var d = jp(t.curves), p = f.inset ? 0 : jG, v = kG(d, -p + (f.inset ? 1 : -1) * f.spread.number, (f.inset ? 1 : -1) * f.spread.number, f.spread.number * (f.inset ? -2 : 2), f.spread.number * (f.inset ? -2 : 2));
                f.inset ? (c.path(d), c.ctx.clip(), c.mask(v)) : (c.mask(d), c.ctx.clip(), c.path(v)), c.ctx.shadowOffsetX = f.offsetX.number + p, c.ctx.shadowOffsetY = f.offsetY.number, c.ctx.shadowColor = $n(f.color), c.ctx.shadowBlur = f.blur.number, c.ctx.fillStyle = f.inset ? $n(f.color) : "rgba(0,0,0,1)", c.ctx.fill(), c.ctx.restore();
              }), h.label = 2;
            case 2:
              o = 0, A = 0, l = s, h.label = 3;
            case 3:
              return A < l.length ? (u = l[A], u.style !== 0 && !nA(u.color) && u.width > 0 ? u.style !== 2 ? [3, 5] : [4, this.renderDashedDottedBorder(
                u.color,
                u.width,
                o,
                t.curves,
                2
                /* DASHED */
              )] : [3, 11]) : [3, 13];
            case 4:
              return h.sent(), [3, 11];
            case 5:
              return u.style !== 3 ? [3, 7] : [4, this.renderDashedDottedBorder(
                u.color,
                u.width,
                o,
                t.curves,
                3
                /* DOTTED */
              )];
            case 6:
              return h.sent(), [3, 11];
            case 7:
              return u.style !== 4 ? [3, 9] : [4, this.renderDoubleBorder(u.color, u.width, o, t.curves)];
            case 8:
              return h.sent(), [3, 11];
            case 9:
              return [4, this.renderSolidBorder(u.color, o, t.curves)];
            case 10:
              h.sent(), h.label = 11;
            case 11:
              o++, h.label = 12;
            case 12:
              return A++, [3, 3];
            case 13:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.renderDashedDottedBorder = function(t, n, i, s, a) {
      return Ui(this, void 0, void 0, function() {
        var o, A, l, u, c, h, f, d, p, v, m, b, w, B, _, x, _, x;
        return wi(this, function(C) {
          return this.ctx.save(), o = OG(s, i), A = JC(s, i), a === 2 && (this.path(A), this.ctx.clip()), Fs(A[0]) ? (l = A[0].start.x, u = A[0].start.y) : (l = A[0].x, u = A[0].y), Fs(A[1]) ? (c = A[1].end.x, h = A[1].end.y) : (c = A[1].x, h = A[1].y), i === 0 || i === 2 ? f = Math.abs(l - c) : f = Math.abs(u - h), this.ctx.beginPath(), a === 3 ? this.formatPath(o) : this.formatPath(A.slice(0, 2)), d = n < 3 ? n * 3 : n * 2, p = n < 3 ? n * 2 : n, a === 3 && (d = n, p = n), v = !0, f <= d * 2 ? v = !1 : f <= d * 2 + p ? (m = f / (2 * d + p), d *= m, p *= m) : (b = Math.floor((f + p) / (d + p)), w = (f - b * d) / (b - 1), B = (f - (b + 1) * d) / b, p = B <= 0 || Math.abs(p - w) < Math.abs(p - B) ? w : B), v && (a === 3 ? this.ctx.setLineDash([0, d + p]) : this.ctx.setLineDash([d, p])), a === 3 ? (this.ctx.lineCap = "round", this.ctx.lineWidth = n) : this.ctx.lineWidth = n * 2 + 1.1, this.ctx.strokeStyle = $n(t), this.ctx.stroke(), this.ctx.setLineDash([]), a === 2 && (Fs(A[0]) && (_ = A[3], x = A[0], this.ctx.beginPath(), this.formatPath([new ot(_.end.x, _.end.y), new ot(x.start.x, x.start.y)]), this.ctx.stroke()), Fs(A[1]) && (_ = A[1], x = A[2], this.ctx.beginPath(), this.formatPath([new ot(_.end.x, _.end.y), new ot(x.start.x, x.start.y)]), this.ctx.stroke())), this.ctx.restore(), [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.render = function(t) {
      return Ui(this, void 0, void 0, function() {
        var n;
        return wi(this, function(i) {
          switch (i.label) {
            case 0:
              return this.options.backgroundColor && (this.ctx.fillStyle = $n(this.options.backgroundColor), this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height)), n = LG(t), [4, this.renderStack(n)];
            case 1:
              return i.sent(), this.applyEffects([]), [2, this.canvas];
          }
        });
      });
    }, e;
  }(yF)
), $G = function(r) {
  return r instanceof nF || r instanceof rF ? !0 : r instanceof Cb && r.type !== Rp && r.type !== Mp;
}, VG = function(r, e) {
  switch (r) {
    case 0:
      return jp(e);
    case 2:
      return SG(e);
    case 1:
    default:
      return Kp(e);
  }
}, zG = function(r) {
  switch (r) {
    case 1:
      return "center";
    case 2:
      return "right";
    case 0:
    default:
      return "left";
  }
}, GG = ["-apple-system", "system-ui"], qG = function(r) {
  return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? r.filter(function(e) {
    return GG.indexOf(e) === -1;
  }) : r;
}, WG = (
  /** @class */
  function(r) {
    ua(e, r);
    function e(t, n) {
      var i = r.call(this, t, n) || this;
      return i.canvas = n.canvas ? n.canvas : document.createElement("canvas"), i.ctx = i.canvas.getContext("2d"), i.options = n, i.canvas.width = Math.floor(n.width * n.scale), i.canvas.height = Math.floor(n.height * n.scale), i.canvas.style.width = n.width + "px", i.canvas.style.height = n.height + "px", i.ctx.scale(i.options.scale, i.options.scale), i.ctx.translate(-n.x, -n.y), i.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + n.width + "x" + n.height + " at " + n.x + "," + n.y + ") with scale " + n.scale), i;
    }
    return e.prototype.render = function(t) {
      return Ui(this, void 0, void 0, function() {
        var n, i;
        return wi(this, function(s) {
          switch (s.label) {
            case 0:
              return n = Kv(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, t), [4, XG(n)];
            case 1:
              return i = s.sent(), this.options.backgroundColor && (this.ctx.fillStyle = $n(this.options.backgroundColor), this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale)), this.ctx.drawImage(i, -this.options.x * this.options.scale, -this.options.y * this.options.scale), [2, this.canvas];
          }
        });
      });
    }, e;
  }(yF)
), XG = function(r) {
  return new Promise(function(e, t) {
    var n = new Image();
    n.onload = function() {
      e(n);
    }, n.onerror = t, n.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(r));
  });
}, JG = (
  /** @class */
  function() {
    function r(e) {
      var t = e.id, n = e.enabled;
      this.id = t, this.enabled = n, this.start = Date.now();
    }
    return r.prototype.debug = function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      this.enabled && (typeof window < "u" && window.console && typeof console.debug == "function" ? console.debug.apply(console, ld([this.id, this.getTime() + "ms"], e)) : this.info.apply(this, e));
    }, r.prototype.getTime = function() {
      return Date.now() - this.start;
    }, r.prototype.info = function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      this.enabled && typeof window < "u" && window.console && typeof console.info == "function" && console.info.apply(console, ld([this.id, this.getTime() + "ms"], e));
    }, r.prototype.warn = function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      this.enabled && (typeof window < "u" && window.console && typeof console.warn == "function" ? console.warn.apply(console, ld([this.id, this.getTime() + "ms"], e)) : this.info.apply(this, e));
    }, r.prototype.error = function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      this.enabled && (typeof window < "u" && window.console && typeof console.error == "function" ? console.error.apply(console, ld([this.id, this.getTime() + "ms"], e)) : this.info.apply(this, e));
    }, r.instances = {}, r;
  }()
), YG = (
  /** @class */
  function() {
    function r(e, t) {
      var n;
      this.windowBounds = t, this.instanceName = "#" + r.instanceCount++, this.logger = new JG({ id: this.instanceName, enabled: e.logging }), this.cache = (n = e.cache) !== null && n !== void 0 ? n : new vG(this, e);
    }
    return r.instanceCount = 1, r;
  }()
), ZG = function(r, e) {
  return e === void 0 && (e = {}), eq(r, e);
};
typeof window < "u" && dF.setContext(window);
var eq = function(r, e) {
  return Ui(void 0, void 0, void 0, function() {
    var t, n, i, s, a, o, A, l, u, c, h, f, d, p, v, m, b, w, B, _, C, x, C, F, N, D, T, E, L, S, X, z, R, V, O, J, Z, U, P, H;
    return wi(this, function($) {
      switch ($.label) {
        case 0:
          if (!r || typeof r != "object")
            return [2, Promise.reject("Invalid element provided as first argument")];
          if (t = r.ownerDocument, !t)
            throw new Error("Element is not attached to a Document");
          if (n = t.defaultView, !n)
            throw new Error("Document is not attached to a Window");
          return i = {
            allowTaint: (F = e.allowTaint) !== null && F !== void 0 ? F : !1,
            imageTimeout: (N = e.imageTimeout) !== null && N !== void 0 ? N : 15e3,
            proxy: e.proxy,
            useCORS: (D = e.useCORS) !== null && D !== void 0 ? D : !1
          }, s = Fv({ logging: (T = e.logging) !== null && T !== void 0 ? T : !0, cache: e.cache }, i), a = {
            windowWidth: (E = e.windowWidth) !== null && E !== void 0 ? E : n.innerWidth,
            windowHeight: (L = e.windowHeight) !== null && L !== void 0 ? L : n.innerHeight,
            scrollX: (S = e.scrollX) !== null && S !== void 0 ? S : n.pageXOffset,
            scrollY: (X = e.scrollY) !== null && X !== void 0 ? X : n.pageYOffset
          }, o = new lo(a.scrollX, a.scrollY, a.windowWidth, a.windowHeight), A = new YG(s, o), l = (z = e.foreignObjectRendering) !== null && z !== void 0 ? z : !1, u = {
            allowTaint: (R = e.allowTaint) !== null && R !== void 0 ? R : !1,
            onclone: e.onclone,
            ignoreElements: e.ignoreElements,
            inlineImages: l,
            copyStyles: l
          }, A.logger.debug("Starting document clone with size " + o.width + "x" + o.height + " scrolled to " + -o.left + "," + -o.top), c = new qC(A, r, u), h = c.clonedReferenceElement, h ? [4, c.toIFrame(t, o)] : [2, Promise.reject("Unable to find element in cloned iframe")];
        case 1:
          return f = $.sent(), d = _b(h) || tG(h) ? kj(h.ownerDocument) : Cg(A, h), p = d.width, v = d.height, m = d.left, b = d.top, w = tq(A, h, e.backgroundColor), B = {
            canvas: e.canvas,
            backgroundColor: w,
            scale: (O = (V = e.scale) !== null && V !== void 0 ? V : n.devicePixelRatio) !== null && O !== void 0 ? O : 1,
            x: ((J = e.x) !== null && J !== void 0 ? J : 0) + m,
            y: ((Z = e.y) !== null && Z !== void 0 ? Z : 0) + b,
            width: (U = e.width) !== null && U !== void 0 ? U : Math.ceil(p),
            height: (P = e.height) !== null && P !== void 0 ? P : Math.ceil(v)
          }, l ? (A.logger.debug("Document cloned, using foreign object rendering"), C = new WG(A, B), [4, C.render(h)]) : [3, 3];
        case 2:
          return _ = $.sent(), [3, 5];
        case 3:
          return A.logger.debug("Document cloned, element located at " + m + "," + b + " with size " + p + "x" + v + " using computed rendering"), A.logger.debug("Starting DOM parsing"), x = aF(A, h), w === x.styles.backgroundColor && (x.styles.backgroundColor = ao.TRANSPARENT), A.logger.debug("Starting renderer for element at " + B.x + "," + B.y + " with size " + B.width + "x" + B.height), C = new KG(A, B), [4, C.render(x)];
        case 4:
          _ = $.sent(), $.label = 5;
        case 5:
          return (!((H = e.removeContainer) !== null && H !== void 0) || H) && (qC.destroy(f) || A.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore")), A.logger.debug("Finished rendering"), [2, _];
      }
    });
  });
}, tq = function(r, e, t) {
  var n = e.ownerDocument, i = n.documentElement ? Af(r, getComputedStyle(n.documentElement).backgroundColor) : ao.TRANSPARENT, s = n.body ? Af(r, getComputedStyle(n.body).backgroundColor) : ao.TRANSPARENT, a = typeof t == "string" ? Af(r, t) : t === null ? ao.TRANSPARENT : 4294967295;
  return e === n.documentElement ? nA(i) ? nA(s) ? a : s : i : a;
};
const rq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ZG
}, Symbol.toStringTag, { value: "Module" }));
/*! @license DOMPurify 2.5.8 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.5.8/LICENSE */
function Ho(r) {
  "@babel/helpers - typeof";
  return Ho = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Ho(r);
}
function Xv(r, e) {
  return Xv = Object.setPrototypeOf || function(n, i) {
    return n.__proto__ = i, n;
  }, Xv(r, e);
}
function nq() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function lp(r, e, t) {
  return nq() ? lp = Reflect.construct : lp = function(i, s, a) {
    var o = [null];
    o.push.apply(o, s);
    var A = Function.bind.apply(i, o), l = new A();
    return a && Xv(l, a.prototype), l;
  }, lp.apply(null, arguments);
}
function Ys(r) {
  return iq(r) || sq(r) || aq(r) || oq();
}
function iq(r) {
  if (Array.isArray(r)) return Jv(r);
}
function sq(r) {
  if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
}
function aq(r, e) {
  if (r) {
    if (typeof r == "string") return Jv(r, e);
    var t = Object.prototype.toString.call(r).slice(8, -1);
    if (t === "Object" && r.constructor && (t = r.constructor.name), t === "Map" || t === "Set") return Array.from(r);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return Jv(r, e);
  }
}
function Jv(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var t = 0, n = new Array(e); t < e; t++) n[t] = r[t];
  return n;
}
function oq() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var Aq = Object.hasOwnProperty, ZC = Object.setPrototypeOf, lq = Object.isFrozen, uq = Object.getPrototypeOf, cq = Object.getOwnPropertyDescriptor, Ri = Object.freeze, Os = Object.seal, fq = Object.create, wF = typeof Reflect < "u" && Reflect, Vp = wF.apply, Yv = wF.construct;
Vp || (Vp = function(e, t, n) {
  return e.apply(t, n);
});
Ri || (Ri = function(e) {
  return e;
});
Os || (Os = function(e) {
  return e;
});
Yv || (Yv = function(e, t) {
  return lp(e, Ys(t));
});
var hq = Qs(Array.prototype.forEach), e_ = Qs(Array.prototype.pop), Fc = Qs(Array.prototype.push), up = Qs(String.prototype.toLowerCase), M0 = Qs(String.prototype.toString), t_ = Qs(String.prototype.match), Ws = Qs(String.prototype.replace), dq = Qs(String.prototype.indexOf), pq = Qs(String.prototype.trim), ri = Qs(RegExp.prototype.test), R0 = gq(TypeError);
function Qs(r) {
  return function(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      n[i - 1] = arguments[i];
    return Vp(r, e, n);
  };
}
function gq(r) {
  return function() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return Yv(r, t);
  };
}
function Zt(r, e, t) {
  var n;
  t = (n = t) !== null && n !== void 0 ? n : up, ZC && ZC(r, null);
  for (var i = e.length; i--; ) {
    var s = e[i];
    if (typeof s == "string") {
      var a = t(s);
      a !== s && (lq(e) || (e[i] = a), s = a);
    }
    r[s] = !0;
  }
  return r;
}
function TA(r) {
  var e = fq(null), t;
  for (t in r)
    Vp(Aq, r, [t]) === !0 && (e[t] = r[t]);
  return e;
}
function Ld(r, e) {
  for (; r !== null; ) {
    var t = cq(r, e);
    if (t) {
      if (t.get)
        return Qs(t.get);
      if (typeof t.value == "function")
        return Qs(t.value);
    }
    r = uq(r);
  }
  function n(i) {
    return console.warn("fallback value for", i), null;
  }
  return n;
}
var r_ = Ri(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), P0 = Ri(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), H0 = Ri(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), mq = Ri(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), j0 = Ri(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), vq = Ri(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), n_ = Ri(["#text"]), i_ = Ri(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), K0 = Ri(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), s_ = Ri(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Ud = Ri(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), bq = Os(/\{\{[\w\W]*|[\w\W]*\}\}/gm), yq = Os(/<%[\w\W]*|[\w\W]*%>/gm), wq = Os(/\${[\w\W]*}/gm), Bq = Os(/^data-[\-\w.\u00B7-\uFFFF]+$/), Cq = Os(/^aria-[\-\w]+$/), _q = Os(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), Eq = Os(/^(?:\w+script|data):/i), Sq = Os(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), Iq = Os(/^html$/i), Fq = Os(/^[a-z][.\w]*(-[.\w]+)+$/i), Tq = function() {
  return typeof window > "u" ? null : window;
}, xq = function(e, t) {
  if (Ho(e) !== "object" || typeof e.createPolicy != "function")
    return null;
  var n = null, i = "data-tt-policy-suffix";
  t.currentScript && t.currentScript.hasAttribute(i) && (n = t.currentScript.getAttribute(i));
  var s = "dompurify" + (n ? "#" + n : "");
  try {
    return e.createPolicy(s, {
      createHTML: function(o) {
        return o;
      },
      createScriptURL: function(o) {
        return o;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + s + " could not be created."), null;
  }
};
function BF() {
  var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Tq(), e = function(be) {
    return BF(be);
  };
  if (e.version = "2.5.8", e.removed = [], !r || !r.document || r.document.nodeType !== 9)
    return e.isSupported = !1, e;
  var t = r.document, n = r.document, i = r.DocumentFragment, s = r.HTMLTemplateElement, a = r.Node, o = r.Element, A = r.NodeFilter, l = r.NamedNodeMap, u = l === void 0 ? r.NamedNodeMap || r.MozNamedAttrMap : l, c = r.HTMLFormElement, h = r.DOMParser, f = r.trustedTypes, d = o.prototype, p = Ld(d, "cloneNode"), v = Ld(d, "nextSibling"), m = Ld(d, "childNodes"), b = Ld(d, "parentNode");
  if (typeof s == "function") {
    var w = n.createElement("template");
    w.content && w.content.ownerDocument && (n = w.content.ownerDocument);
  }
  var B = xq(f, t), _ = B ? B.createHTML("") : "", x = n, C = x.implementation, F = x.createNodeIterator, N = x.createDocumentFragment, D = x.getElementsByTagName, T = t.importNode, E = {};
  try {
    E = TA(n).documentMode ? n.documentMode : {};
  } catch {
  }
  var L = {};
  e.isSupported = typeof b == "function" && C && C.createHTMLDocument !== void 0 && E !== 9;
  var S = bq, X = yq, z = wq, R = Bq, V = Cq, O = Eq, J = Sq, Z = Fq, U = _q, P = null, H = Zt({}, [].concat(Ys(r_), Ys(P0), Ys(H0), Ys(j0), Ys(n_))), $ = null, ie = Zt({}, [].concat(Ys(i_), Ys(K0), Ys(s_), Ys(Ud))), ue = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), he = null, ve = null, Le = !0, de = !0, Ce = !1, Qe = !0, M = !1, Ae = !0, G = !1, ne = !1, ee = !1, ae = !1, re = !1, ce = !1, le = !0, Te = !1, Oe = "user-content-", Ue = !0, Ge = !1, at = {}, it = null, ut = Zt({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), St = null, et = Zt({}, ["audio", "video", "img", "source", "image", "track"]), gr = null, bt = Zt({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Qr = "http://www.w3.org/1998/Math/MathML", Wt = "http://www.w3.org/2000/svg", kt = "http://www.w3.org/1999/xhtml", Dr = kt, Xt = !1, Cn = null, mr = Zt({}, [Qr, Wt, kt], M0), Ir, hr = ["application/xhtml+xml", "text/html"], wr = "text/html", gt, rr = null, Rs = n.createElement("form"), Yr = function(be) {
    return be instanceof RegExp || be instanceof Function;
  }, fi = function(be) {
    rr && rr === be || ((!be || Ho(be) !== "object") && (be = {}), be = TA(be), Ir = // eslint-disable-next-line unicorn/prefer-includes
    hr.indexOf(be.PARSER_MEDIA_TYPE) === -1 ? Ir = wr : Ir = be.PARSER_MEDIA_TYPE, gt = Ir === "application/xhtml+xml" ? M0 : up, P = "ALLOWED_TAGS" in be ? Zt({}, be.ALLOWED_TAGS, gt) : H, $ = "ALLOWED_ATTR" in be ? Zt({}, be.ALLOWED_ATTR, gt) : ie, Cn = "ALLOWED_NAMESPACES" in be ? Zt({}, be.ALLOWED_NAMESPACES, M0) : mr, gr = "ADD_URI_SAFE_ATTR" in be ? Zt(
      TA(bt),
      // eslint-disable-line indent
      be.ADD_URI_SAFE_ATTR,
      // eslint-disable-line indent
      gt
      // eslint-disable-line indent
    ) : bt, St = "ADD_DATA_URI_TAGS" in be ? Zt(
      TA(et),
      // eslint-disable-line indent
      be.ADD_DATA_URI_TAGS,
      // eslint-disable-line indent
      gt
      // eslint-disable-line indent
    ) : et, it = "FORBID_CONTENTS" in be ? Zt({}, be.FORBID_CONTENTS, gt) : ut, he = "FORBID_TAGS" in be ? Zt({}, be.FORBID_TAGS, gt) : {}, ve = "FORBID_ATTR" in be ? Zt({}, be.FORBID_ATTR, gt) : {}, at = "USE_PROFILES" in be ? be.USE_PROFILES : !1, Le = be.ALLOW_ARIA_ATTR !== !1, de = be.ALLOW_DATA_ATTR !== !1, Ce = be.ALLOW_UNKNOWN_PROTOCOLS || !1, Qe = be.ALLOW_SELF_CLOSE_IN_ATTR !== !1, M = be.SAFE_FOR_TEMPLATES || !1, Ae = be.SAFE_FOR_XML !== !1, G = be.WHOLE_DOCUMENT || !1, ae = be.RETURN_DOM || !1, re = be.RETURN_DOM_FRAGMENT || !1, ce = be.RETURN_TRUSTED_TYPE || !1, ee = be.FORCE_BODY || !1, le = be.SANITIZE_DOM !== !1, Te = be.SANITIZE_NAMED_PROPS || !1, Ue = be.KEEP_CONTENT !== !1, Ge = be.IN_PLACE || !1, U = be.ALLOWED_URI_REGEXP || U, Dr = be.NAMESPACE || kt, ue = be.CUSTOM_ELEMENT_HANDLING || {}, be.CUSTOM_ELEMENT_HANDLING && Yr(be.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (ue.tagNameCheck = be.CUSTOM_ELEMENT_HANDLING.tagNameCheck), be.CUSTOM_ELEMENT_HANDLING && Yr(be.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (ue.attributeNameCheck = be.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), be.CUSTOM_ELEMENT_HANDLING && typeof be.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (ue.allowCustomizedBuiltInElements = be.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), M && (de = !1), re && (ae = !0), at && (P = Zt({}, Ys(n_)), $ = [], at.html === !0 && (Zt(P, r_), Zt($, i_)), at.svg === !0 && (Zt(P, P0), Zt($, K0), Zt($, Ud)), at.svgFilters === !0 && (Zt(P, H0), Zt($, K0), Zt($, Ud)), at.mathMl === !0 && (Zt(P, j0), Zt($, s_), Zt($, Ud))), be.ADD_TAGS && (P === H && (P = TA(P)), Zt(P, be.ADD_TAGS, gt)), be.ADD_ATTR && ($ === ie && ($ = TA($)), Zt($, be.ADD_ATTR, gt)), be.ADD_URI_SAFE_ATTR && Zt(gr, be.ADD_URI_SAFE_ATTR, gt), be.FORBID_CONTENTS && (it === ut && (it = TA(it)), Zt(it, be.FORBID_CONTENTS, gt)), Ue && (P["#text"] = !0), G && Zt(P, ["html", "head", "body"]), P.table && (Zt(P, ["tbody"]), delete he.tbody), Ri && Ri(be), rr = be);
  }, Fi = Zt({}, ["mi", "mo", "mn", "ms", "mtext"]), Ct = Zt({}, ["annotation-xml"]), Ti = Zt({}, ["title", "style", "font", "a", "script"]), Yn = Zt({}, P0);
  Zt(Yn, H0), Zt(Yn, mq);
  var _n = Zt({}, j0);
  Zt(_n, vq);
  var Gr = function(be) {
    var Ze = b(be);
    (!Ze || !Ze.tagName) && (Ze = {
      namespaceURI: Dr,
      tagName: "template"
    });
    var rt = up(be.tagName), cr = up(Ze.tagName);
    return Cn[be.namespaceURI] ? be.namespaceURI === Wt ? Ze.namespaceURI === kt ? rt === "svg" : Ze.namespaceURI === Qr ? rt === "svg" && (cr === "annotation-xml" || Fi[cr]) : !!Yn[rt] : be.namespaceURI === Qr ? Ze.namespaceURI === kt ? rt === "math" : Ze.namespaceURI === Wt ? rt === "math" && Ct[cr] : !!_n[rt] : be.namespaceURI === kt ? Ze.namespaceURI === Wt && !Ct[cr] || Ze.namespaceURI === Qr && !Fi[cr] ? !1 : !_n[rt] && (Ti[rt] || !Yn[rt]) : !!(Ir === "application/xhtml+xml" && Cn[be.namespaceURI]) : !1;
  }, ur = function(be) {
    Fc(e.removed, {
      element: be
    });
    try {
      be.parentNode.removeChild(be);
    } catch {
      try {
        be.outerHTML = _;
      } catch {
        be.remove();
      }
    }
  }, En = function(be, Ze) {
    try {
      Fc(e.removed, {
        attribute: Ze.getAttributeNode(be),
        from: Ze
      });
    } catch {
      Fc(e.removed, {
        attribute: null,
        from: Ze
      });
    }
    if (Ze.removeAttribute(be), be === "is" && !$[be])
      if (ae || re)
        try {
          ur(Ze);
        } catch {
        }
      else
        try {
          Ze.setAttribute(be, "");
        } catch {
        }
  }, Ps = function(be) {
    var Ze, rt;
    if (ee)
      be = "<remove></remove>" + be;
    else {
      var cr = t_(be, /^[\r\n\t ]+/);
      rt = cr && cr[0];
    }
    Ir === "application/xhtml+xml" && Dr === kt && (be = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + be + "</body></html>");
    var Pn = B ? B.createHTML(be) : be;
    if (Dr === kt)
      try {
        Ze = new h().parseFromString(Pn, Ir);
      } catch {
      }
    if (!Ze || !Ze.documentElement) {
      Ze = C.createDocument(Dr, "template", null);
      try {
        Ze.documentElement.innerHTML = Xt ? _ : Pn;
      } catch {
      }
    }
    var Wr = Ze.body || Ze.documentElement;
    return be && rt && Wr.insertBefore(n.createTextNode(rt), Wr.childNodes[0] || null), Dr === kt ? D.call(Ze, G ? "html" : "body")[0] : G ? Ze.documentElement : Wr;
  }, Ki = function(be) {
    return F.call(
      be.ownerDocument || be,
      be,
      // eslint-disable-next-line no-bitwise
      A.SHOW_ELEMENT | A.SHOW_COMMENT | A.SHOW_TEXT | A.SHOW_PROCESSING_INSTRUCTION | A.SHOW_CDATA_SECTION,
      null,
      !1
    );
  }, Zn = function(be) {
    return be instanceof c && (typeof be.nodeName != "string" || typeof be.textContent != "string" || typeof be.removeChild != "function" || !(be.attributes instanceof u) || typeof be.removeAttribute != "function" || typeof be.setAttribute != "function" || typeof be.namespaceURI != "string" || typeof be.insertBefore != "function" || typeof be.hasChildNodes != "function");
  }, Nn = function(be) {
    return Ho(a) === "object" ? be instanceof a : be && Ho(be) === "object" && typeof be.nodeType == "number" && typeof be.nodeName == "string";
  }, qr = function(be, Ze, rt) {
    L[be] && hq(L[be], function(cr) {
      cr.call(e, Ze, rt, rr);
    });
  }, Ee = function(be) {
    var Ze;
    if (qr("beforeSanitizeElements", be, null), Zn(be) || ri(/[\u0080-\uFFFF]/, be.nodeName))
      return ur(be), !0;
    var rt = gt(be.nodeName);
    if (qr("uponSanitizeElement", be, {
      tagName: rt,
      allowedTags: P
    }), be.hasChildNodes() && !Nn(be.firstElementChild) && (!Nn(be.content) || !Nn(be.content.firstElementChild)) && ri(/<[/\w]/g, be.innerHTML) && ri(/<[/\w]/g, be.textContent) || rt === "select" && ri(/<template/i, be.innerHTML) || be.nodeType === 7 || Ae && be.nodeType === 8 && ri(/<[/\w]/g, be.data))
      return ur(be), !0;
    if (!P[rt] || he[rt]) {
      if (!he[rt] && hi(rt) && (ue.tagNameCheck instanceof RegExp && ri(ue.tagNameCheck, rt) || ue.tagNameCheck instanceof Function && ue.tagNameCheck(rt)))
        return !1;
      if (Ue && !it[rt]) {
        var cr = b(be) || be.parentNode, Pn = m(be) || be.childNodes;
        if (Pn && cr)
          for (var Wr = Pn.length, Zr = Wr - 1; Zr >= 0; --Zr) {
            var Hs = p(Pn[Zr], !0);
            Hs.__removalCount = (be.__removalCount || 0) + 1, cr.insertBefore(Hs, v(be));
          }
      }
      return ur(be), !0;
    }
    return be instanceof o && !Gr(be) || (rt === "noscript" || rt === "noembed" || rt === "noframes") && ri(/<\/no(script|embed|frames)/i, be.innerHTML) ? (ur(be), !0) : (M && be.nodeType === 3 && (Ze = be.textContent, Ze = Ws(Ze, S, " "), Ze = Ws(Ze, X, " "), Ze = Ws(Ze, z, " "), be.textContent !== Ze && (Fc(e.removed, {
      element: be.cloneNode()
    }), be.textContent = Ze)), qr("afterSanitizeElements", be, null), !1);
  }, or = function(be, Ze, rt) {
    if (le && (Ze === "id" || Ze === "name") && (rt in n || rt in Rs))
      return !1;
    if (!(de && !ve[Ze] && ri(R, Ze))) {
      if (!(Le && ri(V, Ze))) {
        if (!$[Ze] || ve[Ze]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(hi(be) && (ue.tagNameCheck instanceof RegExp && ri(ue.tagNameCheck, be) || ue.tagNameCheck instanceof Function && ue.tagNameCheck(be)) && (ue.attributeNameCheck instanceof RegExp && ri(ue.attributeNameCheck, Ze) || ue.attributeNameCheck instanceof Function && ue.attributeNameCheck(Ze)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            Ze === "is" && ue.allowCustomizedBuiltInElements && (ue.tagNameCheck instanceof RegExp && ri(ue.tagNameCheck, rt) || ue.tagNameCheck instanceof Function && ue.tagNameCheck(rt)))
          ) return !1;
        } else if (!gr[Ze]) {
          if (!ri(U, Ws(rt, J, ""))) {
            if (!((Ze === "src" || Ze === "xlink:href" || Ze === "href") && be !== "script" && dq(rt, "data:") === 0 && St[be])) {
              if (!(Ce && !ri(O, Ws(rt, J, "")))) {
                if (rt)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, hi = function(be) {
    return be !== "annotation-xml" && t_(be, Z);
  }, hs = function(be) {
    var Ze, rt, cr, Pn;
    qr("beforeSanitizeAttributes", be, null);
    var Wr = be.attributes;
    if (!(!Wr || Zn(be))) {
      var Zr = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: $
      };
      for (Pn = Wr.length; Pn--; ) {
        Ze = Wr[Pn];
        var Hs = Ze, $r = Hs.name, dA = Hs.namespaceURI;
        if (rt = $r === "value" ? Ze.value : pq(Ze.value), cr = gt($r), Zr.attrName = cr, Zr.attrValue = rt, Zr.keepAttr = !0, Zr.forceKeepAttr = void 0, qr("uponSanitizeAttribute", be, Zr), rt = Zr.attrValue, !Zr.forceKeepAttr && (En($r, be), !!Zr.keepAttr)) {
          if (!Qe && ri(/\/>/i, rt)) {
            En($r, be);
            continue;
          }
          M && (rt = Ws(rt, S, " "), rt = Ws(rt, X, " "), rt = Ws(rt, z, " "));
          var pA = gt(be.nodeName);
          if (or(pA, cr, rt)) {
            if (Te && (cr === "id" || cr === "name") && (En($r, be), rt = Oe + rt), Ae && ri(/((--!?|])>)|<\/(style|title)/i, rt)) {
              En($r, be);
              continue;
            }
            if (B && Ho(f) === "object" && typeof f.getAttributeType == "function" && !dA)
              switch (f.getAttributeType(pA, cr)) {
                case "TrustedHTML": {
                  rt = B.createHTML(rt);
                  break;
                }
                case "TrustedScriptURL": {
                  rt = B.createScriptURL(rt);
                  break;
                }
              }
            try {
              dA ? be.setAttributeNS(dA, $r, rt) : be.setAttribute($r, rt), Zn(be) ? ur(be) : e_(e.removed);
            } catch {
            }
          }
        }
      }
      qr("afterSanitizeAttributes", be, null);
    }
  }, ds = function dt(be) {
    var Ze, rt = Ki(be);
    for (qr("beforeSanitizeShadowDOM", be, null); Ze = rt.nextNode(); )
      qr("uponSanitizeShadowNode", Ze, null), Ee(Ze), hs(Ze), Ze.content instanceof i && dt(Ze.content);
    qr("afterSanitizeShadowDOM", be, null);
  };
  return e.sanitize = function(dt) {
    var be = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Ze, rt, cr, Pn, Wr;
    if (Xt = !dt, Xt && (dt = "<!-->"), typeof dt != "string" && !Nn(dt))
      if (typeof dt.toString == "function") {
        if (dt = dt.toString(), typeof dt != "string")
          throw R0("dirty is not a string, aborting");
      } else
        throw R0("toString is not a function");
    if (!e.isSupported) {
      if (Ho(r.toStaticHTML) === "object" || typeof r.toStaticHTML == "function") {
        if (typeof dt == "string")
          return r.toStaticHTML(dt);
        if (Nn(dt))
          return r.toStaticHTML(dt.outerHTML);
      }
      return dt;
    }
    if (ne || fi(be), e.removed = [], typeof dt == "string" && (Ge = !1), Ge) {
      if (dt.nodeName) {
        var Zr = gt(dt.nodeName);
        if (!P[Zr] || he[Zr])
          throw R0("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (dt instanceof a)
      Ze = Ps("<!---->"), rt = Ze.ownerDocument.importNode(dt, !0), rt.nodeType === 1 && rt.nodeName === "BODY" || rt.nodeName === "HTML" ? Ze = rt : Ze.appendChild(rt);
    else {
      if (!ae && !M && !G && // eslint-disable-next-line unicorn/prefer-includes
      dt.indexOf("<") === -1)
        return B && ce ? B.createHTML(dt) : dt;
      if (Ze = Ps(dt), !Ze)
        return ae ? null : ce ? _ : "";
    }
    Ze && ee && ur(Ze.firstChild);
    for (var Hs = Ki(Ge ? dt : Ze); cr = Hs.nextNode(); )
      cr.nodeType === 3 && cr === Pn || (Ee(cr), hs(cr), cr.content instanceof i && ds(cr.content), Pn = cr);
    if (Pn = null, Ge)
      return dt;
    if (ae) {
      if (re)
        for (Wr = N.call(Ze.ownerDocument); Ze.firstChild; )
          Wr.appendChild(Ze.firstChild);
      else
        Wr = Ze;
      return ($.shadowroot || $.shadowrootmod) && (Wr = T.call(t, Wr, !0)), Wr;
    }
    var $r = G ? Ze.outerHTML : Ze.innerHTML;
    return G && P["!doctype"] && Ze.ownerDocument && Ze.ownerDocument.doctype && Ze.ownerDocument.doctype.name && ri(Iq, Ze.ownerDocument.doctype.name) && ($r = "<!DOCTYPE " + Ze.ownerDocument.doctype.name + `>
` + $r), M && ($r = Ws($r, S, " "), $r = Ws($r, X, " "), $r = Ws($r, z, " ")), B && ce ? B.createHTML($r) : $r;
  }, e.setConfig = function(dt) {
    fi(dt), ne = !0;
  }, e.clearConfig = function() {
    rr = null, ne = !1;
  }, e.isValidAttribute = function(dt, be, Ze) {
    rr || fi({});
    var rt = gt(dt), cr = gt(be);
    return or(rt, cr, Ze);
  }, e.addHook = function(dt, be) {
    typeof be == "function" && (L[dt] = L[dt] || [], Fc(L[dt], be));
  }, e.removeHook = function(dt) {
    if (L[dt])
      return e_(L[dt]);
  }, e.removeHooks = function(dt) {
    L[dt] && (L[dt] = []);
  }, e.removeAllHooks = function() {
    L = {};
  }, e;
}
var kq = BF();
const Lq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: kq
}, Symbol.toStringTag, { value: "Module" }));
var Tc = function(r) {
  return r && r.Math === Math && r;
}, ln = (
  // eslint-disable-next-line es/no-global-this -- safe
  Tc(typeof globalThis == "object" && globalThis) || Tc(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  Tc(typeof self == "object" && self) || Tc(typeof an == "object" && an) || Tc(typeof an == "object" && an) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")()
), Kf = {}, yn = function(r) {
  try {
    return !!r();
  } catch {
    return !0;
  }
}, Uq = yn, ca = !Uq(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] !== 7;
}), Nq = yn, Ug = !Nq(function() {
  var r = (function() {
  }).bind();
  return typeof r != "function" || r.hasOwnProperty("prototype");
}), Oq = Ug, Nd = Function.prototype.call, ci = Oq ? Nd.bind(Nd) : function() {
  return Nd.apply(Nd, arguments);
}, CF = {}, _F = {}.propertyIsEnumerable, EF = Object.getOwnPropertyDescriptor, Qq = EF && !_F.call({ 1: 2 }, 1);
CF.f = Qq ? function(e) {
  var t = EF(this, e);
  return !!t && t.enumerable;
} : _F;
var Eb = function(r, e) {
  return {
    enumerable: !(r & 1),
    configurable: !(r & 2),
    writable: !(r & 4),
    value: e
  };
}, SF = Ug, IF = Function.prototype, Zv = IF.call, Dq = SF && IF.bind.bind(Zv, Zv), wn = SF ? Dq : function(r) {
  return function() {
    return Zv.apply(r, arguments);
  };
}, FF = wn, Mq = FF({}.toString), Rq = FF("".slice), hl = function(r) {
  return Rq(Mq(r), 8, -1);
}, Pq = wn, Hq = yn, jq = hl, $0 = Object, Kq = Pq("".split), TF = Hq(function() {
  return !$0("z").propertyIsEnumerable(0);
}) ? function(r) {
  return jq(r) === "String" ? Kq(r, "") : $0(r);
} : $0, dl = function(r) {
  return r == null;
}, $q = dl, Vq = TypeError, fa = function(r) {
  if ($q(r)) throw new Vq("Can't call method on " + r);
  return r;
}, zq = TF, Gq = fa, $f = function(r) {
  return zq(Gq(r));
}, V0 = typeof document == "object" && document.all, Bn = typeof V0 > "u" && V0 !== void 0 ? function(r) {
  return typeof r == "function" || r === V0;
} : function(r) {
  return typeof r == "function";
}, qq = Bn, ha = function(r) {
  return typeof r == "object" ? r !== null : qq(r);
}, z0 = ln, Wq = Bn, Xq = function(r) {
  return Wq(r) ? r : void 0;
}, pl = function(r, e) {
  return arguments.length < 2 ? Xq(z0[r]) : z0[r] && z0[r][e];
}, Jq = wn, Ng = Jq({}.isPrototypeOf), Yq = ln, a_ = Yq.navigator, o_ = a_ && a_.userAgent, Vf = o_ ? String(o_) : "", xF = ln, G0 = Vf, A_ = xF.process, l_ = xF.Deno, u_ = A_ && A_.versions || l_ && l_.version, c_ = u_ && u_.v8, ta, zp;
c_ && (ta = c_.split("."), zp = ta[0] > 0 && ta[0] < 4 ? 1 : +(ta[0] + ta[1]));
!zp && G0 && (ta = G0.match(/Edge\/(\d+)/), (!ta || ta[1] >= 74) && (ta = G0.match(/Chrome\/(\d+)/), ta && (zp = +ta[1])));
var Sb = zp, f_ = Sb, Zq = yn, eW = ln, tW = eW.String, kF = !!Object.getOwnPropertySymbols && !Zq(function() {
  var r = Symbol("symbol detection");
  return !tW(r) || !(Object(r) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && f_ && f_ < 41;
}), rW = kF, LF = rW && !Symbol.sham && typeof Symbol.iterator == "symbol", nW = pl, iW = Bn, sW = Ng, aW = LF, oW = Object, UF = aW ? function(r) {
  return typeof r == "symbol";
} : function(r) {
  var e = nW("Symbol");
  return iW(e) && sW(e.prototype, oW(r));
}, AW = String, Og = function(r) {
  try {
    return AW(r);
  } catch {
    return "Object";
  }
}, lW = Bn, uW = Og, cW = TypeError, ho = function(r) {
  if (lW(r)) return r;
  throw new cW(uW(r) + " is not a function");
}, fW = ho, hW = dl, Hu = function(r, e) {
  var t = r[e];
  return hW(t) ? void 0 : fW(t);
}, q0 = ci, W0 = Bn, X0 = ha, dW = TypeError, pW = function(r, e) {
  var t, n;
  if (e === "string" && W0(t = r.toString) && !X0(n = q0(t, r)) || W0(t = r.valueOf) && !X0(n = q0(t, r)) || e !== "string" && W0(t = r.toString) && !X0(n = q0(t, r))) return n;
  throw new dW("Can't convert object to primitive value");
}, NF = { exports: {} }, h_ = ln, gW = Object.defineProperty, Ib = function(r, e) {
  try {
    gW(h_, r, { value: e, configurable: !0, writable: !0 });
  } catch {
    h_[r] = e;
  }
  return e;
}, mW = ln, vW = Ib, d_ = "__core-js_shared__", p_ = NF.exports = mW[d_] || vW(d_, {});
(p_.versions || (p_.versions = [])).push({
  version: "3.40.0",
  mode: "global",
  copyright: "© 2014-2025 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.40.0/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var Fb = NF.exports, g_ = Fb, Tb = function(r, e) {
  return g_[r] || (g_[r] = e || {});
}, bW = fa, yW = Object, Qg = function(r) {
  return yW(bW(r));
}, wW = wn, BW = Qg, CW = wW({}.hasOwnProperty), da = Object.hasOwn || function(e, t) {
  return CW(BW(e), t);
}, _W = wn, EW = 0, SW = Math.random(), IW = _W(1 .toString), OF = function(r) {
  return "Symbol(" + (r === void 0 ? "" : r) + ")_" + IW(++EW + SW, 36);
}, FW = ln, TW = Tb, m_ = da, xW = OF, kW = kF, LW = LF, gu = FW.Symbol, J0 = TW("wks"), UW = LW ? gu.for || gu : gu && gu.withoutSetter || xW, Jn = function(r) {
  return m_(J0, r) || (J0[r] = kW && m_(gu, r) ? gu[r] : UW("Symbol." + r)), J0[r];
}, NW = ci, v_ = ha, b_ = UF, OW = Hu, QW = pW, DW = Jn, MW = TypeError, RW = DW("toPrimitive"), PW = function(r, e) {
  if (!v_(r) || b_(r)) return r;
  var t = OW(r, RW), n;
  if (t) {
    if (e === void 0 && (e = "default"), n = NW(t, r, e), !v_(n) || b_(n)) return n;
    throw new MW("Can't convert object to primitive value");
  }
  return e === void 0 && (e = "number"), QW(r, e);
}, HW = PW, jW = UF, QF = function(r) {
  var e = HW(r, "string");
  return jW(e) ? e : e + "";
}, KW = ln, y_ = ha, e2 = KW.document, $W = y_(e2) && y_(e2.createElement), Dg = function(r) {
  return $W ? e2.createElement(r) : {};
}, VW = ca, zW = yn, GW = Dg, DF = !VW && !zW(function() {
  return Object.defineProperty(GW("div"), "a", {
    get: function() {
      return 7;
    }
  }).a !== 7;
}), qW = ca, WW = ci, XW = CF, JW = Eb, YW = $f, ZW = QF, eX = da, tX = DF, w_ = Object.getOwnPropertyDescriptor;
Kf.f = qW ? w_ : function(e, t) {
  if (e = YW(e), t = ZW(t), tX) try {
    return w_(e, t);
  } catch {
  }
  if (eX(e, t)) return JW(!WW(XW.f, e, t), e[t]);
};
var po = {}, rX = ca, nX = yn, MF = rX && nX(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: !1
  }).prototype !== 42;
}), iX = ha, sX = String, aX = TypeError, Hi = function(r) {
  if (iX(r)) return r;
  throw new aX(sX(r) + " is not an object");
}, oX = ca, AX = DF, lX = MF, Od = Hi, B_ = QF, uX = TypeError, Y0 = Object.defineProperty, cX = Object.getOwnPropertyDescriptor, Z0 = "enumerable", e1 = "configurable", t1 = "writable";
po.f = oX ? lX ? function(e, t, n) {
  if (Od(e), t = B_(t), Od(n), typeof e == "function" && t === "prototype" && "value" in n && t1 in n && !n[t1]) {
    var i = cX(e, t);
    i && i[t1] && (e[t] = n.value, n = {
      configurable: e1 in n ? n[e1] : i[e1],
      enumerable: Z0 in n ? n[Z0] : i[Z0],
      writable: !1
    });
  }
  return Y0(e, t, n);
} : Y0 : function(e, t, n) {
  if (Od(e), t = B_(t), Od(n), AX) try {
    return Y0(e, t, n);
  } catch {
  }
  if ("get" in n || "set" in n) throw new uX("Accessors not supported");
  return "value" in n && (e[t] = n.value), e;
};
var fX = ca, hX = po, dX = Eb, zf = fX ? function(r, e, t) {
  return hX.f(r, e, dX(1, t));
} : function(r, e, t) {
  return r[e] = t, r;
}, RF = { exports: {} }, t2 = ca, pX = da, PF = Function.prototype, gX = t2 && Object.getOwnPropertyDescriptor, xb = pX(PF, "name"), mX = xb && (function() {
}).name === "something", vX = xb && (!t2 || t2 && gX(PF, "name").configurable), Mg = {
  EXISTS: xb,
  PROPER: mX,
  CONFIGURABLE: vX
}, bX = wn, yX = Bn, r2 = Fb, wX = bX(Function.toString);
yX(r2.inspectSource) || (r2.inspectSource = function(r) {
  return wX(r);
});
var kb = r2.inspectSource, BX = ln, CX = Bn, C_ = BX.WeakMap, _X = CX(C_) && /native code/.test(String(C_)), EX = Tb, SX = OF, __ = EX("keys"), Lb = function(r) {
  return __[r] || (__[r] = SX(r));
}, Ub = {}, IX = _X, HF = ln, FX = ha, TX = zf, r1 = da, n1 = Fb, xX = Lb, kX = Ub, E_ = "Object already initialized", n2 = HF.TypeError, LX = HF.WeakMap, Gp, Lf, qp, UX = function(r) {
  return qp(r) ? Lf(r) : Gp(r, {});
}, NX = function(r) {
  return function(e) {
    var t;
    if (!FX(e) || (t = Lf(e)).type !== r)
      throw new n2("Incompatible receiver, " + r + " required");
    return t;
  };
};
if (IX || n1.state) {
  var ya = n1.state || (n1.state = new LX());
  ya.get = ya.get, ya.has = ya.has, ya.set = ya.set, Gp = function(r, e) {
    if (ya.has(r)) throw new n2(E_);
    return e.facade = r, ya.set(r, e), e;
  }, Lf = function(r) {
    return ya.get(r) || {};
  }, qp = function(r) {
    return ya.has(r);
  };
} else {
  var Zl = xX("state");
  kX[Zl] = !0, Gp = function(r, e) {
    if (r1(r, Zl)) throw new n2(E_);
    return e.facade = r, TX(r, Zl, e), e;
  }, Lf = function(r) {
    return r1(r, Zl) ? r[Zl] : {};
  }, qp = function(r) {
    return r1(r, Zl);
  };
}
var Rg = {
  set: Gp,
  get: Lf,
  has: qp,
  enforce: UX,
  getterFor: NX
}, Nb = wn, OX = yn, QX = Bn, Qd = da, i2 = ca, DX = Mg.CONFIGURABLE, MX = kb, jF = Rg, RX = jF.enforce, PX = jF.get, S_ = String, cp = Object.defineProperty, HX = Nb("".slice), jX = Nb("".replace), KX = Nb([].join), $X = i2 && !OX(function() {
  return cp(function() {
  }, "length", { value: 8 }).length !== 8;
}), VX = String(String).split("String"), zX = RF.exports = function(r, e, t) {
  HX(S_(e), 0, 7) === "Symbol(" && (e = "[" + jX(S_(e), /^Symbol\(([^)]*)\).*$/, "$1") + "]"), t && t.getter && (e = "get " + e), t && t.setter && (e = "set " + e), (!Qd(r, "name") || DX && r.name !== e) && (i2 ? cp(r, "name", { value: e, configurable: !0 }) : r.name = e), $X && t && Qd(t, "arity") && r.length !== t.arity && cp(r, "length", { value: t.arity });
  try {
    t && Qd(t, "constructor") && t.constructor ? i2 && cp(r, "prototype", { writable: !1 }) : r.prototype && (r.prototype = void 0);
  } catch {
  }
  var n = RX(r);
  return Qd(n, "source") || (n.source = KX(VX, typeof e == "string" ? e : "")), r;
};
Function.prototype.toString = zX(function() {
  return QX(this) && PX(this).source || MX(this);
}, "toString");
var KF = RF.exports, GX = Bn, qX = po, WX = KF, XX = Ib, gl = function(r, e, t, n) {
  n || (n = {});
  var i = n.enumerable, s = n.name !== void 0 ? n.name : e;
  if (GX(t) && WX(t, s, n), n.global)
    i ? r[e] = t : XX(e, t);
  else {
    try {
      n.unsafe ? r[e] && (i = !0) : delete r[e];
    } catch {
    }
    i ? r[e] = t : qX.f(r, e, {
      value: t,
      enumerable: !1,
      configurable: !n.nonConfigurable,
      writable: !n.nonWritable
    });
  }
  return r;
}, $F = {}, JX = Math.ceil, YX = Math.floor, ZX = Math.trunc || function(e) {
  var t = +e;
  return (t > 0 ? YX : JX)(t);
}, eJ = ZX, Pg = function(r) {
  var e = +r;
  return e !== e || e === 0 ? 0 : eJ(e);
}, tJ = Pg, rJ = Math.max, nJ = Math.min, iJ = function(r, e) {
  var t = tJ(r);
  return t < 0 ? rJ(t + e, 0) : nJ(t, e);
}, sJ = Pg, aJ = Math.min, ju = function(r) {
  var e = sJ(r);
  return e > 0 ? aJ(e, 9007199254740991) : 0;
}, oJ = ju, Ob = function(r) {
  return oJ(r.length);
}, AJ = $f, lJ = iJ, uJ = Ob, I_ = function(r) {
  return function(e, t, n) {
    var i = AJ(e), s = uJ(i);
    if (s === 0) return !r && -1;
    var a = lJ(n, s), o;
    if (r && t !== t) {
      for (; s > a; )
        if (o = i[a++], o !== o) return !0;
    } else for (; s > a; a++)
      if ((r || a in i) && i[a] === t) return r || a || 0;
    return !r && -1;
  };
}, VF = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: I_(!0),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: I_(!1)
}, cJ = wn, i1 = da, fJ = $f, hJ = VF.indexOf, dJ = Ub, F_ = cJ([].push), zF = function(r, e) {
  var t = fJ(r), n = 0, i = [], s;
  for (s in t) !i1(dJ, s) && i1(t, s) && F_(i, s);
  for (; e.length > n; ) i1(t, s = e[n++]) && (~hJ(i, s) || F_(i, s));
  return i;
}, Qb = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
], pJ = zF, gJ = Qb, mJ = gJ.concat("length", "prototype");
$F.f = Object.getOwnPropertyNames || function(e) {
  return pJ(e, mJ);
};
var GF = {};
GF.f = Object.getOwnPropertySymbols;
var vJ = pl, bJ = wn, yJ = $F, wJ = GF, BJ = Hi, CJ = bJ([].concat), _J = vJ("Reflect", "ownKeys") || function(e) {
  var t = yJ.f(BJ(e)), n = wJ.f;
  return n ? CJ(t, n(e)) : t;
}, T_ = da, EJ = _J, SJ = Kf, IJ = po, FJ = function(r, e, t) {
  for (var n = EJ(e), i = IJ.f, s = SJ.f, a = 0; a < n.length; a++) {
    var o = n[a];
    !T_(r, o) && !(t && T_(t, o)) && i(r, o, s(e, o));
  }
}, TJ = yn, xJ = Bn, kJ = /#|\.prototype\./, Gf = function(r, e) {
  var t = UJ[LJ(r)];
  return t === OJ ? !0 : t === NJ ? !1 : xJ(e) ? TJ(e) : !!e;
}, LJ = Gf.normalize = function(r) {
  return String(r).replace(kJ, ".").toLowerCase();
}, UJ = Gf.data = {}, NJ = Gf.NATIVE = "N", OJ = Gf.POLYFILL = "P", qF = Gf, Dd = ln, QJ = Kf.f, DJ = zf, MJ = gl, RJ = Ib, PJ = FJ, HJ = qF, ji = function(r, e) {
  var t = r.target, n = r.global, i = r.stat, s, a, o, A, l, u;
  if (n ? a = Dd : i ? a = Dd[t] || RJ(t, {}) : a = Dd[t] && Dd[t].prototype, a) for (o in e) {
    if (l = e[o], r.dontCallGetSet ? (u = QJ(a, o), A = u && u.value) : A = a[o], s = HJ(n ? o : t + (i ? "." : "#") + o, r.forced), !s && A !== void 0) {
      if (typeof l == typeof A) continue;
      PJ(l, A);
    }
    (r.sham || A && A.sham) && DJ(l, "sham", !0), MJ(a, o, l, r);
  }
}, xc = ln, jJ = Vf, KJ = hl, Md = function(r) {
  return jJ.slice(0, r.length) === r;
}, WF = function() {
  return Md("Bun/") ? "BUN" : Md("Cloudflare-Workers") ? "CLOUDFLARE" : Md("Deno/") ? "DENO" : Md("Node.js/") ? "NODE" : xc.Bun && typeof Bun.version == "string" ? "BUN" : xc.Deno && typeof Deno.version == "object" ? "DENO" : KJ(xc.process) === "process" ? "NODE" : xc.window && xc.document ? "BROWSER" : "REST";
}(), $J = WF, Hg = $J === "NODE", VJ = wn, zJ = ho, GJ = function(r, e, t) {
  try {
    return VJ(zJ(Object.getOwnPropertyDescriptor(r, e)[t]));
  } catch {
  }
}, qJ = ha, WJ = function(r) {
  return qJ(r) || r === null;
}, XJ = WJ, JJ = String, YJ = TypeError, ZJ = function(r) {
  if (XJ(r)) return r;
  throw new YJ("Can't set " + JJ(r) + " as a prototype");
}, eY = GJ, tY = ha, rY = fa, nY = ZJ, XF = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var r = !1, e = {}, t;
  try {
    t = eY(Object.prototype, "__proto__", "set"), t(e, []), r = e instanceof Array;
  } catch {
  }
  return function(i, s) {
    return rY(i), nY(s), tY(i) && (r ? t(i, s) : i.__proto__ = s), i;
  };
}() : void 0), iY = po.f, sY = da, aY = Jn, x_ = aY("toStringTag"), jg = function(r, e, t) {
  r && !t && (r = r.prototype), r && !sY(r, x_) && iY(r, x_, { configurable: !0, value: e });
}, k_ = KF, oY = po, AY = function(r, e, t) {
  return t.get && k_(t.get, e, { getter: !0 }), t.set && k_(t.set, e, { setter: !0 }), oY.f(r, e, t);
}, lY = pl, uY = AY, cY = Jn, fY = ca, L_ = cY("species"), hY = function(r) {
  var e = lY(r);
  fY && e && !e[L_] && uY(e, L_, {
    configurable: !0,
    get: function() {
      return this;
    }
  });
}, dY = Ng, pY = TypeError, gY = function(r, e) {
  if (dY(e, r)) return r;
  throw new pY("Incorrect invocation");
}, mY = Jn, vY = mY("toStringTag"), JF = {};
JF[vY] = "z";
var bY = String(JF) === "[object z]", yY = bY, wY = Bn, fp = hl, BY = Jn, CY = BY("toStringTag"), _Y = Object, EY = fp(/* @__PURE__ */ function() {
  return arguments;
}()) === "Arguments", SY = function(r, e) {
  try {
    return r[e];
  } catch {
  }
}, Db = yY ? fp : function(r) {
  var e, t, n;
  return r === void 0 ? "Undefined" : r === null ? "Null" : typeof (t = SY(e = _Y(r), CY)) == "string" ? t : EY ? fp(e) : (n = fp(e)) === "Object" && wY(e.callee) ? "Arguments" : n;
}, IY = wn, FY = yn, YF = Bn, TY = Db, xY = pl, kY = kb, ZF = function() {
}, eT = xY("Reflect", "construct"), Mb = /^\s*(?:class|function)\b/, LY = IY(Mb.exec), UY = !Mb.test(ZF), kc = function(e) {
  if (!YF(e)) return !1;
  try {
    return eT(ZF, [], e), !0;
  } catch {
    return !1;
  }
}, tT = function(e) {
  if (!YF(e)) return !1;
  switch (TY(e)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return !1;
  }
  try {
    return UY || !!LY(Mb, kY(e));
  } catch {
    return !0;
  }
};
tT.sham = !0;
var NY = !eT || FY(function() {
  var r;
  return kc(kc.call) || !kc(Object) || !kc(function() {
    r = !0;
  }) || r;
}) ? tT : kc, OY = NY, QY = Og, DY = TypeError, MY = function(r) {
  if (OY(r)) return r;
  throw new DY(QY(r) + " is not a constructor");
}, U_ = Hi, RY = MY, PY = dl, HY = Jn, jY = HY("species"), rT = function(r, e) {
  var t = U_(r).constructor, n;
  return t === void 0 || PY(n = U_(t)[jY]) ? e : RY(n);
}, KY = Ug, nT = Function.prototype, N_ = nT.apply, O_ = nT.call, iT = typeof Reflect == "object" && Reflect.apply || (KY ? O_.bind(N_) : function() {
  return O_.apply(N_, arguments);
}), $Y = hl, VY = wn, Kg = function(r) {
  if ($Y(r) === "Function") return VY(r);
}, Q_ = Kg, zY = ho, GY = Ug, qY = Q_(Q_.bind), Rb = function(r, e) {
  return zY(r), e === void 0 ? r : GY ? qY(r, e) : function() {
    return r.apply(e, arguments);
  };
}, WY = pl, sT = WY("document", "documentElement"), XY = wn, JY = XY([].slice), YY = TypeError, ZY = function(r, e) {
  if (r < e) throw new YY("Not enough arguments");
  return r;
}, eZ = Vf, aT = /(?:ipad|iphone|ipod).*applewebkit/i.test(eZ), fs = ln, tZ = iT, rZ = Rb, D_ = Bn, nZ = da, oT = yn, M_ = sT, iZ = JY, R_ = Dg, sZ = ZY, aZ = aT, oZ = Hg, s2 = fs.setImmediate, a2 = fs.clearImmediate, AZ = fs.process, s1 = fs.Dispatch, lZ = fs.Function, P_ = fs.MessageChannel, uZ = fs.String, a1 = 0, ff = {}, H_ = "onreadystatechange", Uf, xA, o1, A1;
oT(function() {
  Uf = fs.location;
});
var Pb = function(r) {
  if (nZ(ff, r)) {
    var e = ff[r];
    delete ff[r], e();
  }
}, l1 = function(r) {
  return function() {
    Pb(r);
  };
}, j_ = function(r) {
  Pb(r.data);
}, K_ = function(r) {
  fs.postMessage(uZ(r), Uf.protocol + "//" + Uf.host);
};
(!s2 || !a2) && (s2 = function(e) {
  sZ(arguments.length, 1);
  var t = D_(e) ? e : lZ(e), n = iZ(arguments, 1);
  return ff[++a1] = function() {
    tZ(t, void 0, n);
  }, xA(a1), a1;
}, a2 = function(e) {
  delete ff[e];
}, oZ ? xA = function(r) {
  AZ.nextTick(l1(r));
} : s1 && s1.now ? xA = function(r) {
  s1.now(l1(r));
} : P_ && !aZ ? (o1 = new P_(), A1 = o1.port2, o1.port1.onmessage = j_, xA = rZ(A1.postMessage, A1)) : fs.addEventListener && D_(fs.postMessage) && !fs.importScripts && Uf && Uf.protocol !== "file:" && !oT(K_) ? (xA = K_, fs.addEventListener("message", j_, !1)) : H_ in R_("script") ? xA = function(r) {
  M_.appendChild(R_("script"))[H_] = function() {
    M_.removeChild(this), Pb(r);
  };
} : xA = function(r) {
  setTimeout(l1(r), 0);
});
var AT = {
  set: s2,
  clear: a2
}, $_ = ln, cZ = ca, fZ = Object.getOwnPropertyDescriptor, hZ = function(r) {
  if (!cZ) return $_[r];
  var e = fZ($_, r);
  return e && e.value;
}, lT = function() {
  this.head = null, this.tail = null;
};
lT.prototype = {
  add: function(r) {
    var e = { item: r, next: null }, t = this.tail;
    t ? t.next = e : this.head = e, this.tail = e;
  },
  get: function() {
    var r = this.head;
    if (r) {
      var e = this.head = r.next;
      return e === null && (this.tail = null), r.item;
    }
  }
};
var uT = lT, dZ = Vf, pZ = /ipad|iphone|ipod/i.test(dZ) && typeof Pebble < "u", gZ = Vf, mZ = /web0s(?!.*chrome)/i.test(gZ), Ou = ln, vZ = hZ, V_ = Rb, u1 = AT.set, bZ = uT, yZ = aT, wZ = pZ, BZ = mZ, c1 = Hg, z_ = Ou.MutationObserver || Ou.WebKitMutationObserver, G_ = Ou.document, q_ = Ou.process, Rd = Ou.Promise, o2 = vZ("queueMicrotask"), eu, f1, h1, Pd, W_;
if (!o2) {
  var Hd = new bZ(), jd = function() {
    var r, e;
    for (c1 && (r = q_.domain) && r.exit(); e = Hd.get(); ) try {
      e();
    } catch (t) {
      throw Hd.head && eu(), t;
    }
    r && r.enter();
  };
  !yZ && !c1 && !BZ && z_ && G_ ? (f1 = !0, h1 = G_.createTextNode(""), new z_(jd).observe(h1, { characterData: !0 }), eu = function() {
    h1.data = f1 = !f1;
  }) : !wZ && Rd && Rd.resolve ? (Pd = Rd.resolve(void 0), Pd.constructor = Rd, W_ = V_(Pd.then, Pd), eu = function() {
    W_(jd);
  }) : c1 ? eu = function() {
    q_.nextTick(jd);
  } : (u1 = V_(u1, Ou), eu = function() {
    u1(jd);
  }), o2 = function(r) {
    Hd.head || eu(), Hd.add(r);
  };
}
var CZ = o2, _Z = function(r, e) {
  try {
    arguments.length === 1 ? console.error(r) : console.error(r, e);
  } catch {
  }
}, Hb = function(r) {
  try {
    return { error: !1, value: r() };
  } catch (e) {
    return { error: !0, value: e };
  }
}, EZ = ln, $g = EZ.Promise, SZ = ln, hf = $g, IZ = Bn, FZ = qF, TZ = kb, xZ = Jn, X_ = WF, d1 = Sb;
hf && hf.prototype;
var kZ = xZ("species"), A2 = !1, cT = IZ(SZ.PromiseRejectionEvent), LZ = FZ("Promise", function() {
  var r = TZ(hf), e = r !== String(hf);
  if (!e && d1 === 66) return !0;
  if (!d1 || d1 < 51 || !/native code/.test(r)) {
    var t = new hf(function(s) {
      s(1);
    }), n = function(s) {
      s(function() {
      }, function() {
      });
    }, i = t.constructor = {};
    if (i[kZ] = n, A2 = t.then(function() {
    }) instanceof n, !A2) return !0;
  }
  return !e && (X_ === "BROWSER" || X_ === "DENO") && !cT;
}), qf = {
  CONSTRUCTOR: LZ,
  REJECTION_EVENT: cT,
  SUBCLASSING: A2
}, Ku = {}, J_ = ho, UZ = TypeError, NZ = function(r) {
  var e, t;
  this.promise = new r(function(n, i) {
    if (e !== void 0 || t !== void 0) throw new UZ("Bad Promise constructor");
    e = n, t = i;
  }), this.resolve = J_(e), this.reject = J_(t);
};
Ku.f = function(r) {
  return new NZ(r);
};
var OZ = ji, Wp = Hg, AA = ln, Qu = ci, Y_ = gl, Z_ = XF, QZ = jg, DZ = hY, MZ = ho, hp = Bn, RZ = ha, PZ = gY, HZ = rT, fT = AT.set, jb = CZ, jZ = _Z, KZ = Hb, $Z = uT, hT = Rg, Xp = $g, Kb = qf, dT = Ku, Vg = "Promise", pT = Kb.CONSTRUCTOR, VZ = Kb.REJECTION_EVENT, zZ = Kb.SUBCLASSING, p1 = hT.getterFor(Vg), GZ = hT.set, uu = Xp && Xp.prototype, MA = Xp, Kd = uu, gT = AA.TypeError, l2 = AA.document, $b = AA.process, u2 = dT.f, qZ = u2, WZ = !!(l2 && l2.createEvent && AA.dispatchEvent), mT = "unhandledrejection", XZ = "rejectionhandled", e4 = 0, vT = 1, JZ = 2, Vb = 1, bT = 2, $d, t4, YZ, r4, yT = function(r) {
  var e;
  return RZ(r) && hp(e = r.then) ? e : !1;
}, wT = function(r, e) {
  var t = e.value, n = e.state === vT, i = n ? r.ok : r.fail, s = r.resolve, a = r.reject, o = r.domain, A, l, u;
  try {
    i ? (n || (e.rejection === bT && eee(e), e.rejection = Vb), i === !0 ? A = t : (o && o.enter(), A = i(t), o && (o.exit(), u = !0)), A === r.promise ? a(new gT("Promise-chain cycle")) : (l = yT(A)) ? Qu(l, A, s, a) : s(A)) : a(t);
  } catch (c) {
    o && !u && o.exit(), a(c);
  }
}, BT = function(r, e) {
  r.notified || (r.notified = !0, jb(function() {
    for (var t = r.reactions, n; n = t.get(); )
      wT(n, r);
    r.notified = !1, e && !r.rejection && ZZ(r);
  }));
}, CT = function(r, e, t) {
  var n, i;
  WZ ? (n = l2.createEvent("Event"), n.promise = e, n.reason = t, n.initEvent(r, !1, !0), AA.dispatchEvent(n)) : n = { promise: e, reason: t }, !VZ && (i = AA["on" + r]) ? i(n) : r === mT && jZ("Unhandled promise rejection", t);
}, ZZ = function(r) {
  Qu(fT, AA, function() {
    var e = r.facade, t = r.value, n = n4(r), i;
    if (n && (i = KZ(function() {
      Wp ? $b.emit("unhandledRejection", t, e) : CT(mT, e, t);
    }), r.rejection = Wp || n4(r) ? bT : Vb, i.error))
      throw i.value;
  });
}, n4 = function(r) {
  return r.rejection !== Vb && !r.parent;
}, eee = function(r) {
  Qu(fT, AA, function() {
    var e = r.facade;
    Wp ? $b.emit("rejectionHandled", e) : CT(XZ, e, r.value);
  });
}, mu = function(r, e, t) {
  return function(n) {
    r(e, n, t);
  };
}, Eu = function(r, e, t) {
  r.done || (r.done = !0, t && (r = t), r.value = e, r.state = JZ, BT(r, !0));
}, c2 = function(r, e, t) {
  if (!r.done) {
    r.done = !0, t && (r = t);
    try {
      if (r.facade === e) throw new gT("Promise can't be resolved itself");
      var n = yT(e);
      n ? jb(function() {
        var i = { done: !1 };
        try {
          Qu(
            n,
            e,
            mu(c2, i, r),
            mu(Eu, i, r)
          );
        } catch (s) {
          Eu(i, s, r);
        }
      }) : (r.value = e, r.state = vT, BT(r, !1));
    } catch (i) {
      Eu({ done: !1 }, i, r);
    }
  }
};
if (pT && (MA = function(e) {
  PZ(this, Kd), MZ(e), Qu($d, this);
  var t = p1(this);
  try {
    e(mu(c2, t), mu(Eu, t));
  } catch (n) {
    Eu(t, n);
  }
}, Kd = MA.prototype, $d = function(e) {
  GZ(this, {
    type: Vg,
    done: !1,
    notified: !1,
    parent: !1,
    reactions: new $Z(),
    rejection: !1,
    state: e4,
    value: null
  });
}, $d.prototype = Y_(Kd, "then", function(e, t) {
  var n = p1(this), i = u2(HZ(this, MA));
  return n.parent = !0, i.ok = hp(e) ? e : !0, i.fail = hp(t) && t, i.domain = Wp ? $b.domain : void 0, n.state === e4 ? n.reactions.add(i) : jb(function() {
    wT(i, n);
  }), i.promise;
}), t4 = function() {
  var r = new $d(), e = p1(r);
  this.promise = r, this.resolve = mu(c2, e), this.reject = mu(Eu, e);
}, dT.f = u2 = function(r) {
  return r === MA || r === YZ ? new t4(r) : qZ(r);
}, hp(Xp) && uu !== Object.prototype)) {
  r4 = uu.then, zZ || Y_(uu, "then", function(e, t) {
    var n = this;
    return new MA(function(i, s) {
      Qu(r4, n, i, s);
    }).then(e, t);
  }, { unsafe: !0 });
  try {
    delete uu.constructor;
  } catch {
  }
  Z_ && Z_(uu, Kd);
}
OZ({ global: !0, constructor: !0, wrap: !0, forced: pT }, {
  Promise: MA
});
QZ(MA, Vg, !1);
DZ(Vg);
var Wf = {}, tee = Jn, ree = Wf, nee = tee("iterator"), iee = Array.prototype, see = function(r) {
  return r !== void 0 && (ree.Array === r || iee[nee] === r);
}, aee = Db, i4 = Hu, oee = dl, Aee = Wf, lee = Jn, uee = lee("iterator"), _T = function(r) {
  if (!oee(r)) return i4(r, uee) || i4(r, "@@iterator") || Aee[aee(r)];
}, cee = ci, fee = ho, hee = Hi, dee = Og, pee = _T, gee = TypeError, mee = function(r, e) {
  var t = arguments.length < 2 ? pee(r) : e;
  if (fee(t)) return hee(cee(t, r));
  throw new gee(dee(r) + " is not iterable");
}, vee = ci, s4 = Hi, bee = Hu, yee = function(r, e, t) {
  var n, i;
  s4(r);
  try {
    if (n = bee(r, "return"), !n) {
      if (e === "throw") throw t;
      return t;
    }
    n = vee(n, r);
  } catch (s) {
    i = !0, n = s;
  }
  if (e === "throw") throw t;
  if (i) throw n;
  return s4(n), t;
}, wee = Rb, Bee = ci, Cee = Hi, _ee = Og, Eee = see, See = Ob, a4 = Ng, Iee = mee, Fee = _T, o4 = yee, Tee = TypeError, dp = function(r, e) {
  this.stopped = r, this.result = e;
}, A4 = dp.prototype, ET = function(r, e, t) {
  var n = t && t.that, i = !!(t && t.AS_ENTRIES), s = !!(t && t.IS_RECORD), a = !!(t && t.IS_ITERATOR), o = !!(t && t.INTERRUPTED), A = wee(e, n), l, u, c, h, f, d, p, v = function(b) {
    return l && o4(l, "normal", b), new dp(!0, b);
  }, m = function(b) {
    return i ? (Cee(b), o ? A(b[0], b[1], v) : A(b[0], b[1])) : o ? A(b, v) : A(b);
  };
  if (s)
    l = r.iterator;
  else if (a)
    l = r;
  else {
    if (u = Fee(r), !u) throw new Tee(_ee(r) + " is not iterable");
    if (Eee(u)) {
      for (c = 0, h = See(r); h > c; c++)
        if (f = m(r[c]), f && a4(A4, f)) return f;
      return new dp(!1);
    }
    l = Iee(r, u);
  }
  for (d = s ? r.next : l.next; !(p = Bee(d, l)).done; ) {
    try {
      f = m(p.value);
    } catch (b) {
      o4(l, "throw", b);
    }
    if (typeof f == "object" && f && a4(A4, f)) return f;
  }
  return new dp(!1);
}, xee = Jn, ST = xee("iterator"), IT = !1;
try {
  var kee = 0, l4 = {
    next: function() {
      return { done: !!kee++ };
    },
    return: function() {
      IT = !0;
    }
  };
  l4[ST] = function() {
    return this;
  }, Array.from(l4, function() {
    throw 2;
  });
} catch {
}
var Lee = function(r, e) {
  try {
    if (!e && !IT) return !1;
  } catch {
    return !1;
  }
  var t = !1;
  try {
    var n = {};
    n[ST] = function() {
      return {
        next: function() {
          return { done: t = !0 };
        }
      };
    }, r(n);
  } catch {
  }
  return t;
}, Uee = $g, Nee = Lee, Oee = qf.CONSTRUCTOR, FT = Oee || !Nee(function(r) {
  Uee.all(r).then(void 0, function() {
  });
}), Qee = ji, Dee = ci, Mee = ho, Ree = Ku, Pee = Hb, Hee = ET, jee = FT;
Qee({ target: "Promise", stat: !0, forced: jee }, {
  all: function(e) {
    var t = this, n = Ree.f(t), i = n.resolve, s = n.reject, a = Pee(function() {
      var o = Mee(t.resolve), A = [], l = 0, u = 1;
      Hee(e, function(c) {
        var h = l++, f = !1;
        u++, Dee(o, t, c).then(function(d) {
          f || (f = !0, A[h] = d, --u || i(A));
        }, s);
      }), --u || i(A);
    });
    return a.error && s(a.value), n.promise;
  }
});
var Kee = ji, $ee = qf.CONSTRUCTOR, f2 = $g, Vee = pl, zee = Bn, Gee = gl, u4 = f2 && f2.prototype;
Kee({ target: "Promise", proto: !0, forced: $ee, real: !0 }, {
  catch: function(r) {
    return this.then(void 0, r);
  }
});
if (zee(f2)) {
  var c4 = Vee("Promise").prototype.catch;
  u4.catch !== c4 && Gee(u4, "catch", c4, { unsafe: !0 });
}
var qee = ji, Wee = ci, Xee = ho, Jee = Ku, Yee = Hb, Zee = ET, ete = FT;
qee({ target: "Promise", stat: !0, forced: ete }, {
  race: function(e) {
    var t = this, n = Jee.f(t), i = n.reject, s = Yee(function() {
      var a = Xee(t.resolve);
      Zee(e, function(o) {
        Wee(a, t, o).then(n.resolve, i);
      });
    });
    return s.error && i(s.value), n.promise;
  }
});
var tte = ji, rte = Ku, nte = qf.CONSTRUCTOR;
tte({ target: "Promise", stat: !0, forced: nte }, {
  reject: function(e) {
    var t = rte.f(this), n = t.reject;
    return n(e), t.promise;
  }
});
var ite = Hi, ste = ha, ate = Ku, ote = function(r, e) {
  if (ite(r), ste(e) && e.constructor === r) return e;
  var t = ate.f(r), n = t.resolve;
  return n(e), t.promise;
}, Ate = ji, lte = pl, ute = qf.CONSTRUCTOR, cte = ote;
lte("Promise");
Ate({ target: "Promise", stat: !0, forced: ute }, {
  resolve: function(e) {
    return cte(this, e);
  }
});
function f4(r, e, t, n, i, s, a) {
  try {
    var o = r[s](a), A = o.value;
  } catch (l) {
    return void t(l);
  }
  o.done ? e(A) : Promise.resolve(A).then(n, i);
}
function uo(r) {
  return function() {
    var e = this, t = arguments;
    return new Promise(function(n, i) {
      var s = r.apply(e, t);
      function a(A) {
        f4(s, n, i, a, o, "next", A);
      }
      function o(A) {
        f4(s, n, i, a, o, "throw", A);
      }
      a(void 0);
    });
  };
}
var fte = Db, hte = String, Ma = function(r) {
  if (fte(r) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
  return hte(r);
}, dte = Hi, TT = function() {
  var r = dte(this), e = "";
  return r.hasIndices && (e += "d"), r.global && (e += "g"), r.ignoreCase && (e += "i"), r.multiline && (e += "m"), r.dotAll && (e += "s"), r.unicode && (e += "u"), r.unicodeSets && (e += "v"), r.sticky && (e += "y"), e;
}, zb = yn, pte = ln, Gb = pte.RegExp, qb = zb(function() {
  var r = Gb("a", "y");
  return r.lastIndex = 2, r.exec("abcd") !== null;
}), gte = qb || zb(function() {
  return !Gb("a", "y").sticky;
}), mte = qb || zb(function() {
  var r = Gb("^r", "gy");
  return r.lastIndex = 2, r.exec("str") !== null;
}), xT = {
  BROKEN_CARET: mte,
  MISSED_STICKY: gte,
  UNSUPPORTED_Y: qb
}, kT = {}, vte = zF, bte = Qb, yte = Object.keys || function(e) {
  return vte(e, bte);
}, wte = ca, Bte = MF, Cte = po, _te = Hi, Ete = $f, Ste = yte;
kT.f = wte && !Bte ? Object.defineProperties : function(e, t) {
  _te(e);
  for (var n = Ete(t), i = Ste(t), s = i.length, a = 0, o; s > a; ) Cte.f(e, o = i[a++], n[o]);
  return e;
};
var Ite = Hi, Fte = kT, h4 = Qb, Tte = Ub, xte = sT, kte = Dg, Lte = Lb, d4 = ">", p4 = "<", h2 = "prototype", d2 = "script", LT = Lte("IE_PROTO"), g1 = function() {
}, UT = function(r) {
  return p4 + d2 + d4 + r + p4 + "/" + d2 + d4;
}, g4 = function(r) {
  r.write(UT("")), r.close();
  var e = r.parentWindow.Object;
  return r = null, e;
}, Ute = function() {
  var r = kte("iframe"), e = "java" + d2 + ":", t;
  return r.style.display = "none", xte.appendChild(r), r.src = String(e), t = r.contentWindow.document, t.open(), t.write(UT("document.F=Object")), t.close(), t.F;
}, Vd, pp = function() {
  try {
    Vd = new ActiveXObject("htmlfile");
  } catch {
  }
  pp = typeof document < "u" ? document.domain && Vd ? g4(Vd) : Ute() : g4(Vd);
  for (var r = h4.length; r--; ) delete pp[h2][h4[r]];
  return pp();
};
Tte[LT] = !0;
var Wb = Object.create || function(e, t) {
  var n;
  return e !== null ? (g1[h2] = Ite(e), n = new g1(), g1[h2] = null, n[LT] = e) : n = pp(), t === void 0 ? n : Fte.f(n, t);
}, Nte = yn, Ote = ln, Qte = Ote.RegExp, Dte = Nte(function() {
  var r = Qte(".", "s");
  return !(r.dotAll && r.test(`
`) && r.flags === "s");
}), Mte = yn, Rte = ln, Pte = Rte.RegExp, Hte = Mte(function() {
  var r = Pte("(?<a>b)", "g");
  return r.exec("b").groups.a !== "b" || "b".replace(r, "$<a>c") !== "bc";
}), vu = ci, zg = wn, jte = Ma, Kte = TT, $te = xT, Vte = Tb, zte = Wb, Gte = Rg.get, qte = Dte, Wte = Hte, Xte = Vte("native-string-replace", String.prototype.replace), Jp = RegExp.prototype.exec, p2 = Jp, Jte = zg("".charAt), Yte = zg("".indexOf), Zte = zg("".replace), m1 = zg("".slice), g2 = function() {
  var r = /a/, e = /b*/g;
  return vu(Jp, r, "a"), vu(Jp, e, "a"), r.lastIndex !== 0 || e.lastIndex !== 0;
}(), NT = $te.BROKEN_CARET, m2 = /()??/.exec("")[1] !== void 0, ere = g2 || m2 || NT || qte || Wte;
ere && (p2 = function(e) {
  var t = this, n = Gte(t), i = jte(e), s = n.raw, a, o, A, l, u, c, h;
  if (s)
    return s.lastIndex = t.lastIndex, a = vu(p2, s, i), t.lastIndex = s.lastIndex, a;
  var f = n.groups, d = NT && t.sticky, p = vu(Kte, t), v = t.source, m = 0, b = i;
  if (d && (p = Zte(p, "y", ""), Yte(p, "g") === -1 && (p += "g"), b = m1(i, t.lastIndex), t.lastIndex > 0 && (!t.multiline || t.multiline && Jte(i, t.lastIndex - 1) !== `
`) && (v = "(?: " + v + ")", b = " " + b, m++), o = new RegExp("^(?:" + v + ")", p)), m2 && (o = new RegExp("^" + v + "$(?!\\s)", p)), g2 && (A = t.lastIndex), l = vu(Jp, d ? o : t, b), d ? l ? (l.input = m1(l.input, m), l[0] = m1(l[0], m), l.index = t.lastIndex, t.lastIndex += l[0].length) : t.lastIndex = 0 : g2 && l && (t.lastIndex = t.global ? l.index + l[0].length : A), m2 && l && l.length > 1 && vu(Xte, l[0], o, function() {
    for (u = 1; u < arguments.length - 2; u++)
      arguments[u] === void 0 && (l[u] = void 0);
  }), l && f)
    for (l.groups = c = zte(null), u = 0; u < f.length; u++)
      h = f[u], c[h[0]] = l[h[1]];
  return l;
});
var Xb = p2, tre = ji, m4 = Xb;
tre({ target: "RegExp", proto: !0, forced: /./.exec !== m4 }, {
  exec: m4
});
var v4 = ci, b4 = gl, rre = Xb, y4 = yn, OT = Jn, nre = zf, ire = OT("species"), v1 = RegExp.prototype, Jb = function(r, e, t, n) {
  var i = OT(r), s = !y4(function() {
    var l = {};
    return l[i] = function() {
      return 7;
    }, ""[r](l) !== 7;
  }), a = s && !y4(function() {
    var l = !1, u = /a/;
    return r === "split" && (u = {}, u.constructor = {}, u.constructor[ire] = function() {
      return u;
    }, u.flags = "", u[i] = /./[i]), u.exec = function() {
      return l = !0, null;
    }, u[i](""), !l;
  });
  if (!s || !a || t) {
    var o = /./[i], A = e(i, ""[r], function(l, u, c, h, f) {
      var d = u.exec;
      return d === rre || d === v1.exec ? s && !f ? { done: !0, value: v4(o, u, c, h) } : { done: !0, value: v4(l, c, u, h) } : { done: !1 };
    });
    b4(String.prototype, r, A[0]), b4(v1, i, A[1]);
  }
  n && nre(v1[i], "sham", !0);
}, Yb = wn, sre = Pg, are = Ma, ore = fa, Are = Yb("".charAt), w4 = Yb("".charCodeAt), lre = Yb("".slice), B4 = function(r) {
  return function(e, t) {
    var n = are(ore(e)), i = sre(t), s = n.length, a, o;
    return i < 0 || i >= s ? r ? "" : void 0 : (a = w4(n, i), a < 55296 || a > 56319 || i + 1 === s || (o = w4(n, i + 1)) < 56320 || o > 57343 ? r ? Are(n, i) : a : r ? lre(n, i, i + 2) : (a - 55296 << 10) + (o - 56320) + 65536);
  };
}, ure = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: B4(!1),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: B4(!0)
}, cre = ure.charAt, Zb = function(r, e, t) {
  return e + (t ? cre(r, e).length : 1);
}, C4 = ci, fre = Hi, hre = Bn, dre = hl, pre = Xb, gre = TypeError, ey = function(r, e) {
  var t = r.exec;
  if (hre(t)) {
    var n = C4(t, r, e);
    return n !== null && fre(n), n;
  }
  if (dre(r) === "RegExp") return C4(pre, r, e);
  throw new gre("RegExp#exec called on incompatible receiver");
}, mre = ci, vre = Jb, bre = Hi, yre = dl, wre = ju, b1 = Ma, Bre = fa, Cre = Hu, _re = Zb, _4 = ey;
vre("match", function(r, e, t) {
  return [
    // `String.prototype.match` method
    // https://tc39.es/ecma262/#sec-string.prototype.match
    function(i) {
      var s = Bre(this), a = yre(i) ? void 0 : Cre(i, r);
      return a ? mre(a, i, s) : new RegExp(i)[r](b1(s));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
    function(n) {
      var i = bre(this), s = b1(n), a = t(e, i, s);
      if (a.done) return a.value;
      if (!i.global) return _4(i, s);
      var o = i.unicode;
      i.lastIndex = 0;
      for (var A = [], l = 0, u; (u = _4(i, s)) !== null; ) {
        var c = b1(u[0]);
        A[l] = c, c === "" && (i.lastIndex = _re(s, wre(i.lastIndex), o)), l++;
      }
      return l === 0 ? null : A;
    }
  ];
});
var ty = wn, Ere = Qg, Sre = Math.floor, y1 = ty("".charAt), Ire = ty("".replace), w1 = ty("".slice), Fre = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, Tre = /\$([$&'`]|\d{1,2})/g, xre = function(r, e, t, n, i, s) {
  var a = t + r.length, o = n.length, A = Tre;
  return i !== void 0 && (i = Ere(i), A = Fre), Ire(s, A, function(l, u) {
    var c;
    switch (y1(u, 0)) {
      case "$":
        return "$";
      case "&":
        return r;
      case "`":
        return w1(e, 0, t);
      case "'":
        return w1(e, a);
      case "<":
        c = i[w1(u, 1, -1)];
        break;
      default:
        var h = +u;
        if (h === 0) return l;
        if (h > o) {
          var f = Sre(h / 10);
          return f === 0 ? l : f <= o ? n[f - 1] === void 0 ? y1(u, 1) : n[f - 1] + y1(u, 1) : l;
        }
        c = n[h - 1];
    }
    return c === void 0 ? "" : c;
  });
}, kre = iT, E4 = ci, Gg = wn, Lre = Jb, Ure = yn, Nre = Hi, Ore = Bn, Qre = dl, Dre = Pg, Mre = ju, tu = Ma, Rre = fa, Pre = Zb, Hre = Hu, jre = xre, Kre = ey, $re = Jn, v2 = $re("replace"), Vre = Math.max, zre = Math.min, Gre = Gg([].concat), B1 = Gg([].push), S4 = Gg("".indexOf), I4 = Gg("".slice), qre = function(r) {
  return r === void 0 ? r : String(r);
}, Wre = function() {
  return "a".replace(/./, "$0") === "$0";
}(), F4 = function() {
  return /./[v2] ? /./[v2]("a", "$0") === "" : !1;
}(), Xre = !Ure(function() {
  var r = /./;
  return r.exec = function() {
    var e = [];
    return e.groups = { a: "7" }, e;
  }, "".replace(r, "$<a>") !== "7";
});
Lre("replace", function(r, e, t) {
  var n = F4 ? "$" : "$0";
  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function(s, a) {
      var o = Rre(this), A = Qre(s) ? void 0 : Hre(s, v2);
      return A ? E4(A, s, o, a) : E4(e, tu(o), s, a);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function(i, s) {
      var a = Nre(this), o = tu(i);
      if (typeof s == "string" && S4(s, n) === -1 && S4(s, "$<") === -1) {
        var A = t(e, a, o, s);
        if (A.done) return A.value;
      }
      var l = Ore(s);
      l || (s = tu(s));
      var u = a.global, c;
      u && (c = a.unicode, a.lastIndex = 0);
      for (var h = [], f; f = Kre(a, o), !(f === null || (B1(h, f), !u)); ) {
        var d = tu(f[0]);
        d === "" && (a.lastIndex = Pre(o, Mre(a.lastIndex), c));
      }
      for (var p = "", v = 0, m = 0; m < h.length; m++) {
        f = h[m];
        for (var b = tu(f[0]), w = Vre(zre(Dre(f.index), o.length), 0), B = [], _, x = 1; x < f.length; x++) B1(B, qre(f[x]));
        var C = f.groups;
        if (l) {
          var F = Gre([b], B, w, o);
          C !== void 0 && B1(F, C), _ = tu(kre(s, void 0, F));
        } else
          _ = jre(b, o, w, B, C, s);
        w >= v && (p += I4(o, v, w) + _, v = w + b.length);
      }
      return p + I4(o, v);
    }
  ];
}, !Xre || !Wre || F4);
var Jre = ha, Yre = hl, Zre = Jn, ene = Zre("match"), tne = function(r) {
  var e;
  return Jre(r) && ((e = r[ene]) !== void 0 ? !!e : Yre(r) === "RegExp");
}, rne = tne, nne = TypeError, ry = function(r) {
  if (rne(r))
    throw new nne("The method doesn't accept regular expressions");
  return r;
}, ine = Jn, sne = ine("match"), ny = function(r) {
  var e = /./;
  try {
    "/./"[r](e);
  } catch {
    try {
      return e[sne] = !1, "/./"[r](e);
    } catch {
    }
  }
  return !1;
}, ane = ji, one = Kg, Ane = Kf.f, lne = ju, T4 = Ma, une = ry, cne = fa, fne = ny, hne = one("".slice), dne = Math.min, QT = fne("startsWith"), pne = !QT && !!function() {
  var r = Ane(String.prototype, "startsWith");
  return r && !r.writable;
}();
ane({ target: "String", proto: !0, forced: !pne && !QT }, {
  startsWith: function(e) {
    var t = T4(cne(this));
    une(e);
    var n = lne(dne(arguments.length > 1 ? arguments[1] : void 0, t.length)), i = T4(e);
    return hne(t, n, n + i.length) === i;
  }
});
var gne = Jn, mne = Wb, vne = po.f, b2 = gne("unscopables"), y2 = Array.prototype;
y2[b2] === void 0 && vne(y2, b2, {
  configurable: !0,
  value: mne(null)
});
var bne = function(r) {
  y2[b2][r] = !0;
}, yne = yn, wne = !yne(function() {
  function r() {
  }
  return r.prototype.constructor = null, Object.getPrototypeOf(new r()) !== r.prototype;
}), Bne = da, Cne = Bn, _ne = Qg, Ene = Lb, Sne = wne, x4 = Ene("IE_PROTO"), w2 = Object, Ine = w2.prototype, DT = Sne ? w2.getPrototypeOf : function(r) {
  var e = _ne(r);
  if (Bne(e, x4)) return e[x4];
  var t = e.constructor;
  return Cne(t) && e instanceof t ? t.prototype : e instanceof w2 ? Ine : null;
}, Fne = yn, Tne = Bn, xne = ha, k4 = DT, kne = gl, Lne = Jn, B2 = Lne("iterator"), MT = !1, ll, C1, _1;
[].keys && (_1 = [].keys(), "next" in _1 ? (C1 = k4(k4(_1)), C1 !== Object.prototype && (ll = C1)) : MT = !0);
var Une = !xne(ll) || Fne(function() {
  var r = {};
  return ll[B2].call(r) !== r;
});
Une && (ll = {});
Tne(ll[B2]) || kne(ll, B2, function() {
  return this;
});
var RT = {
  IteratorPrototype: ll,
  BUGGY_SAFARI_ITERATORS: MT
}, Nne = RT.IteratorPrototype, One = Wb, Qne = Eb, Dne = jg, Mne = Wf, Rne = function() {
  return this;
}, Pne = function(r, e, t, n) {
  var i = e + " Iterator";
  return r.prototype = One(Nne, { next: Qne(+!n, t) }), Dne(r, i, !1), Mne[i] = Rne, r;
}, Hne = ji, jne = ci, PT = Mg, Kne = Bn, $ne = Pne, L4 = DT, U4 = XF, Vne = jg, zne = zf, E1 = gl, Gne = Jn, qne = Wf, HT = RT, Wne = PT.PROPER, Xne = PT.CONFIGURABLE, N4 = HT.IteratorPrototype, zd = HT.BUGGY_SAFARI_ITERATORS, Lc = Gne("iterator"), O4 = "keys", Uc = "values", Q4 = "entries", Jne = function() {
  return this;
}, Yne = function(r, e, t, n, i, s, a) {
  $ne(t, e, n);
  var o = function(m) {
    if (m === i && h) return h;
    if (!zd && m && m in u) return u[m];
    switch (m) {
      case O4:
        return function() {
          return new t(this, m);
        };
      case Uc:
        return function() {
          return new t(this, m);
        };
      case Q4:
        return function() {
          return new t(this, m);
        };
    }
    return function() {
      return new t(this);
    };
  }, A = e + " Iterator", l = !1, u = r.prototype, c = u[Lc] || u["@@iterator"] || i && u[i], h = !zd && c || o(i), f = e === "Array" && u.entries || c, d, p, v;
  if (f && (d = L4(f.call(new r())), d !== Object.prototype && d.next && (L4(d) !== N4 && (U4 ? U4(d, N4) : Kne(d[Lc]) || E1(d, Lc, Jne)), Vne(d, A, !0))), Wne && i === Uc && c && c.name !== Uc && (Xne ? zne(u, "name", Uc) : (l = !0, h = function() {
    return jne(c, this);
  })), i)
    if (p = {
      values: o(Uc),
      keys: s ? h : o(O4),
      entries: o(Q4)
    }, a) for (v in p)
      (zd || l || !(v in u)) && E1(u, v, p[v]);
    else Hne({ target: e, proto: !0, forced: zd || l }, p);
  return u[Lc] !== h && E1(u, Lc, h, { name: i }), qne[e] = h, p;
}, Zne = function(r, e) {
  return { value: r, done: e };
}, eie = $f, iy = bne, D4 = Wf, jT = Rg, tie = po.f, rie = Yne, Gd = Zne, nie = ca, KT = "Array Iterator", iie = jT.set, sie = jT.getterFor(KT), aie = rie(Array, "Array", function(r, e) {
  iie(this, {
    type: KT,
    target: eie(r),
    // target
    index: 0,
    // next index
    kind: e
    // kind
  });
}, function() {
  var r = sie(this), e = r.target, t = r.index++;
  if (!e || t >= e.length)
    return r.target = null, Gd(void 0, !0);
  switch (r.kind) {
    case "keys":
      return Gd(t, !1);
    case "values":
      return Gd(e[t], !1);
  }
  return Gd([t, e[t]], !1);
}, "values"), M4 = D4.Arguments = D4.Array;
iy("keys");
iy("values");
iy("entries");
if (nie && M4.name !== "values") try {
  tie(M4, "name", { value: "values" });
} catch {
}
var oie = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}, Aie = Dg, S1 = Aie("span").classList, R4 = S1 && S1.constructor && S1.constructor.prototype, lie = R4 === Object.prototype ? void 0 : R4, P4 = ln, $T = oie, uie = lie, Vc = aie, H4 = zf, cie = jg, fie = Jn, I1 = fie("iterator"), F1 = Vc.values, VT = function(r, e) {
  if (r) {
    if (r[I1] !== F1) try {
      H4(r, I1, F1);
    } catch {
      r[I1] = F1;
    }
    if (cie(r, e, !0), $T[e]) {
      for (var t in Vc)
        if (r[t] !== Vc[t]) try {
          H4(r, t, Vc[t]);
        } catch {
          r[t] = Vc[t];
        }
    }
  }
};
for (var T1 in $T)
  VT(P4[T1] && P4[T1].prototype, T1);
VT(uie, "DOMTokenList");
function hie(r, e) {
  if (br(r) != "object" || !r) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e || "default");
    if (br(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(r);
}
function die(r) {
  var e = hie(r, "string");
  return br(e) == "symbol" ? e : e + "";
}
function sy(r, e, t) {
  return (e = die(e)) in r ? Object.defineProperty(r, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = t, r;
}
var pie = ho, gie = Qg, mie = TF, vie = Ob, j4 = TypeError, K4 = "Reduce of empty array with no initial value", $4 = function(r) {
  return function(e, t, n, i) {
    var s = gie(e), a = mie(s), o = vie(s);
    if (pie(t), o === 0 && n < 2) throw new j4(K4);
    var A = r ? o - 1 : 0, l = r ? -1 : 1;
    if (n < 2) for (; ; ) {
      if (A in a) {
        i = a[A], A += l;
        break;
      }
      if (A += l, r ? A < 0 : o <= A)
        throw new j4(K4);
    }
    for (; r ? A >= 0 : o > A; A += l) A in a && (i = t(i, a[A], A, s));
    return i;
  };
}, bie = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: $4(!1),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: $4(!0)
}, yie = yn, zT = function(r, e) {
  var t = [][r];
  return !!t && yie(function() {
    t.call(null, e || function() {
      return 1;
    }, 1);
  });
}, wie = ji, Bie = bie.left, Cie = zT, V4 = Sb, _ie = Hg, Eie = !_ie && V4 > 79 && V4 < 83, Sie = Eie || !Cie("reduce");
wie({ target: "Array", proto: !0, forced: Sie }, {
  reduce: function(e) {
    var t = arguments.length;
    return Bie(this, e, t, t > 1 ? arguments[1] : void 0);
  }
});
var Iie = ji, Fie = Kg, Tie = Kf.f, xie = ju, z4 = Ma, kie = ry, Lie = fa, Uie = ny, Nie = Fie("".slice), Oie = Math.min, GT = Uie("endsWith"), Qie = !GT && !!function() {
  var r = Tie(String.prototype, "endsWith");
  return r && !r.writable;
}();
Iie({ target: "String", proto: !0, forced: !Qie && !GT }, {
  endsWith: function(e) {
    var t = z4(Lie(this));
    kie(e);
    var n = arguments.length > 1 ? arguments[1] : void 0, i = t.length, s = n === void 0 ? i : Oie(xie(n), i), a = z4(e);
    return Nie(t, s - a.length, s) === a;
  }
});
var x1 = ci, qT = wn, Die = Jb, Mie = Hi, Rie = dl, Pie = fa, Hie = rT, jie = Zb, Kie = ju, G4 = Ma, $ie = Hu, q4 = ey, Vie = xT, zie = yn, ru = Vie.UNSUPPORTED_Y, Gie = 4294967295, qie = Math.min, k1 = qT([].push), L1 = qT("".slice), Wie = !zie(function() {
  var r = /(?:)/, e = r.exec;
  r.exec = function() {
    return e.apply(this, arguments);
  };
  var t = "ab".split(r);
  return t.length !== 2 || t[0] !== "a" || t[1] !== "b";
}), W4 = "abbc".split(/(b)*/)[1] === "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
"test".split(/(?:)/, -1).length !== 4 || "ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
".".split(/()()/).length > 1 || "".split(/.?/).length;
Die("split", function(r, e, t) {
  var n = "0".split(void 0, 0).length ? function(i, s) {
    return i === void 0 && s === 0 ? [] : x1(e, this, i, s);
  } : e;
  return [
    // `String.prototype.split` method
    // https://tc39.es/ecma262/#sec-string.prototype.split
    function(s, a) {
      var o = Pie(this), A = Rie(s) ? void 0 : $ie(s, r);
      return A ? x1(A, s, o, a) : x1(n, G4(o), s, a);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function(i, s) {
      var a = Mie(this), o = G4(i);
      if (!W4) {
        var A = t(n, a, o, s, n !== e);
        if (A.done) return A.value;
      }
      var l = Hie(a, RegExp), u = a.unicode, c = (a.ignoreCase ? "i" : "") + (a.multiline ? "m" : "") + (a.unicode ? "u" : "") + (ru ? "g" : "y"), h = new l(ru ? "^(?:" + a.source + ")" : a, c), f = s === void 0 ? Gie : s >>> 0;
      if (f === 0) return [];
      if (o.length === 0) return q4(h, o) === null ? [o] : [];
      for (var d = 0, p = 0, v = []; p < o.length; ) {
        h.lastIndex = ru ? 0 : p;
        var m = q4(h, ru ? L1(o, p) : o), b;
        if (m === null || (b = qie(Kie(h.lastIndex + (ru ? p : 0)), o.length)) === d)
          p = jie(o, p, u);
        else {
          if (k1(v, L1(o, d, p)), v.length === f) return v;
          for (var w = 1; w <= m.length - 1; w++)
            if (k1(v, m[w]), v.length === f) return v;
          p = d = b;
        }
      }
      return k1(v, L1(o, d)), v;
    }
  ];
}, W4 || !Wie, ru);
var qg = { exports: {} }, zc = { exports: {} };
(function() {
  var r, e, t, n, i, s;
  typeof performance < "u" && performance !== null && performance.now ? zc.exports = function() {
    return performance.now();
  } : typeof process < "u" && process !== null && process.hrtime ? (zc.exports = function() {
    return (r() - i) / 1e6;
  }, e = process.hrtime, r = function() {
    var a;
    return a = e(), a[0] * 1e9 + a[1];
  }, n = r(), s = process.uptime() * 1e9, i = n - s) : Date.now ? (zc.exports = function() {
    return Date.now() - t;
  }, t = Date.now()) : (zc.exports = function() {
    return (/* @__PURE__ */ new Date()).getTime() - t;
  }, t = (/* @__PURE__ */ new Date()).getTime());
}).call(an);
var Xie = zc.exports, Jie = Xie, oo = typeof window > "u" ? an : window, qd = ["moz", "webkit"], Su = "AnimationFrame", Du = oo["request" + Su], Nf = oo["cancel" + Su] || oo["cancelRequest" + Su];
for (var Nc = 0; !Du && Nc < qd.length; Nc++)
  Du = oo[qd[Nc] + "Request" + Su], Nf = oo[qd[Nc] + "Cancel" + Su] || oo[qd[Nc] + "CancelRequest" + Su];
if (!Du || !Nf) {
  var U1 = 0, X4 = 0, kA = [], Yie = 1e3 / 60;
  Du = function(r) {
    if (kA.length === 0) {
      var e = Jie(), t = Math.max(0, Yie - (e - U1));
      U1 = t + e, setTimeout(function() {
        var n = kA.slice(0);
        kA.length = 0;
        for (var i = 0; i < n.length; i++)
          if (!n[i].cancelled)
            try {
              n[i].callback(U1);
            } catch (s) {
              setTimeout(function() {
                throw s;
              }, 0);
            }
      }, Math.round(t));
    }
    return kA.push({
      handle: ++X4,
      callback: r,
      cancelled: !1
    }), X4;
  }, Nf = function(r) {
    for (var e = 0; e < kA.length; e++)
      kA[e].handle === r && (kA[e].cancelled = !0);
  };
}
qg.exports = function(r) {
  return Du.call(oo, r);
};
qg.exports.cancel = function() {
  Nf.apply(oo, arguments);
};
qg.exports.polyfill = function(r) {
  r || (r = oo), r.requestAnimationFrame = Du, r.cancelAnimationFrame = Nf;
};
var Zie = qg.exports;
const N1 = /* @__PURE__ */ Rf(Zie);
var WT = `	
\v\f\r                　\u2028\u2029\uFEFF`, ese = wn, tse = fa, rse = Ma, C2 = WT, J4 = ese("".replace), nse = RegExp("^[" + C2 + "]+"), ise = RegExp("(^|[^" + C2 + "])[" + C2 + "]+$"), O1 = function(r) {
  return function(e) {
    var t = rse(tse(e));
    return r & 1 && (t = J4(t, nse, "")), r & 2 && (t = J4(t, ise, "$1")), t;
  };
}, sse = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: O1(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: O1(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: O1(3)
}, ase = Mg.PROPER, ose = yn, Y4 = WT, Z4 = "​᠎", Ase = function(r) {
  return ose(function() {
    return !!Y4[r]() || Z4[r]() !== Z4 || ase && Y4[r].name !== r;
  });
}, lse = ji, use = sse.trim, cse = Ase;
lse({ target: "String", proto: !0, forced: cse("trim") }, {
  trim: function() {
    return use(this);
  }
});
var fse = function(r) {
  this.ok = !1, this.alpha = 1, r.charAt(0) == "#" && (r = r.substr(1, 6)), r = r.replace(/ /g, ""), r = r.toLowerCase();
  var e = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "00ffff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000000",
    blanchedalmond: "ffebcd",
    blue: "0000ff",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "00ffff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dodgerblue: "1e90ff",
    feldspar: "d19275",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "ff00ff",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgrey: "d3d3d3",
    lightgreen: "90ee90",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslateblue: "8470ff",
    lightslategray: "778899",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "00ff00",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "ff00ff",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370d8",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "d87093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "ff0000",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    violetred: "d02090",
    wheat: "f5deb3",
    white: "ffffff",
    whitesmoke: "f5f5f5",
    yellow: "ffff00",
    yellowgreen: "9acd32"
  };
  r = e[r] || r;
  for (var t = [
    {
      re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
      example: ["rgba(123, 234, 45, 0.8)", "rgba(255,234,245,1.0)"],
      process: function(A) {
        return [
          parseInt(A[1]),
          parseInt(A[2]),
          parseInt(A[3]),
          parseFloat(A[4])
        ];
      }
    },
    {
      re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
      example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
      process: function(A) {
        return [
          parseInt(A[1]),
          parseInt(A[2]),
          parseInt(A[3])
        ];
      }
    },
    {
      re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      example: ["#00ff00", "336699"],
      process: function(A) {
        return [
          parseInt(A[1], 16),
          parseInt(A[2], 16),
          parseInt(A[3], 16)
        ];
      }
    },
    {
      re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      example: ["#fb0", "f0f"],
      process: function(A) {
        return [
          parseInt(A[1] + A[1], 16),
          parseInt(A[2] + A[2], 16),
          parseInt(A[3] + A[3], 16)
        ];
      }
    }
  ], n = 0; n < t.length; n++) {
    var i = t[n].re, s = t[n].process, a = i.exec(r);
    if (a) {
      var o = s(a);
      this.r = o[0], this.g = o[1], this.b = o[2], o.length > 3 && (this.alpha = o[3]), this.ok = !0;
    }
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toRGBA = function() {
    return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.alpha + ")";
  }, this.toHex = function() {
    var A = this.r.toString(16), l = this.g.toString(16), u = this.b.toString(16);
    return A.length == 1 && (A = "0" + A), l.length == 1 && (l = "0" + l), u.length == 1 && (u = "0" + u), "#" + A + l + u;
  }, this.getHelpXML = function() {
    for (var A = new Array(), l = 0; l < t.length; l++)
      for (var u = t[l].example, c = 0; c < u.length; c++)
        A[A.length] = u[c];
    for (var h in e)
      A[A.length] = h;
    var f = document.createElement("ul");
    f.setAttribute("id", "rgbcolor-examples");
    for (var l = 0; l < A.length; l++)
      try {
        var d = document.createElement("li"), p = new RGBColor(A[l]), v = document.createElement("div");
        v.style.cssText = "margin: 3px; border: 1px solid black; background:" + p.toHex() + "; color:" + p.toHex(), v.appendChild(document.createTextNode("test"));
        var m = document.createTextNode(
          " " + A[l] + " -> " + p.toRGB() + " -> " + p.toHex()
        );
        d.appendChild(v), d.appendChild(m), f.appendChild(d);
      } catch {
      }
    return f;
  };
};
const _2 = /* @__PURE__ */ Rf(fse);
var hse = ji, dse = Kg, pse = VF.indexOf, gse = zT, E2 = dse([].indexOf), XT = !!E2 && 1 / E2([1], 1, -0) < 0, mse = XT || !gse("indexOf");
hse({ target: "Array", proto: !0, forced: mse }, {
  indexOf: function(e) {
    var t = arguments.length > 1 ? arguments[1] : void 0;
    return XT ? E2(this, e, t) || 0 : pse(this, e, t);
  }
});
var vse = ji, bse = wn, yse = ry, wse = fa, eE = Ma, Bse = ny, Cse = bse("".indexOf);
vse({ target: "String", proto: !0, forced: !Bse("includes") }, {
  includes: function(e) {
    return !!~Cse(
      eE(wse(this)),
      eE(yse(e)),
      arguments.length > 1 ? arguments[1] : void 0
    );
  }
});
var _se = hl, Ese = Array.isArray || function(e) {
  return _se(e) === "Array";
}, Sse = ji, Ise = wn, Fse = Ese, Tse = Ise([].reverse), tE = [1, 2];
Sse({ target: "Array", proto: !0, forced: String(tE) === String(tE.reverse()) }, {
  reverse: function() {
    return Fse(this) && (this.length = this.length), Tse(this);
  }
});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var JT = function(r, e) {
  return (JT = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
  })(r, e);
};
function YT(r, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  function t() {
    this.constructor = r;
  }
  JT(r, e), r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function xse(r) {
  var e = "";
  Array.isArray(r) || (r = [r]);
  for (var t = 0; t < r.length; t++) {
    var n = r[t];
    if (n.type === Xe.CLOSE_PATH) e += "z";
    else if (n.type === Xe.HORIZ_LINE_TO) e += (n.relative ? "h" : "H") + n.x;
    else if (n.type === Xe.VERT_LINE_TO) e += (n.relative ? "v" : "V") + n.y;
    else if (n.type === Xe.MOVE_TO) e += (n.relative ? "m" : "M") + n.x + " " + n.y;
    else if (n.type === Xe.LINE_TO) e += (n.relative ? "l" : "L") + n.x + " " + n.y;
    else if (n.type === Xe.CURVE_TO) e += (n.relative ? "c" : "C") + n.x1 + " " + n.y1 + " " + n.x2 + " " + n.y2 + " " + n.x + " " + n.y;
    else if (n.type === Xe.SMOOTH_CURVE_TO) e += (n.relative ? "s" : "S") + n.x2 + " " + n.y2 + " " + n.x + " " + n.y;
    else if (n.type === Xe.QUAD_TO) e += (n.relative ? "q" : "Q") + n.x1 + " " + n.y1 + " " + n.x + " " + n.y;
    else if (n.type === Xe.SMOOTH_QUAD_TO) e += (n.relative ? "t" : "T") + n.x + " " + n.y;
    else {
      if (n.type !== Xe.ARC) throw new Error('Unexpected command type "' + n.type + '" at index ' + t + ".");
      e += (n.relative ? "a" : "A") + n.rX + " " + n.rY + " " + n.xRot + " " + +n.lArcFlag + " " + +n.sweepFlag + " " + n.x + " " + n.y;
    }
  }
  return e;
}
function S2(r, e) {
  var t = r[0], n = r[1];
  return [t * Math.cos(e) - n * Math.sin(e), t * Math.sin(e) + n * Math.cos(e)];
}
function Zs() {
  for (var r = [], e = 0; e < arguments.length; e++) r[e] = arguments[e];
  for (var t = 0; t < r.length; t++) if (typeof r[t] != "number") throw new Error("assertNumbers arguments[" + t + "] is not a number. " + typeof r[t] + " == typeof " + r[t]);
  return !0;
}
var Mo = Math.PI;
function Q1(r, e, t) {
  r.lArcFlag = r.lArcFlag === 0 ? 0 : 1, r.sweepFlag = r.sweepFlag === 0 ? 0 : 1;
  var n = r.rX, i = r.rY, s = r.x, a = r.y;
  n = Math.abs(r.rX), i = Math.abs(r.rY);
  var o = S2([(e - s) / 2, (t - a) / 2], -r.xRot / 180 * Mo), A = o[0], l = o[1], u = Math.pow(A, 2) / Math.pow(n, 2) + Math.pow(l, 2) / Math.pow(i, 2);
  1 < u && (n *= Math.sqrt(u), i *= Math.sqrt(u)), r.rX = n, r.rY = i;
  var c = Math.pow(n, 2) * Math.pow(l, 2) + Math.pow(i, 2) * Math.pow(A, 2), h = (r.lArcFlag !== r.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(n, 2) * Math.pow(i, 2) - c) / c)), f = n * l / i * h, d = -i * A / n * h, p = S2([f, d], r.xRot / 180 * Mo);
  r.cX = p[0] + (e + s) / 2, r.cY = p[1] + (t + a) / 2, r.phi1 = Math.atan2((l - d) / i, (A - f) / n), r.phi2 = Math.atan2((-l - d) / i, (-A - f) / n), r.sweepFlag === 0 && r.phi2 > r.phi1 && (r.phi2 -= 2 * Mo), r.sweepFlag === 1 && r.phi2 < r.phi1 && (r.phi2 += 2 * Mo), r.phi1 *= 180 / Mo, r.phi2 *= 180 / Mo;
}
function rE(r, e, t) {
  Zs(r, e, t);
  var n = r * r + e * e - t * t;
  if (0 > n) return [];
  if (n === 0) return [[r * t / (r * r + e * e), e * t / (r * r + e * e)]];
  var i = Math.sqrt(n);
  return [[(r * t + e * i) / (r * r + e * e), (e * t - r * i) / (r * r + e * e)], [(r * t - e * i) / (r * r + e * e), (e * t + r * i) / (r * r + e * e)]];
}
var xn, Za = Math.PI / 180;
function nE(r, e, t) {
  return (1 - t) * r + t * e;
}
function iE(r, e, t, n) {
  return r + Math.cos(n / 180 * Mo) * e + Math.sin(n / 180 * Mo) * t;
}
function sE(r, e, t, n) {
  var i = 1e-6, s = e - r, a = t - e, o = 3 * s + 3 * (n - t) - 6 * a, A = 6 * (a - s), l = 3 * s;
  return Math.abs(o) < i ? [-l / A] : function(u, c, h) {
    var f = u * u / 4 - c;
    if (f < -h) return [];
    if (f <= h) return [-u / 2];
    var d = Math.sqrt(f);
    return [-u / 2 - d, -u / 2 + d];
  }(A / o, l / o, i);
}
function aE(r, e, t, n, i) {
  var s = 1 - i;
  return r * (s * s * s) + e * (3 * s * s * i) + t * (3 * s * i * i) + n * (i * i * i);
}
(function(r) {
  function e() {
    return i(function(o, A, l) {
      return o.relative && (o.x1 !== void 0 && (o.x1 += A), o.y1 !== void 0 && (o.y1 += l), o.x2 !== void 0 && (o.x2 += A), o.y2 !== void 0 && (o.y2 += l), o.x !== void 0 && (o.x += A), o.y !== void 0 && (o.y += l), o.relative = !1), o;
    });
  }
  function t() {
    var o = NaN, A = NaN, l = NaN, u = NaN;
    return i(function(c, h, f) {
      return c.type & Xe.SMOOTH_CURVE_TO && (c.type = Xe.CURVE_TO, o = isNaN(o) ? h : o, A = isNaN(A) ? f : A, c.x1 = c.relative ? h - o : 2 * h - o, c.y1 = c.relative ? f - A : 2 * f - A), c.type & Xe.CURVE_TO ? (o = c.relative ? h + c.x2 : c.x2, A = c.relative ? f + c.y2 : c.y2) : (o = NaN, A = NaN), c.type & Xe.SMOOTH_QUAD_TO && (c.type = Xe.QUAD_TO, l = isNaN(l) ? h : l, u = isNaN(u) ? f : u, c.x1 = c.relative ? h - l : 2 * h - l, c.y1 = c.relative ? f - u : 2 * f - u), c.type & Xe.QUAD_TO ? (l = c.relative ? h + c.x1 : c.x1, u = c.relative ? f + c.y1 : c.y1) : (l = NaN, u = NaN), c;
    });
  }
  function n() {
    var o = NaN, A = NaN;
    return i(function(l, u, c) {
      if (l.type & Xe.SMOOTH_QUAD_TO && (l.type = Xe.QUAD_TO, o = isNaN(o) ? u : o, A = isNaN(A) ? c : A, l.x1 = l.relative ? u - o : 2 * u - o, l.y1 = l.relative ? c - A : 2 * c - A), l.type & Xe.QUAD_TO) {
        o = l.relative ? u + l.x1 : l.x1, A = l.relative ? c + l.y1 : l.y1;
        var h = l.x1, f = l.y1;
        l.type = Xe.CURVE_TO, l.x1 = ((l.relative ? 0 : u) + 2 * h) / 3, l.y1 = ((l.relative ? 0 : c) + 2 * f) / 3, l.x2 = (l.x + 2 * h) / 3, l.y2 = (l.y + 2 * f) / 3;
      } else o = NaN, A = NaN;
      return l;
    });
  }
  function i(o) {
    var A = 0, l = 0, u = NaN, c = NaN;
    return function(h) {
      if (isNaN(u) && !(h.type & Xe.MOVE_TO)) throw new Error("path must start with moveto");
      var f = o(h, A, l, u, c);
      return h.type & Xe.CLOSE_PATH && (A = u, l = c), h.x !== void 0 && (A = h.relative ? A + h.x : h.x), h.y !== void 0 && (l = h.relative ? l + h.y : h.y), h.type & Xe.MOVE_TO && (u = A, c = l), f;
    };
  }
  function s(o, A, l, u, c, h) {
    return Zs(o, A, l, u, c, h), i(function(f, d, p, v) {
      var m = f.x1, b = f.x2, w = f.relative && !isNaN(v), B = f.x !== void 0 ? f.x : w ? 0 : d, _ = f.y !== void 0 ? f.y : w ? 0 : p;
      function x(U) {
        return U * U;
      }
      f.type & Xe.HORIZ_LINE_TO && A !== 0 && (f.type = Xe.LINE_TO, f.y = f.relative ? 0 : p), f.type & Xe.VERT_LINE_TO && l !== 0 && (f.type = Xe.LINE_TO, f.x = f.relative ? 0 : d), f.x !== void 0 && (f.x = f.x * o + _ * l + (w ? 0 : c)), f.y !== void 0 && (f.y = B * A + f.y * u + (w ? 0 : h)), f.x1 !== void 0 && (f.x1 = f.x1 * o + f.y1 * l + (w ? 0 : c)), f.y1 !== void 0 && (f.y1 = m * A + f.y1 * u + (w ? 0 : h)), f.x2 !== void 0 && (f.x2 = f.x2 * o + f.y2 * l + (w ? 0 : c)), f.y2 !== void 0 && (f.y2 = b * A + f.y2 * u + (w ? 0 : h));
      var C = o * u - A * l;
      if (f.xRot !== void 0 && (o !== 1 || A !== 0 || l !== 0 || u !== 1)) if (C === 0) delete f.rX, delete f.rY, delete f.xRot, delete f.lArcFlag, delete f.sweepFlag, f.type = Xe.LINE_TO;
      else {
        var F = f.xRot * Math.PI / 180, N = Math.sin(F), D = Math.cos(F), T = 1 / x(f.rX), E = 1 / x(f.rY), L = x(D) * T + x(N) * E, S = 2 * N * D * (T - E), X = x(N) * T + x(D) * E, z = L * u * u - S * A * u + X * A * A, R = S * (o * u + A * l) - 2 * (L * l * u + X * o * A), V = L * l * l - S * o * l + X * o * o, O = (Math.atan2(R, z - V) + Math.PI) % Math.PI / 2, J = Math.sin(O), Z = Math.cos(O);
        f.rX = Math.abs(C) / Math.sqrt(z * x(Z) + R * J * Z + V * x(J)), f.rY = Math.abs(C) / Math.sqrt(z * x(J) - R * J * Z + V * x(Z)), f.xRot = 180 * O / Math.PI;
      }
      return f.sweepFlag !== void 0 && 0 > C && (f.sweepFlag = +!f.sweepFlag), f;
    });
  }
  function a() {
    return function(o) {
      var A = {};
      for (var l in o) A[l] = o[l];
      return A;
    };
  }
  r.ROUND = function(o) {
    function A(l) {
      return Math.round(l * o) / o;
    }
    return o === void 0 && (o = 1e13), Zs(o), function(l) {
      return l.x1 !== void 0 && (l.x1 = A(l.x1)), l.y1 !== void 0 && (l.y1 = A(l.y1)), l.x2 !== void 0 && (l.x2 = A(l.x2)), l.y2 !== void 0 && (l.y2 = A(l.y2)), l.x !== void 0 && (l.x = A(l.x)), l.y !== void 0 && (l.y = A(l.y)), l.rX !== void 0 && (l.rX = A(l.rX)), l.rY !== void 0 && (l.rY = A(l.rY)), l;
    };
  }, r.TO_ABS = e, r.TO_REL = function() {
    return i(function(o, A, l) {
      return o.relative || (o.x1 !== void 0 && (o.x1 -= A), o.y1 !== void 0 && (o.y1 -= l), o.x2 !== void 0 && (o.x2 -= A), o.y2 !== void 0 && (o.y2 -= l), o.x !== void 0 && (o.x -= A), o.y !== void 0 && (o.y -= l), o.relative = !0), o;
    });
  }, r.NORMALIZE_HVZ = function(o, A, l) {
    return o === void 0 && (o = !0), A === void 0 && (A = !0), l === void 0 && (l = !0), i(function(u, c, h, f, d) {
      if (isNaN(f) && !(u.type & Xe.MOVE_TO)) throw new Error("path must start with moveto");
      return A && u.type & Xe.HORIZ_LINE_TO && (u.type = Xe.LINE_TO, u.y = u.relative ? 0 : h), l && u.type & Xe.VERT_LINE_TO && (u.type = Xe.LINE_TO, u.x = u.relative ? 0 : c), o && u.type & Xe.CLOSE_PATH && (u.type = Xe.LINE_TO, u.x = u.relative ? f - c : f, u.y = u.relative ? d - h : d), u.type & Xe.ARC && (u.rX === 0 || u.rY === 0) && (u.type = Xe.LINE_TO, delete u.rX, delete u.rY, delete u.xRot, delete u.lArcFlag, delete u.sweepFlag), u;
    });
  }, r.NORMALIZE_ST = t, r.QT_TO_C = n, r.INFO = i, r.SANITIZE = function(o) {
    o === void 0 && (o = 0), Zs(o);
    var A = NaN, l = NaN, u = NaN, c = NaN;
    return i(function(h, f, d, p, v) {
      var m = Math.abs, b = !1, w = 0, B = 0;
      if (h.type & Xe.SMOOTH_CURVE_TO && (w = isNaN(A) ? 0 : f - A, B = isNaN(l) ? 0 : d - l), h.type & (Xe.CURVE_TO | Xe.SMOOTH_CURVE_TO) ? (A = h.relative ? f + h.x2 : h.x2, l = h.relative ? d + h.y2 : h.y2) : (A = NaN, l = NaN), h.type & Xe.SMOOTH_QUAD_TO ? (u = isNaN(u) ? f : 2 * f - u, c = isNaN(c) ? d : 2 * d - c) : h.type & Xe.QUAD_TO ? (u = h.relative ? f + h.x1 : h.x1, c = h.relative ? d + h.y1 : h.y2) : (u = NaN, c = NaN), h.type & Xe.LINE_COMMANDS || h.type & Xe.ARC && (h.rX === 0 || h.rY === 0 || !h.lArcFlag) || h.type & Xe.CURVE_TO || h.type & Xe.SMOOTH_CURVE_TO || h.type & Xe.QUAD_TO || h.type & Xe.SMOOTH_QUAD_TO) {
        var _ = h.x === void 0 ? 0 : h.relative ? h.x : h.x - f, x = h.y === void 0 ? 0 : h.relative ? h.y : h.y - d;
        w = isNaN(u) ? h.x1 === void 0 ? w : h.relative ? h.x : h.x1 - f : u - f, B = isNaN(c) ? h.y1 === void 0 ? B : h.relative ? h.y : h.y1 - d : c - d;
        var C = h.x2 === void 0 ? 0 : h.relative ? h.x : h.x2 - f, F = h.y2 === void 0 ? 0 : h.relative ? h.y : h.y2 - d;
        m(_) <= o && m(x) <= o && m(w) <= o && m(B) <= o && m(C) <= o && m(F) <= o && (b = !0);
      }
      return h.type & Xe.CLOSE_PATH && m(f - p) <= o && m(d - v) <= o && (b = !0), b ? [] : h;
    });
  }, r.MATRIX = s, r.ROTATE = function(o, A, l) {
    A === void 0 && (A = 0), l === void 0 && (l = 0), Zs(o, A, l);
    var u = Math.sin(o), c = Math.cos(o);
    return s(c, u, -u, c, A - A * c + l * u, l - A * u - l * c);
  }, r.TRANSLATE = function(o, A) {
    return A === void 0 && (A = 0), Zs(o, A), s(1, 0, 0, 1, o, A);
  }, r.SCALE = function(o, A) {
    return A === void 0 && (A = o), Zs(o, A), s(o, 0, 0, A, 0, 0);
  }, r.SKEW_X = function(o) {
    return Zs(o), s(1, 0, Math.atan(o), 1, 0, 0);
  }, r.SKEW_Y = function(o) {
    return Zs(o), s(1, Math.atan(o), 0, 1, 0, 0);
  }, r.X_AXIS_SYMMETRY = function(o) {
    return o === void 0 && (o = 0), Zs(o), s(-1, 0, 0, 1, o, 0);
  }, r.Y_AXIS_SYMMETRY = function(o) {
    return o === void 0 && (o = 0), Zs(o), s(1, 0, 0, -1, 0, o);
  }, r.A_TO_C = function() {
    return i(function(o, A, l) {
      return Xe.ARC === o.type ? function(u, c, h) {
        var f, d, p, v;
        u.cX || Q1(u, c, h);
        for (var m = Math.min(u.phi1, u.phi2), b = Math.max(u.phi1, u.phi2) - m, w = Math.ceil(b / 90), B = new Array(w), _ = c, x = h, C = 0; C < w; C++) {
          var F = nE(u.phi1, u.phi2, C / w), N = nE(u.phi1, u.phi2, (C + 1) / w), D = N - F, T = 4 / 3 * Math.tan(D * Za / 4), E = [Math.cos(F * Za) - T * Math.sin(F * Za), Math.sin(F * Za) + T * Math.cos(F * Za)], L = E[0], S = E[1], X = [Math.cos(N * Za), Math.sin(N * Za)], z = X[0], R = X[1], V = [z + T * Math.sin(N * Za), R - T * Math.cos(N * Za)], O = V[0], J = V[1];
          B[C] = { relative: u.relative, type: Xe.CURVE_TO };
          var Z = function(U, P) {
            var H = S2([U * u.rX, P * u.rY], u.xRot), $ = H[0], ie = H[1];
            return [u.cX + $, u.cY + ie];
          };
          f = Z(L, S), B[C].x1 = f[0], B[C].y1 = f[1], d = Z(O, J), B[C].x2 = d[0], B[C].y2 = d[1], p = Z(z, R), B[C].x = p[0], B[C].y = p[1], u.relative && (B[C].x1 -= _, B[C].y1 -= x, B[C].x2 -= _, B[C].y2 -= x, B[C].x -= _, B[C].y -= x), _ = (v = [B[C].x, B[C].y])[0], x = v[1];
        }
        return B;
      }(o, o.relative ? 0 : A, o.relative ? 0 : l) : o;
    });
  }, r.ANNOTATE_ARCS = function() {
    return i(function(o, A, l) {
      return o.relative && (A = 0, l = 0), Xe.ARC === o.type && Q1(o, A, l), o;
    });
  }, r.CLONE = a, r.CALCULATE_BOUNDS = function() {
    var o = function(h) {
      var f = {};
      for (var d in h) f[d] = h[d];
      return f;
    }, A = e(), l = n(), u = t(), c = i(function(h, f, d) {
      var p = u(l(A(o(h))));
      function v(J) {
        J > c.maxX && (c.maxX = J), J < c.minX && (c.minX = J);
      }
      function m(J) {
        J > c.maxY && (c.maxY = J), J < c.minY && (c.minY = J);
      }
      if (p.type & Xe.DRAWING_COMMANDS && (v(f), m(d)), p.type & Xe.HORIZ_LINE_TO && v(p.x), p.type & Xe.VERT_LINE_TO && m(p.y), p.type & Xe.LINE_TO && (v(p.x), m(p.y)), p.type & Xe.CURVE_TO) {
        v(p.x), m(p.y);
        for (var b = 0, w = sE(f, p.x1, p.x2, p.x); b < w.length; b++)
          0 < (O = w[b]) && 1 > O && v(aE(f, p.x1, p.x2, p.x, O));
        for (var B = 0, _ = sE(d, p.y1, p.y2, p.y); B < _.length; B++)
          0 < (O = _[B]) && 1 > O && m(aE(d, p.y1, p.y2, p.y, O));
      }
      if (p.type & Xe.ARC) {
        v(p.x), m(p.y), Q1(p, f, d);
        for (var x = p.xRot / 180 * Math.PI, C = Math.cos(x) * p.rX, F = Math.sin(x) * p.rX, N = -Math.sin(x) * p.rY, D = Math.cos(x) * p.rY, T = p.phi1 < p.phi2 ? [p.phi1, p.phi2] : -180 > p.phi2 ? [p.phi2 + 360, p.phi1 + 360] : [p.phi2, p.phi1], E = T[0], L = T[1], S = function(J) {
          var Z = J[0], U = J[1], P = 180 * Math.atan2(U, Z) / Math.PI;
          return P < E ? P + 360 : P;
        }, X = 0, z = rE(N, -C, 0).map(S); X < z.length; X++)
          (O = z[X]) > E && O < L && v(iE(p.cX, C, N, O));
        for (var R = 0, V = rE(D, -F, 0).map(S); R < V.length; R++) {
          var O;
          (O = V[R]) > E && O < L && m(iE(p.cY, F, D, O));
        }
      }
      return h;
    });
    return c.minX = 1 / 0, c.maxX = -1 / 0, c.minY = 1 / 0, c.maxY = -1 / 0, c;
  };
})(xn || (xn = {}));
var Xs, ZT = function() {
  function r() {
  }
  return r.prototype.round = function(e) {
    return this.transform(xn.ROUND(e));
  }, r.prototype.toAbs = function() {
    return this.transform(xn.TO_ABS());
  }, r.prototype.toRel = function() {
    return this.transform(xn.TO_REL());
  }, r.prototype.normalizeHVZ = function(e, t, n) {
    return this.transform(xn.NORMALIZE_HVZ(e, t, n));
  }, r.prototype.normalizeST = function() {
    return this.transform(xn.NORMALIZE_ST());
  }, r.prototype.qtToC = function() {
    return this.transform(xn.QT_TO_C());
  }, r.prototype.aToC = function() {
    return this.transform(xn.A_TO_C());
  }, r.prototype.sanitize = function(e) {
    return this.transform(xn.SANITIZE(e));
  }, r.prototype.translate = function(e, t) {
    return this.transform(xn.TRANSLATE(e, t));
  }, r.prototype.scale = function(e, t) {
    return this.transform(xn.SCALE(e, t));
  }, r.prototype.rotate = function(e, t, n) {
    return this.transform(xn.ROTATE(e, t, n));
  }, r.prototype.matrix = function(e, t, n, i, s, a) {
    return this.transform(xn.MATRIX(e, t, n, i, s, a));
  }, r.prototype.skewX = function(e) {
    return this.transform(xn.SKEW_X(e));
  }, r.prototype.skewY = function(e) {
    return this.transform(xn.SKEW_Y(e));
  }, r.prototype.xSymmetry = function(e) {
    return this.transform(xn.X_AXIS_SYMMETRY(e));
  }, r.prototype.ySymmetry = function(e) {
    return this.transform(xn.Y_AXIS_SYMMETRY(e));
  }, r.prototype.annotateArcs = function() {
    return this.transform(xn.ANNOTATE_ARCS());
  }, r;
}(), kse = function(r) {
  return r === " " || r === "	" || r === "\r" || r === `
`;
}, oE = function(r) {
  return 48 <= r.charCodeAt(0) && r.charCodeAt(0) <= 57;
}, Lse = function(r) {
  function e() {
    var t = r.call(this) || this;
    return t.curNumber = "", t.curCommandType = -1, t.curCommandRelative = !1, t.canParseCommandOrComma = !0, t.curNumberHasExp = !1, t.curNumberHasExpDigits = !1, t.curNumberHasDecimal = !1, t.curArgs = [], t;
  }
  return YT(e, r), e.prototype.finish = function(t) {
    if (t === void 0 && (t = []), this.parse(" ", t), this.curArgs.length !== 0 || !this.canParseCommandOrComma) throw new SyntaxError("Unterminated command at the path end.");
    return t;
  }, e.prototype.parse = function(t, n) {
    var i = this;
    n === void 0 && (n = []);
    for (var s = function(c) {
      n.push(c), i.curArgs.length = 0, i.canParseCommandOrComma = !0;
    }, a = 0; a < t.length; a++) {
      var o = t[a], A = !(this.curCommandType !== Xe.ARC || this.curArgs.length !== 3 && this.curArgs.length !== 4 || this.curNumber.length !== 1 || this.curNumber !== "0" && this.curNumber !== "1"), l = oE(o) && (this.curNumber === "0" && o === "0" || A);
      if (!oE(o) || l) if (o !== "e" && o !== "E") if (o !== "-" && o !== "+" || !this.curNumberHasExp || this.curNumberHasExpDigits) if (o !== "." || this.curNumberHasExp || this.curNumberHasDecimal || A) {
        if (this.curNumber && this.curCommandType !== -1) {
          var u = Number(this.curNumber);
          if (isNaN(u)) throw new SyntaxError("Invalid number ending at " + a);
          if (this.curCommandType === Xe.ARC) {
            if (this.curArgs.length === 0 || this.curArgs.length === 1) {
              if (0 > u) throw new SyntaxError('Expected positive number, got "' + u + '" at index "' + a + '"');
            } else if ((this.curArgs.length === 3 || this.curArgs.length === 4) && this.curNumber !== "0" && this.curNumber !== "1") throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + a + '"');
          }
          this.curArgs.push(u), this.curArgs.length === Use[this.curCommandType] && (Xe.HORIZ_LINE_TO === this.curCommandType ? s({ type: Xe.HORIZ_LINE_TO, relative: this.curCommandRelative, x: u }) : Xe.VERT_LINE_TO === this.curCommandType ? s({ type: Xe.VERT_LINE_TO, relative: this.curCommandRelative, y: u }) : this.curCommandType === Xe.MOVE_TO || this.curCommandType === Xe.LINE_TO || this.curCommandType === Xe.SMOOTH_QUAD_TO ? (s({ type: this.curCommandType, relative: this.curCommandRelative, x: this.curArgs[0], y: this.curArgs[1] }), Xe.MOVE_TO === this.curCommandType && (this.curCommandType = Xe.LINE_TO)) : this.curCommandType === Xe.CURVE_TO ? s({ type: Xe.CURVE_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x2: this.curArgs[2], y2: this.curArgs[3], x: this.curArgs[4], y: this.curArgs[5] }) : this.curCommandType === Xe.SMOOTH_CURVE_TO ? s({ type: Xe.SMOOTH_CURVE_TO, relative: this.curCommandRelative, x2: this.curArgs[0], y2: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === Xe.QUAD_TO ? s({ type: Xe.QUAD_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === Xe.ARC && s({ type: Xe.ARC, relative: this.curCommandRelative, rX: this.curArgs[0], rY: this.curArgs[1], xRot: this.curArgs[2], lArcFlag: this.curArgs[3], sweepFlag: this.curArgs[4], x: this.curArgs[5], y: this.curArgs[6] })), this.curNumber = "", this.curNumberHasExpDigits = !1, this.curNumberHasExp = !1, this.curNumberHasDecimal = !1, this.canParseCommandOrComma = !0;
        }
        if (!kse(o)) if (o === "," && this.canParseCommandOrComma) this.canParseCommandOrComma = !1;
        else if (o !== "+" && o !== "-" && o !== ".") if (l) this.curNumber = o, this.curNumberHasDecimal = !1;
        else {
          if (this.curArgs.length !== 0) throw new SyntaxError("Unterminated command at index " + a + ".");
          if (!this.canParseCommandOrComma) throw new SyntaxError('Unexpected character "' + o + '" at index ' + a + ". Command cannot follow comma");
          if (this.canParseCommandOrComma = !1, o !== "z" && o !== "Z") if (o === "h" || o === "H") this.curCommandType = Xe.HORIZ_LINE_TO, this.curCommandRelative = o === "h";
          else if (o === "v" || o === "V") this.curCommandType = Xe.VERT_LINE_TO, this.curCommandRelative = o === "v";
          else if (o === "m" || o === "M") this.curCommandType = Xe.MOVE_TO, this.curCommandRelative = o === "m";
          else if (o === "l" || o === "L") this.curCommandType = Xe.LINE_TO, this.curCommandRelative = o === "l";
          else if (o === "c" || o === "C") this.curCommandType = Xe.CURVE_TO, this.curCommandRelative = o === "c";
          else if (o === "s" || o === "S") this.curCommandType = Xe.SMOOTH_CURVE_TO, this.curCommandRelative = o === "s";
          else if (o === "q" || o === "Q") this.curCommandType = Xe.QUAD_TO, this.curCommandRelative = o === "q";
          else if (o === "t" || o === "T") this.curCommandType = Xe.SMOOTH_QUAD_TO, this.curCommandRelative = o === "t";
          else {
            if (o !== "a" && o !== "A") throw new SyntaxError('Unexpected character "' + o + '" at index ' + a + ".");
            this.curCommandType = Xe.ARC, this.curCommandRelative = o === "a";
          }
          else n.push({ type: Xe.CLOSE_PATH }), this.canParseCommandOrComma = !0, this.curCommandType = -1;
        }
        else this.curNumber = o, this.curNumberHasDecimal = o === ".";
      } else this.curNumber += o, this.curNumberHasDecimal = !0;
      else this.curNumber += o;
      else this.curNumber += o, this.curNumberHasExp = !0;
      else this.curNumber += o, this.curNumberHasExpDigits = this.curNumberHasExp;
    }
    return n;
  }, e.prototype.transform = function(t) {
    return Object.create(this, { parse: { value: function(n, i) {
      i === void 0 && (i = []);
      for (var s = 0, a = Object.getPrototypeOf(this).parse.call(this, n); s < a.length; s++) {
        var o = a[s], A = t(o);
        Array.isArray(A) ? i.push.apply(i, A) : i.push(A);
      }
      return i;
    } } });
  }, e;
}(ZT), Xe = function(r) {
  function e(t) {
    var n = r.call(this) || this;
    return n.commands = typeof t == "string" ? e.parse(t) : t, n;
  }
  return YT(e, r), e.prototype.encode = function() {
    return e.encode(this.commands);
  }, e.prototype.getBounds = function() {
    var t = xn.CALCULATE_BOUNDS();
    return this.transform(t), t;
  }, e.prototype.transform = function(t) {
    for (var n = [], i = 0, s = this.commands; i < s.length; i++) {
      var a = t(s[i]);
      Array.isArray(a) ? n.push.apply(n, a) : n.push(a);
    }
    return this.commands = n, this;
  }, e.encode = function(t) {
    return xse(t);
  }, e.parse = function(t) {
    var n = new Lse(), i = [];
    return n.parse(t, i), n.finish(i), i;
  }, e.CLOSE_PATH = 1, e.MOVE_TO = 2, e.HORIZ_LINE_TO = 4, e.VERT_LINE_TO = 8, e.LINE_TO = 16, e.CURVE_TO = 32, e.SMOOTH_CURVE_TO = 64, e.QUAD_TO = 128, e.SMOOTH_QUAD_TO = 256, e.ARC = 512, e.LINE_COMMANDS = e.LINE_TO | e.HORIZ_LINE_TO | e.VERT_LINE_TO, e.DRAWING_COMMANDS = e.HORIZ_LINE_TO | e.VERT_LINE_TO | e.LINE_TO | e.CURVE_TO | e.SMOOTH_CURVE_TO | e.QUAD_TO | e.SMOOTH_QUAD_TO | e.ARC, e;
}(ZT), Use = ((Xs = {})[Xe.MOVE_TO] = 2, Xs[Xe.LINE_TO] = 2, Xs[Xe.HORIZ_LINE_TO] = 1, Xs[Xe.VERT_LINE_TO] = 1, Xs[Xe.CLOSE_PATH] = 0, Xs[Xe.QUAD_TO] = 4, Xs[Xe.SMOOTH_QUAD_TO] = 2, Xs[Xe.CURVE_TO] = 6, Xs[Xe.SMOOTH_CURVE_TO] = 4, Xs[Xe.ARC] = 7, Xs), Nse = ci, Ose = da, Qse = Ng, Dse = TT, AE = RegExp.prototype, Mse = function(r) {
  var e = r.flags;
  return e === void 0 && !("flags" in AE) && !Ose(r, "flags") && Qse(AE, r) ? Nse(Dse, r) : e;
}, Rse = Mg.PROPER, Pse = gl, Hse = Hi, lE = Ma, jse = yn, Kse = Mse, ay = "toString", ex = RegExp.prototype, tx = ex[ay], $se = jse(function() {
  return tx.call({ source: "a", flags: "b" }) !== "/a/b";
}), Vse = Rse && tx.name !== ay;
($se || Vse) && Pse(ex, ay, function() {
  var e = Hse(this), t = lE(e.source), n = lE(Kse(e));
  return "/" + t + "/" + n;
}, { unsafe: !0 });
function gp(r) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? gp = function(e) {
    return typeof e;
  } : gp = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, gp(r);
}
function zse(r, e) {
  if (!(r instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
var Gse = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259], qse = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
function Wse(r, e, t, n, i) {
  if (typeof r == "string" && (r = document.getElementById(r)), !r || gp(r) !== "object" || !("getContext" in r))
    throw new TypeError("Expecting canvas with `getContext` method in processCanvasRGB(A) calls!");
  var s = r.getContext("2d");
  try {
    return s.getImageData(e, t, n, i);
  } catch (a) {
    throw new Error("unable to access image data: " + a);
  }
}
function Xse(r, e, t, n, i, s) {
  if (!(isNaN(s) || s < 1)) {
    s |= 0;
    var a = Wse(r, e, t, n, i);
    a = Jse(a, e, t, n, i, s), r.getContext("2d").putImageData(a, e, t);
  }
}
function Jse(r, e, t, n, i, s) {
  for (var a = r.data, o = 2 * s + 1, A = n - 1, l = i - 1, u = s + 1, c = u * (u + 1) / 2, h = new uE(), f = h, d, p = 1; p < o; p++)
    f = f.next = new uE(), p === u && (d = f);
  f.next = h;
  for (var v = null, m = null, b = 0, w = 0, B = Gse[s], _ = qse[s], x = 0; x < i; x++) {
    f = h;
    for (var C = a[w], F = a[w + 1], N = a[w + 2], D = a[w + 3], T = 0; T < u; T++)
      f.r = C, f.g = F, f.b = N, f.a = D, f = f.next;
    for (var E = 0, L = 0, S = 0, X = 0, z = u * C, R = u * F, V = u * N, O = u * D, J = c * C, Z = c * F, U = c * N, P = c * D, H = 1; H < u; H++) {
      var $ = w + ((A < H ? A : H) << 2), ie = a[$], ue = a[$ + 1], he = a[$ + 2], ve = a[$ + 3], Le = u - H;
      J += (f.r = ie) * Le, Z += (f.g = ue) * Le, U += (f.b = he) * Le, P += (f.a = ve) * Le, E += ie, L += ue, S += he, X += ve, f = f.next;
    }
    v = h, m = d;
    for (var de = 0; de < n; de++) {
      var Ce = P * B >>> _;
      if (a[w + 3] = Ce, Ce !== 0) {
        var Qe = 255 / Ce;
        a[w] = (J * B >>> _) * Qe, a[w + 1] = (Z * B >>> _) * Qe, a[w + 2] = (U * B >>> _) * Qe;
      } else
        a[w] = a[w + 1] = a[w + 2] = 0;
      J -= z, Z -= R, U -= V, P -= O, z -= v.r, R -= v.g, V -= v.b, O -= v.a;
      var M = de + s + 1;
      M = b + (M < A ? M : A) << 2, E += v.r = a[M], L += v.g = a[M + 1], S += v.b = a[M + 2], X += v.a = a[M + 3], J += E, Z += L, U += S, P += X, v = v.next;
      var Ae = m, G = Ae.r, ne = Ae.g, ee = Ae.b, ae = Ae.a;
      z += G, R += ne, V += ee, O += ae, E -= G, L -= ne, S -= ee, X -= ae, m = m.next, w += 4;
    }
    b += n;
  }
  for (var re = 0; re < n; re++) {
    w = re << 2;
    var ce = a[w], le = a[w + 1], Te = a[w + 2], Oe = a[w + 3], Ue = u * ce, Ge = u * le, at = u * Te, it = u * Oe, ut = c * ce, St = c * le, et = c * Te, gr = c * Oe;
    f = h;
    for (var bt = 0; bt < u; bt++)
      f.r = ce, f.g = le, f.b = Te, f.a = Oe, f = f.next;
    for (var Qr = n, Wt = 0, kt = 0, Dr = 0, Xt = 0, Cn = 1; Cn <= s; Cn++) {
      w = Qr + re << 2;
      var mr = u - Cn;
      ut += (f.r = ce = a[w]) * mr, St += (f.g = le = a[w + 1]) * mr, et += (f.b = Te = a[w + 2]) * mr, gr += (f.a = Oe = a[w + 3]) * mr, Xt += ce, Wt += le, kt += Te, Dr += Oe, f = f.next, Cn < l && (Qr += n);
    }
    w = re, v = h, m = d;
    for (var Ir = 0; Ir < i; Ir++) {
      var hr = w << 2;
      a[hr + 3] = Oe = gr * B >>> _, Oe > 0 ? (Oe = 255 / Oe, a[hr] = (ut * B >>> _) * Oe, a[hr + 1] = (St * B >>> _) * Oe, a[hr + 2] = (et * B >>> _) * Oe) : a[hr] = a[hr + 1] = a[hr + 2] = 0, ut -= Ue, St -= Ge, et -= at, gr -= it, Ue -= v.r, Ge -= v.g, at -= v.b, it -= v.a, hr = re + ((hr = Ir + u) < l ? hr : l) * n << 2, ut += Xt += v.r = a[hr], St += Wt += v.g = a[hr + 1], et += kt += v.b = a[hr + 2], gr += Dr += v.a = a[hr + 3], v = v.next, Ue += ce = m.r, Ge += le = m.g, at += Te = m.b, it += Oe = m.a, Xt -= ce, Wt -= le, kt -= Te, Dr -= Oe, m = m.next, w += n;
    }
  }
  return r;
}
var uE = (
  /**
   * Set properties.
   */
  function r() {
    zse(this, r), this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null;
  }
);
function Yse() {
  var {
    DOMParser: r
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = {
    window: null,
    ignoreAnimation: !0,
    ignoreMouse: !0,
    DOMParser: r,
    createCanvas(t, n) {
      return new OffscreenCanvas(t, n);
    },
    createImage(t) {
      return uo(function* () {
        var n = yield fetch(t), i = yield n.blob(), s = yield createImageBitmap(i);
        return s;
      })();
    }
  };
  return (typeof DOMParser < "u" || typeof r > "u") && Reflect.deleteProperty(e, "DOMParser"), e;
}
function Zse(r) {
  var {
    DOMParser: e,
    canvas: t,
    fetch: n
  } = r;
  return {
    window: null,
    ignoreAnimation: !0,
    ignoreMouse: !0,
    DOMParser: e,
    fetch: n,
    createCanvas: t.createCanvas,
    createImage: t.loadImage
  };
}
var eae = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  offscreen: Yse,
  node: Zse
});
function ml(r) {
  return r.replace(/(?!\u3000)\s+/gm, " ");
}
function rx(r) {
  return r.replace(/^[\n \t]+/, "");
}
function nx(r) {
  return r.replace(/[\n \t]+$/, "");
}
function Yi(r) {
  var e = (r || "").match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm) || [];
  return e.map(parseFloat);
}
var tae = /^[A-Z-]+$/;
function ix(r) {
  return tae.test(r) ? r.toLowerCase() : r;
}
function oy(r) {
  var e = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(r) || [];
  return e[2] || e[3] || e[4];
}
function sx(r) {
  if (!r.startsWith("rgb"))
    return r;
  var e = 3, t = r.replace(/\d+(\.\d+)?/g, (n, i) => e-- && i ? String(Math.round(parseFloat(n))) : n);
  return t;
}
var rae = /(\[[^\]]+\])/g, nae = /(#[^\s+>~.[:]+)/g, iae = /(\.[^\s+>~.[:]+)/g, sae = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi, aae = /(:[\w-]+\([^)]*\))/gi, oae = /(:[^\s+>~.[:]+)/g, Aae = /([^\s+>~.[:]+)/g;
function LA(r, e) {
  var t = e.exec(r);
  return t ? [r.replace(e, " "), t.length] : [r, 0];
}
function ax(r) {
  var e = [0, 0, 0], t = r.replace(/:not\(([^)]*)\)/g, "     $1 ").replace(/{[\s\S]*/gm, " "), n = 0;
  return [t, n] = LA(t, rae), e[1] += n, [t, n] = LA(t, nae), e[0] += n, [t, n] = LA(t, iae), e[1] += n, [t, n] = LA(t, sae), e[2] += n, [t, n] = LA(t, aae), e[1] += n, [t, n] = LA(t, oae), e[1] += n, t = t.replace(/[*\s+>~]/g, " ").replace(/[#.]/g, " "), [t, n] = LA(t, Aae), e[2] += n, e.join("");
}
var sl = 1e-8;
function I2(r) {
  return Math.sqrt(Math.pow(r[0], 2) + Math.pow(r[1], 2));
}
function Yp(r, e) {
  return (r[0] * e[0] + r[1] * e[1]) / (I2(r) * I2(e));
}
function F2(r, e) {
  return (r[0] * e[1] < r[1] * e[0] ? -1 : 1) * Math.acos(Yp(r, e));
}
function T2(r) {
  return r * r * r;
}
function x2(r) {
  return 3 * r * r * (1 - r);
}
function k2(r) {
  return 3 * r * (1 - r) * (1 - r);
}
function L2(r) {
  return (1 - r) * (1 - r) * (1 - r);
}
function U2(r) {
  return r * r;
}
function N2(r) {
  return 2 * r * (1 - r);
}
function O2(r) {
  return (1 - r) * (1 - r);
}
class wt {
  constructor(e, t, n) {
    this.document = e, this.name = t, this.value = n, this.isNormalizedColor = !1;
  }
  static empty(e) {
    return new wt(e, "EMPTY", "");
  }
  split() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : " ", {
      document: t,
      name: n
    } = this;
    return ml(this.getString()).trim().split(e).map((i) => new wt(t, n, i));
  }
  hasValue(e) {
    var {
      value: t
    } = this;
    return t !== null && t !== "" && (e || t !== 0) && typeof t < "u";
  }
  isString(e) {
    var {
      value: t
    } = this, n = typeof t == "string";
    return !n || !e ? n : e.test(t);
  }
  isUrlDefinition() {
    return this.isString(/^url\(/);
  }
  isPixels() {
    if (!this.hasValue())
      return !1;
    var e = this.getString();
    switch (!0) {
      case e.endsWith("px"):
      case /^[0-9]+$/.test(e):
        return !0;
      default:
        return !1;
    }
  }
  setValue(e) {
    return this.value = e, this;
  }
  getValue(e) {
    return typeof e > "u" || this.hasValue() ? this.value : e;
  }
  getNumber(e) {
    if (!this.hasValue())
      return typeof e > "u" ? 0 : parseFloat(e);
    var {
      value: t
    } = this, n = parseFloat(t);
    return this.isString(/%$/) && (n /= 100), n;
  }
  getString(e) {
    return typeof e > "u" || this.hasValue() ? typeof this.value > "u" ? "" : String(this.value) : String(e);
  }
  getColor(e) {
    var t = this.getString(e);
    return this.isNormalizedColor || (this.isNormalizedColor = !0, t = sx(t), this.value = t), t;
  }
  getDpi() {
    return 96;
  }
  getRem() {
    return this.document.rootEmSize;
  }
  getEm() {
    return this.document.emSize;
  }
  getUnits() {
    return this.getString().replace(/[0-9.-]/g, "");
  }
  getPixels(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (!this.hasValue())
      return 0;
    var [n, i] = typeof e == "boolean" ? [void 0, e] : [e], {
      viewPort: s
    } = this.document.screen;
    switch (!0) {
      case this.isString(/vmin$/):
        return this.getNumber() / 100 * Math.min(s.computeSize("x"), s.computeSize("y"));
      case this.isString(/vmax$/):
        return this.getNumber() / 100 * Math.max(s.computeSize("x"), s.computeSize("y"));
      case this.isString(/vw$/):
        return this.getNumber() / 100 * s.computeSize("x");
      case this.isString(/vh$/):
        return this.getNumber() / 100 * s.computeSize("y");
      case this.isString(/rem$/):
        return this.getNumber() * this.getRem();
      case this.isString(/em$/):
        return this.getNumber() * this.getEm();
      case this.isString(/ex$/):
        return this.getNumber() * this.getEm() / 2;
      case this.isString(/px$/):
        return this.getNumber();
      case this.isString(/pt$/):
        return this.getNumber() * this.getDpi() * (1 / 72);
      case this.isString(/pc$/):
        return this.getNumber() * 15;
      case this.isString(/cm$/):
        return this.getNumber() * this.getDpi() / 2.54;
      case this.isString(/mm$/):
        return this.getNumber() * this.getDpi() / 25.4;
      case this.isString(/in$/):
        return this.getNumber() * this.getDpi();
      case (this.isString(/%$/) && i):
        return this.getNumber() * this.getEm();
      case this.isString(/%$/):
        return this.getNumber() * s.computeSize(n);
      default: {
        var a = this.getNumber();
        return t && a < 1 ? a * s.computeSize(n) : a;
      }
    }
  }
  getMilliseconds() {
    return this.hasValue() ? this.isString(/ms$/) ? this.getNumber() : this.getNumber() * 1e3 : 0;
  }
  getRadians() {
    if (!this.hasValue())
      return 0;
    switch (!0) {
      case this.isString(/deg$/):
        return this.getNumber() * (Math.PI / 180);
      case this.isString(/grad$/):
        return this.getNumber() * (Math.PI / 200);
      case this.isString(/rad$/):
        return this.getNumber();
      default:
        return this.getNumber() * (Math.PI / 180);
    }
  }
  getDefinition() {
    var e = this.getString(), t = /#([^)'"]+)/.exec(e);
    return t && (t = t[1]), t || (t = e), this.document.definitions[t];
  }
  getFillStyleDefinition(e, t) {
    var n = this.getDefinition();
    if (!n)
      return null;
    if (typeof n.createGradient == "function")
      return n.createGradient(this.document.ctx, e, t);
    if (typeof n.createPattern == "function") {
      if (n.getHrefAttribute().hasValue()) {
        var i = n.getAttribute("patternTransform");
        n = n.getHrefAttribute().getDefinition(), i.hasValue() && n.getAttribute("patternTransform", !0).setValue(i.value);
      }
      return n.createPattern(this.document.ctx, e, t);
    }
    return null;
  }
  getTextBaseline() {
    return this.hasValue() ? wt.textBaselineMapping[this.getString()] : null;
  }
  addOpacity(e) {
    for (var t = this.getColor(), n = t.length, i = 0, s = 0; s < n && (t[s] === "," && i++, i !== 3); s++)
      ;
    if (e.hasValue() && this.isString() && i !== 3) {
      var a = new _2(t);
      a.ok && (a.alpha = e.getNumber(), t = a.toRGBA());
    }
    return new wt(this.document, this.name, t);
  }
}
wt.textBaselineMapping = {
  baseline: "alphabetic",
  "before-edge": "top",
  "text-before-edge": "top",
  middle: "middle",
  central: "middle",
  "after-edge": "bottom",
  "text-after-edge": "bottom",
  ideographic: "ideographic",
  alphabetic: "alphabetic",
  hanging: "hanging",
  mathematical: "alphabetic"
};
class ox {
  constructor() {
    this.viewPorts = [];
  }
  clear() {
    this.viewPorts = [];
  }
  setCurrent(e, t) {
    this.viewPorts.push({
      width: e,
      height: t
    });
  }
  removeCurrent() {
    this.viewPorts.pop();
  }
  getCurrent() {
    var {
      viewPorts: e
    } = this;
    return e[e.length - 1];
  }
  get width() {
    return this.getCurrent().width;
  }
  get height() {
    return this.getCurrent().height;
  }
  computeSize(e) {
    return typeof e == "number" ? e : e === "x" ? this.width : e === "y" ? this.height : Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
  }
}
class sn {
  constructor(e, t) {
    this.x = e, this.y = t;
  }
  static parse(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, [n = t, i = t] = Yi(e);
    return new sn(n, i);
  }
  static parseScale(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, [n = t, i = n] = Yi(e);
    return new sn(n, i);
  }
  static parsePath(e) {
    for (var t = Yi(e), n = t.length, i = [], s = 0; s < n; s += 2)
      i.push(new sn(t[s], t[s + 1]));
    return i;
  }
  angleTo(e) {
    return Math.atan2(e.y - this.y, e.x - this.x);
  }
  applyTransform(e) {
    var {
      x: t,
      y: n
    } = this, i = t * e[0] + n * e[2] + e[4], s = t * e[1] + n * e[3] + e[5];
    this.x = i, this.y = s;
  }
}
class Ax {
  constructor(e) {
    this.screen = e, this.working = !1, this.events = [], this.eventElements = [], this.onClick = this.onClick.bind(this), this.onMouseMove = this.onMouseMove.bind(this);
  }
  isWorking() {
    return this.working;
  }
  start() {
    if (!this.working) {
      var {
        screen: e,
        onClick: t,
        onMouseMove: n
      } = this, i = e.ctx.canvas;
      i.onclick = t, i.onmousemove = n, this.working = !0;
    }
  }
  stop() {
    if (this.working) {
      var e = this.screen.ctx.canvas;
      this.working = !1, e.onclick = null, e.onmousemove = null;
    }
  }
  hasEvents() {
    return this.working && this.events.length > 0;
  }
  runEvents() {
    if (this.working) {
      var {
        screen: e,
        events: t,
        eventElements: n
      } = this, {
        style: i
      } = e.ctx.canvas;
      i && (i.cursor = ""), t.forEach((s, a) => {
        for (var {
          run: o
        } = s, A = n[a]; A; )
          o(A), A = A.parent;
      }), this.events = [], this.eventElements = [];
    }
  }
  checkPath(e, t) {
    if (!(!this.working || !t)) {
      var {
        events: n,
        eventElements: i
      } = this;
      n.forEach((s, a) => {
        var {
          x: o,
          y: A
        } = s;
        !i[a] && t.isPointInPath && t.isPointInPath(o, A) && (i[a] = e);
      });
    }
  }
  checkBoundingBox(e, t) {
    if (!(!this.working || !t)) {
      var {
        events: n,
        eventElements: i
      } = this;
      n.forEach((s, a) => {
        var {
          x: o,
          y: A
        } = s;
        !i[a] && t.isPointInBox(o, A) && (i[a] = e);
      });
    }
  }
  mapXY(e, t) {
    for (var {
      window: n,
      ctx: i
    } = this.screen, s = new sn(e, t), a = i.canvas; a; )
      s.x -= a.offsetLeft, s.y -= a.offsetTop, a = a.offsetParent;
    return n.scrollX && (s.x += n.scrollX), n.scrollY && (s.y += n.scrollY), s;
  }
  onClick(e) {
    var {
      x: t,
      y: n
    } = this.mapXY(e.clientX, e.clientY);
    this.events.push({
      type: "onclick",
      x: t,
      y: n,
      run(i) {
        i.onClick && i.onClick();
      }
    });
  }
  onMouseMove(e) {
    var {
      x: t,
      y: n
    } = this.mapXY(e.clientX, e.clientY);
    this.events.push({
      type: "onmousemove",
      x: t,
      y: n,
      run(i) {
        i.onMouseMove && i.onMouseMove();
      }
    });
  }
}
var lx = typeof window < "u" ? window : null, ux = typeof fetch < "u" ? fetch.bind(void 0) : null;
class Xf {
  constructor(e) {
    var {
      fetch: t = ux,
      window: n = lx
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.ctx = e, this.FRAMERATE = 30, this.MAX_VIRTUAL_PIXELS = 3e4, this.CLIENT_WIDTH = 800, this.CLIENT_HEIGHT = 600, this.viewPort = new ox(), this.mouse = new Ax(this), this.animations = [], this.waits = [], this.frameDuration = 0, this.isReadyLock = !1, this.isFirstRender = !0, this.intervalId = null, this.window = n, this.fetch = t;
  }
  wait(e) {
    this.waits.push(e);
  }
  ready() {
    return this.readyPromise ? this.readyPromise : Promise.resolve();
  }
  isReady() {
    if (this.isReadyLock)
      return !0;
    var e = this.waits.every((t) => t());
    return e && (this.waits = [], this.resolveReady && this.resolveReady()), this.isReadyLock = e, e;
  }
  setDefaults(e) {
    e.strokeStyle = "rgba(0,0,0,0)", e.lineCap = "butt", e.lineJoin = "miter", e.miterLimit = 4;
  }
  setViewBox(e) {
    var {
      document: t,
      ctx: n,
      aspectRatio: i,
      width: s,
      desiredWidth: a,
      height: o,
      desiredHeight: A,
      minX: l = 0,
      minY: u = 0,
      refX: c,
      refY: h,
      clip: f = !1,
      clipX: d = 0,
      clipY: p = 0
    } = e, v = ml(i).replace(/^defer\s/, ""), [m, b] = v.split(" "), w = m || "xMidYMid", B = b || "meet", _ = s / a, x = o / A, C = Math.min(_, x), F = Math.max(_, x), N = a, D = A;
    B === "meet" && (N *= C, D *= C), B === "slice" && (N *= F, D *= F);
    var T = new wt(t, "refX", c), E = new wt(t, "refY", h), L = T.hasValue() && E.hasValue();
    if (L && n.translate(-C * T.getPixels("x"), -C * E.getPixels("y")), f) {
      var S = C * d, X = C * p;
      n.beginPath(), n.moveTo(S, X), n.lineTo(s, X), n.lineTo(s, o), n.lineTo(S, o), n.closePath(), n.clip();
    }
    if (!L) {
      var z = B === "meet" && C === x, R = B === "slice" && F === x, V = B === "meet" && C === _, O = B === "slice" && F === _;
      w.startsWith("xMid") && (z || R) && n.translate(s / 2 - N / 2, 0), w.endsWith("YMid") && (V || O) && n.translate(0, o / 2 - D / 2), w.startsWith("xMax") && (z || R) && n.translate(s - N, 0), w.endsWith("YMax") && (V || O) && n.translate(0, o - D);
    }
    switch (!0) {
      case w === "none":
        n.scale(_, x);
        break;
      case B === "meet":
        n.scale(C, C);
        break;
      case B === "slice":
        n.scale(F, F);
        break;
    }
    n.translate(-l, -u);
  }
  start(e) {
    var {
      enableRedraw: t = !1,
      ignoreMouse: n = !1,
      ignoreAnimation: i = !1,
      ignoreDimensions: s = !1,
      ignoreClear: a = !1,
      forceRedraw: o,
      scaleWidth: A,
      scaleHeight: l,
      offsetX: u,
      offsetY: c
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      FRAMERATE: h,
      mouse: f
    } = this, d = 1e3 / h;
    if (this.frameDuration = d, this.readyPromise = new Promise((w) => {
      this.resolveReady = w;
    }), this.isReady() && this.render(e, s, a, A, l, u, c), !!t) {
      var p = Date.now(), v = p, m = 0, b = () => {
        p = Date.now(), m = p - v, m >= d && (v = p - m % d, this.shouldUpdate(i, o) && (this.render(e, s, a, A, l, u, c), f.runEvents())), this.intervalId = N1(b);
      };
      n || f.start(), this.intervalId = N1(b);
    }
  }
  stop() {
    this.intervalId && (N1.cancel(this.intervalId), this.intervalId = null), this.mouse.stop();
  }
  shouldUpdate(e, t) {
    if (!e) {
      var {
        frameDuration: n
      } = this, i = this.animations.reduce((s, a) => a.update(n) || s, !1);
      if (i)
        return !0;
    }
    return !!(typeof t == "function" && t() || !this.isReadyLock && this.isReady() || this.mouse.hasEvents());
  }
  render(e, t, n, i, s, a, o) {
    var {
      CLIENT_WIDTH: A,
      CLIENT_HEIGHT: l,
      viewPort: u,
      ctx: c,
      isFirstRender: h
    } = this, f = c.canvas;
    u.clear(), f.width && f.height ? u.setCurrent(f.width, f.height) : u.setCurrent(A, l);
    var d = e.getStyle("width"), p = e.getStyle("height");
    !t && (h || typeof i != "number" && typeof s != "number") && (d.hasValue() && (f.width = d.getPixels("x"), f.style && (f.style.width = "".concat(f.width, "px"))), p.hasValue() && (f.height = p.getPixels("y"), f.style && (f.style.height = "".concat(f.height, "px"))));
    var v = f.clientWidth || f.width, m = f.clientHeight || f.height;
    if (t && d.hasValue() && p.hasValue() && (v = d.getPixels("x"), m = p.getPixels("y")), u.setCurrent(v, m), typeof a == "number" && e.getAttribute("x", !0).setValue(a), typeof o == "number" && e.getAttribute("y", !0).setValue(o), typeof i == "number" || typeof s == "number") {
      var b = Yi(e.getAttribute("viewBox").getString()), w = 0, B = 0;
      if (typeof i == "number") {
        var _ = e.getStyle("width");
        _.hasValue() ? w = _.getPixels("x") / i : isNaN(b[2]) || (w = b[2] / i);
      }
      if (typeof s == "number") {
        var x = e.getStyle("height");
        x.hasValue() ? B = x.getPixels("y") / s : isNaN(b[3]) || (B = b[3] / s);
      }
      w || (w = B), B || (B = w), e.getAttribute("width", !0).setValue(i), e.getAttribute("height", !0).setValue(s);
      var C = e.getStyle("transform", !0, !0);
      C.setValue("".concat(C.getString(), " scale(").concat(1 / w, ", ").concat(1 / B, ")"));
    }
    n || c.clearRect(0, 0, v, m), e.render(c), h && (this.isFirstRender = !1);
  }
}
Xf.defaultWindow = lx;
Xf.defaultFetch = ux;
var {
  defaultFetch: lae
} = Xf, uae = typeof DOMParser < "u" ? DOMParser : null;
class mp {
  constructor() {
    var {
      fetch: e = lae,
      DOMParser: t = uae
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.fetch = e, this.DOMParser = t;
  }
  parse(e) {
    var t = this;
    return uo(function* () {
      return e.startsWith("<") ? t.parseFromString(e) : t.load(e);
    })();
  }
  parseFromString(e) {
    var t = new this.DOMParser();
    try {
      return this.checkDocument(t.parseFromString(e, "image/svg+xml"));
    } catch {
      return this.checkDocument(t.parseFromString(e, "text/xml"));
    }
  }
  checkDocument(e) {
    var t = e.getElementsByTagName("parsererror")[0];
    if (t)
      throw new Error(t.textContent);
    return e;
  }
  load(e) {
    var t = this;
    return uo(function* () {
      var n = yield t.fetch(e), i = yield n.text();
      return t.parseFromString(i);
    })();
  }
}
class cx {
  constructor(e, t) {
    this.type = "translate", this.point = null, this.point = sn.parse(t);
  }
  apply(e) {
    var {
      x: t,
      y: n
    } = this.point;
    e.translate(t || 0, n || 0);
  }
  unapply(e) {
    var {
      x: t,
      y: n
    } = this.point;
    e.translate(-1 * t || 0, -1 * n || 0);
  }
  applyToPoint(e) {
    var {
      x: t,
      y: n
    } = this.point;
    e.applyTransform([1, 0, 0, 1, t || 0, n || 0]);
  }
}
class fx {
  constructor(e, t, n) {
    this.type = "rotate", this.angle = null, this.originX = null, this.originY = null, this.cx = 0, this.cy = 0;
    var i = Yi(t);
    this.angle = new wt(e, "angle", i[0]), this.originX = n[0], this.originY = n[1], this.cx = i[1] || 0, this.cy = i[2] || 0;
  }
  apply(e) {
    var {
      cx: t,
      cy: n,
      originX: i,
      originY: s,
      angle: a
    } = this, o = t + i.getPixels("x"), A = n + s.getPixels("y");
    e.translate(o, A), e.rotate(a.getRadians()), e.translate(-o, -A);
  }
  unapply(e) {
    var {
      cx: t,
      cy: n,
      originX: i,
      originY: s,
      angle: a
    } = this, o = t + i.getPixels("x"), A = n + s.getPixels("y");
    e.translate(o, A), e.rotate(-1 * a.getRadians()), e.translate(-o, -A);
  }
  applyToPoint(e) {
    var {
      cx: t,
      cy: n,
      angle: i
    } = this, s = i.getRadians();
    e.applyTransform([
      1,
      0,
      0,
      1,
      t || 0,
      n || 0
      // this.p.y
    ]), e.applyTransform([Math.cos(s), Math.sin(s), -Math.sin(s), Math.cos(s), 0, 0]), e.applyTransform([
      1,
      0,
      0,
      1,
      -t || 0,
      -n || 0
      // -this.p.y
    ]);
  }
}
class hx {
  constructor(e, t, n) {
    this.type = "scale", this.scale = null, this.originX = null, this.originY = null;
    var i = sn.parseScale(t);
    (i.x === 0 || i.y === 0) && (i.x = sl, i.y = sl), this.scale = i, this.originX = n[0], this.originY = n[1];
  }
  apply(e) {
    var {
      scale: {
        x: t,
        y: n
      },
      originX: i,
      originY: s
    } = this, a = i.getPixels("x"), o = s.getPixels("y");
    e.translate(a, o), e.scale(t, n || t), e.translate(-a, -o);
  }
  unapply(e) {
    var {
      scale: {
        x: t,
        y: n
      },
      originX: i,
      originY: s
    } = this, a = i.getPixels("x"), o = s.getPixels("y");
    e.translate(a, o), e.scale(1 / t, 1 / n || t), e.translate(-a, -o);
  }
  applyToPoint(e) {
    var {
      x: t,
      y: n
    } = this.scale;
    e.applyTransform([t || 0, 0, 0, n || 0, 0, 0]);
  }
}
class Ay {
  constructor(e, t, n) {
    this.type = "matrix", this.matrix = [], this.originX = null, this.originY = null, this.matrix = Yi(t), this.originX = n[0], this.originY = n[1];
  }
  apply(e) {
    var {
      originX: t,
      originY: n,
      matrix: i
    } = this, s = t.getPixels("x"), a = n.getPixels("y");
    e.translate(s, a), e.transform(i[0], i[1], i[2], i[3], i[4], i[5]), e.translate(-s, -a);
  }
  unapply(e) {
    var {
      originX: t,
      originY: n,
      matrix: i
    } = this, s = i[0], a = i[2], o = i[4], A = i[1], l = i[3], u = i[5], c = 0, h = 0, f = 1, d = 1 / (s * (l * f - u * h) - a * (A * f - u * c) + o * (A * h - l * c)), p = t.getPixels("x"), v = n.getPixels("y");
    e.translate(p, v), e.transform(d * (l * f - u * h), d * (u * c - A * f), d * (o * h - a * f), d * (s * f - o * c), d * (a * u - o * l), d * (o * A - s * u)), e.translate(-p, -v);
  }
  applyToPoint(e) {
    e.applyTransform(this.matrix);
  }
}
class ly extends Ay {
  constructor(e, t, n) {
    super(e, t, n), this.type = "skew", this.angle = null, this.angle = new wt(e, "angle", t);
  }
}
class dx extends ly {
  constructor(e, t, n) {
    super(e, t, n), this.type = "skewX", this.matrix = [1, 0, Math.tan(this.angle.getRadians()), 1, 0, 0];
  }
}
class px extends ly {
  constructor(e, t, n) {
    super(e, t, n), this.type = "skewY", this.matrix = [1, Math.tan(this.angle.getRadians()), 0, 1, 0, 0];
  }
}
function cae(r) {
  return ml(r).trim().replace(/\)([a-zA-Z])/g, ") $1").replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/);
}
function fae(r) {
  var [e, t] = r.split("(");
  return [e.trim(), t.trim().replace(")", "")];
}
class lA {
  constructor(e, t, n) {
    this.document = e, this.transforms = [];
    var i = cae(t);
    i.forEach((s) => {
      if (s !== "none") {
        var [a, o] = fae(s), A = lA.transformTypes[a];
        typeof A < "u" && this.transforms.push(new A(this.document, o, n));
      }
    });
  }
  static fromElement(e, t) {
    var n = t.getStyle("transform", !1, !0), [i, s = i] = t.getStyle("transform-origin", !1, !0).split(), a = [i, s];
    return n.hasValue() ? new lA(e, n.getString(), a) : null;
  }
  apply(e) {
    for (var {
      transforms: t
    } = this, n = t.length, i = 0; i < n; i++)
      t[i].apply(e);
  }
  unapply(e) {
    for (var {
      transforms: t
    } = this, n = t.length, i = n - 1; i >= 0; i--)
      t[i].unapply(e);
  }
  // TODO: applyToPoint unused ... remove?
  applyToPoint(e) {
    for (var {
      transforms: t
    } = this, n = t.length, i = 0; i < n; i++)
      t[i].applyToPoint(e);
  }
}
lA.transformTypes = {
  translate: cx,
  rotate: fx,
  scale: hx,
  matrix: Ay,
  skewX: dx,
  skewY: px
};
class jr {
  constructor(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    if (this.document = e, this.node = t, this.captureTextNodes = n, this.attributes = {}, this.styles = {}, this.stylesSpecificity = {}, this.animationFrozen = !1, this.animationFrozenValue = "", this.parent = null, this.children = [], !(!t || t.nodeType !== 1)) {
      if (Array.from(t.attributes).forEach((o) => {
        var A = ix(o.nodeName);
        this.attributes[A] = new wt(e, A, o.value);
      }), this.addStylesFromStyleDefinition(), this.getAttribute("style").hasValue()) {
        var i = this.getAttribute("style").getString().split(";").map((o) => o.trim());
        i.forEach((o) => {
          if (o) {
            var [A, l] = o.split(":").map((u) => u.trim());
            this.styles[A] = new wt(e, A, l);
          }
        });
      }
      var {
        definitions: s
      } = e, a = this.getAttribute("id");
      a.hasValue() && (s[a.getString()] || (s[a.getString()] = this)), Array.from(t.childNodes).forEach((o) => {
        if (o.nodeType === 1)
          this.addChild(o);
        else if (n && (o.nodeType === 3 || o.nodeType === 4)) {
          var A = e.createTextNode(o);
          A.getText().length > 0 && this.addChild(A);
        }
      });
    }
  }
  getAttribute(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = this.attributes[e];
    if (!n && t) {
      var i = new wt(this.document, e, "");
      return this.attributes[e] = i, i;
    }
    return n || wt.empty(this.document);
  }
  getHrefAttribute() {
    for (var e in this.attributes)
      if (e === "href" || e.endsWith(":href"))
        return this.attributes[e];
    return wt.empty(this.document);
  }
  getStyle(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, i = this.styles[e];
    if (i)
      return i;
    var s = this.getAttribute(e);
    if (s != null && s.hasValue())
      return this.styles[e] = s, s;
    if (!n) {
      var {
        parent: a
      } = this;
      if (a) {
        var o = a.getStyle(e);
        if (o != null && o.hasValue())
          return o;
      }
    }
    if (t) {
      var A = new wt(this.document, e, "");
      return this.styles[e] = A, A;
    }
    return i || wt.empty(this.document);
  }
  render(e) {
    if (!(this.getStyle("display").getString() === "none" || this.getStyle("visibility").getString() === "hidden")) {
      if (e.save(), this.getStyle("mask").hasValue()) {
        var t = this.getStyle("mask").getDefinition();
        t && (this.applyEffects(e), t.apply(e, this));
      } else if (this.getStyle("filter").getValue("none") !== "none") {
        var n = this.getStyle("filter").getDefinition();
        n && (this.applyEffects(e), n.apply(e, this));
      } else
        this.setContext(e), this.renderChildren(e), this.clearContext(e);
      e.restore();
    }
  }
  setContext(e) {
  }
  applyEffects(e) {
    var t = lA.fromElement(this.document, this);
    t && t.apply(e);
    var n = this.getStyle("clip-path", !1, !0);
    if (n.hasValue()) {
      var i = n.getDefinition();
      i && i.apply(e);
    }
  }
  clearContext(e) {
  }
  renderChildren(e) {
    this.children.forEach((t) => {
      t.render(e);
    });
  }
  addChild(e) {
    var t = e instanceof jr ? e : this.document.createElement(e);
    t.parent = this, jr.ignoreChildTypes.includes(t.type) || this.children.push(t);
  }
  matchesSelector(e) {
    var t, {
      node: n
    } = this;
    if (typeof n.matches == "function")
      return n.matches(e);
    var i = (t = n.getAttribute) === null || t === void 0 ? void 0 : t.call(n, "class");
    return !i || i === "" ? !1 : i.split(" ").some((s) => ".".concat(s) === e);
  }
  addStylesFromStyleDefinition() {
    var {
      styles: e,
      stylesSpecificity: t
    } = this.document;
    for (var n in e)
      if (!n.startsWith("@") && this.matchesSelector(n)) {
        var i = e[n], s = t[n];
        if (i)
          for (var a in i) {
            var o = this.stylesSpecificity[a];
            typeof o > "u" && (o = "000"), s >= o && (this.styles[a] = i[a], this.stylesSpecificity[a] = s);
          }
      }
  }
  removeStyles(e, t) {
    var n = t.reduce((i, s) => {
      var a = e.getStyle(s);
      if (!a.hasValue())
        return i;
      var o = a.getString();
      return a.setValue(""), [...i, [s, o]];
    }, []);
    return n;
  }
  restoreStyles(e, t) {
    t.forEach((n) => {
      var [i, s] = n;
      e.getStyle(i, !0).setValue(s);
    });
  }
  isFirstChild() {
    var e;
    return ((e = this.parent) === null || e === void 0 ? void 0 : e.children.indexOf(this)) === 0;
  }
}
jr.ignoreChildTypes = ["title"];
class gx extends jr {
  constructor(e, t, n) {
    super(e, t, n);
  }
}
function hae(r) {
  var e = r.trim();
  return /^('|")/.test(e) ? e : '"'.concat(e, '"');
}
function dae(r) {
  return typeof process > "u" ? r : r.trim().split(",").map(hae).join(",");
}
function pae(r) {
  if (!r)
    return "";
  var e = r.trim().toLowerCase();
  switch (e) {
    case "normal":
    case "italic":
    case "oblique":
    case "inherit":
    case "initial":
    case "unset":
      return e;
    default:
      return /^oblique\s+(-|)\d+deg$/.test(e) ? e : "";
  }
}
function gae(r) {
  if (!r)
    return "";
  var e = r.trim().toLowerCase();
  switch (e) {
    case "normal":
    case "bold":
    case "lighter":
    case "bolder":
    case "inherit":
    case "initial":
    case "unset":
      return e;
    default:
      return /^[\d.]+$/.test(e) ? e : "";
  }
}
class Ei {
  constructor(e, t, n, i, s, a) {
    var o = a ? typeof a == "string" ? Ei.parse(a) : a : {};
    this.fontFamily = s || o.fontFamily, this.fontSize = i || o.fontSize, this.fontStyle = e || o.fontStyle, this.fontWeight = n || o.fontWeight, this.fontVariant = t || o.fontVariant;
  }
  static parse() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 ? arguments[1] : void 0, n = "", i = "", s = "", a = "", o = "", A = ml(e).trim().split(" "), l = {
      fontSize: !1,
      fontStyle: !1,
      fontWeight: !1,
      fontVariant: !1
    };
    return A.forEach((u) => {
      switch (!0) {
        case (!l.fontStyle && Ei.styles.includes(u)):
          u !== "inherit" && (n = u), l.fontStyle = !0;
          break;
        case (!l.fontVariant && Ei.variants.includes(u)):
          u !== "inherit" && (i = u), l.fontStyle = !0, l.fontVariant = !0;
          break;
        case (!l.fontWeight && Ei.weights.includes(u)):
          u !== "inherit" && (s = u), l.fontStyle = !0, l.fontVariant = !0, l.fontWeight = !0;
          break;
        case !l.fontSize:
          u !== "inherit" && ([a] = u.split("/")), l.fontStyle = !0, l.fontVariant = !0, l.fontWeight = !0, l.fontSize = !0;
          break;
        default:
          u !== "inherit" && (o += u);
      }
    }), new Ei(n, i, s, a, o, t);
  }
  toString() {
    return [
      pae(this.fontStyle),
      this.fontVariant,
      gae(this.fontWeight),
      this.fontSize,
      // Wrap fontFamily only on nodejs and only for canvas.ctx
      dae(this.fontFamily)
    ].join(" ").trim();
  }
}
Ei.styles = "normal|italic|oblique|inherit";
Ei.variants = "normal|small-caps|inherit";
Ei.weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit";
class Ms {
  constructor() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.NaN, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.NaN, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Number.NaN, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Number.NaN;
    this.x1 = e, this.y1 = t, this.x2 = n, this.y2 = i, this.addPoint(e, t), this.addPoint(n, i);
  }
  get x() {
    return this.x1;
  }
  get y() {
    return this.y1;
  }
  get width() {
    return this.x2 - this.x1;
  }
  get height() {
    return this.y2 - this.y1;
  }
  addPoint(e, t) {
    typeof e < "u" && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = e, this.x2 = e), e < this.x1 && (this.x1 = e), e > this.x2 && (this.x2 = e)), typeof t < "u" && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = t, this.y2 = t), t < this.y1 && (this.y1 = t), t > this.y2 && (this.y2 = t));
  }
  addX(e) {
    this.addPoint(e, null);
  }
  addY(e) {
    this.addPoint(null, e);
  }
  addBoundingBox(e) {
    if (e) {
      var {
        x1: t,
        y1: n,
        x2: i,
        y2: s
      } = e;
      this.addPoint(t, n), this.addPoint(i, s);
    }
  }
  sumCubic(e, t, n, i, s) {
    return Math.pow(1 - e, 3) * t + 3 * Math.pow(1 - e, 2) * e * n + 3 * (1 - e) * Math.pow(e, 2) * i + Math.pow(e, 3) * s;
  }
  bezierCurveAdd(e, t, n, i, s) {
    var a = 6 * t - 12 * n + 6 * i, o = -3 * t + 9 * n - 9 * i + 3 * s, A = 3 * n - 3 * t;
    if (o === 0) {
      if (a === 0)
        return;
      var l = -A / a;
      0 < l && l < 1 && (e ? this.addX(this.sumCubic(l, t, n, i, s)) : this.addY(this.sumCubic(l, t, n, i, s)));
      return;
    }
    var u = Math.pow(a, 2) - 4 * A * o;
    if (!(u < 0)) {
      var c = (-a + Math.sqrt(u)) / (2 * o);
      0 < c && c < 1 && (e ? this.addX(this.sumCubic(c, t, n, i, s)) : this.addY(this.sumCubic(c, t, n, i, s)));
      var h = (-a - Math.sqrt(u)) / (2 * o);
      0 < h && h < 1 && (e ? this.addX(this.sumCubic(h, t, n, i, s)) : this.addY(this.sumCubic(h, t, n, i, s)));
    }
  }
  // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
  addBezierCurve(e, t, n, i, s, a, o, A) {
    this.addPoint(e, t), this.addPoint(o, A), this.bezierCurveAdd(!0, e, n, s, o), this.bezierCurveAdd(!1, t, i, a, A);
  }
  addQuadraticCurve(e, t, n, i, s, a) {
    var o = e + 0.6666666666666666 * (n - e), A = t + 2 / 3 * (i - t), l = o + 1 / 3 * (s - e), u = A + 1 / 3 * (a - t);
    this.addBezierCurve(e, t, o, l, A, u, s, a);
  }
  isPointInBox(e, t) {
    var {
      x1: n,
      y1: i,
      x2: s,
      y2: a
    } = this;
    return n <= e && e <= s && i <= t && t <= a;
  }
}
class qt extends Xe {
  constructor(e) {
    super(e.replace(/([+\-.])\s+/gm, "$1").replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, "")), this.control = null, this.start = null, this.current = null, this.command = null, this.commands = this.commands, this.i = -1, this.previousCommand = null, this.points = [], this.angles = [];
  }
  reset() {
    this.i = -1, this.command = null, this.previousCommand = null, this.start = new sn(0, 0), this.control = new sn(0, 0), this.current = new sn(0, 0), this.points = [], this.angles = [];
  }
  isEnd() {
    var {
      i: e,
      commands: t
    } = this;
    return e >= t.length - 1;
  }
  next() {
    var e = this.commands[++this.i];
    return this.previousCommand = this.command, this.command = e, e;
  }
  getPoint() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "x", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "y", n = new sn(this.command[e], this.command[t]);
    return this.makeAbsolute(n);
  }
  getAsControlPoint(e, t) {
    var n = this.getPoint(e, t);
    return this.control = n, n;
  }
  getAsCurrentPoint(e, t) {
    var n = this.getPoint(e, t);
    return this.current = n, n;
  }
  getReflectedControlPoint() {
    var e = this.previousCommand.type;
    if (e !== Xe.CURVE_TO && e !== Xe.SMOOTH_CURVE_TO && e !== Xe.QUAD_TO && e !== Xe.SMOOTH_QUAD_TO)
      return this.current;
    var {
      current: {
        x: t,
        y: n
      },
      control: {
        x: i,
        y: s
      }
    } = this, a = new sn(2 * t - i, 2 * n - s);
    return a;
  }
  makeAbsolute(e) {
    if (this.command.relative) {
      var {
        x: t,
        y: n
      } = this.current;
      e.x += t, e.y += n;
    }
    return e;
  }
  addMarker(e, t, n) {
    var {
      points: i,
      angles: s
    } = this;
    n && s.length > 0 && !s[s.length - 1] && (s[s.length - 1] = i[i.length - 1].angleTo(n)), this.addMarkerAngle(e, t ? t.angleTo(e) : null);
  }
  addMarkerAngle(e, t) {
    this.points.push(e), this.angles.push(t);
  }
  getMarkerPoints() {
    return this.points;
  }
  getMarkerAngles() {
    for (var {
      angles: e
    } = this, t = e.length, n = 0; n < t; n++)
      if (!e[n]) {
        for (var i = n + 1; i < t; i++)
          if (e[i]) {
            e[n] = e[i];
            break;
          }
      }
    return e;
  }
}
class hA extends jr {
  constructor() {
    super(...arguments), this.modifiedEmSizeStack = !1;
  }
  calculateOpacity() {
    for (var e = 1, t = this; t; ) {
      var n = t.getStyle("opacity", !1, !0);
      n.hasValue(!0) && (e *= n.getNumber()), t = t.parent;
    }
    return e;
  }
  setContext(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (!t) {
      var n = this.getStyle("fill"), i = this.getStyle("fill-opacity"), s = this.getStyle("stroke"), a = this.getStyle("stroke-opacity");
      if (n.isUrlDefinition()) {
        var o = n.getFillStyleDefinition(this, i);
        o && (e.fillStyle = o);
      } else if (n.hasValue()) {
        n.getString() === "currentColor" && n.setValue(this.getStyle("color").getColor());
        var A = n.getColor();
        A !== "inherit" && (e.fillStyle = A === "none" ? "rgba(0,0,0,0)" : A);
      }
      if (i.hasValue()) {
        var l = new wt(this.document, "fill", e.fillStyle).addOpacity(i).getColor();
        e.fillStyle = l;
      }
      if (s.isUrlDefinition()) {
        var u = s.getFillStyleDefinition(this, a);
        u && (e.strokeStyle = u);
      } else if (s.hasValue()) {
        s.getString() === "currentColor" && s.setValue(this.getStyle("color").getColor());
        var c = s.getString();
        c !== "inherit" && (e.strokeStyle = c === "none" ? "rgba(0,0,0,0)" : c);
      }
      if (a.hasValue()) {
        var h = new wt(this.document, "stroke", e.strokeStyle).addOpacity(a).getString();
        e.strokeStyle = h;
      }
      var f = this.getStyle("stroke-width");
      if (f.hasValue()) {
        var d = f.getPixels();
        e.lineWidth = d || sl;
      }
      var p = this.getStyle("stroke-linecap"), v = this.getStyle("stroke-linejoin"), m = this.getStyle("stroke-miterlimit"), b = this.getStyle("stroke-dasharray"), w = this.getStyle("stroke-dashoffset");
      if (p.hasValue() && (e.lineCap = p.getString()), v.hasValue() && (e.lineJoin = v.getString()), m.hasValue() && (e.miterLimit = m.getNumber()), b.hasValue() && b.getString() !== "none") {
        var B = Yi(b.getString());
        typeof e.setLineDash < "u" ? e.setLineDash(B) : typeof e.webkitLineDash < "u" ? e.webkitLineDash = B : typeof e.mozDash < "u" && !(B.length === 1 && B[0] === 0) && (e.mozDash = B);
        var _ = w.getPixels();
        typeof e.lineDashOffset < "u" ? e.lineDashOffset = _ : typeof e.webkitLineDashOffset < "u" ? e.webkitLineDashOffset = _ : typeof e.mozDashOffset < "u" && (e.mozDashOffset = _);
      }
    }
    if (this.modifiedEmSizeStack = !1, typeof e.font < "u") {
      var x = this.getStyle("font"), C = this.getStyle("font-style"), F = this.getStyle("font-variant"), N = this.getStyle("font-weight"), D = this.getStyle("font-size"), T = this.getStyle("font-family"), E = new Ei(C.getString(), F.getString(), N.getString(), D.hasValue() ? "".concat(D.getPixels(!0), "px") : "", T.getString(), Ei.parse(x.getString(), e.font));
      C.setValue(E.fontStyle), F.setValue(E.fontVariant), N.setValue(E.fontWeight), D.setValue(E.fontSize), T.setValue(E.fontFamily), e.font = E.toString(), D.isPixels() && (this.document.emSize = D.getPixels(), this.modifiedEmSizeStack = !0);
    }
    t || (this.applyEffects(e), e.globalAlpha = this.calculateOpacity());
  }
  clearContext(e) {
    super.clearContext(e), this.modifiedEmSizeStack && this.document.popEmSize();
  }
}
class _r extends hA {
  constructor(e, t, n) {
    super(e, t, n), this.type = "path", this.pathParser = null, this.pathParser = new qt(this.getAttribute("d").getString());
  }
  path(e) {
    var {
      pathParser: t
    } = this, n = new Ms();
    for (t.reset(), e && e.beginPath(); !t.isEnd(); )
      switch (t.next().type) {
        case qt.MOVE_TO:
          this.pathM(e, n);
          break;
        case qt.LINE_TO:
          this.pathL(e, n);
          break;
        case qt.HORIZ_LINE_TO:
          this.pathH(e, n);
          break;
        case qt.VERT_LINE_TO:
          this.pathV(e, n);
          break;
        case qt.CURVE_TO:
          this.pathC(e, n);
          break;
        case qt.SMOOTH_CURVE_TO:
          this.pathS(e, n);
          break;
        case qt.QUAD_TO:
          this.pathQ(e, n);
          break;
        case qt.SMOOTH_QUAD_TO:
          this.pathT(e, n);
          break;
        case qt.ARC:
          this.pathA(e, n);
          break;
        case qt.CLOSE_PATH:
          this.pathZ(e, n);
          break;
      }
    return n;
  }
  getBoundingBox(e) {
    return this.path();
  }
  getMarkers() {
    var {
      pathParser: e
    } = this, t = e.getMarkerPoints(), n = e.getMarkerAngles(), i = t.map((s, a) => [s, n[a]]);
    return i;
  }
  renderChildren(e) {
    this.path(e), this.document.screen.mouse.checkPath(this, e);
    var t = this.getStyle("fill-rule");
    e.fillStyle !== "" && (t.getString("inherit") !== "inherit" ? e.fill(t.getString()) : e.fill()), e.strokeStyle !== "" && (this.getAttribute("vector-effect").getString() === "non-scaling-stroke" ? (e.save(), e.setTransform(1, 0, 0, 1, 0, 0), e.stroke(), e.restore()) : e.stroke());
    var n = this.getMarkers();
    if (n) {
      var i = n.length - 1, s = this.getStyle("marker-start"), a = this.getStyle("marker-mid"), o = this.getStyle("marker-end");
      if (s.isUrlDefinition()) {
        var A = s.getDefinition(), [l, u] = n[0];
        A.render(e, l, u);
      }
      if (a.isUrlDefinition())
        for (var c = a.getDefinition(), h = 1; h < i; h++) {
          var [f, d] = n[h];
          c.render(e, f, d);
        }
      if (o.isUrlDefinition()) {
        var p = o.getDefinition(), [v, m] = n[i];
        p.render(e, v, m);
      }
    }
  }
  static pathM(e) {
    var t = e.getAsCurrentPoint();
    return e.start = e.current, {
      point: t
    };
  }
  pathM(e, t) {
    var {
      pathParser: n
    } = this, {
      point: i
    } = _r.pathM(n), {
      x: s,
      y: a
    } = i;
    n.addMarker(i), t.addPoint(s, a), e && e.moveTo(s, a);
  }
  static pathL(e) {
    var {
      current: t
    } = e, n = e.getAsCurrentPoint();
    return {
      current: t,
      point: n
    };
  }
  pathL(e, t) {
    var {
      pathParser: n
    } = this, {
      current: i,
      point: s
    } = _r.pathL(n), {
      x: a,
      y: o
    } = s;
    n.addMarker(s, i), t.addPoint(a, o), e && e.lineTo(a, o);
  }
  static pathH(e) {
    var {
      current: t,
      command: n
    } = e, i = new sn((n.relative ? t.x : 0) + n.x, t.y);
    return e.current = i, {
      current: t,
      point: i
    };
  }
  pathH(e, t) {
    var {
      pathParser: n
    } = this, {
      current: i,
      point: s
    } = _r.pathH(n), {
      x: a,
      y: o
    } = s;
    n.addMarker(s, i), t.addPoint(a, o), e && e.lineTo(a, o);
  }
  static pathV(e) {
    var {
      current: t,
      command: n
    } = e, i = new sn(t.x, (n.relative ? t.y : 0) + n.y);
    return e.current = i, {
      current: t,
      point: i
    };
  }
  pathV(e, t) {
    var {
      pathParser: n
    } = this, {
      current: i,
      point: s
    } = _r.pathV(n), {
      x: a,
      y: o
    } = s;
    n.addMarker(s, i), t.addPoint(a, o), e && e.lineTo(a, o);
  }
  static pathC(e) {
    var {
      current: t
    } = e, n = e.getPoint("x1", "y1"), i = e.getAsControlPoint("x2", "y2"), s = e.getAsCurrentPoint();
    return {
      current: t,
      point: n,
      controlPoint: i,
      currentPoint: s
    };
  }
  pathC(e, t) {
    var {
      pathParser: n
    } = this, {
      current: i,
      point: s,
      controlPoint: a,
      currentPoint: o
    } = _r.pathC(n);
    n.addMarker(o, a, s), t.addBezierCurve(i.x, i.y, s.x, s.y, a.x, a.y, o.x, o.y), e && e.bezierCurveTo(s.x, s.y, a.x, a.y, o.x, o.y);
  }
  static pathS(e) {
    var {
      current: t
    } = e, n = e.getReflectedControlPoint(), i = e.getAsControlPoint("x2", "y2"), s = e.getAsCurrentPoint();
    return {
      current: t,
      point: n,
      controlPoint: i,
      currentPoint: s
    };
  }
  pathS(e, t) {
    var {
      pathParser: n
    } = this, {
      current: i,
      point: s,
      controlPoint: a,
      currentPoint: o
    } = _r.pathS(n);
    n.addMarker(o, a, s), t.addBezierCurve(i.x, i.y, s.x, s.y, a.x, a.y, o.x, o.y), e && e.bezierCurveTo(s.x, s.y, a.x, a.y, o.x, o.y);
  }
  static pathQ(e) {
    var {
      current: t
    } = e, n = e.getAsControlPoint("x1", "y1"), i = e.getAsCurrentPoint();
    return {
      current: t,
      controlPoint: n,
      currentPoint: i
    };
  }
  pathQ(e, t) {
    var {
      pathParser: n
    } = this, {
      current: i,
      controlPoint: s,
      currentPoint: a
    } = _r.pathQ(n);
    n.addMarker(a, s, s), t.addQuadraticCurve(i.x, i.y, s.x, s.y, a.x, a.y), e && e.quadraticCurveTo(s.x, s.y, a.x, a.y);
  }
  static pathT(e) {
    var {
      current: t
    } = e, n = e.getReflectedControlPoint();
    e.control = n;
    var i = e.getAsCurrentPoint();
    return {
      current: t,
      controlPoint: n,
      currentPoint: i
    };
  }
  pathT(e, t) {
    var {
      pathParser: n
    } = this, {
      current: i,
      controlPoint: s,
      currentPoint: a
    } = _r.pathT(n);
    n.addMarker(a, s, s), t.addQuadraticCurve(i.x, i.y, s.x, s.y, a.x, a.y), e && e.quadraticCurveTo(s.x, s.y, a.x, a.y);
  }
  static pathA(e) {
    var {
      current: t,
      command: n
    } = e, {
      rX: i,
      rY: s,
      xRot: a,
      lArcFlag: o,
      sweepFlag: A
    } = n, l = a * (Math.PI / 180), u = e.getAsCurrentPoint(), c = new sn(Math.cos(l) * (t.x - u.x) / 2 + Math.sin(l) * (t.y - u.y) / 2, -Math.sin(l) * (t.x - u.x) / 2 + Math.cos(l) * (t.y - u.y) / 2), h = Math.pow(c.x, 2) / Math.pow(i, 2) + Math.pow(c.y, 2) / Math.pow(s, 2);
    h > 1 && (i *= Math.sqrt(h), s *= Math.sqrt(h));
    var f = (o === A ? -1 : 1) * Math.sqrt((Math.pow(i, 2) * Math.pow(s, 2) - Math.pow(i, 2) * Math.pow(c.y, 2) - Math.pow(s, 2) * Math.pow(c.x, 2)) / (Math.pow(i, 2) * Math.pow(c.y, 2) + Math.pow(s, 2) * Math.pow(c.x, 2)));
    isNaN(f) && (f = 0);
    var d = new sn(f * i * c.y / s, f * -s * c.x / i), p = new sn((t.x + u.x) / 2 + Math.cos(l) * d.x - Math.sin(l) * d.y, (t.y + u.y) / 2 + Math.sin(l) * d.x + Math.cos(l) * d.y), v = F2([1, 0], [(c.x - d.x) / i, (c.y - d.y) / s]), m = [(c.x - d.x) / i, (c.y - d.y) / s], b = [(-c.x - d.x) / i, (-c.y - d.y) / s], w = F2(m, b);
    return Yp(m, b) <= -1 && (w = Math.PI), Yp(m, b) >= 1 && (w = 0), {
      currentPoint: u,
      rX: i,
      rY: s,
      sweepFlag: A,
      xAxisRotation: l,
      centp: p,
      a1: v,
      ad: w
    };
  }
  pathA(e, t) {
    var {
      pathParser: n
    } = this, {
      currentPoint: i,
      rX: s,
      rY: a,
      sweepFlag: o,
      xAxisRotation: A,
      centp: l,
      a1: u,
      ad: c
    } = _r.pathA(n), h = 1 - o ? 1 : -1, f = u + h * (c / 2), d = new sn(l.x + s * Math.cos(f), l.y + a * Math.sin(f));
    if (n.addMarkerAngle(d, f - h * Math.PI / 2), n.addMarkerAngle(i, f - h * Math.PI), t.addPoint(i.x, i.y), e && !isNaN(u) && !isNaN(c)) {
      var p = s > a ? s : a, v = s > a ? 1 : s / a, m = s > a ? a / s : 1;
      e.translate(l.x, l.y), e.rotate(A), e.scale(v, m), e.arc(0, 0, p, u, u + c, !!(1 - o)), e.scale(1 / v, 1 / m), e.rotate(-A), e.translate(-l.x, -l.y);
    }
  }
  static pathZ(e) {
    e.current = e.start;
  }
  pathZ(e, t) {
    _r.pathZ(this.pathParser), e && t.x1 !== t.x2 && t.y1 !== t.y2 && e.closePath();
  }
}
class uy extends _r {
  constructor(e, t, n) {
    super(e, t, n), this.type = "glyph", this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber(), this.unicode = this.getAttribute("unicode").getString(), this.arabicForm = this.getAttribute("arabic-form").getString();
  }
}
class co extends hA {
  constructor(e, t, n) {
    super(e, t, new.target === co ? !0 : n), this.type = "text", this.x = 0, this.y = 0, this.measureCache = -1;
  }
  setContext(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    super.setContext(e, t);
    var n = this.getStyle("dominant-baseline").getTextBaseline() || this.getStyle("alignment-baseline").getTextBaseline();
    n && (e.textBaseline = n);
  }
  initializeCoordinates() {
    this.x = 0, this.y = 0, this.leafTexts = [], this.textChunkStart = 0, this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY;
  }
  getBoundingBox(e) {
    if (this.type !== "text")
      return this.getTElementBoundingBox(e);
    this.initializeCoordinates(), this.adjustChildCoordinatesRecursive(e);
    var t = null;
    return this.children.forEach((n, i) => {
      var s = this.getChildBoundingBox(e, this, this, i);
      t ? t.addBoundingBox(s) : t = s;
    }), t;
  }
  getFontSize() {
    var {
      document: e,
      parent: t
    } = this, n = Ei.parse(e.ctx.font).fontSize, i = t.getStyle("font-size").getNumber(n);
    return i;
  }
  getTElementBoundingBox(e) {
    var t = this.getFontSize();
    return new Ms(this.x, this.y - t, this.x + this.measureText(e), this.y);
  }
  getGlyph(e, t, n) {
    var i = t[n], s = null;
    if (e.isArabic) {
      var a = t.length, o = t[n - 1], A = t[n + 1], l = "isolated";
      if ((n === 0 || o === " ") && n < a - 1 && A !== " " && (l = "terminal"), n > 0 && o !== " " && n < a - 1 && A !== " " && (l = "medial"), n > 0 && o !== " " && (n === a - 1 || A === " ") && (l = "initial"), typeof e.glyphs[i] < "u") {
        var u = e.glyphs[i];
        s = u instanceof uy ? u : u[l];
      }
    } else
      s = e.glyphs[i];
    return s || (s = e.missingGlyph), s;
  }
  getText() {
    return "";
  }
  getTextFromNode(e) {
    var t = e || this.node, n = Array.from(t.parentNode.childNodes), i = n.indexOf(t), s = n.length - 1, a = ml(
      // textNode.value
      // || textNode.text
      t.textContent || ""
    );
    return i === 0 && (a = rx(a)), i === s && (a = nx(a)), a;
  }
  renderChildren(e) {
    if (this.type !== "text") {
      this.renderTElementChildren(e);
      return;
    }
    this.initializeCoordinates(), this.adjustChildCoordinatesRecursive(e), this.children.forEach((n, i) => {
      this.renderChild(e, this, this, i);
    });
    var {
      mouse: t
    } = this.document.screen;
    t.isWorking() && t.checkBoundingBox(this, this.getBoundingBox(e));
  }
  renderTElementChildren(e) {
    var {
      document: t,
      parent: n
    } = this, i = this.getText(), s = n.getStyle("font-family").getDefinition();
    if (s) {
      for (var {
        unitsPerEm: a
      } = s.fontFace, o = Ei.parse(t.ctx.font), A = n.getStyle("font-size").getNumber(o.fontSize), l = n.getStyle("font-style").getString(o.fontStyle), u = A / a, c = s.isRTL ? i.split("").reverse().join("") : i, h = Yi(n.getAttribute("dx").getString()), f = c.length, d = 0; d < f; d++) {
        var p = this.getGlyph(s, c, d);
        e.translate(this.x, this.y), e.scale(u, -u);
        var v = e.lineWidth;
        e.lineWidth = e.lineWidth * a / A, l === "italic" && e.transform(1, 0, 0.4, 1, 0, 0), p.render(e), l === "italic" && e.transform(1, 0, -0.4, 1, 0, 0), e.lineWidth = v, e.scale(1 / u, -1 / u), e.translate(-this.x, -this.y), this.x += A * (p.horizAdvX || s.horizAdvX) / a, typeof h[d] < "u" && !isNaN(h[d]) && (this.x += h[d]);
      }
      return;
    }
    var {
      x: m,
      y: b
    } = this;
    e.fillStyle && e.fillText(i, m, b), e.strokeStyle && e.strokeText(i, m, b);
  }
  applyAnchoring() {
    if (!(this.textChunkStart >= this.leafTexts.length)) {
      var e = this.leafTexts[this.textChunkStart], t = e.getStyle("text-anchor").getString("start"), n = !1, i = 0;
      t === "start" && !n || t === "end" && n ? i = e.x - this.minX : t === "end" && !n || t === "start" && n ? i = e.x - this.maxX : i = e.x - (this.minX + this.maxX) / 2;
      for (var s = this.textChunkStart; s < this.leafTexts.length; s++)
        this.leafTexts[s].x += i;
      this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.textChunkStart = this.leafTexts.length;
    }
  }
  adjustChildCoordinatesRecursive(e) {
    this.children.forEach((t, n) => {
      this.adjustChildCoordinatesRecursiveCore(e, this, this, n);
    }), this.applyAnchoring();
  }
  adjustChildCoordinatesRecursiveCore(e, t, n, i) {
    var s = n.children[i];
    s.children.length > 0 ? s.children.forEach((a, o) => {
      t.adjustChildCoordinatesRecursiveCore(e, t, s, o);
    }) : this.adjustChildCoordinates(e, t, n, i);
  }
  adjustChildCoordinates(e, t, n, i) {
    var s = n.children[i];
    if (typeof s.measureText != "function")
      return s;
    e.save(), s.setContext(e, !0);
    var a = s.getAttribute("x"), o = s.getAttribute("y"), A = s.getAttribute("dx"), l = s.getAttribute("dy"), u = s.getStyle("font-family").getDefinition(), c = !!u && u.isRTL;
    i === 0 && (a.hasValue() || a.setValue(s.getInheritedAttribute("x")), o.hasValue() || o.setValue(s.getInheritedAttribute("y")), A.hasValue() || A.setValue(s.getInheritedAttribute("dx")), l.hasValue() || l.setValue(s.getInheritedAttribute("dy")));
    var h = s.measureText(e);
    return c && (t.x -= h), a.hasValue() ? (t.applyAnchoring(), s.x = a.getPixels("x"), A.hasValue() && (s.x += A.getPixels("x"))) : (A.hasValue() && (t.x += A.getPixels("x")), s.x = t.x), t.x = s.x, c || (t.x += h), o.hasValue() ? (s.y = o.getPixels("y"), l.hasValue() && (s.y += l.getPixels("y"))) : (l.hasValue() && (t.y += l.getPixels("y")), s.y = t.y), t.y = s.y, t.leafTexts.push(s), t.minX = Math.min(t.minX, s.x, s.x + h), t.maxX = Math.max(t.maxX, s.x, s.x + h), s.clearContext(e), e.restore(), s;
  }
  getChildBoundingBox(e, t, n, i) {
    var s = n.children[i];
    if (typeof s.getBoundingBox != "function")
      return null;
    var a = s.getBoundingBox(e);
    return a ? (s.children.forEach((o, A) => {
      var l = t.getChildBoundingBox(e, t, s, A);
      a.addBoundingBox(l);
    }), a) : null;
  }
  renderChild(e, t, n, i) {
    var s = n.children[i];
    s.render(e), s.children.forEach((a, o) => {
      t.renderChild(e, t, s, o);
    });
  }
  measureText(e) {
    var {
      measureCache: t
    } = this;
    if (~t)
      return t;
    var n = this.getText(), i = this.measureTargetText(e, n);
    return this.measureCache = i, i;
  }
  measureTargetText(e, t) {
    if (!t.length)
      return 0;
    var {
      parent: n
    } = this, i = n.getStyle("font-family").getDefinition();
    if (i) {
      for (var s = this.getFontSize(), a = i.isRTL ? t.split("").reverse().join("") : t, o = Yi(n.getAttribute("dx").getString()), A = a.length, l = 0, u = 0; u < A; u++) {
        var c = this.getGlyph(i, a, u);
        l += (c.horizAdvX || i.horizAdvX) * s / i.fontFace.unitsPerEm, typeof o[u] < "u" && !isNaN(o[u]) && (l += o[u]);
      }
      return l;
    }
    if (!e.measureText)
      return t.length * 10;
    e.save(), this.setContext(e, !0);
    var {
      width: h
    } = e.measureText(t);
    return this.clearContext(e), e.restore(), h;
  }
  /**
   * Inherits positional attributes from {@link TextElement} parent(s). Attributes
   * are only inherited from a parent to its first child.
   * @param name - The attribute name.
   * @returns The attribute value or null.
   */
  getInheritedAttribute(e) {
    for (var t = this; t instanceof co && t.isFirstChild(); ) {
      var n = t.parent.getAttribute(e);
      if (n.hasValue(!0))
        return n.getValue("0");
      t = t.parent;
    }
    return null;
  }
}
class Jf extends co {
  constructor(e, t, n) {
    super(e, t, new.target === Jf ? !0 : n), this.type = "tspan", this.text = this.children.length > 0 ? "" : this.getTextFromNode();
  }
  getText() {
    return this.text;
  }
}
class mae extends Jf {
  constructor() {
    super(...arguments), this.type = "textNode";
  }
}
class $u extends hA {
  constructor() {
    super(...arguments), this.type = "svg", this.root = !1;
  }
  setContext(e) {
    var t, {
      document: n
    } = this, {
      screen: i,
      window: s
    } = n, a = e.canvas;
    if (i.setDefaults(e), a.style && typeof e.font < "u" && s && typeof s.getComputedStyle < "u") {
      e.font = s.getComputedStyle(a).getPropertyValue("font");
      var o = new wt(n, "fontSize", Ei.parse(e.font).fontSize);
      o.hasValue() && (n.rootEmSize = o.getPixels("y"), n.emSize = n.rootEmSize);
    }
    this.getAttribute("x").hasValue() || this.getAttribute("x", !0).setValue(0), this.getAttribute("y").hasValue() || this.getAttribute("y", !0).setValue(0);
    var {
      width: A,
      height: l
    } = i.viewPort;
    this.getStyle("width").hasValue() || this.getStyle("width", !0).setValue("100%"), this.getStyle("height").hasValue() || this.getStyle("height", !0).setValue("100%"), this.getStyle("color").hasValue() || this.getStyle("color", !0).setValue("black");
    var u = this.getAttribute("refX"), c = this.getAttribute("refY"), h = this.getAttribute("viewBox"), f = h.hasValue() ? Yi(h.getString()) : null, d = !this.root && this.getStyle("overflow").getValue("hidden") !== "visible", p = 0, v = 0, m = 0, b = 0;
    f && (p = f[0], v = f[1]), this.root || (A = this.getStyle("width").getPixels("x"), l = this.getStyle("height").getPixels("y"), this.type === "marker" && (m = p, b = v, p = 0, v = 0)), i.viewPort.setCurrent(A, l), this.node && (!this.parent || ((t = this.node.parentNode) === null || t === void 0 ? void 0 : t.nodeName) === "foreignObject") && this.getStyle("transform", !1, !0).hasValue() && !this.getStyle("transform-origin", !1, !0).hasValue() && this.getStyle("transform-origin", !0, !0).setValue("50% 50%"), super.setContext(e), e.translate(this.getAttribute("x").getPixels("x"), this.getAttribute("y").getPixels("y")), f && (A = f[2], l = f[3]), n.setViewBox({
      ctx: e,
      aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
      width: i.viewPort.width,
      desiredWidth: A,
      height: i.viewPort.height,
      desiredHeight: l,
      minX: p,
      minY: v,
      refX: u.getValue(),
      refY: c.getValue(),
      clip: d,
      clipX: m,
      clipY: b
    }), f && (i.viewPort.removeCurrent(), i.viewPort.setCurrent(A, l));
  }
  clearContext(e) {
    super.clearContext(e), this.document.screen.viewPort.removeCurrent();
  }
  /**
   * Resize SVG to fit in given size.
   * @param width
   * @param height
   * @param preserveAspectRatio
   */
  resize(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, i = this.getAttribute("width", !0), s = this.getAttribute("height", !0), a = this.getAttribute("viewBox"), o = this.getAttribute("style"), A = i.getNumber(0), l = s.getNumber(0);
    if (n)
      if (typeof n == "string")
        this.getAttribute("preserveAspectRatio", !0).setValue(n);
      else {
        var u = this.getAttribute("preserveAspectRatio");
        u.hasValue() && u.setValue(u.getString().replace(/^\s*(\S.*\S)\s*$/, "$1"));
      }
    if (i.setValue(e), s.setValue(t), a.hasValue() || a.setValue("0 0 ".concat(A || e, " ").concat(l || t)), o.hasValue()) {
      var c = this.getStyle("width"), h = this.getStyle("height");
      c.hasValue() && c.setValue("".concat(e, "px")), h.hasValue() && h.setValue("".concat(t, "px"));
    }
  }
}
class cy extends _r {
  constructor() {
    super(...arguments), this.type = "rect";
  }
  path(e) {
    var t = this.getAttribute("x").getPixels("x"), n = this.getAttribute("y").getPixels("y"), i = this.getStyle("width", !1, !0).getPixels("x"), s = this.getStyle("height", !1, !0).getPixels("y"), a = this.getAttribute("rx"), o = this.getAttribute("ry"), A = a.getPixels("x"), l = o.getPixels("y");
    if (a.hasValue() && !o.hasValue() && (l = A), o.hasValue() && !a.hasValue() && (A = l), A = Math.min(A, i / 2), l = Math.min(l, s / 2), e) {
      var u = 4 * ((Math.sqrt(2) - 1) / 3);
      e.beginPath(), s > 0 && i > 0 && (e.moveTo(t + A, n), e.lineTo(t + i - A, n), e.bezierCurveTo(t + i - A + u * A, n, t + i, n + l - u * l, t + i, n + l), e.lineTo(t + i, n + s - l), e.bezierCurveTo(t + i, n + s - l + u * l, t + i - A + u * A, n + s, t + i - A, n + s), e.lineTo(t + A, n + s), e.bezierCurveTo(t + A - u * A, n + s, t, n + s - l + u * l, t, n + s - l), e.lineTo(t, n + l), e.bezierCurveTo(t, n + l - u * l, t + A - u * A, n, t + A, n), e.closePath());
    }
    return new Ms(t, n, t + i, n + s);
  }
  getMarkers() {
    return null;
  }
}
class mx extends _r {
  constructor() {
    super(...arguments), this.type = "circle";
  }
  path(e) {
    var t = this.getAttribute("cx").getPixels("x"), n = this.getAttribute("cy").getPixels("y"), i = this.getAttribute("r").getPixels();
    return e && i > 0 && (e.beginPath(), e.arc(t, n, i, 0, Math.PI * 2, !1), e.closePath()), new Ms(t - i, n - i, t + i, n + i);
  }
  getMarkers() {
    return null;
  }
}
class vx extends _r {
  constructor() {
    super(...arguments), this.type = "ellipse";
  }
  path(e) {
    var t = 4 * ((Math.sqrt(2) - 1) / 3), n = this.getAttribute("rx").getPixels("x"), i = this.getAttribute("ry").getPixels("y"), s = this.getAttribute("cx").getPixels("x"), a = this.getAttribute("cy").getPixels("y");
    return e && n > 0 && i > 0 && (e.beginPath(), e.moveTo(s + n, a), e.bezierCurveTo(s + n, a + t * i, s + t * n, a + i, s, a + i), e.bezierCurveTo(s - t * n, a + i, s - n, a + t * i, s - n, a), e.bezierCurveTo(s - n, a - t * i, s - t * n, a - i, s, a - i), e.bezierCurveTo(s + t * n, a - i, s + n, a - t * i, s + n, a), e.closePath()), new Ms(s - n, a - i, s + n, a + i);
  }
  getMarkers() {
    return null;
  }
}
class bx extends _r {
  constructor() {
    super(...arguments), this.type = "line";
  }
  getPoints() {
    return [new sn(this.getAttribute("x1").getPixels("x"), this.getAttribute("y1").getPixels("y")), new sn(this.getAttribute("x2").getPixels("x"), this.getAttribute("y2").getPixels("y"))];
  }
  path(e) {
    var [{
      x: t,
      y: n
    }, {
      x: i,
      y: s
    }] = this.getPoints();
    return e && (e.beginPath(), e.moveTo(t, n), e.lineTo(i, s)), new Ms(t, n, i, s);
  }
  getMarkers() {
    var [e, t] = this.getPoints(), n = e.angleTo(t);
    return [[e, n], [t, n]];
  }
}
class fy extends _r {
  constructor(e, t, n) {
    super(e, t, n), this.type = "polyline", this.points = [], this.points = sn.parsePath(this.getAttribute("points").getString());
  }
  path(e) {
    var {
      points: t
    } = this, [{
      x: n,
      y: i
    }] = t, s = new Ms(n, i);
    return e && (e.beginPath(), e.moveTo(n, i)), t.forEach((a) => {
      var {
        x: o,
        y: A
      } = a;
      s.addPoint(o, A), e && e.lineTo(o, A);
    }), s;
  }
  getMarkers() {
    var {
      points: e
    } = this, t = e.length - 1, n = [];
    return e.forEach((i, s) => {
      s !== t && n.push([i, i.angleTo(e[s + 1])]);
    }), n.length > 0 && n.push([e[e.length - 1], n[n.length - 1][1]]), n;
  }
}
class yx extends fy {
  constructor() {
    super(...arguments), this.type = "polygon";
  }
  path(e) {
    var t = super.path(e), [{
      x: n,
      y: i
    }] = this.points;
    return e && (e.lineTo(n, i), e.closePath()), t;
  }
}
class wx extends jr {
  constructor() {
    super(...arguments), this.type = "pattern";
  }
  createPattern(e, t, n) {
    var i = this.getStyle("width").getPixels("x", !0), s = this.getStyle("height").getPixels("y", !0), a = new $u(this.document, null);
    a.attributes.viewBox = new wt(this.document, "viewBox", this.getAttribute("viewBox").getValue()), a.attributes.width = new wt(this.document, "width", "".concat(i, "px")), a.attributes.height = new wt(this.document, "height", "".concat(s, "px")), a.attributes.transform = new wt(this.document, "transform", this.getAttribute("patternTransform").getValue()), a.children = this.children;
    var o = this.document.createCanvas(i, s), A = o.getContext("2d"), l = this.getAttribute("x"), u = this.getAttribute("y");
    l.hasValue() && u.hasValue() && A.translate(l.getPixels("x", !0), u.getPixels("y", !0)), n.hasValue() ? this.styles["fill-opacity"] = n : Reflect.deleteProperty(this.styles, "fill-opacity");
    for (var c = -1; c <= 1; c++)
      for (var h = -1; h <= 1; h++)
        A.save(), a.attributes.x = new wt(this.document, "x", c * o.width), a.attributes.y = new wt(this.document, "y", h * o.height), a.render(A), A.restore();
    var f = e.createPattern(o, "repeat");
    return f;
  }
}
class Bx extends jr {
  constructor() {
    super(...arguments), this.type = "marker";
  }
  render(e, t, n) {
    if (t) {
      var {
        x: i,
        y: s
      } = t, a = this.getAttribute("orient").getString("auto"), o = this.getAttribute("markerUnits").getString("strokeWidth");
      e.translate(i, s), a === "auto" && e.rotate(n), o === "strokeWidth" && e.scale(e.lineWidth, e.lineWidth), e.save();
      var A = new $u(this.document, null);
      A.type = this.type, A.attributes.viewBox = new wt(this.document, "viewBox", this.getAttribute("viewBox").getValue()), A.attributes.refX = new wt(this.document, "refX", this.getAttribute("refX").getValue()), A.attributes.refY = new wt(this.document, "refY", this.getAttribute("refY").getValue()), A.attributes.width = new wt(this.document, "width", this.getAttribute("markerWidth").getValue()), A.attributes.height = new wt(this.document, "height", this.getAttribute("markerHeight").getValue()), A.attributes.overflow = new wt(this.document, "overflow", this.getAttribute("overflow").getValue()), A.attributes.fill = new wt(this.document, "fill", this.getAttribute("fill").getColor("black")), A.attributes.stroke = new wt(this.document, "stroke", this.getAttribute("stroke").getValue("none")), A.children = this.children, A.render(e), e.restore(), o === "strokeWidth" && e.scale(1 / e.lineWidth, 1 / e.lineWidth), a === "auto" && e.rotate(-n), e.translate(-i, -s);
    }
  }
}
class Cx extends jr {
  constructor() {
    super(...arguments), this.type = "defs";
  }
  render() {
  }
}
class Wg extends hA {
  constructor() {
    super(...arguments), this.type = "g";
  }
  getBoundingBox(e) {
    var t = new Ms();
    return this.children.forEach((n) => {
      t.addBoundingBox(n.getBoundingBox(e));
    }), t;
  }
}
class hy extends jr {
  constructor(e, t, n) {
    super(e, t, n), this.attributesToInherit = ["gradientUnits"], this.stops = [];
    var {
      stops: i,
      children: s
    } = this;
    s.forEach((a) => {
      a.type === "stop" && i.push(a);
    });
  }
  getGradientUnits() {
    return this.getAttribute("gradientUnits").getString("objectBoundingBox");
  }
  createGradient(e, t, n) {
    var i = this;
    this.getHrefAttribute().hasValue() && (i = this.getHrefAttribute().getDefinition(), this.inheritStopContainer(i));
    var {
      stops: s
    } = i, a = this.getGradient(e, t);
    if (!a)
      return this.addParentOpacity(n, s[s.length - 1].color);
    if (s.forEach((v) => {
      a.addColorStop(v.offset, this.addParentOpacity(n, v.color));
    }), this.getAttribute("gradientTransform").hasValue()) {
      var {
        document: o
      } = this, {
        MAX_VIRTUAL_PIXELS: A,
        viewPort: l
      } = o.screen, [u] = l.viewPorts, c = new cy(o, null);
      c.attributes.x = new wt(o, "x", -A / 3), c.attributes.y = new wt(o, "y", -A / 3), c.attributes.width = new wt(o, "width", A), c.attributes.height = new wt(o, "height", A);
      var h = new Wg(o, null);
      h.attributes.transform = new wt(o, "transform", this.getAttribute("gradientTransform").getValue()), h.children = [c];
      var f = new $u(o, null);
      f.attributes.x = new wt(o, "x", 0), f.attributes.y = new wt(o, "y", 0), f.attributes.width = new wt(o, "width", u.width), f.attributes.height = new wt(o, "height", u.height), f.children = [h];
      var d = o.createCanvas(u.width, u.height), p = d.getContext("2d");
      return p.fillStyle = a, f.render(p), p.createPattern(d, "no-repeat");
    }
    return a;
  }
  inheritStopContainer(e) {
    this.attributesToInherit.forEach((t) => {
      !this.getAttribute(t).hasValue() && e.getAttribute(t).hasValue() && this.getAttribute(t, !0).setValue(e.getAttribute(t).getValue());
    });
  }
  addParentOpacity(e, t) {
    if (e.hasValue()) {
      var n = new wt(this.document, "color", t);
      return n.addOpacity(e).getColor();
    }
    return t;
  }
}
class _x extends hy {
  constructor(e, t, n) {
    super(e, t, n), this.type = "linearGradient", this.attributesToInherit.push("x1", "y1", "x2", "y2");
  }
  getGradient(e, t) {
    var n = this.getGradientUnits() === "objectBoundingBox", i = n ? t.getBoundingBox(e) : null;
    if (n && !i)
      return null;
    !this.getAttribute("x1").hasValue() && !this.getAttribute("y1").hasValue() && !this.getAttribute("x2").hasValue() && !this.getAttribute("y2").hasValue() && (this.getAttribute("x1", !0).setValue(0), this.getAttribute("y1", !0).setValue(0), this.getAttribute("x2", !0).setValue(1), this.getAttribute("y2", !0).setValue(0));
    var s = n ? i.x + i.width * this.getAttribute("x1").getNumber() : this.getAttribute("x1").getPixels("x"), a = n ? i.y + i.height * this.getAttribute("y1").getNumber() : this.getAttribute("y1").getPixels("y"), o = n ? i.x + i.width * this.getAttribute("x2").getNumber() : this.getAttribute("x2").getPixels("x"), A = n ? i.y + i.height * this.getAttribute("y2").getNumber() : this.getAttribute("y2").getPixels("y");
    return s === o && a === A ? null : e.createLinearGradient(s, a, o, A);
  }
}
class Ex extends hy {
  constructor(e, t, n) {
    super(e, t, n), this.type = "radialGradient", this.attributesToInherit.push("cx", "cy", "r", "fx", "fy", "fr");
  }
  getGradient(e, t) {
    var n = this.getGradientUnits() === "objectBoundingBox", i = t.getBoundingBox(e);
    if (n && !i)
      return null;
    this.getAttribute("cx").hasValue() || this.getAttribute("cx", !0).setValue("50%"), this.getAttribute("cy").hasValue() || this.getAttribute("cy", !0).setValue("50%"), this.getAttribute("r").hasValue() || this.getAttribute("r", !0).setValue("50%");
    var s = n ? i.x + i.width * this.getAttribute("cx").getNumber() : this.getAttribute("cx").getPixels("x"), a = n ? i.y + i.height * this.getAttribute("cy").getNumber() : this.getAttribute("cy").getPixels("y"), o = s, A = a;
    this.getAttribute("fx").hasValue() && (o = n ? i.x + i.width * this.getAttribute("fx").getNumber() : this.getAttribute("fx").getPixels("x")), this.getAttribute("fy").hasValue() && (A = n ? i.y + i.height * this.getAttribute("fy").getNumber() : this.getAttribute("fy").getPixels("y"));
    var l = n ? (i.width + i.height) / 2 * this.getAttribute("r").getNumber() : this.getAttribute("r").getPixels(), u = this.getAttribute("fr").getPixels();
    return e.createRadialGradient(o, A, u, s, a, l);
  }
}
class Sx extends jr {
  constructor(e, t, n) {
    super(e, t, n), this.type = "stop";
    var i = Math.max(0, Math.min(1, this.getAttribute("offset").getNumber())), s = this.getStyle("stop-opacity"), a = this.getStyle("stop-color", !0);
    a.getString() === "" && a.setValue("#000"), s.hasValue() && (a = a.addOpacity(s)), this.offset = i, this.color = a.getColor();
  }
}
class Xg extends jr {
  constructor(e, t, n) {
    super(e, t, n), this.type = "animate", this.duration = 0, this.initialValue = null, this.initialUnits = "", this.removed = !1, this.frozen = !1, e.screen.animations.push(this), this.begin = this.getAttribute("begin").getMilliseconds(), this.maxDuration = this.begin + this.getAttribute("dur").getMilliseconds(), this.from = this.getAttribute("from"), this.to = this.getAttribute("to"), this.values = new wt(e, "values", null);
    var i = this.getAttribute("values");
    i.hasValue() && this.values.setValue(i.getString().split(";"));
  }
  getProperty() {
    var e = this.getAttribute("attributeType").getString(), t = this.getAttribute("attributeName").getString();
    return e === "CSS" ? this.parent.getStyle(t, !0) : this.parent.getAttribute(t, !0);
  }
  calcValue() {
    var {
      initialUnits: e
    } = this, {
      progress: t,
      from: n,
      to: i
    } = this.getProgress(), s = n.getNumber() + (i.getNumber() - n.getNumber()) * t;
    return e === "%" && (s *= 100), "".concat(s).concat(e);
  }
  update(e) {
    var {
      parent: t
    } = this, n = this.getProperty();
    if (this.initialValue || (this.initialValue = n.getString(), this.initialUnits = n.getUnits()), this.duration > this.maxDuration) {
      var i = this.getAttribute("fill").getString("remove");
      if (this.getAttribute("repeatCount").getString() === "indefinite" || this.getAttribute("repeatDur").getString() === "indefinite")
        this.duration = 0;
      else if (i === "freeze" && !this.frozen)
        this.frozen = !0, t.animationFrozen = !0, t.animationFrozenValue = n.getString();
      else if (i === "remove" && !this.removed)
        return this.removed = !0, n.setValue(t.animationFrozen ? t.animationFrozenValue : this.initialValue), !0;
      return !1;
    }
    this.duration += e;
    var s = !1;
    if (this.begin < this.duration) {
      var a = this.calcValue(), o = this.getAttribute("type");
      if (o.hasValue()) {
        var A = o.getString();
        a = "".concat(A, "(").concat(a, ")");
      }
      n.setValue(a), s = !0;
    }
    return s;
  }
  getProgress() {
    var {
      document: e,
      values: t
    } = this, n = {
      progress: (this.duration - this.begin) / (this.maxDuration - this.begin)
    };
    if (t.hasValue()) {
      var i = n.progress * (t.getValue().length - 1), s = Math.floor(i), a = Math.ceil(i);
      n.from = new wt(e, "from", parseFloat(t.getValue()[s])), n.to = new wt(e, "to", parseFloat(t.getValue()[a])), n.progress = (i - s) / (a - s);
    } else
      n.from = this.from, n.to = this.to;
    return n;
  }
}
class Ix extends Xg {
  constructor() {
    super(...arguments), this.type = "animateColor";
  }
  calcValue() {
    var {
      progress: e,
      from: t,
      to: n
    } = this.getProgress(), i = new _2(t.getColor()), s = new _2(n.getColor());
    if (i.ok && s.ok) {
      var a = i.r + (s.r - i.r) * e, o = i.g + (s.g - i.g) * e, A = i.b + (s.b - i.b) * e;
      return "rgb(".concat(Math.floor(a), ", ").concat(Math.floor(o), ", ").concat(Math.floor(A), ")");
    }
    return this.getAttribute("from").getColor();
  }
}
class Fx extends Xg {
  constructor() {
    super(...arguments), this.type = "animateTransform";
  }
  calcValue() {
    var {
      progress: e,
      from: t,
      to: n
    } = this.getProgress(), i = Yi(t.getString()), s = Yi(n.getString()), a = i.map((o, A) => {
      var l = s[A];
      return o + (l - o) * e;
    }).join(" ");
    return a;
  }
}
class Tx extends jr {
  constructor(e, t, n) {
    super(e, t, n), this.type = "font", this.glyphs = {}, this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
    var {
      definitions: i
    } = e, {
      children: s
    } = this;
    for (var a of s)
      switch (a.type) {
        case "font-face": {
          this.fontFace = a;
          var o = a.getStyle("font-family");
          o.hasValue() && (i[o.getString()] = this);
          break;
        }
        case "missing-glyph":
          this.missingGlyph = a;
          break;
        case "glyph": {
          var A = a;
          A.arabicForm ? (this.isRTL = !0, this.isArabic = !0, typeof this.glyphs[A.unicode] > "u" && (this.glyphs[A.unicode] = {}), this.glyphs[A.unicode][A.arabicForm] = A) : this.glyphs[A.unicode] = A;
          break;
        }
      }
  }
  render() {
  }
}
class xx extends jr {
  constructor(e, t, n) {
    super(e, t, n), this.type = "font-face", this.ascent = this.getAttribute("ascent").getNumber(), this.descent = this.getAttribute("descent").getNumber(), this.unitsPerEm = this.getAttribute("units-per-em").getNumber();
  }
}
class kx extends _r {
  constructor() {
    super(...arguments), this.type = "missing-glyph", this.horizAdvX = 0;
  }
}
class Lx extends co {
  constructor() {
    super(...arguments), this.type = "tref";
  }
  getText() {
    var e = this.getHrefAttribute().getDefinition();
    if (e) {
      var t = e.children[0];
      if (t)
        return t.getText();
    }
    return "";
  }
}
class Ux extends co {
  constructor(e, t, n) {
    super(e, t, n), this.type = "a";
    var {
      childNodes: i
    } = t, s = i[0], a = i.length > 0 && Array.from(i).every((o) => o.nodeType === 3);
    this.hasText = a, this.text = a ? this.getTextFromNode(s) : "";
  }
  getText() {
    return this.text;
  }
  renderChildren(e) {
    if (this.hasText) {
      super.renderChildren(e);
      var {
        document: t,
        x: n,
        y: i
      } = this, {
        mouse: s
      } = t.screen, a = new wt(t, "fontSize", Ei.parse(t.ctx.font).fontSize);
      s.isWorking() && s.checkBoundingBox(this, new Ms(n, i - a.getPixels("y"), n + this.measureText(e), i));
    } else if (this.children.length > 0) {
      var o = new Wg(this.document, null);
      o.children = this.children, o.parent = this, o.render(e);
    }
  }
  onClick() {
    var {
      window: e
    } = this.document;
    e && e.open(this.getHrefAttribute().getString());
  }
  onMouseMove() {
    var e = this.document.ctx;
    e.canvas.style.cursor = "pointer";
  }
}
function cE(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Wd(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? cE(Object(t), !0).forEach(function(n) {
      sy(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : cE(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
class Nx extends co {
  constructor(e, t, n) {
    super(e, t, n), this.type = "textPath", this.textWidth = 0, this.textHeight = 0, this.pathLength = -1, this.glyphInfo = null, this.letterSpacingCache = [], this.measuresCache = /* @__PURE__ */ new Map([["", 0]]);
    var i = this.getHrefAttribute().getDefinition();
    this.text = this.getTextFromNode(), this.dataArray = this.parsePathData(i);
  }
  getText() {
    return this.text;
  }
  path(e) {
    var {
      dataArray: t
    } = this;
    e && e.beginPath(), t.forEach((n) => {
      var {
        type: i,
        points: s
      } = n;
      switch (i) {
        case qt.LINE_TO:
          e && e.lineTo(s[0], s[1]);
          break;
        case qt.MOVE_TO:
          e && e.moveTo(s[0], s[1]);
          break;
        case qt.CURVE_TO:
          e && e.bezierCurveTo(s[0], s[1], s[2], s[3], s[4], s[5]);
          break;
        case qt.QUAD_TO:
          e && e.quadraticCurveTo(s[0], s[1], s[2], s[3]);
          break;
        case qt.ARC: {
          var [a, o, A, l, u, c, h, f] = s, d = A > l ? A : l, p = A > l ? 1 : A / l, v = A > l ? l / A : 1;
          e && (e.translate(a, o), e.rotate(h), e.scale(p, v), e.arc(0, 0, d, u, u + c, !!(1 - f)), e.scale(1 / p, 1 / v), e.rotate(-h), e.translate(-a, -o));
          break;
        }
        case qt.CLOSE_PATH:
          e && e.closePath();
          break;
      }
    });
  }
  renderChildren(e) {
    this.setTextData(e), e.save();
    var t = this.parent.getStyle("text-decoration").getString(), n = this.getFontSize(), {
      glyphInfo: i
    } = this, s = e.fillStyle;
    t === "underline" && e.beginPath(), i.forEach((a, o) => {
      var {
        p0: A,
        p1: l,
        rotation: u,
        text: c
      } = a;
      e.save(), e.translate(A.x, A.y), e.rotate(u), e.fillStyle && e.fillText(c, 0, 0), e.strokeStyle && e.strokeText(c, 0, 0), e.restore(), t === "underline" && (o === 0 && e.moveTo(A.x, A.y + n / 8), e.lineTo(l.x, l.y + n / 5));
    }), t === "underline" && (e.lineWidth = n / 20, e.strokeStyle = s, e.stroke(), e.closePath()), e.restore();
  }
  getLetterSpacingAt() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return this.letterSpacingCache[e] || 0;
  }
  findSegmentToFitChar(e, t, n, i, s, a, o, A, l) {
    var u = a, c = this.measureText(e, A);
    A === " " && t === "justify" && n < i && (c += (i - n) / s), l > -1 && (u += this.getLetterSpacingAt(l));
    var h = this.textHeight / 20, f = this.getEquidistantPointOnPath(u, h, 0), d = this.getEquidistantPointOnPath(u + c, h, 0), p = {
      p0: f,
      p1: d
    }, v = f && d ? Math.atan2(d.y - f.y, d.x - f.x) : 0;
    if (o) {
      var m = Math.cos(Math.PI / 2 + v) * o, b = Math.cos(-v) * o;
      p.p0 = Wd(Wd({}, f), {}, {
        x: f.x + m,
        y: f.y + b
      }), p.p1 = Wd(Wd({}, d), {}, {
        x: d.x + m,
        y: d.y + b
      });
    }
    return u += c, {
      offset: u,
      segment: p,
      rotation: v
    };
  }
  measureText(e, t) {
    var {
      measuresCache: n
    } = this, i = t || this.getText();
    if (n.has(i))
      return n.get(i);
    var s = this.measureTargetText(e, i);
    return n.set(i, s), s;
  }
  // This method supposes what all custom fonts already loaded.
  // If some font will be loaded after this method call, <textPath> will not be rendered correctly.
  // You need to call this method manually to update glyphs cache.
  setTextData(e) {
    if (!this.glyphInfo) {
      var t = this.getText(), n = t.split(""), i = t.split(" ").length - 1, s = this.parent.getAttribute("dx").split().map((B) => B.getPixels("x")), a = this.parent.getAttribute("dy").getPixels("y"), o = this.parent.getStyle("text-anchor").getString("start"), A = this.getStyle("letter-spacing"), l = this.parent.getStyle("letter-spacing"), u = 0;
      !A.hasValue() || A.getValue() === "inherit" ? u = l.getPixels() : A.hasValue() && A.getValue() !== "initial" && A.getValue() !== "unset" && (u = A.getPixels());
      var c = [], h = t.length;
      this.letterSpacingCache = c;
      for (var f = 0; f < h; f++)
        c.push(typeof s[f] < "u" ? s[f] : u);
      var d = c.reduce((B, _, x) => x === 0 ? 0 : B + _ || 0, 0), p = this.measureText(e), v = Math.max(p + d, 0);
      this.textWidth = p, this.textHeight = this.getFontSize(), this.glyphInfo = [];
      var m = this.getPathLength(), b = this.getStyle("startOffset").getNumber(0) * m, w = 0;
      (o === "middle" || o === "center") && (w = -v / 2), (o === "end" || o === "right") && (w = -v), w += b, n.forEach((B, _) => {
        var {
          offset: x,
          segment: C,
          rotation: F
        } = this.findSegmentToFitChar(e, o, v, m, i, w, a, B, _);
        w = x, !(!C.p0 || !C.p1) && this.glyphInfo.push({
          // transposeX: midpoint.x,
          // transposeY: midpoint.y,
          text: n[_],
          p0: C.p0,
          p1: C.p1,
          rotation: F
        });
      });
    }
  }
  parsePathData(e) {
    if (this.pathLength = -1, !e)
      return [];
    var t = [], {
      pathParser: n
    } = e;
    for (n.reset(); !n.isEnd(); ) {
      var {
        current: i
      } = n, s = i ? i.x : 0, a = i ? i.y : 0, o = n.next(), A = o.type, l = [];
      switch (o.type) {
        case qt.MOVE_TO:
          this.pathM(n, l);
          break;
        case qt.LINE_TO:
          A = this.pathL(n, l);
          break;
        case qt.HORIZ_LINE_TO:
          A = this.pathH(n, l);
          break;
        case qt.VERT_LINE_TO:
          A = this.pathV(n, l);
          break;
        case qt.CURVE_TO:
          this.pathC(n, l);
          break;
        case qt.SMOOTH_CURVE_TO:
          A = this.pathS(n, l);
          break;
        case qt.QUAD_TO:
          this.pathQ(n, l);
          break;
        case qt.SMOOTH_QUAD_TO:
          A = this.pathT(n, l);
          break;
        case qt.ARC:
          l = this.pathA(n);
          break;
        case qt.CLOSE_PATH:
          _r.pathZ(n);
          break;
      }
      o.type !== qt.CLOSE_PATH ? t.push({
        type: A,
        points: l,
        start: {
          x: s,
          y: a
        },
        pathLength: this.calcLength(s, a, A, l)
      }) : t.push({
        type: qt.CLOSE_PATH,
        points: [],
        pathLength: 0
      });
    }
    return t;
  }
  pathM(e, t) {
    var {
      x: n,
      y: i
    } = _r.pathM(e).point;
    t.push(n, i);
  }
  pathL(e, t) {
    var {
      x: n,
      y: i
    } = _r.pathL(e).point;
    return t.push(n, i), qt.LINE_TO;
  }
  pathH(e, t) {
    var {
      x: n,
      y: i
    } = _r.pathH(e).point;
    return t.push(n, i), qt.LINE_TO;
  }
  pathV(e, t) {
    var {
      x: n,
      y: i
    } = _r.pathV(e).point;
    return t.push(n, i), qt.LINE_TO;
  }
  pathC(e, t) {
    var {
      point: n,
      controlPoint: i,
      currentPoint: s
    } = _r.pathC(e);
    t.push(n.x, n.y, i.x, i.y, s.x, s.y);
  }
  pathS(e, t) {
    var {
      point: n,
      controlPoint: i,
      currentPoint: s
    } = _r.pathS(e);
    return t.push(n.x, n.y, i.x, i.y, s.x, s.y), qt.CURVE_TO;
  }
  pathQ(e, t) {
    var {
      controlPoint: n,
      currentPoint: i
    } = _r.pathQ(e);
    t.push(n.x, n.y, i.x, i.y);
  }
  pathT(e, t) {
    var {
      controlPoint: n,
      currentPoint: i
    } = _r.pathT(e);
    return t.push(n.x, n.y, i.x, i.y), qt.QUAD_TO;
  }
  pathA(e) {
    var {
      rX: t,
      rY: n,
      sweepFlag: i,
      xAxisRotation: s,
      centp: a,
      a1: o,
      ad: A
    } = _r.pathA(e);
    return i === 0 && A > 0 && (A -= 2 * Math.PI), i === 1 && A < 0 && (A += 2 * Math.PI), [a.x, a.y, t, n, o, A, s, i];
  }
  calcLength(e, t, n, i) {
    var s = 0, a = null, o = null, A = 0;
    switch (n) {
      case qt.LINE_TO:
        return this.getLineLength(e, t, i[0], i[1]);
      case qt.CURVE_TO:
        for (s = 0, a = this.getPointOnCubicBezier(0, e, t, i[0], i[1], i[2], i[3], i[4], i[5]), A = 0.01; A <= 1; A += 0.01)
          o = this.getPointOnCubicBezier(A, e, t, i[0], i[1], i[2], i[3], i[4], i[5]), s += this.getLineLength(a.x, a.y, o.x, o.y), a = o;
        return s;
      case qt.QUAD_TO:
        for (s = 0, a = this.getPointOnQuadraticBezier(0, e, t, i[0], i[1], i[2], i[3]), A = 0.01; A <= 1; A += 0.01)
          o = this.getPointOnQuadraticBezier(A, e, t, i[0], i[1], i[2], i[3]), s += this.getLineLength(a.x, a.y, o.x, o.y), a = o;
        return s;
      case qt.ARC: {
        s = 0;
        var l = i[4], u = i[5], c = i[4] + u, h = Math.PI / 180;
        if (Math.abs(l - c) < h && (h = Math.abs(l - c)), a = this.getPointOnEllipticalArc(i[0], i[1], i[2], i[3], l, 0), u < 0)
          for (A = l - h; A > c; A -= h)
            o = this.getPointOnEllipticalArc(i[0], i[1], i[2], i[3], A, 0), s += this.getLineLength(a.x, a.y, o.x, o.y), a = o;
        else
          for (A = l + h; A < c; A += h)
            o = this.getPointOnEllipticalArc(i[0], i[1], i[2], i[3], A, 0), s += this.getLineLength(a.x, a.y, o.x, o.y), a = o;
        return o = this.getPointOnEllipticalArc(i[0], i[1], i[2], i[3], c, 0), s += this.getLineLength(a.x, a.y, o.x, o.y), s;
      }
    }
    return 0;
  }
  getPointOnLine(e, t, n, i, s) {
    var a = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : t, o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : n, A = (s - n) / (i - t + sl), l = Math.sqrt(e * e / (1 + A * A));
    i < t && (l *= -1);
    var u = A * l, c = null;
    if (i === t)
      c = {
        x: a,
        y: o + u
      };
    else if ((o - n) / (a - t + sl) === A)
      c = {
        x: a + l,
        y: o + u
      };
    else {
      var h = 0, f = 0, d = this.getLineLength(t, n, i, s);
      if (d < sl)
        return null;
      var p = (a - t) * (i - t) + (o - n) * (s - n);
      p /= d * d, h = t + p * (i - t), f = n + p * (s - n);
      var v = this.getLineLength(a, o, h, f), m = Math.sqrt(e * e - v * v);
      l = Math.sqrt(m * m / (1 + A * A)), i < t && (l *= -1), u = A * l, c = {
        x: h + l,
        y: f + u
      };
    }
    return c;
  }
  getPointOnPath(e) {
    var t = this.getPathLength(), n = 0, i = null;
    if (e < -5e-5 || e - 5e-5 > t)
      return null;
    var {
      dataArray: s
    } = this;
    for (var a of s) {
      if (a && (a.pathLength < 5e-5 || n + a.pathLength + 5e-5 < e)) {
        n += a.pathLength;
        continue;
      }
      var o = e - n, A = 0;
      switch (a.type) {
        case qt.LINE_TO:
          i = this.getPointOnLine(o, a.start.x, a.start.y, a.points[0], a.points[1], a.start.x, a.start.y);
          break;
        case qt.ARC: {
          var l = a.points[4], u = a.points[5], c = a.points[4] + u;
          if (A = l + o / a.pathLength * u, u < 0 && A < c || u >= 0 && A > c)
            break;
          i = this.getPointOnEllipticalArc(a.points[0], a.points[1], a.points[2], a.points[3], A, a.points[6]);
          break;
        }
        case qt.CURVE_TO:
          A = o / a.pathLength, A > 1 && (A = 1), i = this.getPointOnCubicBezier(A, a.start.x, a.start.y, a.points[0], a.points[1], a.points[2], a.points[3], a.points[4], a.points[5]);
          break;
        case qt.QUAD_TO:
          A = o / a.pathLength, A > 1 && (A = 1), i = this.getPointOnQuadraticBezier(A, a.start.x, a.start.y, a.points[0], a.points[1], a.points[2], a.points[3]);
          break;
      }
      if (i)
        return i;
      break;
    }
    return null;
  }
  getLineLength(e, t, n, i) {
    return Math.sqrt((n - e) * (n - e) + (i - t) * (i - t));
  }
  getPathLength() {
    return this.pathLength === -1 && (this.pathLength = this.dataArray.reduce((e, t) => t.pathLength > 0 ? e + t.pathLength : e, 0)), this.pathLength;
  }
  getPointOnCubicBezier(e, t, n, i, s, a, o, A, l) {
    var u = A * T2(e) + a * x2(e) + i * k2(e) + t * L2(e), c = l * T2(e) + o * x2(e) + s * k2(e) + n * L2(e);
    return {
      x: u,
      y: c
    };
  }
  getPointOnQuadraticBezier(e, t, n, i, s, a, o) {
    var A = a * U2(e) + i * N2(e) + t * O2(e), l = o * U2(e) + s * N2(e) + n * O2(e);
    return {
      x: A,
      y: l
    };
  }
  getPointOnEllipticalArc(e, t, n, i, s, a) {
    var o = Math.cos(a), A = Math.sin(a), l = {
      x: n * Math.cos(s),
      y: i * Math.sin(s)
    };
    return {
      x: e + (l.x * o - l.y * A),
      y: t + (l.x * A + l.y * o)
    };
  }
  // TODO need some optimisations. possibly build cache only for curved segments?
  buildEquidistantCache(e, t) {
    var n = this.getPathLength(), i = t || 0.25, s = e || n / 100;
    if (!this.equidistantCache || this.equidistantCache.step !== s || this.equidistantCache.precision !== i) {
      this.equidistantCache = {
        step: s,
        precision: i,
        points: []
      };
      for (var a = 0, o = 0; o <= n; o += i) {
        var A = this.getPointOnPath(o), l = this.getPointOnPath(o + i);
        !A || !l || (a += this.getLineLength(A.x, A.y, l.x, l.y), a >= s && (this.equidistantCache.points.push({
          x: A.x,
          y: A.y,
          distance: o
        }), a -= s));
      }
    }
  }
  getEquidistantPointOnPath(e, t, n) {
    if (this.buildEquidistantCache(t, n), e < 0 || e - this.getPathLength() > 5e-5)
      return null;
    var i = Math.round(e / this.getPathLength() * (this.equidistantCache.points.length - 1));
    return this.equidistantCache.points[i] || null;
  }
}
var vae = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
class Ox extends hA {
  constructor(e, t, n) {
    super(e, t, n), this.type = "image", this.loaded = !1;
    var i = this.getHrefAttribute().getString();
    if (i) {
      var s = i.endsWith(".svg") || /^\s*data:image\/svg\+xml/i.test(i);
      e.images.push(this), s ? this.loadSvg(i) : this.loadImage(i), this.isSvg = s;
    }
  }
  loadImage(e) {
    var t = this;
    return uo(function* () {
      try {
        var n = yield t.document.createImage(e);
        t.image = n;
      } catch (i) {
        console.error('Error while loading image "'.concat(e, '":'), i);
      }
      t.loaded = !0;
    })();
  }
  loadSvg(e) {
    var t = this;
    return uo(function* () {
      var n = vae.exec(e);
      if (n) {
        var i = n[5];
        n[4] === "base64" ? t.image = atob(i) : t.image = decodeURIComponent(i);
      } else
        try {
          var s = yield t.document.fetch(e), a = yield s.text();
          t.image = a;
        } catch (o) {
          console.error('Error while loading image "'.concat(e, '":'), o);
        }
      t.loaded = !0;
    })();
  }
  renderChildren(e) {
    var {
      document: t,
      image: n,
      loaded: i
    } = this, s = this.getAttribute("x").getPixels("x"), a = this.getAttribute("y").getPixels("y"), o = this.getStyle("width").getPixels("x"), A = this.getStyle("height").getPixels("y");
    if (!(!i || !n || !o || !A)) {
      if (e.save(), e.translate(s, a), this.isSvg) {
        var l = t.canvg.forkString(e, this.image, {
          ignoreMouse: !0,
          ignoreAnimation: !0,
          ignoreDimensions: !0,
          ignoreClear: !0,
          offsetX: 0,
          offsetY: 0,
          scaleWidth: o,
          scaleHeight: A
        });
        l.document.documentElement.parent = this, l.render();
      } else {
        var u = this.image;
        t.setViewBox({
          ctx: e,
          aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
          width: o,
          desiredWidth: u.width,
          height: A,
          desiredHeight: u.height
        }), this.loaded && (typeof u.complete > "u" || u.complete) && e.drawImage(u, 0, 0);
      }
      e.restore();
    }
  }
  getBoundingBox() {
    var e = this.getAttribute("x").getPixels("x"), t = this.getAttribute("y").getPixels("y"), n = this.getStyle("width").getPixels("x"), i = this.getStyle("height").getPixels("y");
    return new Ms(e, t, e + n, t + i);
  }
}
class Qx extends hA {
  constructor() {
    super(...arguments), this.type = "symbol";
  }
  render(e) {
  }
}
class Dx {
  constructor(e) {
    this.document = e, this.loaded = !1, e.fonts.push(this);
  }
  load(e, t) {
    var n = this;
    return uo(function* () {
      try {
        var {
          document: i
        } = n, s = yield i.canvg.parser.load(t), a = s.getElementsByTagName("font");
        Array.from(a).forEach((o) => {
          var A = i.createElement(o);
          i.definitions[e] = A;
        });
      } catch (o) {
        console.error('Error while loading font "'.concat(t, '":'), o);
      }
      n.loaded = !0;
    })();
  }
}
class dy extends jr {
  constructor(e, t, n) {
    super(e, t, n), this.type = "style";
    var i = ml(
      Array.from(t.childNodes).map((a) => a.textContent).join("").replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, "").replace(/@import.*;/g, "")
      // remove imports
    ), s = i.split("}");
    s.forEach((a) => {
      var o = a.trim();
      if (o) {
        var A = o.split("{"), l = A[0].split(","), u = A[1].split(";");
        l.forEach((c) => {
          var h = c.trim();
          if (h) {
            var f = e.styles[h] || {};
            if (u.forEach((v) => {
              var m = v.indexOf(":"), b = v.substr(0, m).trim(), w = v.substr(m + 1, v.length - m).trim();
              b && w && (f[b] = new wt(e, b, w));
            }), e.styles[h] = f, e.stylesSpecificity[h] = ax(h), h === "@font-face") {
              var d = f["font-family"].getString().replace(/"|'/g, ""), p = f.src.getString().split(",");
              p.forEach((v) => {
                if (v.indexOf('format("svg")') > 0) {
                  var m = oy(v);
                  m && new Dx(e).load(d, m);
                }
              });
            }
          }
        });
      }
    });
  }
}
dy.parseExternalUrl = oy;
class Mx extends hA {
  constructor() {
    super(...arguments), this.type = "use";
  }
  setContext(e) {
    super.setContext(e);
    var t = this.getAttribute("x"), n = this.getAttribute("y");
    t.hasValue() && e.translate(t.getPixels("x"), 0), n.hasValue() && e.translate(0, n.getPixels("y"));
  }
  path(e) {
    var {
      element: t
    } = this;
    t && t.path(e);
  }
  renderChildren(e) {
    var {
      document: t,
      element: n
    } = this;
    if (n) {
      var i = n;
      if (n.type === "symbol" && (i = new $u(t, null), i.attributes.viewBox = new wt(t, "viewBox", n.getAttribute("viewBox").getString()), i.attributes.preserveAspectRatio = new wt(t, "preserveAspectRatio", n.getAttribute("preserveAspectRatio").getString()), i.attributes.overflow = new wt(t, "overflow", n.getAttribute("overflow").getString()), i.children = n.children, n.styles.opacity = new wt(t, "opacity", this.calculateOpacity())), i.type === "svg") {
        var s = this.getStyle("width", !1, !0), a = this.getStyle("height", !1, !0);
        s.hasValue() && (i.attributes.width = new wt(t, "width", s.getString())), a.hasValue() && (i.attributes.height = new wt(t, "height", a.getString()));
      }
      var o = i.parent;
      i.parent = this, i.render(e), i.parent = o;
    }
  }
  getBoundingBox(e) {
    var {
      element: t
    } = this;
    return t ? t.getBoundingBox(e) : null;
  }
  elementTransform() {
    var {
      document: e,
      element: t
    } = this;
    return lA.fromElement(e, t);
  }
  get element() {
    return this.cachedElement || (this.cachedElement = this.getHrefAttribute().getDefinition()), this.cachedElement;
  }
}
function Xd(r, e, t, n, i, s) {
  return r[t * n * 4 + e * 4 + s];
}
function Jd(r, e, t, n, i, s, a) {
  r[t * n * 4 + e * 4 + s] = a;
}
function Tn(r, e, t) {
  var n = r[e];
  return n * t;
}
function eo(r, e, t, n) {
  return e + Math.cos(r) * t + Math.sin(r) * n;
}
class py extends jr {
  constructor(e, t, n) {
    super(e, t, n), this.type = "feColorMatrix";
    var i = Yi(this.getAttribute("values").getString());
    switch (this.getAttribute("type").getString("matrix")) {
      case "saturate": {
        var s = i[0];
        i = [0.213 + 0.787 * s, 0.715 - 0.715 * s, 0.072 - 0.072 * s, 0, 0, 0.213 - 0.213 * s, 0.715 + 0.285 * s, 0.072 - 0.072 * s, 0, 0, 0.213 - 0.213 * s, 0.715 - 0.715 * s, 0.072 + 0.928 * s, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
        break;
      }
      case "hueRotate": {
        var a = i[0] * Math.PI / 180;
        i = [eo(a, 0.213, 0.787, -0.213), eo(a, 0.715, -0.715, -0.715), eo(a, 0.072, -0.072, 0.928), 0, 0, eo(a, 0.213, -0.213, 0.143), eo(a, 0.715, 0.285, 0.14), eo(a, 0.072, -0.072, -0.283), 0, 0, eo(a, 0.213, -0.213, -0.787), eo(a, 0.715, -0.715, 0.715), eo(a, 0.072, 0.928, 0.072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
        break;
      }
      case "luminanceToAlpha":
        i = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2125, 0.7154, 0.0721, 0, 0, 0, 0, 0, 0, 1];
        break;
    }
    this.matrix = i, this.includeOpacity = this.getAttribute("includeOpacity").hasValue();
  }
  apply(e, t, n, i, s) {
    for (var {
      includeOpacity: a,
      matrix: o
    } = this, A = e.getImageData(0, 0, i, s), l = 0; l < s; l++)
      for (var u = 0; u < i; u++) {
        var c = Xd(A.data, u, l, i, s, 0), h = Xd(A.data, u, l, i, s, 1), f = Xd(A.data, u, l, i, s, 2), d = Xd(A.data, u, l, i, s, 3), p = Tn(o, 0, c) + Tn(o, 1, h) + Tn(o, 2, f) + Tn(o, 3, d) + Tn(o, 4, 1), v = Tn(o, 5, c) + Tn(o, 6, h) + Tn(o, 7, f) + Tn(o, 8, d) + Tn(o, 9, 1), m = Tn(o, 10, c) + Tn(o, 11, h) + Tn(o, 12, f) + Tn(o, 13, d) + Tn(o, 14, 1), b = Tn(o, 15, c) + Tn(o, 16, h) + Tn(o, 17, f) + Tn(o, 18, d) + Tn(o, 19, 1);
        a && (p = 0, v = 0, m = 0, b *= d / 255), Jd(A.data, u, l, i, s, 0, p), Jd(A.data, u, l, i, s, 1, v), Jd(A.data, u, l, i, s, 2, m), Jd(A.data, u, l, i, s, 3, b);
      }
    e.clearRect(0, 0, i, s), e.putImageData(A, 0, 0);
  }
}
class Yf extends jr {
  constructor() {
    super(...arguments), this.type = "mask";
  }
  apply(e, t) {
    var {
      document: n
    } = this, i = this.getAttribute("x").getPixels("x"), s = this.getAttribute("y").getPixels("y"), a = this.getStyle("width").getPixels("x"), o = this.getStyle("height").getPixels("y");
    if (!a && !o) {
      var A = new Ms();
      this.children.forEach((d) => {
        A.addBoundingBox(d.getBoundingBox(e));
      }), i = Math.floor(A.x1), s = Math.floor(A.y1), a = Math.floor(A.width), o = Math.floor(A.height);
    }
    var l = this.removeStyles(t, Yf.ignoreStyles), u = n.createCanvas(i + a, s + o), c = u.getContext("2d");
    n.screen.setDefaults(c), this.renderChildren(c), new py(n, {
      nodeType: 1,
      childNodes: [],
      attributes: [{
        nodeName: "type",
        value: "luminanceToAlpha"
      }, {
        nodeName: "includeOpacity",
        value: "true"
      }]
    }).apply(c, 0, 0, i + a, s + o);
    var h = n.createCanvas(i + a, s + o), f = h.getContext("2d");
    n.screen.setDefaults(f), t.render(f), f.globalCompositeOperation = "destination-in", f.fillStyle = c.createPattern(u, "no-repeat"), f.fillRect(0, 0, i + a, s + o), e.fillStyle = f.createPattern(h, "no-repeat"), e.fillRect(0, 0, i + a, s + o), this.restoreStyles(t, l);
  }
  render(e) {
  }
}
Yf.ignoreStyles = ["mask", "transform", "clip-path"];
var fE = () => {
};
class Rx extends jr {
  constructor() {
    super(...arguments), this.type = "clipPath";
  }
  apply(e) {
    var {
      document: t
    } = this, n = Reflect.getPrototypeOf(e), {
      beginPath: i,
      closePath: s
    } = e;
    n && (n.beginPath = fE, n.closePath = fE), Reflect.apply(i, e, []), this.children.forEach((a) => {
      if (!(typeof a.path > "u")) {
        var o = typeof a.elementTransform < "u" ? a.elementTransform() : null;
        o || (o = lA.fromElement(t, a)), o && o.apply(e), a.path(e), n && (n.closePath = s), o && o.unapply(e);
      }
    }), Reflect.apply(s, e, []), e.clip(), n && (n.beginPath = i, n.closePath = s);
  }
  render(e) {
  }
}
class Zf extends jr {
  constructor() {
    super(...arguments), this.type = "filter";
  }
  apply(e, t) {
    var {
      document: n,
      children: i
    } = this, s = t.getBoundingBox(e);
    if (s) {
      var a = 0, o = 0;
      i.forEach((m) => {
        var b = m.extraFilterDistance || 0;
        a = Math.max(a, b), o = Math.max(o, b);
      });
      var A = Math.floor(s.width), l = Math.floor(s.height), u = A + 2 * a, c = l + 2 * o;
      if (!(u < 1 || c < 1)) {
        var h = Math.floor(s.x), f = Math.floor(s.y), d = this.removeStyles(t, Zf.ignoreStyles), p = n.createCanvas(u, c), v = p.getContext("2d");
        n.screen.setDefaults(v), v.translate(-h + a, -f + o), t.render(v), i.forEach((m) => {
          typeof m.apply == "function" && m.apply(v, 0, 0, u, c);
        }), e.drawImage(p, 0, 0, u, c, h - a, f - o, u, c), this.restoreStyles(t, d);
      }
    }
  }
  render(e) {
  }
}
Zf.ignoreStyles = ["filter", "transform", "clip-path"];
class Px extends jr {
  constructor(e, t, n) {
    super(e, t, n), this.type = "feDropShadow", this.addStylesFromStyleDefinition();
  }
  apply(e, t, n, i, s) {
  }
}
class Hx extends jr {
  constructor() {
    super(...arguments), this.type = "feMorphology";
  }
  apply(e, t, n, i, s) {
  }
}
class jx extends jr {
  constructor() {
    super(...arguments), this.type = "feComposite";
  }
  apply(e, t, n, i, s) {
  }
}
class Kx extends jr {
  constructor(e, t, n) {
    super(e, t, n), this.type = "feGaussianBlur", this.blurRadius = Math.floor(this.getAttribute("stdDeviation").getNumber()), this.extraFilterDistance = this.blurRadius;
  }
  apply(e, t, n, i, s) {
    var {
      document: a,
      blurRadius: o
    } = this, A = a.window ? a.window.document.body : null, l = e.canvas;
    l.id = a.getUniqueId(), A && (l.style.display = "none", A.appendChild(l)), Xse(l, t, n, i, s, o), A && A.removeChild(l);
  }
}
class $x extends jr {
  constructor() {
    super(...arguments), this.type = "title";
  }
}
class Vx extends jr {
  constructor() {
    super(...arguments), this.type = "desc";
  }
}
var bae = {
  svg: $u,
  rect: cy,
  circle: mx,
  ellipse: vx,
  line: bx,
  polyline: fy,
  polygon: yx,
  path: _r,
  pattern: wx,
  marker: Bx,
  defs: Cx,
  linearGradient: _x,
  radialGradient: Ex,
  stop: Sx,
  animate: Xg,
  animateColor: Ix,
  animateTransform: Fx,
  font: Tx,
  "font-face": xx,
  "missing-glyph": kx,
  glyph: uy,
  text: co,
  tspan: Jf,
  tref: Lx,
  a: Ux,
  textPath: Nx,
  image: Ox,
  g: Wg,
  symbol: Qx,
  style: dy,
  use: Mx,
  mask: Yf,
  clipPath: Rx,
  filter: Zf,
  feDropShadow: Px,
  feMorphology: Hx,
  feComposite: jx,
  feColorMatrix: py,
  feGaussianBlur: Kx,
  title: $x,
  desc: Vx
};
function hE(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function yae(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? hE(Object(t), !0).forEach(function(n) {
      sy(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : hE(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function wae(r, e) {
  var t = document.createElement("canvas");
  return t.width = r, t.height = e, t;
}
function Bae(r) {
  return Q2.apply(this, arguments);
}
function Q2() {
  return Q2 = uo(function* (r) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, t = document.createElement("img");
    return e && (t.crossOrigin = "Anonymous"), new Promise((n, i) => {
      t.onload = () => {
        n(t);
      }, t.onerror = (s, a, o, A, l) => {
        i(l);
      }, t.src = r;
    });
  }), Q2.apply(this, arguments);
}
class Ao {
  constructor(e) {
    var {
      rootEmSize: t = 12,
      emSize: n = 12,
      createCanvas: i = Ao.createCanvas,
      createImage: s = Ao.createImage,
      anonymousCrossOrigin: a
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.canvg = e, this.definitions = {}, this.styles = {}, this.stylesSpecificity = {}, this.images = [], this.fonts = [], this.emSizeStack = [], this.uniqueId = 0, this.screen = e.screen, this.rootEmSize = t, this.emSize = n, this.createCanvas = i, this.createImage = this.bindCreateImage(s, a), this.screen.wait(this.isImagesLoaded.bind(this)), this.screen.wait(this.isFontsLoaded.bind(this));
  }
  bindCreateImage(e, t) {
    return typeof t == "boolean" ? (n, i) => e(n, typeof i == "boolean" ? i : t) : e;
  }
  get window() {
    return this.screen.window;
  }
  get fetch() {
    return this.screen.fetch;
  }
  get ctx() {
    return this.screen.ctx;
  }
  get emSize() {
    var {
      emSizeStack: e
    } = this;
    return e[e.length - 1];
  }
  set emSize(e) {
    var {
      emSizeStack: t
    } = this;
    t.push(e);
  }
  popEmSize() {
    var {
      emSizeStack: e
    } = this;
    e.pop();
  }
  getUniqueId() {
    return "canvg".concat(++this.uniqueId);
  }
  isImagesLoaded() {
    return this.images.every((e) => e.loaded);
  }
  isFontsLoaded() {
    return this.fonts.every((e) => e.loaded);
  }
  createDocumentElement(e) {
    var t = this.createElement(e.documentElement);
    return t.root = !0, t.addStylesFromStyleDefinition(), this.documentElement = t, t;
  }
  createElement(e) {
    var t = e.nodeName.replace(/^[^:]+:/, ""), n = Ao.elementTypes[t];
    return typeof n < "u" ? new n(this, e) : new gx(this, e);
  }
  createTextNode(e) {
    return new mae(this, e);
  }
  setViewBox(e) {
    this.screen.setViewBox(yae({
      document: this
    }, e));
  }
}
Ao.createCanvas = wae;
Ao.createImage = Bae;
Ao.elementTypes = bae;
function dE(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function UA(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? dE(Object(t), !0).forEach(function(n) {
      sy(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : dE(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
class zA {
  /**
   * Main constructor.
   * @param ctx - Rendering context.
   * @param svg - SVG Document.
   * @param options - Rendering options.
   */
  constructor(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.parser = new mp(n), this.screen = new Xf(e, n), this.options = n;
    var i = new Ao(this, n), s = i.createDocumentElement(t);
    this.document = i, this.documentElement = s;
  }
  /**
   * Create Canvg instance from SVG source string or URL.
   * @param ctx - Rendering context.
   * @param svg - SVG source string or URL.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */
  static from(e, t) {
    var n = arguments;
    return uo(function* () {
      var i = n.length > 2 && n[2] !== void 0 ? n[2] : {}, s = new mp(i), a = yield s.parse(t);
      return new zA(e, a, i);
    })();
  }
  /**
   * Create Canvg instance from SVG source string.
   * @param ctx - Rendering context.
   * @param svg - SVG source string.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */
  static fromString(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = new mp(n), s = i.parseFromString(t);
    return new zA(e, s, n);
  }
  /**
   * Create new Canvg instance with inherited options.
   * @param ctx - Rendering context.
   * @param svg - SVG source string or URL.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */
  fork(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return zA.from(e, t, UA(UA({}, this.options), n));
  }
  /**
   * Create new Canvg instance with inherited options.
   * @param ctx - Rendering context.
   * @param svg - SVG source string.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */
  forkString(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return zA.fromString(e, t, UA(UA({}, this.options), n));
  }
  /**
   * Document is ready promise.
   * @returns Ready promise.
   */
  ready() {
    return this.screen.ready();
  }
  /**
   * Document is ready value.
   * @returns Is ready or not.
   */
  isReady() {
    return this.screen.isReady();
  }
  /**
   * Render only first frame, ignoring animations and mouse.
   * @param options - Rendering options.
   */
  render() {
    var e = arguments, t = this;
    return uo(function* () {
      var n = e.length > 0 && e[0] !== void 0 ? e[0] : {};
      t.start(UA({
        enableRedraw: !0,
        ignoreAnimation: !0,
        ignoreMouse: !0
      }, n)), yield t.ready(), t.stop();
    })();
  }
  /**
   * Start rendering.
   * @param options - Render options.
   */
  start() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, {
      documentElement: t,
      screen: n,
      options: i
    } = this;
    n.start(t, UA(UA({
      enableRedraw: !0
    }, i), e));
  }
  /**
   * Stop rendering.
   */
  stop() {
    this.screen.stop();
  }
  /**
   * Resize SVG to fit in given size.
   * @param width
   * @param height
   * @param preserveAspectRatio
   */
  resize(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    this.documentElement.resize(e, t, n);
  }
}
const Cae = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AElement: Ux,
  AnimateColorElement: Ix,
  AnimateElement: Xg,
  AnimateTransformElement: Fx,
  BoundingBox: Ms,
  CB1: T2,
  CB2: x2,
  CB3: k2,
  CB4: L2,
  Canvg: zA,
  CircleElement: mx,
  ClipPathElement: Rx,
  DefsElement: Cx,
  DescElement: Vx,
  Document: Ao,
  Element: jr,
  EllipseElement: vx,
  FeColorMatrixElement: py,
  FeCompositeElement: jx,
  FeDropShadowElement: Px,
  FeGaussianBlurElement: Kx,
  FeMorphologyElement: Hx,
  FilterElement: Zf,
  Font: Ei,
  FontElement: Tx,
  FontFaceElement: xx,
  GElement: Wg,
  GlyphElement: uy,
  GradientElement: hy,
  ImageElement: Ox,
  LineElement: bx,
  LinearGradientElement: _x,
  MarkerElement: Bx,
  MaskElement: Yf,
  Matrix: Ay,
  MissingGlyphElement: kx,
  Mouse: Ax,
  PSEUDO_ZERO: sl,
  Parser: mp,
  PathElement: _r,
  PathParser: qt,
  PatternElement: wx,
  Point: sn,
  PolygonElement: yx,
  PolylineElement: fy,
  Property: wt,
  QB1: U2,
  QB2: N2,
  QB3: O2,
  RadialGradientElement: Ex,
  RectElement: cy,
  RenderedElement: hA,
  Rotate: fx,
  SVGElement: $u,
  SVGFontLoader: Dx,
  Scale: hx,
  Screen: Xf,
  Skew: ly,
  SkewX: dx,
  SkewY: px,
  StopElement: Sx,
  StyleElement: dy,
  SymbolElement: Qx,
  TRefElement: Lx,
  TSpanElement: Jf,
  TextElement: co,
  TextPathElement: Nx,
  TitleElement: $x,
  Transform: lA,
  Translate: cx,
  UnknownElement: gx,
  UseElement: Mx,
  ViewPort: ox,
  compressSpaces: ml,
  default: zA,
  getSelectorSpecificity: ax,
  normalizeAttributeName: ix,
  normalizeColor: sx,
  parseExternalUrl: oy,
  presets: eae,
  toNumbers: Yi,
  trimLeft: rx,
  trimRight: nx,
  vectorMagnitude: I2,
  vectorsAngle: F2,
  vectorsRatio: Yp
}, Symbol.toStringTag, { value: "Module" }));
export {
  Iae as default
};

{"version":3,"file":"testHelpers-053f956f.js","sources":["../node_modules/tslib/tslib.es6.js","../node_modules/@openenergytools/xml-lib/dist/editv2.js","../node_modules/@openenergytools/xml-lib/dist/editv1.js","../node_modules/@openenergytools/xml-lib/dist/convertEdit.js","../node_modules/fast-check/lib/esm/check/precondition/PreconditionFailure.js","../node_modules/fast-check/lib/esm/stream/StreamHelpers.js","../node_modules/fast-check/lib/esm/stream/Stream.js","../node_modules/fast-check/lib/esm/check/symbols.js","../node_modules/fast-check/lib/esm/check/arbitrary/definition/Value.js","../node_modules/fast-check/lib/esm/check/arbitrary/definition/Arbitrary.js","../node_modules/fast-check/lib/esm/utils/apply.js","../node_modules/fast-check/lib/esm/utils/globals.js","../node_modules/fast-check/lib/esm/stream/LazyIterableIterator.js","../node_modules/fast-check/lib/esm/arbitrary/_internals/TupleArbitrary.js","../node_modules/fast-check/lib/esm/arbitrary/tuple.js","../node_modules/fast-check/lib/esm/check/runner/configuration/VerbosityLevel.js","../node_modules/fast-check/lib/esm/utils/stringify.js","../node_modules/fast-check/lib/esm/check/runner/reporter/ExecutionStatus.js","../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BiasNumericRange.js","../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkInteger.js","../node_modules/fast-check/lib/esm/arbitrary/_internals/IntegerArbitrary.js","../node_modules/fast-check/lib/esm/arbitrary/integer.js","../node_modules/fast-check/lib/esm/arbitrary/_internals/ConstantArbitrary.js","../node_modules/fast-check/lib/esm/arbitrary/constantFrom.js","../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToCharString.js","../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterArbitraryBuilder.js","../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToPrintableIndex.js","../node_modules/fast-check/lib/esm/arbitrary/char.js","../node_modules/fast-check/lib/esm/arbitrary/fullUnicode.js","../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterRangeArbitraryBuilder.js","../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleHelpers.js","../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatHelpers.js","../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js","../node_modules/fast-check/lib/esm/arbitrary/sparseArray.js","../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ReadRegex.js","../node_modules/fast-check/lib/esm/arbitrary/stringMatching.js","../node_modules/@openenergytools/xml-lib/dist/testHelpers.js"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport default {\r\n    __extends,\r\n    __assign,\r\n    __rest,\r\n    __decorate,\r\n    __param,\r\n    __metadata,\r\n    __awaiter,\r\n    __generator,\r\n    __createBinding,\r\n    __exportStar,\r\n    __values,\r\n    __read,\r\n    __spread,\r\n    __spreadArrays,\r\n    __spreadArray,\r\n    __await,\r\n    __asyncGenerator,\r\n    __asyncDelegator,\r\n    __asyncValues,\r\n    __makeTemplateObject,\r\n    __importStar,\r\n    __importDefault,\r\n    __classPrivateFieldGet,\r\n    __classPrivateFieldSet,\r\n    __classPrivateFieldIn,\r\n};\r\n","export function isComplex(edit) {\n    return edit instanceof Array;\n}\nexport function isSetTextContent(edit) {\n    return (edit.element !== undefined &&\n        edit.textContent !== undefined);\n}\nexport function isRemove(edit) {\n    return (edit.parent === undefined && edit.node !== undefined);\n}\nexport function isSetAttributes(edit) {\n    return (edit.element !== undefined &&\n        edit.attributes !== undefined &&\n        edit.attributesNS !== undefined);\n}\nexport function isInsert(edit) {\n    return (edit.parent !== undefined &&\n        edit.node !== undefined &&\n        edit.reference !== undefined);\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isEditV2(edit) {\n    if (isComplex(edit))\n        return !edit.some((e) => !isEditV2(e));\n    return (isSetAttributes(edit) ||\n        isSetTextContent(edit) ||\n        isInsert(edit) ||\n        isRemove(edit));\n}\n//# sourceMappingURL=editv2.js.map","import { isSetAttributes } from \"./editv2\";\nexport function isComplex(edit) {\n    return edit instanceof Array;\n}\nexport function isInsert(edit) {\n    return edit.parent !== undefined;\n}\nexport function isNamespaced(value) {\n    return value !== null && typeof value !== \"string\";\n}\nexport function isUpdate(edit) {\n    return (edit.element !== undefined &&\n        edit.attributes !== undefined);\n}\nexport function isRemove(edit) {\n    return (edit.parent === undefined && edit.node !== undefined);\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isEdit(edit) {\n    if (isComplex(edit))\n        return !edit.some((e) => !isEdit(e));\n    return (!isSetAttributes(edit) &&\n        (isUpdate(edit) || isInsert(edit) || isRemove(edit)));\n}\n//# sourceMappingURL=editv1.js.map","import { isComplex, isInsert, isNamespaced, isUpdate, isRemove, } from \"./editv1.js\";\nfunction convertUpdate(edit) {\n    const attributes = {};\n    const attributesNS = {};\n    Object.entries(edit.attributes).forEach(([key, value]) => {\n        if (isNamespaced(value)) {\n            const ns = value.namespaceURI;\n            if (!ns)\n                return;\n            if (!attributesNS[ns]) {\n                attributesNS[ns] = {};\n            }\n            attributesNS[ns][key] = value.value;\n        }\n        else\n            attributes[key] = value;\n    });\n    return { element: edit.element, attributes, attributesNS };\n}\nexport function convertEdit(edit) {\n    if (isRemove(edit))\n        return edit;\n    if (isInsert(edit))\n        return edit;\n    if (isUpdate(edit))\n        return convertUpdate(edit);\n    if (isComplex(edit))\n        return edit.map(convertEdit);\n    return [];\n}\n//# sourceMappingURL=convertEdit.js.map","export class PreconditionFailure extends Error {\n    constructor(interruptExecution = false) {\n        super();\n        this.interruptExecution = interruptExecution;\n        this.footprint = PreconditionFailure.SharedFootPrint;\n    }\n    static isFailure(err) {\n        return err != null && err.footprint === PreconditionFailure.SharedFootPrint;\n    }\n}\nPreconditionFailure.SharedFootPrint = Symbol.for('fast-check/PreconditionFailure');\n","class Nil {\n    [Symbol.iterator]() {\n        return this;\n    }\n    next(value) {\n        return { value, done: true };\n    }\n}\nNil.nil = new Nil();\nexport function nilHelper() {\n    return Nil.nil;\n}\nexport function* mapHelper(g, f) {\n    for (const v of g) {\n        yield f(v);\n    }\n}\nexport function* flatMapHelper(g, f) {\n    for (const v of g) {\n        yield* f(v);\n    }\n}\nexport function* filterHelper(g, f) {\n    for (const v of g) {\n        if (f(v)) {\n            yield v;\n        }\n    }\n}\nexport function* takeNHelper(g, n) {\n    for (let i = 0; i < n; ++i) {\n        const cur = g.next();\n        if (cur.done) {\n            break;\n        }\n        yield cur.value;\n    }\n}\nexport function* takeWhileHelper(g, f) {\n    let cur = g.next();\n    while (!cur.done && f(cur.value)) {\n        yield cur.value;\n        cur = g.next();\n    }\n}\nexport function* joinHelper(g, others) {\n    for (let cur = g.next(); !cur.done; cur = g.next()) {\n        yield cur.value;\n    }\n    for (const s of others) {\n        for (let cur = s.next(); !cur.done; cur = s.next()) {\n            yield cur.value;\n        }\n    }\n}\n","import { filterHelper, flatMapHelper, joinHelper, mapHelper, nilHelper, takeNHelper, takeWhileHelper, } from './StreamHelpers.js';\nconst safeSymbolIterator = Symbol.iterator;\nexport class Stream {\n    static nil() {\n        return new Stream(nilHelper());\n    }\n    static of(...elements) {\n        return new Stream(elements[safeSymbolIterator]());\n    }\n    constructor(g) {\n        this.g = g;\n    }\n    next() {\n        return this.g.next();\n    }\n    [Symbol.iterator]() {\n        return this.g;\n    }\n    map(f) {\n        return new Stream(mapHelper(this.g, f));\n    }\n    flatMap(f) {\n        return new Stream(flatMapHelper(this.g, f));\n    }\n    dropWhile(f) {\n        let foundEligible = false;\n        function* helper(v) {\n            if (foundEligible || !f(v)) {\n                foundEligible = true;\n                yield v;\n            }\n        }\n        return this.flatMap(helper);\n    }\n    drop(n) {\n        if (n <= 0) {\n            return this;\n        }\n        let idx = 0;\n        function helper() {\n            return idx++ < n;\n        }\n        return this.dropWhile(helper);\n    }\n    takeWhile(f) {\n        return new Stream(takeWhileHelper(this.g, f));\n    }\n    take(n) {\n        return new Stream(takeNHelper(this.g, n));\n    }\n    filter(f) {\n        return new Stream(filterHelper(this.g, f));\n    }\n    every(f) {\n        for (const v of this.g) {\n            if (!f(v)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    has(f) {\n        for (const v of this.g) {\n            if (f(v)) {\n                return [true, v];\n            }\n        }\n        return [false, null];\n    }\n    join(...others) {\n        return new Stream(joinHelper(this.g, others));\n    }\n    getNthOrLast(nth) {\n        let remaining = nth;\n        let last = null;\n        for (const v of this.g) {\n            if (remaining-- === 0)\n                return v;\n            last = v;\n        }\n        return last;\n    }\n}\nexport function stream(g) {\n    return new Stream(g);\n}\n","export const cloneMethod = Symbol.for('fast-check/cloneMethod');\nexport function hasCloneMethod(instance) {\n    return (instance !== null &&\n        (typeof instance === 'object' || typeof instance === 'function') &&\n        cloneMethod in instance &&\n        typeof instance[cloneMethod] === 'function');\n}\nexport function cloneIfNeeded(instance) {\n    return hasCloneMethod(instance) ? instance[cloneMethod]() : instance;\n}\n","import { cloneMethod, hasCloneMethod } from '../../symbols.js';\nconst safeObjectDefineProperty = Object.defineProperty;\nexport class Value {\n    constructor(value_, context, customGetValue = undefined) {\n        this.value_ = value_;\n        this.context = context;\n        this.hasToBeCloned = customGetValue !== undefined || hasCloneMethod(value_);\n        this.readOnce = false;\n        if (this.hasToBeCloned) {\n            safeObjectDefineProperty(this, 'value', { get: customGetValue !== undefined ? customGetValue : this.getValue });\n        }\n        else {\n            this.value = value_;\n        }\n    }\n    getValue() {\n        if (this.hasToBeCloned) {\n            if (!this.readOnce) {\n                this.readOnce = true;\n                return this.value_;\n            }\n            return this.value_[cloneMethod]();\n        }\n        return this.value_;\n    }\n}\n","import { Stream } from '../../../stream/Stream.js';\nimport { cloneMethod, hasCloneMethod } from '../../symbols.js';\nimport { Value } from './Value.js';\nconst safeObjectAssign = Object.assign;\nexport class Arbitrary {\n    filter(refinement) {\n        return new FilterArbitrary(this, refinement);\n    }\n    map(mapper, unmapper) {\n        return new MapArbitrary(this, mapper, unmapper);\n    }\n    chain(chainer) {\n        return new ChainArbitrary(this, chainer);\n    }\n    noShrink() {\n        return new NoShrinkArbitrary(this);\n    }\n    noBias() {\n        return new NoBiasArbitrary(this);\n    }\n}\nclass ChainArbitrary extends Arbitrary {\n    constructor(arb, chainer) {\n        super();\n        this.arb = arb;\n        this.chainer = chainer;\n    }\n    generate(mrng, biasFactor) {\n        const clonedMrng = mrng.clone();\n        const src = this.arb.generate(mrng, biasFactor);\n        return this.valueChainer(src, mrng, clonedMrng, biasFactor);\n    }\n    canShrinkWithoutContext(value) {\n        return false;\n    }\n    shrink(value, context) {\n        if (this.isSafeContext(context)) {\n            return (!context.stoppedForOriginal\n                ? this.arb\n                    .shrink(context.originalValue, context.originalContext)\n                    .map((v) => this.valueChainer(v, context.clonedMrng.clone(), context.clonedMrng, context.originalBias))\n                : Stream.nil()).join(context.chainedArbitrary.shrink(value, context.chainedContext).map((dst) => {\n                const newContext = safeObjectAssign(safeObjectAssign({}, context), {\n                    chainedContext: dst.context,\n                    stoppedForOriginal: true,\n                });\n                return new Value(dst.value_, newContext);\n            }));\n        }\n        return Stream.nil();\n    }\n    valueChainer(v, generateMrng, clonedMrng, biasFactor) {\n        const chainedArbitrary = this.chainer(v.value_);\n        const dst = chainedArbitrary.generate(generateMrng, biasFactor);\n        const context = {\n            originalBias: biasFactor,\n            originalValue: v.value_,\n            originalContext: v.context,\n            stoppedForOriginal: false,\n            chainedArbitrary,\n            chainedContext: dst.context,\n            clonedMrng,\n        };\n        return new Value(dst.value_, context);\n    }\n    isSafeContext(context) {\n        return (context != null &&\n            typeof context === 'object' &&\n            'originalBias' in context &&\n            'originalValue' in context &&\n            'originalContext' in context &&\n            'stoppedForOriginal' in context &&\n            'chainedArbitrary' in context &&\n            'chainedContext' in context &&\n            'clonedMrng' in context);\n    }\n}\nclass MapArbitrary extends Arbitrary {\n    constructor(arb, mapper, unmapper) {\n        super();\n        this.arb = arb;\n        this.mapper = mapper;\n        this.unmapper = unmapper;\n        this.bindValueMapper = (v) => this.valueMapper(v);\n    }\n    generate(mrng, biasFactor) {\n        const g = this.arb.generate(mrng, biasFactor);\n        return this.valueMapper(g);\n    }\n    canShrinkWithoutContext(value) {\n        if (this.unmapper !== undefined) {\n            try {\n                const unmapped = this.unmapper(value);\n                return this.arb.canShrinkWithoutContext(unmapped);\n            }\n            catch (_err) {\n                return false;\n            }\n        }\n        return false;\n    }\n    shrink(value, context) {\n        if (this.isSafeContext(context)) {\n            return this.arb.shrink(context.originalValue, context.originalContext).map(this.bindValueMapper);\n        }\n        if (this.unmapper !== undefined) {\n            const unmapped = this.unmapper(value);\n            return this.arb.shrink(unmapped, undefined).map(this.bindValueMapper);\n        }\n        return Stream.nil();\n    }\n    mapperWithCloneIfNeeded(v) {\n        const sourceValue = v.value;\n        const mappedValue = this.mapper(sourceValue);\n        if (v.hasToBeCloned &&\n            ((typeof mappedValue === 'object' && mappedValue !== null) || typeof mappedValue === 'function') &&\n            Object.isExtensible(mappedValue) &&\n            !hasCloneMethod(mappedValue)) {\n            Object.defineProperty(mappedValue, cloneMethod, { get: () => () => this.mapperWithCloneIfNeeded(v)[0] });\n        }\n        return [mappedValue, sourceValue];\n    }\n    valueMapper(v) {\n        const [mappedValue, sourceValue] = this.mapperWithCloneIfNeeded(v);\n        const context = { originalValue: sourceValue, originalContext: v.context };\n        return new Value(mappedValue, context);\n    }\n    isSafeContext(context) {\n        return (context != null &&\n            typeof context === 'object' &&\n            'originalValue' in context &&\n            'originalContext' in context);\n    }\n}\nclass FilterArbitrary extends Arbitrary {\n    constructor(arb, refinement) {\n        super();\n        this.arb = arb;\n        this.refinement = refinement;\n        this.bindRefinementOnValue = (v) => this.refinementOnValue(v);\n    }\n    generate(mrng, biasFactor) {\n        while (true) {\n            const g = this.arb.generate(mrng, biasFactor);\n            if (this.refinementOnValue(g)) {\n                return g;\n            }\n        }\n    }\n    canShrinkWithoutContext(value) {\n        return this.arb.canShrinkWithoutContext(value) && this.refinement(value);\n    }\n    shrink(value, context) {\n        return this.arb.shrink(value, context).filter(this.bindRefinementOnValue);\n    }\n    refinementOnValue(v) {\n        return this.refinement(v.value);\n    }\n}\nclass NoShrinkArbitrary extends Arbitrary {\n    constructor(arb) {\n        super();\n        this.arb = arb;\n    }\n    generate(mrng, biasFactor) {\n        return this.arb.generate(mrng, biasFactor);\n    }\n    canShrinkWithoutContext(value) {\n        return this.arb.canShrinkWithoutContext(value);\n    }\n    shrink(_value, _context) {\n        return Stream.nil();\n    }\n    noShrink() {\n        return this;\n    }\n}\nclass NoBiasArbitrary extends Arbitrary {\n    constructor(arb) {\n        super();\n        this.arb = arb;\n    }\n    generate(mrng, _biasFactor) {\n        return this.arb.generate(mrng, undefined);\n    }\n    canShrinkWithoutContext(value) {\n        return this.arb.canShrinkWithoutContext(value);\n    }\n    shrink(value, context) {\n        return this.arb.shrink(value, context);\n    }\n    noBias() {\n        return this;\n    }\n}\nexport function isArbitrary(instance) {\n    return (typeof instance === 'object' &&\n        instance !== null &&\n        'generate' in instance &&\n        'shrink' in instance &&\n        'canShrinkWithoutContext' in instance);\n}\nexport function assertIsArbitrary(instance) {\n    if (!isArbitrary(instance)) {\n        throw new Error('Unexpected value received: not an instance of Arbitrary');\n    }\n}\n","const untouchedApply = Function.prototype.apply;\nconst ApplySymbol = Symbol('apply');\nfunction safeExtractApply(f) {\n    try {\n        return f.apply;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction safeApplyHacky(f, instance, args) {\n    const ff = f;\n    ff[ApplySymbol] = untouchedApply;\n    const out = ff[ApplySymbol](instance, args);\n    delete ff[ApplySymbol];\n    return out;\n}\nexport function safeApply(f, instance, args) {\n    if (safeExtractApply(f) === untouchedApply) {\n        return f.apply(instance, args);\n    }\n    return safeApplyHacky(f, instance, args);\n}\n","import { safeApply } from './apply.js';\nconst SArray = typeof Array !== 'undefined' ? Array : undefined;\nexport { SArray as Array };\nconst SBigInt = typeof BigInt !== 'undefined' ? BigInt : undefined;\nexport { SBigInt as BigInt };\nconst SBigInt64Array = typeof BigInt64Array !== 'undefined' ? BigInt64Array : undefined;\nexport { SBigInt64Array as BigInt64Array };\nconst SBigUint64Array = typeof BigUint64Array !== 'undefined' ? BigUint64Array : undefined;\nexport { SBigUint64Array as BigUint64Array };\nconst SBoolean = typeof Boolean !== 'undefined' ? Boolean : undefined;\nexport { SBoolean as Boolean };\nconst SDate = typeof Date !== 'undefined' ? Date : undefined;\nexport { SDate as Date };\nconst SError = typeof Error !== 'undefined' ? Error : undefined;\nexport { SError as Error };\nconst SFloat32Array = typeof Float32Array !== 'undefined' ? Float32Array : undefined;\nexport { SFloat32Array as Float32Array };\nconst SFloat64Array = typeof Float64Array !== 'undefined' ? Float64Array : undefined;\nexport { SFloat64Array as Float64Array };\nconst SInt8Array = typeof Int8Array !== 'undefined' ? Int8Array : undefined;\nexport { SInt8Array as Int8Array };\nconst SInt16Array = typeof Int16Array !== 'undefined' ? Int16Array : undefined;\nexport { SInt16Array as Int16Array };\nconst SInt32Array = typeof Int32Array !== 'undefined' ? Int32Array : undefined;\nexport { SInt32Array as Int32Array };\nconst SNumber = typeof Number !== 'undefined' ? Number : undefined;\nexport { SNumber as Number };\nconst SString = typeof String !== 'undefined' ? String : undefined;\nexport { SString as String };\nconst SSet = typeof Set !== 'undefined' ? Set : undefined;\nexport { SSet as Set };\nconst SUint8Array = typeof Uint8Array !== 'undefined' ? Uint8Array : undefined;\nexport { SUint8Array as Uint8Array };\nconst SUint8ClampedArray = typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : undefined;\nexport { SUint8ClampedArray as Uint8ClampedArray };\nconst SUint16Array = typeof Uint16Array !== 'undefined' ? Uint16Array : undefined;\nexport { SUint16Array as Uint16Array };\nconst SUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : undefined;\nexport { SUint32Array as Uint32Array };\nconst SencodeURIComponent = typeof encodeURIComponent !== 'undefined' ? encodeURIComponent : undefined;\nexport { SencodeURIComponent as encodeURIComponent };\nconst untouchedForEach = Array.prototype.forEach;\nconst untouchedIndexOf = Array.prototype.indexOf;\nconst untouchedJoin = Array.prototype.join;\nconst untouchedMap = Array.prototype.map;\nconst untouchedFilter = Array.prototype.filter;\nconst untouchedPush = Array.prototype.push;\nconst untouchedPop = Array.prototype.pop;\nconst untouchedSplice = Array.prototype.splice;\nconst untouchedSlice = Array.prototype.slice;\nconst untouchedSort = Array.prototype.sort;\nconst untouchedEvery = Array.prototype.every;\nfunction extractForEach(instance) {\n    try {\n        return instance.forEach;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractIndexOf(instance) {\n    try {\n        return instance.indexOf;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractJoin(instance) {\n    try {\n        return instance.join;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractMap(instance) {\n    try {\n        return instance.map;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractFilter(instance) {\n    try {\n        return instance.filter;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractPush(instance) {\n    try {\n        return instance.push;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractPop(instance) {\n    try {\n        return instance.pop;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractSplice(instance) {\n    try {\n        return instance.splice;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractSlice(instance) {\n    try {\n        return instance.slice;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractSort(instance) {\n    try {\n        return instance.sort;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractEvery(instance) {\n    try {\n        return instance.every;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nexport function safeForEach(instance, fn) {\n    if (extractForEach(instance) === untouchedForEach) {\n        return instance.forEach(fn);\n    }\n    return safeApply(untouchedForEach, instance, [fn]);\n}\nexport function safeIndexOf(instance, ...args) {\n    if (extractIndexOf(instance) === untouchedIndexOf) {\n        return instance.indexOf(...args);\n    }\n    return safeApply(untouchedIndexOf, instance, args);\n}\nexport function safeJoin(instance, ...args) {\n    if (extractJoin(instance) === untouchedJoin) {\n        return instance.join(...args);\n    }\n    return safeApply(untouchedJoin, instance, args);\n}\nexport function safeMap(instance, fn) {\n    if (extractMap(instance) === untouchedMap) {\n        return instance.map(fn);\n    }\n    return safeApply(untouchedMap, instance, [fn]);\n}\nexport function safeFilter(instance, predicate) {\n    if (extractFilter(instance) === untouchedFilter) {\n        return instance.filter(predicate);\n    }\n    return safeApply(untouchedFilter, instance, [predicate]);\n}\nexport function safePush(instance, ...args) {\n    if (extractPush(instance) === untouchedPush) {\n        return instance.push(...args);\n    }\n    return safeApply(untouchedPush, instance, args);\n}\nexport function safePop(instance) {\n    if (extractPop(instance) === untouchedPop) {\n        return instance.pop();\n    }\n    return safeApply(untouchedPop, instance, []);\n}\nexport function safeSplice(instance, ...args) {\n    if (extractSplice(instance) === untouchedSplice) {\n        return instance.splice(...args);\n    }\n    return safeApply(untouchedSplice, instance, args);\n}\nexport function safeSlice(instance, ...args) {\n    if (extractSlice(instance) === untouchedSlice) {\n        return instance.slice(...args);\n    }\n    return safeApply(untouchedSlice, instance, args);\n}\nexport function safeSort(instance, ...args) {\n    if (extractSort(instance) === untouchedSort) {\n        return instance.sort(...args);\n    }\n    return safeApply(untouchedSort, instance, args);\n}\nexport function safeEvery(instance, ...args) {\n    if (extractEvery(instance) === untouchedEvery) {\n        return instance.every(...args);\n    }\n    return safeApply(untouchedEvery, instance, args);\n}\nconst untouchedGetTime = Date.prototype.getTime;\nconst untouchedToISOString = Date.prototype.toISOString;\nfunction extractGetTime(instance) {\n    try {\n        return instance.getTime;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractToISOString(instance) {\n    try {\n        return instance.toISOString;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nexport function safeGetTime(instance) {\n    if (extractGetTime(instance) === untouchedGetTime) {\n        return instance.getTime();\n    }\n    return safeApply(untouchedGetTime, instance, []);\n}\nexport function safeToISOString(instance) {\n    if (extractToISOString(instance) === untouchedToISOString) {\n        return instance.toISOString();\n    }\n    return safeApply(untouchedToISOString, instance, []);\n}\nconst untouchedAdd = Set.prototype.add;\nconst untouchedHas = Set.prototype.has;\nfunction extractAdd(instance) {\n    try {\n        return instance.add;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractHas(instance) {\n    try {\n        return instance.has;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nexport function safeAdd(instance, value) {\n    if (extractAdd(instance) === untouchedAdd) {\n        return instance.add(value);\n    }\n    return safeApply(untouchedAdd, instance, [value]);\n}\nexport function safeHas(instance, value) {\n    if (extractHas(instance) === untouchedHas) {\n        return instance.has(value);\n    }\n    return safeApply(untouchedHas, instance, [value]);\n}\nconst untouchedSet = WeakMap.prototype.set;\nconst untouchedGet = WeakMap.prototype.get;\nfunction extractSet(instance) {\n    try {\n        return instance.set;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractGet(instance) {\n    try {\n        return instance.get;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nexport function safeSet(instance, key, value) {\n    if (extractSet(instance) === untouchedSet) {\n        return instance.set(key, value);\n    }\n    return safeApply(untouchedSet, instance, [key, value]);\n}\nexport function safeGet(instance, key) {\n    if (extractGet(instance) === untouchedGet) {\n        return instance.get(key);\n    }\n    return safeApply(untouchedGet, instance, [key]);\n}\nconst untouchedMapSet = Map.prototype.set;\nconst untouchedMapGet = Map.prototype.get;\nfunction extractMapSet(instance) {\n    try {\n        return instance.set;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractMapGet(instance) {\n    try {\n        return instance.get;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nexport function safeMapSet(instance, key, value) {\n    if (extractMapSet(instance) === untouchedMapSet) {\n        return instance.set(key, value);\n    }\n    return safeApply(untouchedMapSet, instance, [key, value]);\n}\nexport function safeMapGet(instance, key) {\n    if (extractMapGet(instance) === untouchedMapGet) {\n        return instance.get(key);\n    }\n    return safeApply(untouchedMapGet, instance, [key]);\n}\nconst untouchedSplit = String.prototype.split;\nconst untouchedStartsWith = String.prototype.startsWith;\nconst untouchedEndsWith = String.prototype.endsWith;\nconst untouchedSubstring = String.prototype.substring;\nconst untouchedToLowerCase = String.prototype.toLowerCase;\nconst untouchedToUpperCase = String.prototype.toUpperCase;\nconst untouchedPadStart = String.prototype.padStart;\nconst untouchedCharCodeAt = String.prototype.charCodeAt;\nconst untouchedNormalize = String.prototype.normalize;\nconst untouchedReplace = String.prototype.replace;\nfunction extractSplit(instance) {\n    try {\n        return instance.split;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractStartsWith(instance) {\n    try {\n        return instance.startsWith;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractEndsWith(instance) {\n    try {\n        return instance.endsWith;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractSubstring(instance) {\n    try {\n        return instance.substring;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractToLowerCase(instance) {\n    try {\n        return instance.toLowerCase;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractToUpperCase(instance) {\n    try {\n        return instance.toUpperCase;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractPadStart(instance) {\n    try {\n        return instance.padStart;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractCharCodeAt(instance) {\n    try {\n        return instance.charCodeAt;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractNormalize(instance) {\n    try {\n        return instance.normalize;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nfunction extractReplace(instance) {\n    try {\n        return instance.replace;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nexport function safeSplit(instance, ...args) {\n    if (extractSplit(instance) === untouchedSplit) {\n        return instance.split(...args);\n    }\n    return safeApply(untouchedSplit, instance, args);\n}\nexport function safeStartsWith(instance, ...args) {\n    if (extractStartsWith(instance) === untouchedStartsWith) {\n        return instance.startsWith(...args);\n    }\n    return safeApply(untouchedStartsWith, instance, args);\n}\nexport function safeEndsWith(instance, ...args) {\n    if (extractEndsWith(instance) === untouchedEndsWith) {\n        return instance.endsWith(...args);\n    }\n    return safeApply(untouchedEndsWith, instance, args);\n}\nexport function safeSubstring(instance, ...args) {\n    if (extractSubstring(instance) === untouchedSubstring) {\n        return instance.substring(...args);\n    }\n    return safeApply(untouchedSubstring, instance, args);\n}\nexport function safeToLowerCase(instance) {\n    if (extractToLowerCase(instance) === untouchedToLowerCase) {\n        return instance.toLowerCase();\n    }\n    return safeApply(untouchedToLowerCase, instance, []);\n}\nexport function safeToUpperCase(instance) {\n    if (extractToUpperCase(instance) === untouchedToUpperCase) {\n        return instance.toUpperCase();\n    }\n    return safeApply(untouchedToUpperCase, instance, []);\n}\nexport function safePadStart(instance, ...args) {\n    if (extractPadStart(instance) === untouchedPadStart) {\n        return instance.padStart(...args);\n    }\n    return safeApply(untouchedPadStart, instance, args);\n}\nexport function safeCharCodeAt(instance, index) {\n    if (extractCharCodeAt(instance) === untouchedCharCodeAt) {\n        return instance.charCodeAt(index);\n    }\n    return safeApply(untouchedCharCodeAt, instance, [index]);\n}\nexport function safeNormalize(instance, form) {\n    if (extractNormalize(instance) === untouchedNormalize) {\n        return instance.normalize(form);\n    }\n    return safeApply(untouchedNormalize, instance, [form]);\n}\nexport function safeReplace(instance, pattern, replacement) {\n    if (extractReplace(instance) === untouchedReplace) {\n        return instance.replace(pattern, replacement);\n    }\n    return safeApply(untouchedReplace, instance, [pattern, replacement]);\n}\nconst untouchedNumberToString = Number.prototype.toString;\nfunction extractNumberToString(instance) {\n    try {\n        return instance.toString;\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nexport function safeNumberToString(instance, ...args) {\n    if (extractNumberToString(instance) === untouchedNumberToString) {\n        return instance.toString(...args);\n    }\n    return safeApply(untouchedNumberToString, instance, args);\n}\nconst untouchedHasOwnProperty = Object.prototype.hasOwnProperty;\nconst untouchedToString = Object.prototype.toString;\nexport function safeHasOwnProperty(instance, v) {\n    return safeApply(untouchedHasOwnProperty, instance, [v]);\n}\nexport function safeToString(instance) {\n    return safeApply(untouchedToString, instance, []);\n}\n","class LazyIterableIterator {\n    constructor(producer) {\n        this.producer = producer;\n    }\n    [Symbol.iterator]() {\n        if (this.it === undefined) {\n            this.it = this.producer();\n        }\n        return this.it;\n    }\n    next() {\n        if (this.it === undefined) {\n            this.it = this.producer();\n        }\n        return this.it.next();\n    }\n}\nexport function makeLazy(producer) {\n    return new LazyIterableIterator(producer);\n}\n","import { Stream } from '../../stream/Stream.js';\nimport { cloneIfNeeded, cloneMethod } from '../../check/symbols.js';\nimport { Arbitrary } from '../../check/arbitrary/definition/Arbitrary.js';\nimport { Value } from '../../check/arbitrary/definition/Value.js';\nimport { safeMap, safePush, safeSlice } from '../../utils/globals.js';\nimport { makeLazy } from '../../stream/LazyIterableIterator.js';\nconst safeArrayIsArray = Array.isArray;\nconst safeObjectDefineProperty = Object.defineProperty;\nfunction tupleMakeItCloneable(vs, values) {\n    return safeObjectDefineProperty(vs, cloneMethod, {\n        value: () => {\n            const cloned = [];\n            for (let idx = 0; idx !== values.length; ++idx) {\n                safePush(cloned, values[idx].value);\n            }\n            tupleMakeItCloneable(cloned, values);\n            return cloned;\n        },\n    });\n}\nfunction tupleWrapper(values) {\n    let cloneable = false;\n    const vs = [];\n    const ctxs = [];\n    for (let idx = 0; idx !== values.length; ++idx) {\n        const v = values[idx];\n        cloneable = cloneable || v.hasToBeCloned;\n        safePush(vs, v.value);\n        safePush(ctxs, v.context);\n    }\n    if (cloneable) {\n        tupleMakeItCloneable(vs, values);\n    }\n    return new Value(vs, ctxs);\n}\nexport function tupleShrink(arbs, value, context) {\n    const shrinks = [];\n    const safeContext = safeArrayIsArray(context) ? context : [];\n    for (let idx = 0; idx !== arbs.length; ++idx) {\n        safePush(shrinks, makeLazy(() => arbs[idx]\n            .shrink(value[idx], safeContext[idx])\n            .map((v) => {\n            const nextValues = safeMap(value, (v, idx) => new Value(cloneIfNeeded(v), safeContext[idx]));\n            return [...safeSlice(nextValues, 0, idx), v, ...safeSlice(nextValues, idx + 1)];\n        })\n            .map(tupleWrapper)));\n    }\n    return Stream.nil().join(...shrinks);\n}\nexport class TupleArbitrary extends Arbitrary {\n    constructor(arbs) {\n        super();\n        this.arbs = arbs;\n        for (let idx = 0; idx !== arbs.length; ++idx) {\n            const arb = arbs[idx];\n            if (arb == null || arb.generate == null)\n                throw new Error(`Invalid parameter encountered at index ${idx}: expecting an Arbitrary`);\n        }\n    }\n    generate(mrng, biasFactor) {\n        const mapped = [];\n        for (let idx = 0; idx !== this.arbs.length; ++idx) {\n            safePush(mapped, this.arbs[idx].generate(mrng, biasFactor));\n        }\n        return tupleWrapper(mapped);\n    }\n    canShrinkWithoutContext(value) {\n        if (!safeArrayIsArray(value) || value.length !== this.arbs.length) {\n            return false;\n        }\n        for (let index = 0; index !== this.arbs.length; ++index) {\n            if (!this.arbs[index].canShrinkWithoutContext(value[index])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    shrink(value, context) {\n        return tupleShrink(this.arbs, value, context);\n    }\n}\n","import { TupleArbitrary } from './_internals/TupleArbitrary.js';\nexport function tuple(...arbs) {\n    return new TupleArbitrary(arbs);\n}\n","export var VerbosityLevel;\n(function (VerbosityLevel) {\n    VerbosityLevel[VerbosityLevel[\"None\"] = 0] = \"None\";\n    VerbosityLevel[VerbosityLevel[\"Verbose\"] = 1] = \"Verbose\";\n    VerbosityLevel[VerbosityLevel[\"VeryVerbose\"] = 2] = \"VeryVerbose\";\n})(VerbosityLevel || (VerbosityLevel = {}));\n","import { safeFilter, safeGetTime, safeIndexOf, safeJoin, safeMap, safePush, safeToISOString, safeToString, String, } from './globals.js';\nconst safeArrayFrom = Array.from;\nconst safeBufferIsBuffer = typeof Buffer !== 'undefined' ? Buffer.isBuffer : undefined;\nconst safeJsonStringify = JSON.stringify;\nconst safeNumberIsNaN = Number.isNaN;\nconst safeObjectKeys = Object.keys;\nconst safeObjectGetOwnPropertySymbols = Object.getOwnPropertySymbols;\nconst safeObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nconst safeObjectGetPrototypeOf = Object.getPrototypeOf;\nconst safeNegativeInfinity = Number.NEGATIVE_INFINITY;\nconst safePositiveInfinity = Number.POSITIVE_INFINITY;\nexport const toStringMethod = Symbol.for('fast-check/toStringMethod');\nexport function hasToStringMethod(instance) {\n    return (instance !== null &&\n        (typeof instance === 'object' || typeof instance === 'function') &&\n        toStringMethod in instance &&\n        typeof instance[toStringMethod] === 'function');\n}\nexport const asyncToStringMethod = Symbol.for('fast-check/asyncToStringMethod');\nexport function hasAsyncToStringMethod(instance) {\n    return (instance !== null &&\n        (typeof instance === 'object' || typeof instance === 'function') &&\n        asyncToStringMethod in instance &&\n        typeof instance[asyncToStringMethod] === 'function');\n}\nconst findSymbolNameRegex = /^Symbol\\((.*)\\)$/;\nfunction getSymbolDescription(s) {\n    if (s.description !== undefined)\n        return s.description;\n    const m = findSymbolNameRegex.exec(String(s));\n    return m && m[1].length ? m[1] : null;\n}\nfunction stringifyNumber(numValue) {\n    switch (numValue) {\n        case 0:\n            return 1 / numValue === safeNegativeInfinity ? '-0' : '0';\n        case safeNegativeInfinity:\n            return 'Number.NEGATIVE_INFINITY';\n        case safePositiveInfinity:\n            return 'Number.POSITIVE_INFINITY';\n        default:\n            return numValue === numValue ? String(numValue) : 'Number.NaN';\n    }\n}\nfunction isSparseArray(arr) {\n    let previousNumberedIndex = -1;\n    for (const index in arr) {\n        const numberedIndex = Number(index);\n        if (numberedIndex !== previousNumberedIndex + 1)\n            return true;\n        previousNumberedIndex = numberedIndex;\n    }\n    return previousNumberedIndex + 1 !== arr.length;\n}\nexport function stringifyInternal(value, previousValues, getAsyncContent) {\n    const currentValues = [...previousValues, value];\n    if (typeof value === 'object') {\n        if (safeIndexOf(previousValues, value) !== -1) {\n            return '[cyclic]';\n        }\n    }\n    if (hasAsyncToStringMethod(value)) {\n        const content = getAsyncContent(value);\n        if (content.state === 'fulfilled') {\n            return content.value;\n        }\n    }\n    if (hasToStringMethod(value)) {\n        try {\n            return value[toStringMethod]();\n        }\n        catch (err) {\n        }\n    }\n    switch (safeToString(value)) {\n        case '[object Array]': {\n            const arr = value;\n            if (arr.length >= 50 && isSparseArray(arr)) {\n                const assignments = [];\n                for (const index in arr) {\n                    if (!safeNumberIsNaN(Number(index)))\n                        safePush(assignments, `${index}:${stringifyInternal(arr[index], currentValues, getAsyncContent)}`);\n                }\n                return assignments.length !== 0\n                    ? `Object.assign(Array(${arr.length}),{${safeJoin(assignments, ',')}})`\n                    : `Array(${arr.length})`;\n            }\n            const stringifiedArray = safeJoin(safeMap(arr, (v) => stringifyInternal(v, currentValues, getAsyncContent)), ',');\n            return arr.length === 0 || arr.length - 1 in arr ? `[${stringifiedArray}]` : `[${stringifiedArray},]`;\n        }\n        case '[object BigInt]':\n            return `${value}n`;\n        case '[object Boolean]': {\n            const unboxedToString = value == true ? 'true' : 'false';\n            return typeof value === 'boolean' ? unboxedToString : `new Boolean(${unboxedToString})`;\n        }\n        case '[object Date]': {\n            const d = value;\n            return safeNumberIsNaN(safeGetTime(d)) ? `new Date(NaN)` : `new Date(${safeJsonStringify(safeToISOString(d))})`;\n        }\n        case '[object Map]':\n            return `new Map(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;\n        case '[object Null]':\n            return `null`;\n        case '[object Number]':\n            return typeof value === 'number' ? stringifyNumber(value) : `new Number(${stringifyNumber(Number(value))})`;\n        case '[object Object]': {\n            try {\n                const toStringAccessor = value.toString;\n                if (typeof toStringAccessor === 'function' && toStringAccessor !== Object.prototype.toString) {\n                    return value.toString();\n                }\n            }\n            catch (err) {\n                return '[object Object]';\n            }\n            const mapper = (k) => `${k === '__proto__'\n                ? '[\"__proto__\"]'\n                : typeof k === 'symbol'\n                    ? `[${stringifyInternal(k, currentValues, getAsyncContent)}]`\n                    : safeJsonStringify(k)}:${stringifyInternal(value[k], currentValues, getAsyncContent)}`;\n            const stringifiedProperties = [\n                ...safeMap(safeObjectKeys(value), mapper),\n                ...safeMap(safeFilter(safeObjectGetOwnPropertySymbols(value), (s) => {\n                    const descriptor = safeObjectGetOwnPropertyDescriptor(value, s);\n                    return descriptor && descriptor.enumerable;\n                }), mapper),\n            ];\n            const rawRepr = '{' + safeJoin(stringifiedProperties, ',') + '}';\n            if (safeObjectGetPrototypeOf(value) === null) {\n                return rawRepr === '{}' ? 'Object.create(null)' : `Object.assign(Object.create(null),${rawRepr})`;\n            }\n            return rawRepr;\n        }\n        case '[object Set]':\n            return `new Set(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;\n        case '[object String]':\n            return typeof value === 'string' ? safeJsonStringify(value) : `new String(${safeJsonStringify(value)})`;\n        case '[object Symbol]': {\n            const s = value;\n            if (Symbol.keyFor(s) !== undefined) {\n                return `Symbol.for(${safeJsonStringify(Symbol.keyFor(s))})`;\n            }\n            const desc = getSymbolDescription(s);\n            if (desc === null) {\n                return 'Symbol()';\n            }\n            const knownSymbol = desc.startsWith('Symbol.') && Symbol[desc.substring(7)];\n            return s === knownSymbol ? desc : `Symbol(${safeJsonStringify(desc)})`;\n        }\n        case '[object Promise]': {\n            const promiseContent = getAsyncContent(value);\n            switch (promiseContent.state) {\n                case 'fulfilled':\n                    return `Promise.resolve(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;\n                case 'rejected':\n                    return `Promise.reject(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;\n                case 'pending':\n                    return `new Promise(() => {/*pending*/})`;\n                case 'unknown':\n                default:\n                    return `new Promise(() => {/*unknown*/})`;\n            }\n        }\n        case '[object Error]':\n            if (value instanceof Error) {\n                return `new Error(${stringifyInternal(value.message, currentValues, getAsyncContent)})`;\n            }\n            break;\n        case '[object Undefined]':\n            return `undefined`;\n        case '[object Int8Array]':\n        case '[object Uint8Array]':\n        case '[object Uint8ClampedArray]':\n        case '[object Int16Array]':\n        case '[object Uint16Array]':\n        case '[object Int32Array]':\n        case '[object Uint32Array]':\n        case '[object Float32Array]':\n        case '[object Float64Array]':\n        case '[object BigInt64Array]':\n        case '[object BigUint64Array]': {\n            if (typeof safeBufferIsBuffer === 'function' && safeBufferIsBuffer(value)) {\n                return `Buffer.from(${stringifyInternal(safeArrayFrom(value.values()), currentValues, getAsyncContent)})`;\n            }\n            const valuePrototype = safeObjectGetPrototypeOf(value);\n            const className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;\n            if (typeof className === 'string') {\n                const typedArray = value;\n                const valuesFromTypedArr = typedArray.values();\n                return `${className}.from(${stringifyInternal(safeArrayFrom(valuesFromTypedArr), currentValues, getAsyncContent)})`;\n            }\n            break;\n        }\n    }\n    try {\n        return value.toString();\n    }\n    catch (_a) {\n        return safeToString(value);\n    }\n}\nexport function stringify(value) {\n    return stringifyInternal(value, [], () => ({ state: 'unknown', value: undefined }));\n}\nexport function possiblyAsyncStringify(value) {\n    const stillPendingMarker = Symbol();\n    const pendingPromisesForCache = [];\n    const cache = new Map();\n    function createDelay0() {\n        let handleId = null;\n        const cancel = () => {\n            if (handleId !== null) {\n                clearTimeout(handleId);\n            }\n        };\n        const delay = new Promise((resolve) => {\n            handleId = setTimeout(() => {\n                handleId = null;\n                resolve(stillPendingMarker);\n            }, 0);\n        });\n        return { delay, cancel };\n    }\n    const unknownState = { state: 'unknown', value: undefined };\n    const getAsyncContent = function getAsyncContent(data) {\n        const cacheKey = data;\n        if (cache.has(cacheKey)) {\n            return cache.get(cacheKey);\n        }\n        const delay0 = createDelay0();\n        const p = asyncToStringMethod in data\n            ? Promise.resolve().then(() => data[asyncToStringMethod]())\n            : data;\n        p.catch(() => { });\n        pendingPromisesForCache.push(Promise.race([p, delay0.delay]).then((successValue) => {\n            if (successValue === stillPendingMarker)\n                cache.set(cacheKey, { state: 'pending', value: undefined });\n            else\n                cache.set(cacheKey, { state: 'fulfilled', value: successValue });\n            delay0.cancel();\n        }, (errorValue) => {\n            cache.set(cacheKey, { state: 'rejected', value: errorValue });\n            delay0.cancel();\n        }));\n        cache.set(cacheKey, unknownState);\n        return unknownState;\n    };\n    function loop() {\n        const stringifiedValue = stringifyInternal(value, [], getAsyncContent);\n        if (pendingPromisesForCache.length === 0) {\n            return stringifiedValue;\n        }\n        return Promise.all(pendingPromisesForCache.splice(0)).then(loop);\n    }\n    return loop();\n}\nexport async function asyncStringify(value) {\n    return Promise.resolve(possiblyAsyncStringify(value));\n}\n","export var ExecutionStatus;\n(function (ExecutionStatus) {\n    ExecutionStatus[ExecutionStatus[\"Success\"] = 0] = \"Success\";\n    ExecutionStatus[ExecutionStatus[\"Skipped\"] = -1] = \"Skipped\";\n    ExecutionStatus[ExecutionStatus[\"Failure\"] = 1] = \"Failure\";\n})(ExecutionStatus || (ExecutionStatus = {}));\n","import { BigInt, String } from '../../../utils/globals.js';\nconst safeMathFloor = Math.floor;\nconst safeMathLog = Math.log;\nexport function integerLogLike(v) {\n    return safeMathFloor(safeMathLog(v) / safeMathLog(2));\n}\nexport function bigIntLogLike(v) {\n    if (v === BigInt(0))\n        return BigInt(0);\n    return BigInt(String(v).length);\n}\nfunction biasNumericRange(min, max, logLike) {\n    if (min === max) {\n        return [{ min: min, max: max }];\n    }\n    if (min < 0 && max > 0) {\n        const logMin = logLike(-min);\n        const logMax = logLike(max);\n        return [\n            { min: -logMin, max: logMax },\n            { min: (max - logMax), max: max },\n            { min: min, max: min + logMin },\n        ];\n    }\n    const logGap = logLike((max - min));\n    const arbCloseToMin = { min: min, max: min + logGap };\n    const arbCloseToMax = { min: (max - logGap), max: max };\n    return min < 0\n        ? [arbCloseToMax, arbCloseToMin]\n        : [arbCloseToMin, arbCloseToMax];\n}\nexport { biasNumericRange };\n","import { Value } from '../../../check/arbitrary/definition/Value.js';\nimport { stream } from '../../../stream/Stream.js';\nconst safeMathCeil = Math.ceil;\nconst safeMathFloor = Math.floor;\nfunction halvePosInteger(n) {\n    return safeMathFloor(n / 2);\n}\nfunction halveNegInteger(n) {\n    return safeMathCeil(n / 2);\n}\nexport function shrinkInteger(current, target, tryTargetAsap) {\n    const realGap = current - target;\n    function* shrinkDecr() {\n        let previous = tryTargetAsap ? undefined : target;\n        const gap = tryTargetAsap ? realGap : halvePosInteger(realGap);\n        for (let toremove = gap; toremove > 0; toremove = halvePosInteger(toremove)) {\n            const next = toremove === realGap ? target : current - toremove;\n            yield new Value(next, previous);\n            previous = next;\n        }\n    }\n    function* shrinkIncr() {\n        let previous = tryTargetAsap ? undefined : target;\n        const gap = tryTargetAsap ? realGap : halveNegInteger(realGap);\n        for (let toremove = gap; toremove < 0; toremove = halveNegInteger(toremove)) {\n            const next = toremove === realGap ? target : current - toremove;\n            yield new Value(next, previous);\n            previous = next;\n        }\n    }\n    return realGap > 0 ? stream(shrinkDecr()) : stream(shrinkIncr());\n}\n","import { Arbitrary } from '../../check/arbitrary/definition/Arbitrary.js';\nimport { Value } from '../../check/arbitrary/definition/Value.js';\nimport { Stream } from '../../stream/Stream.js';\nimport { integerLogLike, biasNumericRange } from './helpers/BiasNumericRange.js';\nimport { shrinkInteger } from './helpers/ShrinkInteger.js';\nconst safeMathSign = Math.sign;\nconst safeNumberIsInteger = Number.isInteger;\nconst safeObjectIs = Object.is;\nexport class IntegerArbitrary extends Arbitrary {\n    constructor(min, max) {\n        super();\n        this.min = min;\n        this.max = max;\n    }\n    generate(mrng, biasFactor) {\n        const range = this.computeGenerateRange(mrng, biasFactor);\n        return new Value(mrng.nextInt(range.min, range.max), undefined);\n    }\n    canShrinkWithoutContext(value) {\n        return (typeof value === 'number' &&\n            safeNumberIsInteger(value) &&\n            !safeObjectIs(value, -0) &&\n            this.min <= value &&\n            value <= this.max);\n    }\n    shrink(current, context) {\n        if (!IntegerArbitrary.isValidContext(current, context)) {\n            const target = this.defaultTarget();\n            return shrinkInteger(current, target, true);\n        }\n        if (this.isLastChanceTry(current, context)) {\n            return Stream.of(new Value(context, undefined));\n        }\n        return shrinkInteger(current, context, false);\n    }\n    defaultTarget() {\n        if (this.min <= 0 && this.max >= 0) {\n            return 0;\n        }\n        return this.min < 0 ? this.max : this.min;\n    }\n    computeGenerateRange(mrng, biasFactor) {\n        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {\n            return { min: this.min, max: this.max };\n        }\n        const ranges = biasNumericRange(this.min, this.max, integerLogLike);\n        if (ranges.length === 1) {\n            return ranges[0];\n        }\n        const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);\n        return id < 0 ? ranges[0] : ranges[id + 1];\n    }\n    isLastChanceTry(current, context) {\n        if (current > 0)\n            return current === context + 1 && current > this.min;\n        if (current < 0)\n            return current === context - 1 && current < this.max;\n        return false;\n    }\n    static isValidContext(current, context) {\n        if (context === undefined) {\n            return false;\n        }\n        if (typeof context !== 'number') {\n            throw new Error(`Invalid context type passed to IntegerArbitrary (#1)`);\n        }\n        if (context !== 0 && safeMathSign(current) !== safeMathSign(context)) {\n            throw new Error(`Invalid context value passed to IntegerArbitrary (#2)`);\n        }\n        return true;\n    }\n}\n","import { IntegerArbitrary } from './_internals/IntegerArbitrary.js';\nconst safeNumberIsInteger = Number.isInteger;\nfunction buildCompleteIntegerConstraints(constraints) {\n    const min = constraints.min !== undefined ? constraints.min : -0x80000000;\n    const max = constraints.max !== undefined ? constraints.max : 0x7fffffff;\n    return { min, max };\n}\nexport function integer(constraints = {}) {\n    const fullConstraints = buildCompleteIntegerConstraints(constraints);\n    if (fullConstraints.min > fullConstraints.max) {\n        throw new Error('fc.integer maximum value should be equal or greater than the minimum one');\n    }\n    if (!safeNumberIsInteger(fullConstraints.min)) {\n        throw new Error('fc.integer minimum value should be an integer');\n    }\n    if (!safeNumberIsInteger(fullConstraints.max)) {\n        throw new Error('fc.integer maximum value should be an integer');\n    }\n    return new IntegerArbitrary(fullConstraints.min, fullConstraints.max);\n}\n","import { Stream } from '../../stream/Stream.js';\nimport { Arbitrary } from '../../check/arbitrary/definition/Arbitrary.js';\nimport { Value } from '../../check/arbitrary/definition/Value.js';\nimport { cloneMethod, hasCloneMethod } from '../../check/symbols.js';\nimport { Set, safeHas } from '../../utils/globals.js';\nconst safeObjectIs = Object.is;\nexport class ConstantArbitrary extends Arbitrary {\n    constructor(values) {\n        super();\n        this.values = values;\n    }\n    generate(mrng, _biasFactor) {\n        const idx = this.values.length === 1 ? 0 : mrng.nextInt(0, this.values.length - 1);\n        const value = this.values[idx];\n        if (!hasCloneMethod(value)) {\n            return new Value(value, idx);\n        }\n        return new Value(value, idx, () => value[cloneMethod]());\n    }\n    canShrinkWithoutContext(value) {\n        if (this.values.length === 1) {\n            return safeObjectIs(this.values[0], value);\n        }\n        if (this.fastValues === undefined) {\n            this.fastValues = new FastConstantValuesLookup(this.values);\n        }\n        return this.fastValues.has(value);\n    }\n    shrink(value, context) {\n        if (context === 0 || safeObjectIs(value, this.values[0])) {\n            return Stream.nil();\n        }\n        return Stream.of(new Value(this.values[0], 0));\n    }\n}\nclass FastConstantValuesLookup {\n    constructor(values) {\n        this.values = values;\n        this.fastValues = new Set(this.values);\n        let hasMinusZero = false;\n        let hasPlusZero = false;\n        if (safeHas(this.fastValues, 0)) {\n            for (let idx = 0; idx !== this.values.length; ++idx) {\n                const value = this.values[idx];\n                hasMinusZero = hasMinusZero || safeObjectIs(value, -0);\n                hasPlusZero = hasPlusZero || safeObjectIs(value, 0);\n            }\n        }\n        this.hasMinusZero = hasMinusZero;\n        this.hasPlusZero = hasPlusZero;\n    }\n    has(value) {\n        if (value === 0) {\n            if (safeObjectIs(value, 0)) {\n                return this.hasPlusZero;\n            }\n            return this.hasMinusZero;\n        }\n        return safeHas(this.fastValues, value);\n    }\n}\n","import { ConstantArbitrary } from './_internals/ConstantArbitrary.js';\nfunction constantFrom(...values) {\n    if (values.length === 0) {\n        throw new Error('fc.constantFrom expects at least one parameter');\n    }\n    return new ConstantArbitrary(values);\n}\nexport { constantFrom };\n","import { safeCharCodeAt } from '../../../utils/globals.js';\nexport const indexToCharStringMapper = String.fromCodePoint;\nexport function indexToCharStringUnmapper(c) {\n    if (typeof c !== 'string') {\n        throw new Error('Cannot unmap non-string');\n    }\n    if (c.length === 0 || c.length > 2) {\n        throw new Error('Cannot unmap string with more or less than one character');\n    }\n    const c1 = safeCharCodeAt(c, 0);\n    if (c.length === 1) {\n        return c1;\n    }\n    const c2 = safeCharCodeAt(c, 1);\n    if (c1 < 0xd800 || c1 > 0xdbff || c2 < 0xdc00 || c2 > 0xdfff) {\n        throw new Error('Cannot unmap invalid surrogate pairs');\n    }\n    return c.codePointAt(0);\n}\n","import { integer } from '../../integer.js';\nimport { indexToCharStringMapper, indexToCharStringUnmapper } from '../mappers/IndexToCharString.js';\nexport function buildCharacterArbitrary(min, max, mapToCode, unmapFromCode) {\n    return integer({ min, max }).map((n) => indexToCharStringMapper(mapToCode(n)), (c) => unmapFromCode(indexToCharStringUnmapper(c)));\n}\n","export function indexToPrintableIndexMapper(v) {\n    if (v < 95)\n        return v + 0x20;\n    if (v <= 0x7e)\n        return v - 95;\n    return v;\n}\nexport function indexToPrintableIndexUnmapper(v) {\n    if (v >= 0x20 && v <= 0x7e)\n        return v - 0x20;\n    if (v >= 0 && v <= 0x1f)\n        return v + 95;\n    return v;\n}\n","import { buildCharacterArbitrary } from './_internals/builders/CharacterArbitraryBuilder.js';\nfunction identity(v) {\n    return v;\n}\nexport function char() {\n    return buildCharacterArbitrary(0x20, 0x7e, identity, identity);\n}\n","import { buildCharacterArbitrary } from './_internals/builders/CharacterArbitraryBuilder.js';\nimport { indexToPrintableIndexMapper, indexToPrintableIndexUnmapper } from './_internals/mappers/IndexToPrintableIndex.js';\nconst gapSize = 0xdfff + 1 - 0xd800;\nfunction unicodeMapper(v) {\n    if (v < 0xd800)\n        return indexToPrintableIndexMapper(v);\n    return v + gapSize;\n}\nfunction unicodeUnmapper(v) {\n    if (v < 0xd800)\n        return indexToPrintableIndexUnmapper(v);\n    if (v <= 0xdfff)\n        return -1;\n    return v - gapSize;\n}\nexport function fullUnicode() {\n    return buildCharacterArbitrary(0x0000, 0x10ffff - gapSize, unicodeMapper, unicodeUnmapper);\n}\n","import { fullUnicode } from '../../fullUnicode.js';\nimport { oneof } from '../../oneof.js';\nimport { mapToConstant } from '../../mapToConstant.js';\nimport { safeCharCodeAt, safeNumberToString, encodeURIComponent, safeMapGet, safeMapSet } from '../../../utils/globals.js';\nconst SMap = Map;\nconst safeStringFromCharCode = String.fromCharCode;\nconst lowerCaseMapper = { num: 26, build: (v) => safeStringFromCharCode(v + 0x61) };\nconst upperCaseMapper = { num: 26, build: (v) => safeStringFromCharCode(v + 0x41) };\nconst numericMapper = { num: 10, build: (v) => safeStringFromCharCode(v + 0x30) };\nfunction percentCharArbMapper(c) {\n    const encoded = encodeURIComponent(c);\n    return c !== encoded ? encoded : `%${safeNumberToString(safeCharCodeAt(c, 0), 16)}`;\n}\nfunction percentCharArbUnmapper(value) {\n    if (typeof value !== 'string') {\n        throw new Error('Unsupported');\n    }\n    const decoded = decodeURIComponent(value);\n    return decoded;\n}\nconst percentCharArb = fullUnicode().map(percentCharArbMapper, percentCharArbUnmapper);\nlet lowerAlphaArbitrary = undefined;\nexport function getOrCreateLowerAlphaArbitrary() {\n    if (lowerAlphaArbitrary === undefined) {\n        lowerAlphaArbitrary = mapToConstant(lowerCaseMapper);\n    }\n    return lowerAlphaArbitrary;\n}\nlet lowerAlphaNumericArbitraries = undefined;\nexport function getOrCreateLowerAlphaNumericArbitrary(others) {\n    if (lowerAlphaNumericArbitraries === undefined) {\n        lowerAlphaNumericArbitraries = new SMap();\n    }\n    let match = safeMapGet(lowerAlphaNumericArbitraries, others);\n    if (match === undefined) {\n        match = mapToConstant(lowerCaseMapper, numericMapper, {\n            num: others.length,\n            build: (v) => others[v],\n        });\n        safeMapSet(lowerAlphaNumericArbitraries, others, match);\n    }\n    return match;\n}\nfunction buildAlphaNumericArbitrary(others) {\n    return mapToConstant(lowerCaseMapper, upperCaseMapper, numericMapper, {\n        num: others.length,\n        build: (v) => others[v],\n    });\n}\nlet alphaNumericPercentArbitraries = undefined;\nexport function getOrCreateAlphaNumericPercentArbitrary(others) {\n    if (alphaNumericPercentArbitraries === undefined) {\n        alphaNumericPercentArbitraries = new SMap();\n    }\n    let match = safeMapGet(alphaNumericPercentArbitraries, others);\n    if (match === undefined) {\n        match = oneof({ weight: 10, arbitrary: buildAlphaNumericArbitrary(others) }, { weight: 1, arbitrary: percentCharArb });\n        safeMapSet(alphaNumericPercentArbitraries, others, match);\n    }\n    return match;\n}\n","import { clone64, isEqual64 } from './ArrayInt64.js';\nconst safeNegativeInfinity = Number.NEGATIVE_INFINITY;\nconst safePositiveInfinity = Number.POSITIVE_INFINITY;\nconst safeEpsilon = Number.EPSILON;\nconst INDEX_POSITIVE_INFINITY = { sign: 1, data: [2146435072, 0] };\nconst INDEX_NEGATIVE_INFINITY = { sign: -1, data: [2146435072, 1] };\nconst f64 = new Float64Array(1);\nconst u32 = new Uint32Array(f64.buffer, f64.byteOffset);\nfunction bitCastDoubleToUInt64(f) {\n    f64[0] = f;\n    return [u32[1], u32[0]];\n}\nexport function decomposeDouble(d) {\n    const { 0: hi, 1: lo } = bitCastDoubleToUInt64(d);\n    const signBit = hi >>> 31;\n    const exponentBits = (hi >>> 20) & 0x7ff;\n    const significandBits = (hi & 0xfffff) * 0x100000000 + lo;\n    const exponent = exponentBits === 0 ? -1022 : exponentBits - 1023;\n    let significand = exponentBits === 0 ? 0 : 1;\n    significand += significandBits / 2 ** 52;\n    significand *= signBit === 0 ? 1 : -1;\n    return { exponent, significand };\n}\nfunction positiveNumberToInt64(n) {\n    return [~~(n / 0x100000000), n >>> 0];\n}\nfunction indexInDoubleFromDecomp(exponent, significand) {\n    if (exponent === -1022) {\n        const rescaledSignificand = significand * 2 ** 52;\n        return positiveNumberToInt64(rescaledSignificand);\n    }\n    const rescaledSignificand = (significand - 1) * 2 ** 52;\n    const exponentOnlyHigh = (exponent + 1023) * 2 ** 20;\n    const index = positiveNumberToInt64(rescaledSignificand);\n    index[0] += exponentOnlyHigh;\n    return index;\n}\nexport function doubleToIndex(d) {\n    if (d === safePositiveInfinity) {\n        return clone64(INDEX_POSITIVE_INFINITY);\n    }\n    if (d === safeNegativeInfinity) {\n        return clone64(INDEX_NEGATIVE_INFINITY);\n    }\n    const decomp = decomposeDouble(d);\n    const exponent = decomp.exponent;\n    const significand = decomp.significand;\n    if (d > 0 || (d === 0 && 1 / d === safePositiveInfinity)) {\n        return { sign: 1, data: indexInDoubleFromDecomp(exponent, significand) };\n    }\n    else {\n        const indexOpposite = indexInDoubleFromDecomp(exponent, -significand);\n        if (indexOpposite[1] === 0xffffffff) {\n            indexOpposite[0] += 1;\n            indexOpposite[1] = 0;\n        }\n        else {\n            indexOpposite[1] += 1;\n        }\n        return { sign: -1, data: indexOpposite };\n    }\n}\nexport function indexToDouble(index) {\n    if (index.sign === -1) {\n        const indexOpposite = { sign: 1, data: [index.data[0], index.data[1]] };\n        if (indexOpposite.data[1] === 0) {\n            indexOpposite.data[0] -= 1;\n            indexOpposite.data[1] = 0xffffffff;\n        }\n        else {\n            indexOpposite.data[1] -= 1;\n        }\n        return -indexToDouble(indexOpposite);\n    }\n    if (isEqual64(index, INDEX_POSITIVE_INFINITY)) {\n        return safePositiveInfinity;\n    }\n    if (index.data[0] < 0x200000) {\n        return (index.data[0] * 0x100000000 + index.data[1]) * 2 ** -1074;\n    }\n    const postIndexHigh = index.data[0] - 0x200000;\n    const exponent = -1021 + (postIndexHigh >> 20);\n    const significand = 1 + ((postIndexHigh & 0xfffff) * 2 ** 32 + index.data[1]) * safeEpsilon;\n    return significand * 2 ** exponent;\n}\n","const safeNegativeInfinity = Number.NEGATIVE_INFINITY;\nconst safePositiveInfinity = Number.POSITIVE_INFINITY;\nexport const MIN_VALUE_32 = 2 ** -126 * 2 ** -23;\nexport const MAX_VALUE_32 = 2 ** 127 * (1 + (2 ** 23 - 1) / 2 ** 23);\nexport const EPSILON_32 = 2 ** -23;\nconst INDEX_POSITIVE_INFINITY = 2139095040;\nconst INDEX_NEGATIVE_INFINITY = -2139095041;\nconst f32 = new Float32Array(1);\nconst u32 = new Uint32Array(f32.buffer, f32.byteOffset);\nfunction bitCastFloatToUInt32(f) {\n    f32[0] = f;\n    return u32[0];\n}\nexport function decomposeFloat(f) {\n    const bits = bitCastFloatToUInt32(f);\n    const signBit = bits >>> 31;\n    const exponentBits = (bits >>> 23) & 0xff;\n    const significandBits = bits & 0x7fffff;\n    const exponent = exponentBits === 0 ? -126 : exponentBits - 127;\n    let significand = exponentBits === 0 ? 0 : 1;\n    significand += significandBits / 2 ** 23;\n    significand *= signBit === 0 ? 1 : -1;\n    return { exponent, significand };\n}\nfunction indexInFloatFromDecomp(exponent, significand) {\n    if (exponent === -126) {\n        return significand * 0x800000;\n    }\n    return (exponent + 127) * 0x800000 + (significand - 1) * 0x800000;\n}\nexport function floatToIndex(f) {\n    if (f === safePositiveInfinity) {\n        return INDEX_POSITIVE_INFINITY;\n    }\n    if (f === safeNegativeInfinity) {\n        return INDEX_NEGATIVE_INFINITY;\n    }\n    const decomp = decomposeFloat(f);\n    const exponent = decomp.exponent;\n    const significand = decomp.significand;\n    if (f > 0 || (f === 0 && 1 / f === safePositiveInfinity)) {\n        return indexInFloatFromDecomp(exponent, significand);\n    }\n    else {\n        return -indexInFloatFromDecomp(exponent, -significand) - 1;\n    }\n}\nexport function indexToFloat(index) {\n    if (index < 0) {\n        return -indexToFloat(-index - 1);\n    }\n    if (index === INDEX_POSITIVE_INFINITY) {\n        return safePositiveInfinity;\n    }\n    if (index < 0x1000000) {\n        return index * 2 ** -149;\n    }\n    const postIndex = index - 0x1000000;\n    const exponent = -125 + (postIndex >> 23);\n    const significand = 1 + (postIndex & 0x7fffff) / 0x800000;\n    return significand * 2 ** exponent;\n}\n","var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { array } from '../../array.js';\nexport function typedIntArrayArbitraryArbitraryBuilder(constraints, defaultMin, defaultMax, TypedArrayClass, arbitraryBuilder) {\n    const generatorName = TypedArrayClass.name;\n    const { min = defaultMin, max = defaultMax } = constraints, arrayConstraints = __rest(constraints, [\"min\", \"max\"]);\n    if (min > max) {\n        throw new Error(`Invalid range passed to ${generatorName}: min must be lower than or equal to max`);\n    }\n    if (min < defaultMin) {\n        throw new Error(`Invalid min value passed to ${generatorName}: min must be greater than or equal to ${defaultMin}`);\n    }\n    if (max > defaultMax) {\n        throw new Error(`Invalid max value passed to ${generatorName}: max must be lower than or equal to ${defaultMax}`);\n    }\n    return array(arbitraryBuilder({ min, max }), arrayConstraints).map((data) => TypedArrayClass.from(data), (value) => {\n        if (!(value instanceof TypedArrayClass))\n            throw new Error('Invalid type');\n        return [...value];\n    });\n}\n","import { Array, safeMap, safeSlice } from '../utils/globals.js';\nimport { tuple } from './tuple.js';\nimport { uniqueArray } from './uniqueArray.js';\nimport { restrictedIntegerArbitraryBuilder } from './_internals/builders/RestrictedIntegerArbitraryBuilder.js';\nimport { maxGeneratedLengthFromSizeForArbitrary, MaxLengthUpperBound, } from './_internals/helpers/MaxLengthFromMinLength.js';\nconst safeMathMin = Math.min;\nconst safeMathMax = Math.max;\nconst safeArrayIsArray = Array.isArray;\nconst safeObjectEntries = Object.entries;\nfunction extractMaxIndex(indexesAndValues) {\n    let maxIndex = -1;\n    for (let index = 0; index !== indexesAndValues.length; ++index) {\n        maxIndex = safeMathMax(maxIndex, indexesAndValues[index][0]);\n    }\n    return maxIndex;\n}\nfunction arrayFromItems(length, indexesAndValues) {\n    const array = Array(length);\n    for (let index = 0; index !== indexesAndValues.length; ++index) {\n        const it = indexesAndValues[index];\n        if (it[0] < length)\n            array[it[0]] = it[1];\n    }\n    return array;\n}\nexport function sparseArray(arb, constraints = {}) {\n    const { size, minNumElements = 0, maxLength = MaxLengthUpperBound, maxNumElements = maxLength, noTrailingHole, depthIdentifier, } = constraints;\n    const maxGeneratedNumElements = maxGeneratedLengthFromSizeForArbitrary(size, minNumElements, maxNumElements, constraints.maxNumElements !== undefined);\n    const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(size, maxGeneratedNumElements, maxLength, constraints.maxLength !== undefined);\n    if (minNumElements > maxLength) {\n        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);\n    }\n    if (minNumElements > maxNumElements) {\n        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);\n    }\n    const resultedMaxNumElements = safeMathMin(maxNumElements, maxLength);\n    const resultedSizeMaxNumElements = constraints.maxNumElements !== undefined || size !== undefined ? size : '=';\n    const maxGeneratedIndexAuthorized = safeMathMax(maxGeneratedLength - 1, 0);\n    const maxIndexAuthorized = safeMathMax(maxLength - 1, 0);\n    const sparseArrayNoTrailingHole = uniqueArray(tuple(restrictedIntegerArbitraryBuilder(0, maxGeneratedIndexAuthorized, maxIndexAuthorized), arb), {\n        size: resultedSizeMaxNumElements,\n        minLength: minNumElements,\n        maxLength: resultedMaxNumElements,\n        selector: (item) => item[0],\n        depthIdentifier,\n    }).map((items) => {\n        const lastIndex = extractMaxIndex(items);\n        return arrayFromItems(lastIndex + 1, items);\n    }, (value) => {\n        if (!safeArrayIsArray(value)) {\n            throw new Error('Not supported entry type');\n        }\n        if (noTrailingHole && value.length !== 0 && !(value.length - 1 in value)) {\n            throw new Error('No trailing hole');\n        }\n        return safeMap(safeObjectEntries(value), (entry) => [Number(entry[0]), entry[1]]);\n    });\n    if (noTrailingHole || maxLength === minNumElements) {\n        return sparseArrayNoTrailingHole;\n    }\n    return tuple(sparseArrayNoTrailingHole, restrictedIntegerArbitraryBuilder(minNumElements, maxGeneratedLength, maxLength)).map((data) => {\n        const sparse = data[0];\n        const targetLength = data[1];\n        if (sparse.length >= targetLength) {\n            return sparse;\n        }\n        const longerSparse = safeSlice(sparse);\n        longerSparse.length = targetLength;\n        return longerSparse;\n    }, (value) => {\n        if (!safeArrayIsArray(value)) {\n            throw new Error('Not supported entry type');\n        }\n        return [value, value.length];\n    });\n}\n","function charSizeAt(text, pos) {\n    return text[pos] >= '\\uD800' && text[pos] <= '\\uDBFF' && text[pos + 1] >= '\\uDC00' && text[pos + 1] <= '\\uDFFF'\n        ? 2\n        : 1;\n}\nfunction isHexaDigit(char) {\n    return (char >= '0' && char <= '9') || (char >= 'a' && char <= 'f') || (char >= 'A' && char <= 'F');\n}\nfunction isDigit(char) {\n    return char >= '0' && char <= '9';\n}\nfunction squaredBracketBlockContentEndFrom(text, from) {\n    for (let index = from; index !== text.length; ++index) {\n        const char = text[index];\n        if (char === '\\\\') {\n            index += 1;\n        }\n        else if (char === ']') {\n            return index;\n        }\n    }\n    throw new Error(`Missing closing ']'`);\n}\nfunction parenthesisBlockContentEndFrom(text, from) {\n    let numExtraOpened = 0;\n    for (let index = from; index !== text.length; ++index) {\n        const char = text[index];\n        if (char === '\\\\') {\n            index += 1;\n        }\n        else if (char === ')') {\n            if (numExtraOpened === 0) {\n                return index;\n            }\n            numExtraOpened -= 1;\n        }\n        else if (char === '[') {\n            index = squaredBracketBlockContentEndFrom(text, index);\n        }\n        else if (char === '(') {\n            numExtraOpened += 1;\n        }\n    }\n    throw new Error(`Missing closing ')'`);\n}\nfunction curlyBracketBlockContentEndFrom(text, from) {\n    let foundComma = false;\n    for (let index = from; index !== text.length; ++index) {\n        const char = text[index];\n        if (isDigit(char)) {\n        }\n        else if (from === index) {\n            return -1;\n        }\n        else if (char === ',') {\n            if (foundComma) {\n                return -1;\n            }\n            foundComma = true;\n        }\n        else if (char === '}') {\n            return index;\n        }\n        else {\n            return -1;\n        }\n    }\n    return -1;\n}\nexport var TokenizerBlockMode;\n(function (TokenizerBlockMode) {\n    TokenizerBlockMode[TokenizerBlockMode[\"Full\"] = 0] = \"Full\";\n    TokenizerBlockMode[TokenizerBlockMode[\"Character\"] = 1] = \"Character\";\n})(TokenizerBlockMode || (TokenizerBlockMode = {}));\nfunction blockEndFrom(text, from, unicodeMode, mode) {\n    switch (text[from]) {\n        case '[': {\n            if (mode === TokenizerBlockMode.Character) {\n                return from + 1;\n            }\n            return squaredBracketBlockContentEndFrom(text, from + 1) + 1;\n        }\n        case '{': {\n            if (mode === TokenizerBlockMode.Character) {\n                return from + 1;\n            }\n            const foundEnd = curlyBracketBlockContentEndFrom(text, from + 1);\n            if (foundEnd === -1) {\n                return from + 1;\n            }\n            return foundEnd + 1;\n        }\n        case '(': {\n            if (mode === TokenizerBlockMode.Character) {\n                return from + 1;\n            }\n            return parenthesisBlockContentEndFrom(text, from + 1) + 1;\n        }\n        case ']':\n        case '}':\n        case ')':\n            return from + 1;\n        case '\\\\': {\n            const next1 = text[from + 1];\n            switch (next1) {\n                case 'x':\n                    if (isHexaDigit(text[from + 2]) && isHexaDigit(text[from + 3])) {\n                        return from + 4;\n                    }\n                    throw new Error(`Unexpected token '${text.substring(from, from + 4)}' found`);\n                case 'u':\n                    if (text[from + 2] === '{') {\n                        if (!unicodeMode) {\n                            return from + 2;\n                        }\n                        if (text[from + 4] === '}') {\n                            if (isHexaDigit(text[from + 3])) {\n                                return from + 5;\n                            }\n                            throw new Error(`Unexpected token '${text.substring(from, from + 5)}' found`);\n                        }\n                        if (text[from + 5] === '}') {\n                            if (isHexaDigit(text[from + 3]) && isHexaDigit(text[from + 4])) {\n                                return from + 6;\n                            }\n                            throw new Error(`Unexpected token '${text.substring(from, from + 6)}' found`);\n                        }\n                        if (text[from + 6] === '}') {\n                            if (isHexaDigit(text[from + 3]) && isHexaDigit(text[from + 4]) && isHexaDigit(text[from + 5])) {\n                                return from + 7;\n                            }\n                            throw new Error(`Unexpected token '${text.substring(from, from + 7)}' found`);\n                        }\n                        if (text[from + 7] === '}') {\n                            if (isHexaDigit(text[from + 3]) &&\n                                isHexaDigit(text[from + 4]) &&\n                                isHexaDigit(text[from + 5]) &&\n                                isHexaDigit(text[from + 6])) {\n                                return from + 8;\n                            }\n                            throw new Error(`Unexpected token '${text.substring(from, from + 8)}' found`);\n                        }\n                        if (text[from + 8] === '}' &&\n                            isHexaDigit(text[from + 3]) &&\n                            isHexaDigit(text[from + 4]) &&\n                            isHexaDigit(text[from + 5]) &&\n                            isHexaDigit(text[from + 6]) &&\n                            isHexaDigit(text[from + 7])) {\n                            return from + 9;\n                        }\n                        throw new Error(`Unexpected token '${text.substring(from, from + 9)}' found`);\n                    }\n                    if (isHexaDigit(text[from + 2]) &&\n                        isHexaDigit(text[from + 3]) &&\n                        isHexaDigit(text[from + 4]) &&\n                        isHexaDigit(text[from + 5])) {\n                        return from + 6;\n                    }\n                    throw new Error(`Unexpected token '${text.substring(from, from + 6)}' found`);\n                case 'p':\n                case 'P': {\n                    if (!unicodeMode) {\n                        return from + 2;\n                    }\n                    let subIndex = from + 2;\n                    for (; subIndex < text.length && text[subIndex] !== '}'; subIndex += text[subIndex] === '\\\\' ? 2 : 1) {\n                    }\n                    if (text[subIndex] !== '}') {\n                        throw new Error(`Invalid \\\\P definition`);\n                    }\n                    return subIndex + 1;\n                }\n                case 'k': {\n                    let subIndex = from + 2;\n                    for (; subIndex < text.length && text[subIndex] !== '>'; ++subIndex) {\n                    }\n                    if (text[subIndex] !== '>') {\n                        if (!unicodeMode) {\n                            return from + 2;\n                        }\n                        throw new Error(`Invalid \\\\k definition`);\n                    }\n                    return subIndex + 1;\n                }\n                default: {\n                    if (isDigit(next1)) {\n                        const maxIndex = unicodeMode ? text.length : Math.min(from + 4, text.length);\n                        let subIndex = from + 2;\n                        for (; subIndex < maxIndex && isDigit(text[subIndex]); ++subIndex) {\n                        }\n                        return subIndex;\n                    }\n                    const charSize = unicodeMode ? charSizeAt(text, from + 1) : 1;\n                    return from + charSize + 1;\n                }\n            }\n        }\n        default: {\n            const charSize = unicodeMode ? charSizeAt(text, from) : 1;\n            return from + charSize;\n        }\n    }\n}\nexport function readFrom(text, from, unicodeMode, mode) {\n    const to = blockEndFrom(text, from, unicodeMode, mode);\n    return text.substring(from, to);\n}\n","import { safeCharCodeAt, safeEvery, safeJoin, safeSubstring, Error, safeIndexOf, safeMap } from '../utils/globals.js';\nimport { stringify } from '../utils/stringify.js';\nimport { addMissingDotStar } from './_internals/helpers/SanitizeRegexAst.js';\nimport { tokenizeRegex } from './_internals/helpers/TokenizeRegex.js';\nimport { char } from './char.js';\nimport { constant } from './constant.js';\nimport { constantFrom } from './constantFrom.js';\nimport { integer } from './integer.js';\nimport { oneof } from './oneof.js';\nimport { stringOf } from './stringOf.js';\nimport { tuple } from './tuple.js';\nconst safeStringFromCodePoint = String.fromCodePoint;\nconst wordChars = [...'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'];\nconst digitChars = [...'0123456789'];\nconst spaceChars = [...' \\t\\r\\n\\v\\f'];\nconst newLineChars = [...'\\r\\n'];\nconst terminatorChars = [...'\\x1E\\x15'];\nconst newLineAndTerminatorChars = [...newLineChars, ...terminatorChars];\nconst defaultChar = char();\nfunction raiseUnsupportedASTNode(astNode) {\n    return new Error(`Unsupported AST node! Received: ${stringify(astNode)}`);\n}\nfunction toMatchingArbitrary(astNode, constraints, flags) {\n    switch (astNode.type) {\n        case 'Char': {\n            if (astNode.kind === 'meta') {\n                switch (astNode.value) {\n                    case '\\\\w': {\n                        return constantFrom(...wordChars);\n                    }\n                    case '\\\\W': {\n                        return defaultChar.filter((c) => safeIndexOf(wordChars, c) === -1);\n                    }\n                    case '\\\\d': {\n                        return constantFrom(...digitChars);\n                    }\n                    case '\\\\D': {\n                        return defaultChar.filter((c) => safeIndexOf(digitChars, c) === -1);\n                    }\n                    case '\\\\s': {\n                        return constantFrom(...spaceChars);\n                    }\n                    case '\\\\S': {\n                        return defaultChar.filter((c) => safeIndexOf(spaceChars, c) === -1);\n                    }\n                    case '\\\\b':\n                    case '\\\\B': {\n                        throw new Error(`Meta character ${astNode.value} not implemented yet!`);\n                    }\n                    case '.': {\n                        const forbiddenChars = flags.dotAll ? terminatorChars : newLineAndTerminatorChars;\n                        return defaultChar.filter((c) => safeIndexOf(forbiddenChars, c) === -1);\n                    }\n                }\n            }\n            if (astNode.symbol === undefined) {\n                throw new Error(`Unexpected undefined symbol received for non-meta Char! Received: ${stringify(astNode)}`);\n            }\n            return constant(astNode.symbol);\n        }\n        case 'Repetition': {\n            const node = toMatchingArbitrary(astNode.expression, constraints, flags);\n            switch (astNode.quantifier.kind) {\n                case '*': {\n                    return stringOf(node, constraints);\n                }\n                case '+': {\n                    return stringOf(node, Object.assign(Object.assign({}, constraints), { minLength: 1 }));\n                }\n                case '?': {\n                    return stringOf(node, Object.assign(Object.assign({}, constraints), { minLength: 0, maxLength: 1 }));\n                }\n                case 'Range': {\n                    return stringOf(node, Object.assign(Object.assign({}, constraints), { minLength: astNode.quantifier.from, maxLength: astNode.quantifier.to }));\n                }\n                default: {\n                    throw raiseUnsupportedASTNode(astNode.quantifier);\n                }\n            }\n        }\n        case 'Quantifier': {\n            throw new Error(`Wrongly defined AST tree, Quantifier nodes not supposed to be scanned!`);\n        }\n        case 'Alternative': {\n            return tuple(...safeMap(astNode.expressions, (n) => toMatchingArbitrary(n, constraints, flags))).map((vs) => safeJoin(vs, ''));\n        }\n        case 'CharacterClass':\n            if (astNode.negative) {\n                const childrenArbitraries = safeMap(astNode.expressions, (n) => toMatchingArbitrary(n, constraints, flags));\n                return defaultChar.filter((c) => safeEvery(childrenArbitraries, (arb) => !arb.canShrinkWithoutContext(c)));\n            }\n            return oneof(...safeMap(astNode.expressions, (n) => toMatchingArbitrary(n, constraints, flags)));\n        case 'ClassRange': {\n            const min = astNode.from.codePoint;\n            const max = astNode.to.codePoint;\n            return integer({ min, max }).map((n) => safeStringFromCodePoint(n), (c) => {\n                if (typeof c !== 'string')\n                    throw new Error('Invalid type');\n                if ([...c].length !== 1)\n                    throw new Error('Invalid length');\n                return safeCharCodeAt(c, 0);\n            });\n        }\n        case 'Group': {\n            return toMatchingArbitrary(astNode.expression, constraints, flags);\n        }\n        case 'Disjunction': {\n            const left = astNode.left !== null ? toMatchingArbitrary(astNode.left, constraints, flags) : constant('');\n            const right = astNode.right !== null ? toMatchingArbitrary(astNode.right, constraints, flags) : constant('');\n            return oneof(left, right);\n        }\n        case 'Assertion': {\n            if (astNode.kind === '^' || astNode.kind === '$') {\n                if (flags.multiline) {\n                    if (astNode.kind === '^') {\n                        return oneof(constant(''), tuple(stringOf(defaultChar), constantFrom(...newLineChars)).map((t) => `${t[0]}${t[1]}`, (value) => {\n                            if (typeof value !== 'string' || value.length === 0)\n                                throw new Error('Invalid type');\n                            return [safeSubstring(value, 0, value.length - 1), value[value.length - 1]];\n                        }));\n                    }\n                    else {\n                        return oneof(constant(''), tuple(constantFrom(...newLineChars), stringOf(defaultChar)).map((t) => `${t[0]}${t[1]}`, (value) => {\n                            if (typeof value !== 'string' || value.length === 0)\n                                throw new Error('Invalid type');\n                            return [value[0], safeSubstring(value, 1)];\n                        }));\n                    }\n                }\n                return constant('');\n            }\n            throw new Error(`Assertions of kind ${astNode.kind} not implemented yet!`);\n        }\n        case 'Backreference': {\n            throw new Error(`Backreference nodes not implemented yet!`);\n        }\n        default: {\n            throw raiseUnsupportedASTNode(astNode);\n        }\n    }\n}\nexport function stringMatching(regex, constraints = {}) {\n    for (const flag of regex.flags) {\n        if (flag !== 'd' && flag !== 'g' && flag !== 'm' && flag !== 's' && flag !== 'u') {\n            throw new Error(`Unable to use \"stringMatching\" against a regex using the flag ${flag}`);\n        }\n    }\n    const sanitizedConstraints = { size: constraints.size };\n    const flags = { multiline: regex.multiline, dotAll: regex.dotAll };\n    const regexRootToken = addMissingDotStar(tokenizeRegex(regex));\n    return toMatchingArbitrary(regexRootToken, sanitizedConstraints, flags);\n}\n","import { array, constant, constantFrom, dictionary, object as objectArbitrary, oneof, record, string as stringArbitrary, tuple, webUrl, } from \"fast-check\";\nexport const xmlAttributeName = /^(?!xml|Xml|xMl|xmL|XMl|xML|XmL|XML)[A-Za-z_][A-Za-z0-9-_.]*(:[A-Za-z_][A-Za-z0-9-_.]*)?$/;\nexport function descendants(parent) {\n    return Array.from(parent.childNodes).concat(...Array.from(parent.children).map((child) => descendants(child)));\n}\nexport const sclDocString = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <SCL version=\"2007\" revision=\"B\" xmlns=\"http://www.iec.ch/61850/2003/SCL\" xmlns:ens1=\"http://example.org/somePreexistingExtensionNamespace\">\n    <Substation name=\"A1\" desc=\"test substation\"></Substation>\n  </SCL>`;\nconst testDocStrings = [\n    sclDocString,\n    `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <testDoc1>\n  <element1 property1=\"value1\" property2=\"value2\">SomeText</element1>\n  <element2 property2=\"value2\" property3=\"value3\"><!--AComment--></element2>\n  <element3 property3=\"value3\" property1=\"value1\">\n    <subelement1 property1=\"value1\" property2=\"value2\">SomeMoreText</subelement1>\n    <subelement2 property2=\"value2\" property3=\"value3\"><!----></subelement2>\n    <subelement3 property3=\"value3\" property1=\"value1\"></subelement3>\n  </element3>\n  </testDoc1>`,\n    `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <testDoc2>\n  <element1 property1=\"value1\" property2=\"value2\">SomeText</element1>\n  <element2 property2=\"value2\" property3=\"value3\"><!--AComment--></element2>\n  <element3 property3=\"value3\" property1=\"value1\">\n    <subelement1 property1=\"value1\" property2=\"value2\">SomeMoreText</subelement1>\n    <subelement2 property2=\"value2\" property3=\"value3\"><!----></subelement2>\n    <subelement3 property3=\"value3\" property1=\"value1\"></subelement3>\n  </element3>\n  </testDoc2>`,\n];\nexport const testDocs = tuple(constantFrom(...testDocStrings), constantFrom(...testDocStrings))\n    .map((strs) => strs.map((str) => new DOMParser().parseFromString(str, \"application/xml\")))\n    .map((docs) => docs.map((doc) => ({ doc, nodes: descendants(doc).concat([doc]) })));\nexport function remove(nodes) {\n    const node = oneof({ arbitrary: constantFrom(...nodes), weight: nodes.length }, testDocs.chain((docs) => constantFrom(...docs.map((d) => d.doc))));\n    return record({ node });\n}\nexport function insert(nodes) {\n    const references = nodes.concat([null]);\n    const parent = constantFrom(...nodes);\n    const node = constantFrom(...nodes);\n    const reference = constantFrom(...references);\n    return record({ parent, node, reference });\n}\nexport function setTextContent(nodes) {\n    const element = (constantFrom(...nodes.filter((nd) => nd.nodeType === Node.ELEMENT_NODE)));\n    const textContent = stringArbitrary();\n    return record({ element, textContent });\n}\nexport function setAttribute(nodes) {\n    const element = (constantFrom(...nodes.filter((nd) => nd.nodeType === Node.ELEMENT_NODE)));\n    const attributes = dictionary(stringArbitrary(), oneof(stringArbitrary(), constant(null)));\n    // object() instead of nested dictionary() necessary for performance reasons\n    const attributesNS = objectArbitrary({\n        key: webUrl(),\n        values: [attributes],\n        maxDepth: 0,\n    });\n    return record({ element, attributes, attributesNS });\n}\nexport function complexEdit(nodes) {\n    return array(simpleEdit(nodes));\n}\nexport function simpleEdit(nodes) {\n    return oneof(remove(nodes), insert(nodes), setAttribute(nodes), setTextContent(nodes));\n}\nexport function edit(nodes) {\n    return oneof({ arbitrary: simpleEdit(nodes), weight: 2 }, complexEdit(nodes));\n}\nexport function undoRedoTestCases(testDoc1, testDoc2) {\n    const nodes = testDoc1.nodes.concat(testDoc2.nodes);\n    return record({\n        doc1: constant(testDoc1.doc),\n        doc2: constant(testDoc2.doc),\n        edits: array(edit(nodes)),\n    });\n}\nexport function isParentNode(node) {\n    return (node instanceof Element ||\n        node instanceof Document ||\n        node instanceof DocumentFragment);\n}\nexport function isParentOf(parent, node) {\n    return (isParentNode(parent) &&\n        (node === null || Array.from(parent.childNodes).includes(node)));\n}\nexport function isValidInsert({ parent, node, reference }) {\n    return (node !== reference &&\n        isParentOf(parent, reference) &&\n        !node.contains(parent) &&\n        ![Node.DOCUMENT_NODE, Node.DOCUMENT_TYPE_NODE].some((nodeType) => node.nodeType === nodeType) &&\n        !(parent instanceof Document &&\n            (parent.documentElement || !(node instanceof Element))));\n}\n//# sourceMappingURL=testHelpers.js.map"],"names":["isComplex","isRemove","isInsert","safeObjectDefineProperty","safeMathFloor","safeNumberIsInteger","safeObjectIs","Set","encodeURIComponent","this","Array"],"mappings":"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"}
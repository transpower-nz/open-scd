{"version":3,"file":"stringMatching.js","sources":["../../../../../../node_modules/fast-check/lib/esm/arbitrary/stringMatching.js"],"sourcesContent":["import { safeCharCodeAt, safeEvery, safeJoin, safeSubstring, Error, safeIndexOf, safeMap } from '../utils/globals.js';\nimport { stringify } from '../utils/stringify.js';\nimport { addMissingDotStar } from './_internals/helpers/SanitizeRegexAst.js';\nimport { tokenizeRegex } from './_internals/helpers/TokenizeRegex.js';\nimport { char } from './char.js';\nimport { constant } from './constant.js';\nimport { constantFrom } from './constantFrom.js';\nimport { integer } from './integer.js';\nimport { oneof } from './oneof.js';\nimport { stringOf } from './stringOf.js';\nimport { tuple } from './tuple.js';\nconst safeStringFromCodePoint = String.fromCodePoint;\nconst wordChars = [...'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'];\nconst digitChars = [...'0123456789'];\nconst spaceChars = [...' \\t\\r\\n\\v\\f'];\nconst newLineChars = [...'\\r\\n'];\nconst terminatorChars = [...'\\x1E\\x15'];\nconst newLineAndTerminatorChars = [...newLineChars, ...terminatorChars];\nconst defaultChar = char();\nfunction raiseUnsupportedASTNode(astNode) {\n    return new Error(`Unsupported AST node! Received: ${stringify(astNode)}`);\n}\nfunction toMatchingArbitrary(astNode, constraints, flags) {\n    switch (astNode.type) {\n        case 'Char': {\n            if (astNode.kind === 'meta') {\n                switch (astNode.value) {\n                    case '\\\\w': {\n                        return constantFrom(...wordChars);\n                    }\n                    case '\\\\W': {\n                        return defaultChar.filter((c) => safeIndexOf(wordChars, c) === -1);\n                    }\n                    case '\\\\d': {\n                        return constantFrom(...digitChars);\n                    }\n                    case '\\\\D': {\n                        return defaultChar.filter((c) => safeIndexOf(digitChars, c) === -1);\n                    }\n                    case '\\\\s': {\n                        return constantFrom(...spaceChars);\n                    }\n                    case '\\\\S': {\n                        return defaultChar.filter((c) => safeIndexOf(spaceChars, c) === -1);\n                    }\n                    case '\\\\b':\n                    case '\\\\B': {\n                        throw new Error(`Meta character ${astNode.value} not implemented yet!`);\n                    }\n                    case '.': {\n                        const forbiddenChars = flags.dotAll ? terminatorChars : newLineAndTerminatorChars;\n                        return defaultChar.filter((c) => safeIndexOf(forbiddenChars, c) === -1);\n                    }\n                }\n            }\n            if (astNode.symbol === undefined) {\n                throw new Error(`Unexpected undefined symbol received for non-meta Char! Received: ${stringify(astNode)}`);\n            }\n            return constant(astNode.symbol);\n        }\n        case 'Repetition': {\n            const node = toMatchingArbitrary(astNode.expression, constraints, flags);\n            switch (astNode.quantifier.kind) {\n                case '*': {\n                    return stringOf(node, constraints);\n                }\n                case '+': {\n                    return stringOf(node, Object.assign(Object.assign({}, constraints), { minLength: 1 }));\n                }\n                case '?': {\n                    return stringOf(node, Object.assign(Object.assign({}, constraints), { minLength: 0, maxLength: 1 }));\n                }\n                case 'Range': {\n                    return stringOf(node, Object.assign(Object.assign({}, constraints), { minLength: astNode.quantifier.from, maxLength: astNode.quantifier.to }));\n                }\n                default: {\n                    throw raiseUnsupportedASTNode(astNode.quantifier);\n                }\n            }\n        }\n        case 'Quantifier': {\n            throw new Error(`Wrongly defined AST tree, Quantifier nodes not supposed to be scanned!`);\n        }\n        case 'Alternative': {\n            return tuple(...safeMap(astNode.expressions, (n) => toMatchingArbitrary(n, constraints, flags))).map((vs) => safeJoin(vs, ''));\n        }\n        case 'CharacterClass':\n            if (astNode.negative) {\n                const childrenArbitraries = safeMap(astNode.expressions, (n) => toMatchingArbitrary(n, constraints, flags));\n                return defaultChar.filter((c) => safeEvery(childrenArbitraries, (arb) => !arb.canShrinkWithoutContext(c)));\n            }\n            return oneof(...safeMap(astNode.expressions, (n) => toMatchingArbitrary(n, constraints, flags)));\n        case 'ClassRange': {\n            const min = astNode.from.codePoint;\n            const max = astNode.to.codePoint;\n            return integer({ min, max }).map((n) => safeStringFromCodePoint(n), (c) => {\n                if (typeof c !== 'string')\n                    throw new Error('Invalid type');\n                if ([...c].length !== 1)\n                    throw new Error('Invalid length');\n                return safeCharCodeAt(c, 0);\n            });\n        }\n        case 'Group': {\n            return toMatchingArbitrary(astNode.expression, constraints, flags);\n        }\n        case 'Disjunction': {\n            const left = astNode.left !== null ? toMatchingArbitrary(astNode.left, constraints, flags) : constant('');\n            const right = astNode.right !== null ? toMatchingArbitrary(astNode.right, constraints, flags) : constant('');\n            return oneof(left, right);\n        }\n        case 'Assertion': {\n            if (astNode.kind === '^' || astNode.kind === '$') {\n                if (flags.multiline) {\n                    if (astNode.kind === '^') {\n                        return oneof(constant(''), tuple(stringOf(defaultChar), constantFrom(...newLineChars)).map((t) => `${t[0]}${t[1]}`, (value) => {\n                            if (typeof value !== 'string' || value.length === 0)\n                                throw new Error('Invalid type');\n                            return [safeSubstring(value, 0, value.length - 1), value[value.length - 1]];\n                        }));\n                    }\n                    else {\n                        return oneof(constant(''), tuple(constantFrom(...newLineChars), stringOf(defaultChar)).map((t) => `${t[0]}${t[1]}`, (value) => {\n                            if (typeof value !== 'string' || value.length === 0)\n                                throw new Error('Invalid type');\n                            return [value[0], safeSubstring(value, 1)];\n                        }));\n                    }\n                }\n                return constant('');\n            }\n            throw new Error(`Assertions of kind ${astNode.kind} not implemented yet!`);\n        }\n        case 'Backreference': {\n            throw new Error(`Backreference nodes not implemented yet!`);\n        }\n        default: {\n            throw raiseUnsupportedASTNode(astNode);\n        }\n    }\n}\nexport function stringMatching(regex, constraints = {}) {\n    for (const flag of regex.flags) {\n        if (flag !== 'd' && flag !== 'g' && flag !== 'm' && flag !== 's' && flag !== 'u') {\n            throw new Error(`Unable to use \"stringMatching\" against a regex using the flag ${flag}`);\n        }\n    }\n    const sanitizedConstraints = { size: constraints.size };\n    const flags = { multiline: regex.multiline, dotAll: regex.dotAll };\n    const regexRootToken = addMissingDotStar(tokenizeRegex(regex));\n    return toMatchingArbitrary(regexRootToken, sanitizedConstraints, flags);\n}\n"],"names":[],"mappings":";;;;;AAkBoB,IAAI"}